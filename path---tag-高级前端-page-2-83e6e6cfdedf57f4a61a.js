webpackJsonp([50623193433078],{1429:function(n,a){n.exports={data:{site:{siteMetadata:{title:"女王控的博客",description:'前端工程师，黑猫女王控，欢迎勾搭，技术相关<a href="https://github.com/towavephone" target="_blank">@towavephone</a>，QQ闲聊<a href="tencent://AddContact/?fromId=45&fromSubId=1&subcmd=all&uin=634407147&website=www.oicqzone.com">@towave</a>，bili关注<a href="https://space.bilibili.com/11507708#/" target="_blank">@towave</a>',siteUrl:"https://blog.towavephone.com"}}},pathContext:{posts:[{excerpt:"随着 Javascript 语言的发展，ES6 规范为我们带来了许多新的内容，其中生成器 Generators 是一项重要的特性。利用这一特性，我们可以简化迭代器的创建，更加令人兴奋的，是 Generators 允许我们在函数执行过程中暂停、并在将来某一时刻恢复执行。这一特性改变了以往函数必须执行完成才返回的特点，将这一特性应用到异步代码编写中，可以有效的简化异步方法的写法，同时避免陷入回调地狱。 本文将对 Generators 进行简单介绍，然后结合笔者在 C…",html:'<p>随着 Javascript 语言的发展，ES6 规范为我们带来了许多新的内容，其中生成器 Generators 是一项重要的特性。利用这一特性，我们可以简化迭代器的创建，更加令人兴奋的，是 Generators 允许我们在函数执行过程中暂停、并在将来某一时刻恢复执行。这一特性改变了以往函数必须执行完成才返回的特点，将这一特性应用到异步代码编写中，可以有效的简化异步方法的写法，同时避免陷入回调地狱。</p>\n<p>本文将对 Generators 进行简单介绍，然后结合笔者在 C# 上的一点经验，重点探讨 Generators 运行机制及在 ES5 的实现原理。</p>\n<h1 id="介绍"><a href="#%E4%BB%8B%E7%BB%8D" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>介绍</h1>\n<p>一个简单的 Generator 函数示例</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="90955507034810300000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function* example() {\n  yield 1;\n  yield 2;\n  yield 3;\n}\nvar iter = example();\niter.next(); // {value:1，done:false}\niter.next(); // {value:2，done:false}\niter.next(); // {value:3，done:false}\niter.next(); // {value:undefined，done:true}`, `90955507034810300000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">example</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">yield</span> <span class="token number">1</span><span class="token punctuation">;</span>\n  <span class="token keyword">yield</span> <span class="token number">2</span><span class="token punctuation">;</span>\n  <span class="token keyword">yield</span> <span class="token number">3</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">var</span> iter <span class="token operator">=</span> <span class="token function">example</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\niter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// {value:1，done:false}</span>\niter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// {value:2，done:false}</span>\niter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// {value:3，done:false}</span>\niter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// {value:undefined，done:true}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>上述代码中定义了一个生成器函数，当调用生成器函数 example() 时，并非立即执行该函数，而是返回一个生成器对象。每当调用生成器对象的 .next() 方法时，函数将运行到下一个 yield 表达式，返回表达式结果并暂停自身。当抵达生成器函数的末尾时，返回结果中 done 的值为 true，value 的值为 undefined。我们将上述 example() 函数称之为生成器函数，与普通函数相比二者有如下区别</p>\n<ul>\n<li>普通函数使用 function 声明，生成器函数用 function* 声明</li>\n<li>普通函数使用 return 返回值，生成器函数使用 yield 返回值</li>\n<li>普通函数是 run to completion 模式，即普通函数开始执行后，会一直执行到该函数所有语句完成，在此期间别的代码语句是不会被执行的；生成器函数是 run-pause-run 模式，即生成器函数可以在函数运行中被暂停一次或多次，并且在后面再恢复执行，在暂停期间允许其他代码语句被执行</li>\n</ul>\n<h1 id="generators-in-c"><a href="#generators-in-c" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Generators in C</h1>\n<p>生成器不是一个新的概念，我最初接触这一概念是在学习使用 C# 时。C# 从 2.0 版本便引入了 yield 关键字，使得我们可以更简单的创建枚举数和可枚举类型。不同的是 C# 中未将其命名为生成器 Generators，而将其称之为迭代器。</p>\n<p>本文不会介绍 C# 中可枚举类 IEnumerable 和枚举数 IEnumerator 内容，如需了解推荐阅读《C#4.0 图解教程》相关章节。</p>\n<h2 id="c-迭代器介绍"><a href="#c-%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%BB%8B%E7%BB%8D" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>C# 迭代器介绍</h2>\n<p>让我们先看一个示例，下面方法声明实现了一个产生和返回枚举数的迭代器</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="93061055079505460000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`public IEnumerable <int> Example() {\n  yield return 1;\n  yield return 2;\n  yield return 3;\n}`, `93061055079505460000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                cs 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="cs"><pre style="counter-reset: linenumber NaN" class="language-cs line-numbers"><code class="language-cs"><span class="token keyword">public</span> IEnumerable <span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">Example</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">yield</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>\n  <span class="token keyword">yield</span> <span class="token keyword">return</span> <span class="token number">2</span><span class="token punctuation">;</span>\n  <span class="token keyword">yield</span> <span class="token keyword">return</span> <span class="token number">3</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>方法定义与 ES6 Generators 定义很接近，定义中声明返回了一个 int 类型的泛型可枚举类型，方法体内通过 yield return 语句返回值并将自身暂停执行。</p>\n<p>使用迭代器来创建可枚举类型的类</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="22340404406191383000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`class YieldClass {\n  public IEnumerable<int> Example() { // 迭代器\n    yield return 1;\n    yield return 2;\n    yield return 3;\n  }\n}\n\nclass Program {\n  static void Main() {\n    YieldClass yc = new YieldClass();\n    foreach(var a in yc.Example())\n      Console.WriteLine(a);\n  }\n}`, `22340404406191383000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                cs 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="cs"><pre style="counter-reset: linenumber NaN" class="language-cs line-numbers"><code class="language-cs"><span class="token keyword">class</span> <span class="token class-name">YieldClass</span> <span class="token punctuation">{</span>\n  <span class="token keyword">public</span> IEnumerable<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">Example</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 迭代器</span>\n    <span class="token keyword">yield</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>\n    <span class="token keyword">yield</span> <span class="token keyword">return</span> <span class="token number">2</span><span class="token punctuation">;</span>\n    <span class="token keyword">yield</span> <span class="token keyword">return</span> <span class="token number">3</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">class</span> <span class="token class-name">Program</span> <span class="token punctuation">{</span>\n  <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token class-name">YieldClass</span> yc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">YieldClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">foreach</span><span class="token punctuation">(</span><span class="token keyword">var</span> a <span class="token keyword">in</span> yc<span class="token punctuation">.</span><span class="token function">Example</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n      Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>上述代码会产生如下输入</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="55664137317066030000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`1\n2\n3`, `55664137317066030000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">1\n2\n3</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span></span></pre></div>\n<h2 id="c-迭代器原理"><a href="#c-%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%8E%9F%E7%90%86" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>C# 迭代器原理</h2>\n<p>在 .Net 中，yield 并不是 .Net runtime 的特性，而是一个语法糖，代码编译时，这一语法糖会被 C# 编译器编译成简单的 IL 代码。</p>\n<p>继续研究上述示例，通过 Reflector 反编译工具可以看到，编译器为我们生成了一个带有如下声明的内部类</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="74118798444864850000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`[CompilerGenerated]\nprivate sealed class YieldEnumerator :\n   IEnumerable<object>, IEnumerator<object>\n{\n    // Fields字段\n    private int state;\n    private int current;\n    public YieldClass owner;\n    private int initialThreadId;\n\n    // Methods方法\n    [DebuggerHidden]\n    public YieldEnumerator(int state);\n    private bool MoveNext();\n    [DebuggerHidden]\n    IEnumerator<int> IEnumerable<int>.GetEnumerator();\n    [DebuggerHidden]\n    IEnumerator IEnumerable.GetEnumerator();\n    [DebuggerHidden]\n    void IEnumerator.Reset();\n    void IDisposable.Dispose();\n\n    // Properties属性\n    object IEnumerator<object>.Current\n    { [DebuggerHidden] get; }\n\n    object IEnumerator.Current\n    { [DebuggerHidden] get; }\n}`, `74118798444864850000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                cs 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="cs"><pre style="counter-reset: linenumber NaN" class="language-cs line-numbers"><code class="language-cs"><span class="token punctuation">[</span><span class="token class-name">CompilerGenerated</span><span class="token punctuation">]</span>\n<span class="token keyword">private</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">YieldEnumerator</span> <span class="token punctuation">:</span>\n   <span class="token class-name">IEnumerable</span><span class="token operator">&lt;</span><span class="token keyword">object</span><span class="token operator">></span><span class="token punctuation">,</span> IEnumerator<span class="token operator">&lt;</span><span class="token keyword">object</span><span class="token operator">></span>\n<span class="token punctuation">{</span>\n    <span class="token comment">// Fields字段</span>\n    <span class="token keyword">private</span> <span class="token keyword">int</span> state<span class="token punctuation">;</span>\n    <span class="token keyword">private</span> <span class="token keyword">int</span> current<span class="token punctuation">;</span>\n    <span class="token keyword">public</span> <span class="token class-name">YieldClass</span> owner<span class="token punctuation">;</span>\n    <span class="token keyword">private</span> <span class="token keyword">int</span> initialThreadId<span class="token punctuation">;</span>\n\n    <span class="token comment">// Methods方法</span>\n    <span class="token punctuation">[</span><span class="token class-name">DebuggerHidden</span><span class="token punctuation">]</span>\n    <span class="token keyword">public</span> <span class="token function">YieldEnumerator</span><span class="token punctuation">(</span><span class="token keyword">int</span> state<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">private</span> <span class="token keyword">bool</span> <span class="token function">MoveNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">[</span><span class="token class-name">DebuggerHidden</span><span class="token punctuation">]</span>\n    IEnumerator<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> IEnumerable<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">.</span><span class="token function">GetEnumerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">[</span><span class="token class-name">DebuggerHidden</span><span class="token punctuation">]</span>\n    <span class="token class-name">IEnumerator</span> IEnumerable<span class="token punctuation">.</span><span class="token function">GetEnumerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">[</span><span class="token class-name">DebuggerHidden</span><span class="token punctuation">]</span>\n    <span class="token keyword">void</span> IEnumerator<span class="token punctuation">.</span><span class="token function">Reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">void</span> IDisposable<span class="token punctuation">.</span><span class="token function">Dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    <span class="token comment">// Properties属性</span>\n    <span class="token keyword">object</span> IEnumerator<span class="token operator">&lt;</span><span class="token keyword">object</span><span class="token operator">></span><span class="token punctuation">.</span>Current\n    <span class="token punctuation">{</span> <span class="token punctuation">[</span><span class="token class-name">DebuggerHidden</span><span class="token punctuation">]</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>\n\n    <span class="token keyword">object</span> IEnumerator<span class="token punctuation">.</span>Current\n    <span class="token punctuation">{</span> <span class="token punctuation">[</span><span class="token class-name">DebuggerHidden</span><span class="token punctuation">]</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>原始的 Example() 方法仅返回一个 YieldEnumerator 的实例，并将初始状态 -2 传递给它自身和其引用者，每一个迭代器保存一个状态指示</p>\n<ul>\n<li>-2：初始化为可迭代类 Enumerable</li>\n<li>-1: 迭代结束</li>\n<li>0: 初始化为迭代器 Enumerator</li>\n<li>1-n: 原始 Example() 方法中的 yield return 索引值</li>\n</ul>\n<p>Example() 方法中代码被转换为 YieldingEnumerator.MoveNext()，在我们的示例中转换后代码如下</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="67897599753686880000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`bool MoveNext() {\n  switch (state) {\n    case 0:\n      state = -1;\n      current = 1;\n      state = 1;\n      return true;\n    case 1:\n      state = -1;\n      current = 2;\n      state = 2;\n      return true;\n    case 2:\n      state = -1;\n      current = 3;\n      state = 3;\n      return true;\n    case 3:\n      state = -1;\n      break;\n  }\n  return false;\n}`, `67897599753686880000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                cs 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="cs"><pre style="counter-reset: linenumber NaN" class="language-cs line-numbers"><code class="language-cs"><span class="token keyword">bool</span> <span class="token function">MoveNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">switch</span> <span class="token punctuation">(</span>state<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">case</span> <span class="token number">0</span><span class="token punctuation">:</span>\n      state <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>\n      current <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>\n      state <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>\n      <span class="token keyword">return</span> <span class="token keyword">true</span><span class="token punctuation">;</span>\n    <span class="token keyword">case</span> <span class="token number">1</span><span class="token punctuation">:</span>\n      state <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>\n      current <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>\n      state <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>\n      <span class="token keyword">return</span> <span class="token keyword">true</span><span class="token punctuation">;</span>\n    <span class="token keyword">case</span> <span class="token number">2</span><span class="token punctuation">:</span>\n      state <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>\n      current <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>\n      state <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>\n      <span class="token keyword">return</span> <span class="token keyword">true</span><span class="token punctuation">;</span>\n    <span class="token keyword">case</span> <span class="token number">3</span><span class="token punctuation">:</span>\n      state <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>\n      <span class="token keyword">break</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token keyword">return</span> <span class="token keyword">false</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>利用上述的代码转换，编译器为我们生成了一个状态机，正是基于这一状态机模型，实现了 yield 关键字的特性。</p>\n<p>迭代器状态机模型可如下图所示</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-06-25-11-35-01-f242b8429492cc77e5f614a90ea2f061-6de41.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 327px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 107.95107033639144%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAWCAIAAABPIytRAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABsUlEQVQ4y42U246CQBBE5/8/ivjio1EWo09GUYiGKIJ4QwT27JQh7rrR6cRJM051VddcTNu2RVGkabrf71MbJLfbrXUIA/JwODxP3e/33W5X1/VnsHiaphmPx6PRaLvdSsvpdCJh/h0Y2uPxSHa5XEiqqiJHvJIPzNTO8xz+siyRCh7NFHLqWdoIYJvNRnnrFkZL6XC5XM5ms/V67Wj1g5lAMOJBXq9X3NZk8zv+B4MEkCQJhlc2XtcBRhG7kGUZHkudAYlbfIOhBLbBP51OMXyxWMznc0YsZBKYTGVlbsPwO5/PlCltSDPOMcmnRmAQiJxPWqMENhltKd9fNiaTCWAw2i21CpiE8xMEAa0Nh8M4jsEbdkj/de1RG2bAhQ0YWIP+Zy/UrNE+ZTb4liWM8KxWKxjCMEQdIzNqVSup/mMYtLQKAFfUJL29XgwtU0ipoTYMnBCE9Xq9fr/v+77neVEUSZ42WcnffdYs/bDPOEFV9eZySB8XgzboHM/1MLhejO5KdmeQET+6Q/oODA8OkdHkYDDQG0A5p8cAnch+ZoaTXXF6hvTosFqvH8eY0fFWfgOraP8k46SB9gAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 06 25 11 35 01"\n        title=""\n        src="/static/2021-06-25-11-35-01-f242b8429492cc77e5f614a90ea2f061-6de41.png"\n        srcset="/static/2021-06-25-11-35-01-f242b8429492cc77e5f614a90ea2f061-e9163.png 200w,\n/static/2021-06-25-11-35-01-f242b8429492cc77e5f614a90ea2f061-6de41.png 327w"\n        sizes="(max-width: 327px) 100vw, 327px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<ul>\n<li>Before 为迭代器初始状态</li>\n<li>Running 为调用 MoveNext 后进入这个状态。在这个状态，枚举数检测并设置下一项的位置。遇到 yield return、yield break 或者迭代结束时，退出该状态</li>\n<li>Suspended 为状态机等待下次调用 MoveNext 的状态</li>\n<li>After 为迭代结束的状态</li>\n</ul>\n<h1 id="generators-in-javascript"><a href="#generators-in-javascript" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Generators in Javascript</h1>\n<p>通过阅读上文，我们了解了 Generator 在 C# 中的使用，并且通过查看编译器生成的 IL 代码，得知编译器会生成一个内部类来保存上下文信息，然后将 yield return 表达式转换成 switch case，通过状态机模式实现 yield 关键字的特性。</p>\n<h2 id="javascript-generators-原理浅析"><a href="#javascript-generators-%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Javascript Generators 原理浅析</h2>\n<p>yield 关键字在 Javascript 中如何实现呢？</p>\n<p>首先，生成器不是线程。支持线程的语言中，多段不同的代码可以在同一时候运行，这经常会导致资源竞争，使用得当会有不错的性能提升。生成器则完全不同，Javascript 执行引擎仍然是一个基于事件循环的单线程环境，当生成器运行的时候，它会在叫做 caller 的同一个线程中运行。执行的顺序是有序、确定的，并且永远不会产生并发。不同于系统的线程，生成器只会在其内部用到 yield 的时候才会被挂起。</p>\n<p>既然生成器并非由引擎从底层提供额外的支持，我们可以沿用上文在 C# 中对 yield 特性的原理探究的经验，将生成器视为一个语法糖，用一个辅助工具将生成器函数转换为普通的 Javascript 代码，在经过转换的代码中，有两个关键点，一是要保存函数的上下文信息，二是实现一个完善的迭代方法，使得多个 yield 表达式按序执行，从而实现生成器的特性。</p>\n<h2 id="how-generators-work-in-es5"><a href="#how-generators-work-in-es5" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>How Generators work in ES5</h2>\n<p>Regenerator 工具已经实现了上述思路，借助 Regenerator 工具，我们已经可以在原生 ES5 中使用生成器函数，本节我们来分析 Regenerator 实现方式以深入理解 Generators 运行原理。</p>\n<p>通过这个<a href="http://babeljs.io/repl/" target="_blank" rel="nofollow noreferrer noopener">在线地址</a>可以方便的查看经过转换后的代码，仍然以文章初始为例</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="43688219727478500000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function* example() {\n  yield 1;\n  yield 2;\n  yield 3;\n}\nvar iter = example();\niter.next();`, `43688219727478500000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">example</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">yield</span> <span class="token number">1</span><span class="token punctuation">;</span>\n  <span class="token keyword">yield</span> <span class="token number">2</span><span class="token punctuation">;</span>\n  <span class="token keyword">yield</span> <span class="token number">3</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">var</span> iter <span class="token operator">=</span> <span class="token function">example</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\niter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>经过转换后为</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="96338639259883620000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`var marked0\\$0 = [example].map(regeneratorRuntime.mark);\nfunction example() {\n  return regeneratorRuntime.wrap(\n    function example\\$(context\\$1\\$0) {\n      while (1)\n        switch ((context\\$1\\$0.prev = context\\$1\\$0.next)) {\n          case 0:\n            context\\$1\\$0.next = 2;\n            return 1;\n\n          case 2:\n            context\\$1\\$0.next = 4;\n            return 2;\n\n          case 4:\n            context\\$1\\$0.next = 6;\n            return 3;\n\n          case 6:\n          case \'end\':\n            return context\\$1\\$0.stop();\n        }\n    },\n    marked0\\$0[0],\n    this\n  );\n}\nvar iter = example();\niter.next();`, `96338639259883620000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">var</span> marked0$<span class="token number">0</span> <span class="token operator">=</span> <span class="token punctuation">[</span>example<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>regeneratorRuntime<span class="token punctuation">.</span>mark<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">function</span> <span class="token function">example</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> regeneratorRuntime<span class="token punctuation">.</span><span class="token function">wrap</span><span class="token punctuation">(</span>\n    <span class="token keyword">function</span> <span class="token function">example$</span><span class="token punctuation">(</span><span class="token parameter">context$<span class="token number">1</span>$<span class="token number">0</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>\n        <span class="token keyword">switch</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>context$<span class="token number">1</span>$<span class="token number">0.</span>prev <span class="token operator">=</span> context$<span class="token number">1</span>$<span class="token number">0.</span>next<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n          <span class="token keyword">case</span> <span class="token number">0</span><span class="token punctuation">:</span>\n            context$<span class="token number">1</span>$<span class="token number">0.</span>next <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>\n            <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>\n\n          <span class="token keyword">case</span> <span class="token number">2</span><span class="token punctuation">:</span>\n            context$<span class="token number">1</span>$<span class="token number">0.</span>next <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>\n            <span class="token keyword">return</span> <span class="token number">2</span><span class="token punctuation">;</span>\n\n          <span class="token keyword">case</span> <span class="token number">4</span><span class="token punctuation">:</span>\n            context$<span class="token number">1</span>$<span class="token number">0.</span>next <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>\n            <span class="token keyword">return</span> <span class="token number">3</span><span class="token punctuation">;</span>\n\n          <span class="token keyword">case</span> <span class="token number">6</span><span class="token punctuation">:</span>\n          <span class="token keyword">case</span> <span class="token string">\'end\'</span><span class="token punctuation">:</span>\n            <span class="token keyword">return</span> context$<span class="token number">1</span>$<span class="token number">0.</span><span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n    marked0$<span class="token number">0</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>\n    <span class="token keyword">this</span>\n  <span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">var</span> iter <span class="token operator">=</span> <span class="token function">example</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\niter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>从转换后的代码中可以看到，与 C# 编译器对 yield return 表达式的转换相似，Regenerator 将生成器函数中的 yield 表达式重写为 switch case，同时，在每个 case 中使用 context<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base"><span class="mord">1</span></span></span></span>0 来保存函数当前的上下文状态。</p>\n<p>switch case 之外，迭代器函数 example 被 regeneratorRuntime.mark 包装，返回一个被 regeneratorRuntime.wrap 包装的迭代器对象。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="48747850555526840000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`runtime.mark = function(genFun) {\n  if (Object.setPrototypeOf) {\n    Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n  } else {\n    genFun.__proto__ = GeneratorFunctionPrototype;\n  }\n  genFun.prototype = Object.create(Gp);\n  return genFun;\n};`, `48747850555526840000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js">runtime<span class="token punctuation">.</span><span class="token function-variable function">mark</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">genFun</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>Object<span class="token punctuation">.</span>setPrototypeOf<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    Object<span class="token punctuation">.</span><span class="token function">setPrototypeOf</span><span class="token punctuation">(</span>genFun<span class="token punctuation">,</span> GeneratorFunctionPrototype<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n    genFun<span class="token punctuation">.</span>__proto__ <span class="token operator">=</span> GeneratorFunctionPrototype<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  genFun<span class="token punctuation">.</span>prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>Gp<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">return</span> genFun<span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>通过 mark 包装，将 example 包装成如下对象</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-06-25-13-35-30-36238a821c4f54bd3a2ef4bfea07ace6-bee38.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 404px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 62.37623762376238%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABf0lEQVQoz42S647bIBCF/f6vt6q6iZI4iYmxGa6GGYNvFCdt1a121Z4fgDT6hjOXKqUklQQJSimttZSSc36/MyHsPE855+1rVeu22s5g65F7A4Yx1u3qvQ9CiHme89eq9tzLNqoROwwafQgBsdjZ8lbIkv4fcBGpMQjEgRKO27L8Dv/l8xM4pUiSSFOSJtxuljVTSvk/9IRjdMZHNwWISPF8vd4bBkJqbQQA7/v+eZaWLutaalmWcu+q8tNLUNLX7djI8QpjA1h36ls9HB+6vrXHo7hcutOpP59V25ahlIkAABEVeKdDx+HQurujbvAHRbWFprvfrlNMr9Jff2Tn8h+V/4RJSsvMwDEoIo7Ighee8XZM8UOV3n8Ch/YhvzP9DvoA9gSh1v6kbC2i8aujGcKicAq0WvMRznndtmgMNgJvcmTK133zduSHC3FJvcQOqAVswfd9dK6swPJrc6qnl8FZr8ENNgRH+qERcLBeWWOcM3tw2B/OaWtLqxDxBf8AWU2xTF/vgL0AAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 06 25 13 35 30"\n        title=""\n        src="/static/2021-06-25-13-35-30-36238a821c4f54bd3a2ef4bfea07ace6-bee38.png"\n        srcset="/static/2021-06-25-13-35-30-36238a821c4f54bd3a2ef4bfea07ace6-3ac6c.png 200w,\n/static/2021-06-25-13-35-30-36238a821c4f54bd3a2ef4bfea07ace6-b7ce3.png 400w,\n/static/2021-06-25-13-35-30-36238a821c4f54bd3a2ef4bfea07ace6-bee38.png 404w"\n        sizes="(max-width: 404px) 100vw, 404px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>当调用生成器函数 example() 时，返回一个被 wrap 函数包装后的迭代器对象</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="10145573890832460000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`runtime.wrap = function(innerFn, outerFn, self, tryLocsList) {\n  // If outerFn provided, then outerFn.prototype instanceof Generator.\n  var generator = Object.create((outerFn || Generator).prototype);\n  var context = new Context(tryLocsList || []);\n\n  // The ._invoke method unifies the implementations of the .next,\n  // .throw, and .return methods.\n  generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n  return generator;\n};`, `10145573890832460000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js">runtime<span class="token punctuation">.</span><span class="token function-variable function">wrap</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">innerFn<span class="token punctuation">,</span> outerFn<span class="token punctuation">,</span> self<span class="token punctuation">,</span> tryLocsList</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// If outerFn provided, then outerFn.prototype instanceof Generator.</span>\n  <span class="token keyword">var</span> generator <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">(</span>outerFn <span class="token operator">||</span> Generator<span class="token punctuation">)</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">var</span> context <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Context</span><span class="token punctuation">(</span>tryLocsList <span class="token operator">||</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token comment">// The ._invoke method unifies the implementations of the .next,</span>\n  <span class="token comment">// .throw, and .return methods.</span>\n  generator<span class="token punctuation">.</span>_invoke <span class="token operator">=</span> <span class="token function">makeInvokeMethod</span><span class="token punctuation">(</span>innerFn<span class="token punctuation">,</span> self<span class="token punctuation">,</span> context<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token keyword">return</span> generator<span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>返回的迭代器对象如下所示</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-06-25-13-36-06-9ce4295f79368566bb71f9e836c39855-f72ce.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 419px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 44.391408114558466%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAIAAAC9o5sfAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABIUlEQVQoz4WRi27DIAxF8/+fOK3LmrSQ8DCEpwMkmde1Ujtp2tUVmMcBY7ocgjPGKGUNGK21FN4te2vHvv82Tb66W9eVkOHzPDGlIJeEJZaGFRHTQ2spNNy2bT+OZ3ettZwzTOBZiEBRVP3sxBJTtHctRHrvCT5e1ZVSqPOLjxAREAOO13EYBy201VYKyTmf55kxJqWkzZRpuYnOusOlFittBswqZZ2yijAoewHiZyEIU/QmAHrgrT6KglrrA25l7gV82CC9fzPh3QLT7/2JEj7+1h2urQI37uK9CPHq0yWEyU18+ln9B6a0xVmYkzXDYnqznK0bFjta9FjciiqtVMuUd/qwZ5gK8H1zrcFFtJjJETnjSqpW2la3jdqbSfurvgBP0Aabong3IgAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 06 25 13 36 06"\n        title=""\n        src="/static/2021-06-25-13-36-06-9ce4295f79368566bb71f9e836c39855-f72ce.png"\n        srcset="/static/2021-06-25-13-36-06-9ce4295f79368566bb71f9e836c39855-58799.png 200w,\n/static/2021-06-25-13-36-06-9ce4295f79368566bb71f9e836c39855-69db4.png 400w,\n/static/2021-06-25-13-36-06-9ce4295f79368566bb71f9e836c39855-f72ce.png 419w"\n        sizes="(max-width: 419px) 100vw, 419px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>当调用迭代器对象 iter.next() 方法时，因为有如下代码，所以会执行 _invoke 方法，而根据前面 wrap 方法代码可知，最终是调用了迭代器对象的 makeInvokeMethod(innerFn, self, context); 方法</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="26364447343217700000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// Helper for defining the .next, .throw, and .return methods of the\n// Iterator interface in terms of a single ._invoke method.\nfunction defineIteratorMethods(prototype) {\n  [\'next\', \'throw\', \'return\'].forEach(function(method) {\n    prototype[method] = function(arg) {\n      return this._invoke(method, arg);\n    };\n  });\n}`, `26364447343217700000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">// Helper for defining the .next, .throw, and .return methods of the</span>\n<span class="token comment">// Iterator interface in terms of a single ._invoke method.</span>\n<span class="token keyword">function</span> <span class="token function">defineIteratorMethods</span><span class="token punctuation">(</span><span class="token parameter">prototype</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token punctuation">[</span><span class="token string">\'next\'</span><span class="token punctuation">,</span> <span class="token string">\'throw\'</span><span class="token punctuation">,</span> <span class="token string">\'return\'</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">method</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    prototype<span class="token punctuation">[</span>method<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">arg</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">_invoke</span><span class="token punctuation">(</span>method<span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>makeInvokeMethod 方法内容较多，这里选取部分分析。首先，我们发现生成器将自身状态初始化为“Suspended Start”</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="53238774642487984000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function makeInvokeMethod(innerFn, self, context) {\n  var state = GenStateSuspendedStart;\n\n  return function invoke(method, arg) {`, `53238774642487984000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span> <span class="token function">makeInvokeMethod</span><span class="token punctuation">(</span><span class="token parameter">innerFn<span class="token punctuation">,</span> self<span class="token punctuation">,</span> context</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">var</span> state <span class="token operator">=</span> GenStateSuspendedStart<span class="token punctuation">;</span>\n\n  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token function">invoke</span><span class="token punctuation">(</span><span class="token parameter">method<span class="token punctuation">,</span> arg</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>makeInvokeMethod 返回 invoke 函数，当我们执行 .next 方法时，实际调用的是 invoke 方法中的下面语句</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="63505597517483614000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`var record = tryCatch(innerFn, self, context);`, `63505597517483614000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">var</span> record <span class="token operator">=</span> <span class="token function">tryCatch</span><span class="token punctuation">(</span>innerFn<span class="token punctuation">,</span> self<span class="token punctuation">,</span> context<span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>这里 tryCatch 方法中 fn 为经过转换后的 example$ 方法，arg 为上下文对象 context, 因为 invoke 函数内部对 context 的引用形成闭包引用，所以 context 上下文得以在迭代期间一直保持。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="12154519878327030000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function tryCatch(fn, obj, arg) {\n  try {\n    return { type: \'normal\', arg: fn.call(obj, arg) };\n  } catch (err) {\n    return { type: \'throw\', arg: err };\n  }\n}`, `12154519878327030000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span> <span class="token function">tryCatch</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span> obj<span class="token punctuation">,</span> arg</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">try</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token punctuation">{</span> type<span class="token punctuation">:</span> <span class="token string">\'normal\'</span><span class="token punctuation">,</span> arg<span class="token punctuation">:</span> <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> arg<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token punctuation">{</span> type<span class="token punctuation">:</span> <span class="token string">\'throw\'</span><span class="token punctuation">,</span> arg<span class="token punctuation">:</span> err <span class="token punctuation">}</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>tryCatch 方法会实际调用 example$ 方法，进入转换后的 switch case, 执行代码逻辑。如果得到的结果是一个普通类型的值，我们将它包装成一个可迭代对象格式，并且更新生成器状态至 GenStateCompleted 或者 GenStateSuspendedYield</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="24709191711337540000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`var record = tryCatch(innerFn, self, context);\nif (record.type === &quot;normal&quot;) {\n  // If an exception is thrown from innerFn, we leave state ===\n  // GenStateExecuting and loop back for another invocation.\n  state = context.done\n    ? GenStateCompleted\n    : GenStateSuspendedYield;\n\n  var info = {\n    value: record.arg,\n    done: context.done\n  };`, `24709191711337540000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">var</span> record <span class="token operator">=</span> <span class="token function">tryCatch</span><span class="token punctuation">(</span>innerFn<span class="token punctuation">,</span> self<span class="token punctuation">,</span> context<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">if</span> <span class="token punctuation">(</span>record<span class="token punctuation">.</span>type <span class="token operator">===</span> <span class="token string">"normal"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// If an exception is thrown from innerFn, we leave state ===</span>\n  <span class="token comment">// GenStateExecuting and loop back for another invocation.</span>\n  state <span class="token operator">=</span> context<span class="token punctuation">.</span>done\n    <span class="token operator">?</span> GenStateCompleted\n    <span class="token punctuation">:</span> GenStateSuspendedYield<span class="token punctuation">;</span>\n\n  <span class="token keyword">var</span> info <span class="token operator">=</span> <span class="token punctuation">{</span>\n    value<span class="token punctuation">:</span> record<span class="token punctuation">.</span>arg<span class="token punctuation">,</span>\n    done<span class="token punctuation">:</span> context<span class="token punctuation">.</span>done\n  <span class="token punctuation">}</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h1 id="总结"><a href="#%E6%80%BB%E7%BB%93" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总结</h1>\n<p>通过对 Regenerator 转换后的生成器代码及工具源码分析，我们探究了生成器的运行原理。Regenerator 通过工具函数将生成器函数包装，为其添加如 next/return 等方法。同时也对返回的生成器对象进行包装，使得对 next 等方法的调用，最终进入由 switch case 组成的状态机模型中。除此之外，利用闭包技巧，保存生成器函数上下文信息。</p>\n<p>上述过程与 C# 中 yield 关键字的实现原理基本一致，都采用了编译转换思路，运用状态机模型，同时保存函数上下文信息，最终实现了新的 yield 关键字带来的新的语言特性。</p>',
id:"/github/workspace/blog/深入理解 Generators/index.md absPath of file >>> MarkdownRemark",timeToRead:5,frontmatter:{date:"2021-06-25 11:14:53",path:"/deep-learn-generators/",tags:"前端, JS, 高级前端",title:"深入理解 Generators",draft:null}},{excerpt:"背景 我们都知道，javascript 从诞生之日起就是一门单线程的非阻塞的脚本语言。这是由其最初的用途来决定的：与浏览器交互。 单线程意味着 javascript 代码在执行的任何时候，都只有一个主线程来处理所有的任务。 而非阻塞则是当代码需要进行一项异步任务（无法立刻返回结果，需要花一定时间才能返回的任务，如 I/O 事件）的时候，主线程会挂起（pending）这个任务，然后在异步任务返回结果的时候再根据一定规则去执行相应的回调。 单线程是必要的，也是 javascript…",html:'<h1 id="背景"><a href="#%E8%83%8C%E6%99%AF" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>背景</h1>\n<p>我们都知道，javascript 从诞生之日起就是一门单线程的非阻塞的脚本语言。这是由其最初的用途来决定的：与浏览器交互。</p>\n<p>单线程意味着 javascript 代码在执行的任何时候，都只有一个主线程来处理所有的任务。</p>\n<p>而非阻塞则是当代码需要进行一项异步任务（无法立刻返回结果，需要花一定时间才能返回的任务，如 I/O 事件）的时候，主线程会挂起（pending）这个任务，然后在异步任务返回结果的时候再根据一定规则去执行相应的回调。</p>\n<p>单线程是必要的，也是 javascript 这门语言的基石，原因之一在最主要的执行环境浏览器中，我们需要进行各种各样的 dom 操作。试想一下如果 javascript 是多线程的，那么当两个线程同时对 dom 进行一项操作，例如一个向其添加事件，而另一个删除了这个 dom，此时该如何处理呢？因此，为了保证不会发生类似于这个例子中的情景，javascript 选择只用一个主线程来执行代码，这样就保证了程序执行的一致性。</p>\n<p>当然，现如今人们也意识到，单线程在保证了执行顺序的同时也限制了 javascript 的效率，因此开发出了 web worker 技术，这项技术号称让 javascript 成为一门多线程语言。</p>\n<p>然而，使用 web worker 技术的多线程有着诸多限制，例如所有新线程都受主线程的完全控制，不能独立执行。这意味着这些“线程” 实际上应属于主线程的子线程。另外，这些子线程并没有执行 I/O 操作的权限，只能为主线程分担一些诸如计算等任务。所以严格来讲这些线程并没有完整的功能，也因此这项技术并非改变了 javascript 语言的单线程本质。</p>\n<p>可以预见，未来的 javascript 也会一直是一门单线程的语言。</p>\n<p>话说回来，前面提到 javascript 的另一个特点是“非阻塞”，那么 javascript 引擎到底是如何实现的这一点呢？答案就是今天这篇文章的主角——event loop（事件循环）。</p>\n<blockquote>\n<p>注：虽然 nodejs 中的也存在与传统浏览器环境下的相似的事件循环。然而两者间却有着诸多不同，故把两者分开，单独解释。</p>\n</blockquote>\n<h1 id="浏览器事件循环"><a href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>浏览器事件循环</h1>\n<h2 id="执行栈与事件队列"><a href="#%E6%89%A7%E8%A1%8C%E6%A0%88%E4%B8%8E%E4%BA%8B%E4%BB%B6%E9%98%9F%E5%88%97" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>执行栈与事件队列</h2>\n<p>当 javascript 代码执行的时候会将不同的变量存于内存中的不同位置：堆（heap）和栈（stack）中来加以区分。其中，堆里存放着一些对象，而栈中则存放着一些基础类型变量以及对象的指针，但是我们这里说的执行栈和上面这个栈的意义却有些不同。</p>\n<p>我们知道，当我们调用一个方法的时候，js 会生成一个与这个方法对应的执行环境（context），又叫执行上下文。这个执行环境中存在着这个方法的私有作用域，上层作用域的指向，方法的参数，这个作用域中定义的变量以及这个作用域的 this 对象。 而当一系列方法被依次调用的时候，因为 js 是单线程的，同一时间只能执行一个方法，于是这些方法被排队在一个单独的地方，这个地方被称为执行栈。</p>\n<p>当一个脚本第一次执行的时候，js 引擎会解析这段代码，并将其中的同步代码按照执行顺序加入执行栈中，然后从头开始执行。如果当前执行的是一个方法，那么 js 会向执行栈中添加这个方法的执行环境，然后进入这个执行环境继续执行其中的代码。当这个执行环境中的代码执行完毕并返回结果后，js 会退出这个执行环境并把这个执行环境销毁，回到上一个方法的执行环境。这个过程反复进行，直到执行栈中的代码全部执行完毕。</p>\n<p>下面这个图片非常直观的展示了这个过程，其中的 global 就是初次运行脚本时向执行栈中加入的代码：</p>\n<p><img src="/static/function-eval-2f761eb83b50f53d741e6aa1f15a9db1.gif"></p>\n<p>从图片可知，一个方法执行会向执行栈中加入这个方法的执行环境，在这个执行环境中还可以调用其他方法，甚至是自己，其结果不过是在执行栈中再添加一个执行环境。这个过程可以是无限进行下去的，除非发生了栈溢出，即超过了所能使用内存的最大值。</p>\n<p>以上的过程说的都是同步代码的执行，那么当一个异步代码（如发送 ajax 请求数据）执行后会如何呢？前文提过，js 的另一大特点是非阻塞，实现这一点的关键在于下面要说的这项机制——事件队列（Task Queue）。</p>\n<p>js 引擎遇到一个异步事件后并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。当一个异步事件返回结果后，js 会将这个事件加入与当前执行栈不同的另一个队列，我们称之为事件队列。被放入事件队列不会立刻执行其回调，而是等待当前执行栈中的所有任务都执行完毕，主线程处于闲置状态时，主线程会去查找事件队列是否有任务。如果有，那么主线程会从中取出排在第一位的事件，并把这个事件对应的回调放入执行栈中，然后执行其中的同步代码，如此反复，这样就形成了一个无限的循环，这个过程被称为“事件循环（Event Loop）”。</p>\n<p>这里还有一张图来展示这个过程：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-06-24-11-25-19-8dc896bf82e7cb24d77d406e3f89dd05-2c5fa.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 601px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 87.68718801996673%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAIAAADUsmlHAAAACXBIWXMAAA7DAAAOwwHHb6hkAAADUElEQVQ4y4WTz2skRRTH66YXPbiJnhQCXlZxJZEE9SYe1P9AQQlo9qZ4UJAFDwGjiRJBFGVdEVEQBDeKCovOsrusyc7OpJN0Qoyzmemenpmd7unpnh+Z/lU/X5XVE1dFDzbN49Wr+tb7dtWnkVRCKRWl3kXjDJPvS6Wk4lIBKPG/L8pwnGGFWfmL79CVjSe5UHmFpBzYv5YKyf+Kf4oJy3Q33TsIzwc9Q+WdRZoljNO8v2QARAjMOZaSEpIAUF3JoxYfjYb7+2alcoNSNRiMdrY363UrTiIm8mmQoLcjjJXN3c3dvZK51+r4ugJSHttOPd+96TWTbBTF/eZNuz/oJmnMc7FicZc6m8TZyuwytq5Tx9BD1jBoe083R4RiNX70Loyz4zxOY8YzneDdb4JXbyvOTxbnJ9ZfmLj2/IlLz05UX7wjWnyQJT10oxX+uDMqZBcaUYuz347Sy5hfJWwAUowwd9bPeh887KzOVZdn7ZVZa3nWeW+uuTLtffoUkD5KGOtWagfurwPOM/JSM5jqZw+43qXqoVNruvbVj/eXT+4vP2IuTR+8O7311rSxNGMsnqp+9ISkIeLa8Na1rPY7VYryV9rhTEQf64ZFjHlu+/Cro89udz+5x1yaPHhncmdxsrpy9+jDO6OvZwQboCRNi5frlBNMFRYvd45ORWyO8QNNiT6wzLsSXXwu/OV0/fsF6/y8tbbg/nQ6+nk+2XhDiARhgs0NmzFMqCJiwRveH7OHMDF5LtacwJi5HIVW24d8pMYVPcERZUSPBXCes1OhfJPQUpaFHMYY3YJE35ptHepjkTkhY0gkQ/1hr9VqeJ22jp1Ot1AouF4HFBUyAZWCwqAynXBIbLv2TzZzSILQrzu1Xj+w7EPf75VKNdsOtBdt5NYqqU0OhqNKpZLX4e8ZpAHWJDKBx1+yA/IMyDc5nAP5NqjXhPwS1KpSrwu5KgBrmW6u/xm9RS7u+F65XDKM61bNT9m5ZoCsNkr4o27/rkYX9eOng+jeaguF0RSoGJRGmh/rx2yTdHvbME0jCPXVft4KUcNHEXm8HZ5wOlrzTHd0n+Uifzgl/yvWmb5kDpTrswcH1JpUP3BYl/KCUt8CFEEWlFrTUehjB5F7FkyMbf8Bd+Crm/fIVg4AAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 06 24 11 25 19"\n        title=""\n        src="/static/2021-06-24-11-25-19-8dc896bf82e7cb24d77d406e3f89dd05-2c5fa.png"\n        srcset="/static/2021-06-24-11-25-19-8dc896bf82e7cb24d77d406e3f89dd05-31ae8.png 200w,\n/static/2021-06-24-11-25-19-8dc896bf82e7cb24d77d406e3f89dd05-e4d65.png 400w,\n/static/2021-06-24-11-25-19-8dc896bf82e7cb24d77d406e3f89dd05-2c5fa.png 601w"\n        sizes="(max-width: 601px) 100vw, 601px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>图中的 stack 表示我们所说的执行栈，web apis 则是代表一些异步事件，而 callback queue 即事件队列。</p>\n<h2 id="macro-task-与-micro-task"><a href="#macro-task-%E4%B8%8E-micro-task" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>macro task 与 micro task</h2>\n<p>以上的事件循环过程是一个宏观的表述，实际上因为异步任务之间并不相同，因此他们的执行优先级也有区别。不同的异步任务被分为两类：微任务（micro task）和宏任务（macro task）。</p>\n<p>以下事件属于宏任务：</p>\n<ul>\n<li>setInterval()</li>\n<li>setTimeout()</li>\n</ul>\n<p>以下事件属于微任务</p>\n<ul>\n<li>new Promise()</li>\n<li>new MutationObserver()</li>\n</ul>\n<p>前面我们介绍过，在一个事件循环中，异步事件返回结果后会被放到一个任务队列中。然而，根据这个异步事件的类型，这个事件实际上会进入对应的宏任务队列或者微任务队列中。并且在当前执行栈为空的时候，主线程会查看微任务队列是否有事件存在。如果不存在，那么再去宏任务队列中取出一个事件并把对应的加入当前执行栈；如果存在，则会依次执行队列中事件对应的回调，直到微任务队列为空，然后去宏任务队列中取出最前面的一个事件，把对应的回调加入当前执行栈，如此反复，进入循环。</p>\n<p>我们只需记住当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件，然后再去宏任务队列中取出一个事件。同一次事件循环中，微任务永远在宏任务之前执行。</p>\n<p>这样就能解释下面这段代码的结果：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="78920356193145630000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`setTimeout(function() {\n  console.log(1);\n});\n\nnew Promise(function(resolve, reject) {\n  console.log(2);\n  resolve(3);\n}).then(function(val) {\n  console.log(val);\n});`, `78920356193145630000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">val</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>结果为：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="97134448236066230000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`2\n3\n1`, `97134448236066230000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">2\n3\n1</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span></span></pre></div>\n<h1 id="node-事件循环"><a href="#node-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>node 事件循环</h1>\n<h2 id="与浏览器环境的不同"><a href="#%E4%B8%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E7%8E%AF%E5%A2%83%E7%9A%84%E4%B8%8D%E5%90%8C" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>与浏览器环境的不同</h2>\n<p>在 node 中，事件循环表现出的状态与浏览器中大致相同。不同的是 node 中有一套自己的模型。node 中事件循环的实现是依靠的 libuv 引擎。我们知道 node 选择 chrome v8 引擎作为 js 解释器，v8 引擎将 js 代码分析后去调用对应的 node api，而这些 api 最后则由 libuv 引擎驱动，执行对应的任务，并把不同的事件放在不同的队列中等待主线程执行。因此实际上 node 中的事件循环存在于 libuv 引擎中。</p>\n<h2 id="事件循环模型"><a href="#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%A8%A1%E5%9E%8B" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>事件循环模型</h2>\n<p>下面是一个 libuv 引擎中的事件循环的模型:</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="80342443335609900000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(` ┌───────────────────────┐\n┌─>│        timers         │\n│  └──────────┬────────────┘\n│  ┌──────────┴────────────┐\n│  │     I/O callbacks     │\n│  └──────────┬────────────┘\n│  ┌──────────┴────────────┐\n│  │     idle, prepare     │\n│  └──────────┬────────────┘      ┌───────────────┐\n│  ┌──────────┴────────────┐      │   incoming:   │\n│  │         poll          │<──connections───     │\n│  └──────────┬────────────┘      │   data, etc.  │\n│  ┌──────────┴────────────┐      └───────────────┘\n│  │        check          │\n│  └──────────┬────────────┘\n│  ┌──────────┴────────────┐\n└──┤    close callbacks    │\n   └───────────────────────┘`, `80342443335609900000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text"> ┌───────────────────────┐\n┌─&gt;│        timers         │\n│  └──────────┬────────────┘\n│  ┌──────────┴────────────┐\n│  │     I/O callbacks     │\n│  └──────────┬────────────┘\n│  ┌──────────┴────────────┐\n│  │     idle, prepare     │\n│  └──────────┬────────────┘      ┌───────────────┐\n│  ┌──────────┴────────────┐      │   incoming:   │\n│  │         poll          │&lt;──connections───     │\n│  └──────────┬────────────┘      │   data, etc.  │\n│  ┌──────────┴────────────┐      └───────────────┘\n│  │        check          │\n│  └──────────┬────────────┘\n│  ┌──────────┴────────────┐\n└──┤    close callbacks    │\n   └───────────────────────┘</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<blockquote>\n<p>注：模型中的每一个方块代表事件循环的一个阶段</p>\n</blockquote>\n<p>这个模型是 node 官网上的一篇文章中给出的，下面的解释也都来源于这篇文章。</p>\n<h2 id="事件循环各阶段详解"><a href="#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E5%90%84%E9%98%B6%E6%AE%B5%E8%AF%A6%E8%A7%A3" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>事件循环各阶段详解</h2>\n<p>从上面这个模型中，我们可以大致分析出 node 中的事件循环的顺序：</p>\n<p>外部输入数据 —> 轮询阶段(poll) —> 检查阶段(check) —> 关闭事件回调阶段(close callback) —> 定时器检测阶段(timer) —> I/O 事件回调阶段(I/O callbacks) —> 闲置阶段(idle, prepare) —> 轮询阶段</p>\n<p>以上各阶段的名称是根据我个人理解的翻译，为了避免错误和歧义，下面解释的时候会用英文来表示这些阶段。</p>\n<p>这些阶段大致的功能如下：</p>\n<ul>\n<li>timers: 这个阶段执行定时器队列中的回调如 setTimeout() 和 setInterval()。</li>\n<li>I/O callbacks: 这个阶段执行几乎所有的回调，但是不包括 close 事件，定时器和 setImmediate() 的回调。</li>\n<li>idle, prepare: 这个阶段仅在内部使用，可以不必理会。</li>\n<li>poll: 等待新的 I/O 事件，node 在一些特殊情况下会阻塞在这里。</li>\n<li>check: setImmediate() 的回调会在这个阶段执行。</li>\n<li>close callbacks: 例如 socket.on(‘close’, …) 这种 close 事件的回调。</li>\n</ul>\n<p>下面我们来按照代码第一次进入 libuv 引擎后的顺序来详细解说这些阶段：</p>\n<h3 id="poll-阶段"><a href="#poll-%E9%98%B6%E6%AE%B5" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>poll 阶段</h3>\n<p>当 v8 引擎将 js 代码解析传入 libuv 引擎后，循环首先进入 poll 阶段。poll 阶段的执行逻辑如下：先查看 poll queue 中是否有事件，有任务就按先进先出的顺序依次执行回调。当 queue 为空时，会检查是否有 setImmediate() 的 callback，如果有就进入 check 阶段执行这些 callback。但同时也会检查是否有到期的 timer，如果有，就把这些到期的 timer 的 callback 按照调用顺序放到 timer queue 中，之后循环会进入 timer 阶段执行 queue 中的 callback。这两者的顺序是不固定的，受到代码运行的环境的影响。如果两者的 queue 都是空的，那么 loop 会在 poll 阶段停留，直到有一个 i/o 事件返回，循环会进入 i/o callback 阶段并立即执行这个事件的 callback。</p>\n<p>值得注意的是，poll 阶段在执行 poll queue 中的回调时实际上不会无限的执行下去，有两种情况 poll 阶段会终止执行 poll queue 中的下一个回调：</p>\n<ol>\n<li>所有回调执行完毕。</li>\n<li>执行数超过了 node 的限制。</li>\n</ol>\n<h3 id="check-阶段"><a href="#check-%E9%98%B6%E6%AE%B5" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>check 阶段</h3>\n<p>check 阶段专门用来执行 setImmediate() 方法的回调，当 poll 阶段进入空闲状态，并且 setImmediate queue 中有 callback 时，事件循环进入这个阶段。</p>\n<h3 id="close-阶段"><a href="#close-%E9%98%B6%E6%AE%B5" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>close 阶段</h3>\n<p>当一个 socket 连接或者一个 handle 被突然关闭时（例如调用了 socket.destroy() 方法），close 事件会被发送到这个阶段执行回调，否则事件会用 process.nextTick() 方法发送出去。</p>\n<h3 id="timer-阶段"><a href="#timer-%E9%98%B6%E6%AE%B5" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>timer 阶段</h3>\n<p>这个阶段以先进先出的方式执行所有到期的加入 timer 队列里的 callback，一个 timer callback 指得是一个通过 setTimeout 或者 setInterval 函数设置的回调函数。</p>\n<h3 id="io-callback-阶段"><a href="#io-callback-%E9%98%B6%E6%AE%B5" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>I/O callback 阶段</h3>\n<p>如上文所言，这个阶段主要执行大部分 I/O 事件的回调，包括一些为操作系统执行的回调。例如一个 TCP 连接错误时，系统需要执行回调来获得这个错误的报告。</p>\n<h2 id="processnexttick"><a href="#processnexttick" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>process.nextTick()</h2>\n<p>尽管没有提及，但是实际上 node 中存在着一个特殊的队列，即 nextTick queue。这个队列中的回调执行虽然没有被表示为一个阶段，当时这些事件却会在每一个阶段执行完毕准备进入下一个阶段时优先执行。当事件循环准备进入下一个阶段之前，会先检查 nextTick queue 中是否有任务，如果有，那么会先清空这个队列。与执行 poll queue 中的任务不同的是，这个操作在队列清空前是不会停止的。这也就意味着，错误的使用 process.nextTick() 方法会导致 node 进入一个死循环，直到内存泄漏。</p>\n<p>那么怎么使用这个方法比较合适呢？下面有一个例子：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="72544212958505350000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`const server = net.createServer(() => {}).listen(8080);\n\nserver.on(\'listening\', () => {});`, `72544212958505350000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">const</span> server <span class="token operator">=</span> net<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">8080</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\nserver<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">\'listening\'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span></span></pre></div>\n<p>这个例子中当 listen 方法被调用时，除非端口被占用，否则会立刻绑定在对应的端口上。这意味着此时这个端口可以立刻触发 listening 事件并执行其回调。然而，这时候 <code class="language-text">on(&#39;listening&#39;)</code> 还没有将 callback 设置好，自然没有 callback 可以执行。为了避免出现这种情况，node 会在 listen 事件中使用 process.nextTick()方法，确保事件在回调函数绑定后被触发。</p>\n<h2 id="settimeout-和-setimmediate"><a href="#settimeout-%E5%92%8C-setimmediate" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>setTimeout() 和 setImmediate()</h2>\n<p>在三个方法中，这两个方法最容易被弄混。实际上，某些情况下这两个方法的表现也非常相似。然而实际上，这两个方法的意义却大为不同。</p>\n<p>setTimeout() 方法是定义一个回调，并且希望这个回调在我们所指定的时间间隔后第一时间去执行。注意这个“第一时间执行”，这意味着，受到操作系统和当前执行任务的诸多影响，该回调并不会在我们预期的时间间隔后精准的执行。执行的时间存在一定的延迟和误差，这是不可避免的。node 会在可以执行 timer 回调的第一时间去执行你所设定的任务。</p>\n<p>setImmediate() 方法从意义上将是立刻执行的意思，但是实际上它却是在一个固定的阶段才会执行回调，即 poll 阶段之后。有趣的是，这个名字的意义和之前提到过的 process.nextTick() 方法才是最匹配的。node 的开发者们也清楚这两个方法的命名上存在一定的混淆，他们表示不会把这两个方法的名字调换过来---因为有大量的 node 程序使用着这两个方法，调换命名所带来的好处与它的影响相比不值一提。</p>\n<p>setTimeout() 和不设置时间间隔的 setImmediate() 表现上及其相似。猜猜下面这段代码的结果是什么？</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="13149522730123686000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`setTimeout(() => {\n  console.log(\'timeout\');\n}, 0);\n\nsetImmediate(() => {\n  console.log(\'immediate\');\n});`, `13149522730123686000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'timeout\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token function">setImmediate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'immediate\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>实际上，答案是不一定。没错，就连 node 的开发者都无法准确的判断这两者的顺序谁前谁后。这取决于这段代码的运行环境。运行环境中的各种复杂的情况会导致在同步队列里两个方法的顺序随机决定。但是，在一种情况下可以准确判断两个方法回调的执行顺序，那就是在一个 I/O 事件的回调中。下面这段代码的顺序永远是固定的：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="39622569242571550000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`const fs = require(\'fs\');\n\nfs.readFile(__filename, () => {\n  setTimeout(() => {\n    console.log(\'timeout\');\n  }, 0);\n  setImmediate(() => {\n    console.log(\'immediate\');\n  });\n});`, `39622569242571550000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">const</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">\'fs\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\nfs<span class="token punctuation">.</span><span class="token function">readFile</span><span class="token punctuation">(</span>__filename<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'timeout\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token function">setImmediate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'immediate\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>答案永远是：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="94052693757965550000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`immediate\ntimeout`, `94052693757965550000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">immediate\ntimeout</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span></span></pre></div>\n<p>因为在 I/O 事件的回调中，setImmediate 方法的回调永远在 timer 的回调前执行。</p>',
id:"/github/workspace/blog/详解 Event Loop（事件循环）机制/index.md absPath of file >>> MarkdownRemark",timeToRead:5,frontmatter:{date:"2021-06-24 10:47:41",path:"/js-event-loop/",tags:"前端, 高级前端, 事件循环",title:"详解 Event Loop（事件循环）机制",draft:null}},{excerpt:"背景 作为目前最流行的 JavaScript 引擎，V8 引擎从出现的那一刻起便广泛受到人们的关注，我们知道 JavaScript 可以高效地运行在浏览器和 Nodejs 这两大宿主环境中，也是因为背后有强大的 V8 引擎在为其保驾护航，甚至成就了 Chrome 在浏览器中的霸主地位。不得不说，V8 引擎为了追求极致的性能和更好的用户体验，为我们做了太多太多，从原始的 Full-codegen 和 Crankshaft 编译器升级为 Ignition 解释器和 TurboFan…",html:'<h1 id="背景"><a href="#%E8%83%8C%E6%99%AF" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>背景</h1>\n<p>作为目前最流行的 JavaScript 引擎，V8 引擎从出现的那一刻起便广泛受到人们的关注，我们知道 JavaScript 可以高效地运行在浏览器和 Nodejs 这两大宿主环境中，也是因为背后有强大的 V8 引擎在为其保驾护航，甚至成就了 Chrome 在浏览器中的霸主地位。不得不说，V8 引擎为了追求极致的性能和更好的用户体验，为我们做了太多太多，从原始的 Full-codegen 和 Crankshaft 编译器升级为 Ignition 解释器和 TurboFan 编译器的强强组合，到隐藏类、内联缓存和 HotSpot 热点代码收集等一系列强有力的优化策略，V8 引擎正在努力降低整体的内存占用和提升到更高的运行性能。</p>\n<p>本篇主要是从 V8 引擎的垃圾回收机制入手，讲解一下在 JavaScript 代码执行的整个生命周期中 V8 引擎是采取怎样的垃圾回收策略来减少内存占比的，当然这部分的知识并不太影响我们写代码的流程，毕竟在一般情况下我们很少会遇到浏览器端出现内存溢出而导致程序崩溃的情况，但是至少我们对这方面有一定的了解之后，能增强我们在写代码过程中对减少内存占用，避免内存泄漏的主观意识，也许能够帮助你写出更加健壮和对 V8 引擎更加友好的代码。</p>\n<h1 id="为何需要垃圾回收"><a href="#%E4%B8%BA%E4%BD%95%E9%9C%80%E8%A6%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>为何需要垃圾回收</h1>\n<p>在 V8 引擎逐行执行 JavaScript 代码的过程中，当遇到函数的情况时，会为其创建一个函数执行上下文(Context)环境并添加到调用堆栈的栈顶，函数的作用域(handleScope)中包含了该函数中声明的所有变量，当该函数执行完毕后，对应的执行上下文从栈顶弹出，函数的作用域会随之销毁，其包含的所有变量也会统一释放并被自动回收。试想如果在这个作用域被销毁的过程中，其中的变量不被回收，即持久占用内存，那么必然会导致内存暴增，从而引发内存泄漏导致程序的性能直线下降甚至崩溃，因此内存在使用完毕之后理当归还给操作系统以保证内存的重复利用。</p>\n<blockquote>\n<p>这个过程就好比你向亲戚朋友借钱，借得多了却不按时归还，那么你再下次借钱的时候肯定没有那么顺利了，或者说你的亲戚朋友不愿意再借你了，导致你的手头有点儿紧(内存泄漏，性能下降)，所以说有借有还，再借不难嘛，毕竟出来混都是要还的。</p>\n</blockquote>\n<p>但是 JavaScript 作为一门高级编程语言，并不像 C 语言或 C++ 语言中需要手动地申请分配和释放内存，V8 引擎已经帮我们自动进行了内存的分配和管理，好让我们有更多的精力去专注于业务层面的复杂逻辑，这对于我们前端开发人员来说是一项福利，但是随之带来的问题也是显而易见的，那就是由于不用去手动管理内存，导致写代码的过程中不够严谨从而容易引发内存泄漏。</p>\n<h1 id="v8-引擎的内存限制"><a href="#v8-%E5%BC%95%E6%93%8E%E7%9A%84%E5%86%85%E5%AD%98%E9%99%90%E5%88%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>V8 引擎的内存限制</h1>\n<p>虽然 V8 引擎帮助我们实现了自动的垃圾回收管理，解放了我们勤劳的双手，但 V8 引擎中的内存使用也并不是无限制的。具体来说，默认情况下，V8 引擎在 64 位系统下最多只能使用约 1.4GB 的内存，在 32 位系统下最多只能使用约 0.7GB 的内存，在这样的限制下，必然会导致在 node 中无法直接操作大内存对象，比如将一个 2GB 大小的文件全部读入内存进行字符串分析处理，即使物理内存高达 32GB 也无法充分利用计算机的内存资源，那么为什么会有这种限制呢？这个要回到 V8 引擎的设计之初，起初只是作为浏览器端 JavaScript 的执行环境，在浏览器端我们其实很少会遇到使用大量内存的场景，因此也就没有必要将最大内存设置得过高。但这只是一方面，其实还有另外两个主要的原因：</p>\n<h2 id="js-单线程机制"><a href="#js-%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%9C%BA%E5%88%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>JS 单线程机制</h2>\n<p>作为浏览器的脚本语言，JS 的主要用途是与用户交互以及操作 DOM，那么这也决定了其作为单线程的本质，单线程意味着执行的代码必须按顺序执行，在同一时间只能处理一个任务。试想如果 JS 是多线程的，一个线程在删除 DOM 元素的同时，另一个线程对该元素进行修改操作，那么必然会导致复杂的同步问题。既然 JS 是单线程的，那么也就意味着在 V8 执行垃圾回收时，程序中的其他各种逻辑都要进入暂停等待阶段，直到垃圾回收结束后才会再次重新执行 JS 逻辑。因此，由于 JS 的单线程机制，垃圾回收的过程阻碍了主线程逻辑的执行。</p>\n<blockquote>\n<p>虽然 JS 是单线程的，但是为了能够充分利用操作系统的多核 CPU 计算能力，在 HTML5 中引入了新的 Web Worker 标准，其作用就是为 JS 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行。在主线程运行的同时，Worker 在后台运行，两者互不干扰。等到 Worker 线程完成计算任务，再把结果返回给主线程。这样的好处是， 一些计算密集型或高延迟的任务，被 Worker 线程负担，主线程(通常负责 UI 交互)就会很流畅，不会被阻塞或者拖慢。Web Worker 不是 JS 的一部分，而是通过 JS 访问的浏览器特性，其虽然创造了一个多线程的执行环境，但是子线程完全受主线程控制，不能访问浏览器特定的 API，例如操作 DOM，因此这个新标准并没有改变 JS 单线程的本质。</p>\n</blockquote>\n<h2 id="垃圾回收机制"><a href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>垃圾回收机制</h2>\n<p>垃圾回收本身也是一件非常耗时的操作，假设 V8 的堆内存为 1.5G，那么 V8 做一次小的垃圾回收需要 50ms 以上，而做一次非增量式回收甚至需要 1s 以上，可见其耗时之久，而在这 1s 的时间内，浏览器一直处于等待的状态，同时会失去对用户的响应，如果有动画正在运行，也会造成动画卡顿掉帧的情况，严重影响应用程序的性能。因此如果内存使用过高，那么必然会导致垃圾回收的过程缓慢，也就会导致主线程的等待时间越长，浏览器也就越长时间得不到响应。</p>\n<p>基于以上两点，V8 引擎为了减少对应用的性能造成的影响，采用了一种比较粗暴的手段，那就是直接限制堆内存的大小，毕竟在浏览器端一般也不会遇到需要操作几个 G 内存这样的场景。但是在 node 端，涉及到的 I/O 操作可能会比浏览器端更加复杂多样，因此更有可能出现内存溢出的情况。不过也没关系，V8 为我们提供了可配置项来让我们手动地调整内存大小，但是需要在 node 初始化的时候进行配置，我们可以通过如下方式来手动设置。</p>\n<p>我们尝试在 node 命令行中输入以下命令：</p>\n<blockquote>\n<p>本地安装的 node 版本为 v10.14.2，可通过 node -v 查看本地 node 的版本号，不同版本可能会导致下面的命令会有所差异。</p>\n</blockquote>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="45423473491321230000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// 该命令可以用来查看 node 中可用的 V8 引擎的选项及其含义\nnode --v8-options`, `45423473491321230000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                bash 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="bash"><pre style="counter-reset: linenumber NaN" class="language-bash line-numbers"><code class="language-bash">// 该命令可以用来查看 node 中可用的 V8 引擎的选项及其含义\nnode --v8-options</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span></span></pre></div>\n<p>然后我们会在命令行窗口中看到大量关于 V8 的选项，这里我们暂且只关注图中红色选框中的几个选项：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-06-22-17-29-42-4991c99c7f65952bddb545700afa6667-b1c4a.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 562px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 114.76868327402134%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAXCAIAAACEf/j0AAAACXBIWXMAAA7DAAAOwwHHb6hkAAADoUlEQVQ4y01UaW/jNhCVbVkS71uXdfqQ7ThZpEWzSYOm2P//q/qo7IcOCGpEcK7HeZOkaVpV1TRO83zqumEa5+PxOAxT27Tee+ecNdY5KN4YG0KoylIIuUvTBLLb7XB6Op7HYeoO/XW5Dv0Ive96IYSSCsZGG+icc6WU1iaEUiuVbGCcpsEHBByxhnmaj303nE8XRFZSuihWSS0l/iS8wBfcJN+y3W5xcDqd+76bpmlZroeur+o65okoxgRYW4fsjNHwRAiFSbaPkuDCOIzfcbzFVW+txSFnnOEioYxSyRklRTyJf0wwLpiQQiY5Y9aXh25sDodQN8M0V3UjjSkYywjsFBWq4JxJVVAOEyp4RmlB2b4gycPqF+8+T6ev5fw+Dr+ent76bpHyKsWFs6uSNy0XybHflFyEuCqxCL6se/KXNXVV38b5MozXcbrN89y0QQjLuaHUMR6ksIR4JStAjRPOPedWyIsUyV1J5nyPh+3HwzBWLcCepDY55Ugsp4xwKAURscw0X08Yz4Q8IPKbt00o7/N8G8b7NCH4pe8brT1juigcpZYSWxDHqGXMEOIokfs9y7Ipz5NDunt49+/19jHPP8fx67r8Pc8/qvoR/M3qJ2/vzj5Z8+TsI4SXMrw29UjyIc+mIk+0C3gqtCeapGs79OYZb962fT/UddO1bVPV2I0yeCcpOBUS4BMuqBDJn0reQ/g4Hj/Pp7d+/DifoHxMMyLcrLk7/wjuqs2qu4EU426bbja/O+yVFM/e/3M8fU7T1/n0Pgy/luW9756Uejj3R129luWL9z/K8HPon509Z/t0u0k2UZI83bXO3ZFsP1zn6TLNj/NlGeehrErwoCiKzWZdW5ruCDoz+Z/khFRNC1YNaNK2a9pD27Z12/XDYKwVSuWEGuMpY+hULiOr0LNgGHiWfLf7DDIduhJ89UErTQqaZVmeY8sQG/0MdbvZfct2FXy++WzAwe7QAfHH8wvI3NQN6KEiDSOfMQ2gr0Tawx3mxz7dYyV5lnNwA7QzBsmAsFpHxjLOkR4kW4USFlkthIl8Fkheax1hY4z2/ViWdVVW8xQHkNFobcFQowQdGXaMjlgq6Mgokv0NGHzXdY2aMUSQOdCCMSbaoe3WWWCjpVZlGWwkuvE+4BHiTOIiAVpNUwPty/mCuYVhWIYIHGBbMVsly0ENIAcFwfAl+CUkISRWttZgAA98RcARS2nUhtrj6GPxYSAoBLkg83Wkqf8AQHZmYwqvR8EAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 06 22 17 29 42"\n        title=""\n        src="/static/2021-06-22-17-29-42-4991c99c7f65952bddb545700afa6667-b1c4a.png"\n        srcset="/static/2021-06-22-17-29-42-4991c99c7f65952bddb545700afa6667-3ced9.png 200w,\n/static/2021-06-22-17-29-42-4991c99c7f65952bddb545700afa6667-4c4f5.png 400w,\n/static/2021-06-22-17-29-42-4991c99c7f65952bddb545700afa6667-b1c4a.png 562w"\n        sizes="(max-width: 562px) 100vw, 562px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="16252613850685150000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// 设置新生代内存中单个半空间的内存最小值，单位 MB\nnode --min-semi-space-size=1024 xxx.js\n\n// 设置新生代内存中单个半空间的内存最大值，单位 MB\nnode --max-semi-space-size=1024 xxx.js\n\n// 设置老生代内存最大值，单位 MB\nnode --max-old-space-size=2048 xxx.js`, `16252613850685150000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                bash 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="bash"><pre style="counter-reset: linenumber NaN" class="language-bash line-numbers"><code class="language-bash">// 设置新生代内存中单个半空间的内存最小值，单位 MB\nnode --min-semi-space-size<span class="token operator">=</span><span class="token number">1024</span> xxx.js\n\n// 设置新生代内存中单个半空间的内存最大值，单位 MB\nnode --max-semi-space-size<span class="token operator">=</span><span class="token number">1024</span> xxx.js\n\n// 设置老生代内存最大值，单位 MB\nnode --max-old-space-size<span class="token operator">=</span><span class="token number">2048</span> xxx.js</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>通过以上方法便可以手动放宽 V8 引擎所使用的内存限制，同时 node 也为我们提供了 process.memoryUsage() 方法来让我们可以查看当前 node 进程所占用的实际内存大小。</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-06-22-17-30-25-d1e74165cfd807b82f95e75395e7900b-0d2ef.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 561px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 13.547237076648841%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAIAAAAcOLh5AAAACXBIWXMAAA7DAAAOwwHHb6hkAAAARUlEQVQI12NQkJdXURLV0pSSkRaXkpTm5OBgYGBgBEJigJKSopychJQUu4oqs4AAMwNJQEdHV0ZGUV6eXUGRg5OTgyS9ADoyBMcr+JAYAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 06 22 17 30 25"\n        title=""\n        src="/static/2021-06-22-17-30-25-d1e74165cfd807b82f95e75395e7900b-0d2ef.png"\n        srcset="/static/2021-06-22-17-30-25-d1e74165cfd807b82f95e75395e7900b-77ffd.png 200w,\n/static/2021-06-22-17-30-25-d1e74165cfd807b82f95e75395e7900b-5ea91.png 400w,\n/static/2021-06-22-17-30-25-d1e74165cfd807b82f95e75395e7900b-0d2ef.png 561w"\n        sizes="(max-width: 561px) 100vw, 561px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>在上图中，包含的几个字段的含义分别如下所示，单位均为字节：</p>\n<ul>\n<li>heapTotal：表示 V8 当前申请到的堆内存总大小。</li>\n<li>heapUsed：表示当前内存使用量。</li>\n<li>external：表示 V8 内部的 C++ 对象所占用的内存。</li>\n<li>rss(resident set size)：表示驻留集大小，是给这个 node 进程分配了多少物理内存，这些物理内存中包含堆，栈和代码片段。对象，闭包等存于堆内存，变量存于栈内存，实际的 JavaScript 源代码存于代码段内存。使用 Worker 线程时，rss 将会是一个对整个进程有效的值，而其他字段则只针对当前线程。</li>\n</ul>\n<blockquote>\n<p>在 JS 中声明对象时，该对象的内存就分配在堆中，如果当前已申请的堆内存已经不够分配新的对象，则会继续申请堆内存直到堆的大小超过 V8 的限制为止。</p>\n</blockquote>\n<h1 id="v8-的垃圾回收策略"><a href="#v8-%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>V8 的垃圾回收策略</h1>\n<p>V8 的垃圾回收策略主要是基于分代式垃圾回收机制，其根据对象的存活时间将内存的垃圾回收进行不同的分代，然后对不同的分代采用不同的垃圾回收算法。</p>\n<h2 id="v8-的内存结构"><a href="#v8-%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>V8 的内存结构</h2>\n<p>在 V8 引擎的堆结构组成中，其实除了新生代和老生代外，还包含其他几个部分，但是垃圾回收的过程主要出现在新生代和老生代，所以对于其他的部分我们没必要做太多的深入，V8 的内存结构主要由以下几个部分组成：</p>\n<ul>\n<li>新生代(new_space)：大多数的对象开始都会被分配在这里，这个区域相对较小但是垃圾回收特别频繁，该区域被分为两半，一半用来分配内存，另一半用于在垃圾回收时将需要保留的对象复制过来。</li>\n<li>老生代(old_space)：新生代中的对象在存活一段时间后就会被转移到老生代内存区，相对于新生代该内存区域的垃圾回收频率较低。老生代又分为老生代指针区和老生代数据区，前者包含大多数可能存在指向其他对象的指针的对象，后者只保存原始数据对象，这些对象没有指向其他对象的指针。</li>\n<li>大对象区(large<em>object</em>space)：存放体积超越其他区域大小的对象，每个对象都会有自己的内存，垃圾回收不会移动大对象区。</li>\n<li>代码区(code_space)：代码对象，会被分配在这里，唯一拥有执行权限的内存区域。</li>\n<li>map 区(map_space)：存放 Cell 和 Map，每个区域都是存放相同大小的元素，结构简单。</li>\n</ul>\n<p>内存结构图如下所示：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-06-22-17-31-50-e500357a5389ed9f85c5e0133c822ec1-787fb.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 720px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 112.22222222222223%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAWCAIAAABPIytRAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAD8klEQVQ4y4WUiVNaRxjA+R/bZoxGCB418WhFE2IY40w6GQ9AgSQar1g84kF0WquAwAOPhApPUI5UOUQeh3gQ5e279r0nat8zY2KTTjvzm52d3e+3++03uyuhKObtwq5xJlxZ++t3FSNdisGVunZrTfvSvXaktqNteL50wiYzmqWjVqlxUWa0yowW+bj9zugSih1KCJLpGw09H/YrlKbqxpkXrePuFr3rgWH5oWFVaeiaWKqetFe9MlUNzVUN/VY5MFc1MFtvct2fcW6lj0W5Z8CnG0A7deY29cKYxuRQdFl+Vpt/6kSatB1GS+WM68cp5P40UjftrJ1y1k47aqedNZP2zfShhCRhu36107CiNZhbO0xvdLNz99oma56MVavmG56N/OF+thpSLwd+QTZbrD6V1f9YaC0+pRkN5U7FnQ1DoRevA7o+R2evc7JndrVZizR3u66YQbYGwtmRAKZ+H1Xa/3qMbKucEQElshM6IkRZPxx8+XrL0G/r6LVP9rxdae5yNKmRJrWrWTNlQ/sCWL838mR+tWHKqTCtqJBwq+NDiz0cOsQlgISdr3a0/dvql++eGtaMXfPO+m5rXc9SXY+9XjdqD+uC+V7/wdM1rMESb7QlFPY9gQZbYvOQlDA06XYuvLNNrC3olxef+35XR8ZU21fsjKv87kH35hvP5rgLNZrdI5ZrFt8P7ecxCc8WipiG22mEgVtssIwJltFh6Wegr5T1lkC0hPOV8P7P3OZ93/MfUQkHcSKmB8FHOCrFNyrwDTm+cfcLaAXurfxE4SYeGZP3C3KBihuIsBKg5WCjAmzIb0KgcsIrB19TATzlMO+T8BCnBTn0CHik4uiNoJM/5afr8sL6/8g6MqT8Vo6Yy7cXypMOqZgFehMh7ErmWCFtHQg9/FYWOEVlBe9d4PsK4UR3rmSICzIR/DcZleM+GY7+p0zH9YSYtgx4K6/8a4RS+4SCy8XofyDU9frMVExDBBS4+xZYLwPrpV/wlAK0BPfcBt7bAL1JKfD+APOocElIOjNH7Q3SMQ0V0dKfiHZTEQ0d1QrrMnEtHdeIszGN2IlryKiajLRDPCrh+bOz4iVNwpPsMSCZAqBwgv5YAAQJhT5B0un9k6M8QVKM8IRwQAmDLHfO8Rccfy7K3NklcUIex7Pp3EE0lkhlDiLRSDa3H08k95Kp8E46lTnZTWJYKp1IJHcTKcgW+bNLwZdcXJxjGTyVw9MHuSSWxdKZeDIHjkI8tZfaP8Yy2WQyheWOPuTJ48OjTCaXTu/HY7uFAlksXoo7s+w5wxVpyJIMJClIUCwDGY7naMgRDAQUpCBPcWcMZIXfkiIhTbMsV+T5i78BGO3U4Mn0OZIAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 06 22 17 31 50"\n        title=""\n        src="/static/2021-06-22-17-31-50-e500357a5389ed9f85c5e0133c822ec1-787fb.png"\n        srcset="/static/2021-06-22-17-31-50-e500357a5389ed9f85c5e0133c822ec1-4591d.png 200w,\n/static/2021-06-22-17-31-50-e500357a5389ed9f85c5e0133c822ec1-bf018.png 400w,\n/static/2021-06-22-17-31-50-e500357a5389ed9f85c5e0133c822ec1-787fb.png 720w"\n        sizes="(max-width: 720px) 100vw, 720px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>上图中的带斜纹的区域代表暂未使用的内存，新生代(new_space)被划分为了两个部分，其中一部分叫做 inactive new space，表示暂未激活的内存区域，另一部分为激活状态，为什么会划分为两个部分呢，在下一小节我们会讲到。</p>\n<h2 id="新生代"><a href="#%E6%96%B0%E7%94%9F%E4%BB%A3" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>新生代</h2>\n<p>在 V8 引擎的内存结构中，新生代主要用于存放存活时间较短的对象。新生代内存是由两个 semispace(半空间) 构成的，内存最大值在 64 位系统和 32 位系统上分别为 32MB 和 16MB，在新生代的垃圾回收过程中主要采用了 Scavenge 算法。</p>\n<p>Scavenge 算法是一种典型的牺牲空间换取时间的算法，对于老生代内存来说，可能会存储大量对象，如果在老生代中使用这种算法，势必会造成内存资源的浪费，但是在新生代内存中，大部分对象的生命周期较短，在时间效率上表现可观，所以还是比较适合这种算法。</p>\n<blockquote>\n<p>在 Scavenge 算法的具体实现中，主要采用了 Cheney 算法，它将新生代内存一分为二，每一个部分的空间称为 semispace，也就是我们在上图中看见的 new_space 中划分的两个区域，其中处于激活状态的区域我们称为 From 空间，未激活(inactive new space)的区域我们称为 To 空间。这两个空间中，始终只有一个处于使用状态，另一个处于闲置状态。我们的程序中声明的对象首先会被分配到 From 空间，当进行垃圾回收时，如果 From 空间中尚有存活对象，则会被复制到 To 空间进行保存，非存活的对象会被自动回收。当复制完成后，From 空间和 To 空间完成一次角色互换，To 空间会变为新的 From 空间，原来的 From 空间则变为 To 空间。</p>\n</blockquote>\n<p>基于以上算法，我们可以画出如下的流程图：</p>\n<ul>\n<li>假设我们在 From 空间中分配了三个对象 A、B、C \n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-06-22-17-33-00-f8017c4fbad5670beaeadd13c4272b70-571e1.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 584px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 23.972602739726025%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAIAAADKYVtkAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAA8UlEQVQY023IwUrDQBgE4NGAIPgEgifZBZ9Dr7VKYw+ePCqKemgfqbXdKvtHD4r8HtQo1KOP0N1rNWm0oRtjrQEhB4ePYRhM/+IyN0qTsUun/yXLv+PUjV1ePnFmwq7tz7RM2B48dsyDsqGyT8reKztQNld2oqzrWtc2k06xe9a1jHseZsBF1Qvqc7QzT9vQPnSlUIVeh1bQX9BD6OgXFXTkzbr37vc/AF1butpdCOqLlzWQD6qANkFboA2QAuWgN1Bc5gUxziP/5RMrt4eCG4Kbq3wq+UTwvuADwUeC9yRfS84lx5KTsrW7ZPlmdPya/gBoj8I7P9GDxQAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 06 22 17 33 00"\n        title=""\n        src="/static/2021-06-22-17-33-00-f8017c4fbad5670beaeadd13c4272b70-571e1.png"\n        srcset="/static/2021-06-22-17-33-00-f8017c4fbad5670beaeadd13c4272b70-2fa92.png 200w,\n/static/2021-06-22-17-33-00-f8017c4fbad5670beaeadd13c4272b70-52932.png 400w,\n/static/2021-06-22-17-33-00-f8017c4fbad5670beaeadd13c4272b70-571e1.png 584w"\n        sizes="(max-width: 584px) 100vw, 584px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </li>\n<li>当程序主线程任务第一次执行完毕后进入垃圾回收时，发现对象 A 已经没有其他引用，则表示可以对其进行回收 \n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-06-22-17-33-20-2f6165964bc33e840bb4189e0d8025af-571e1.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 584px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 25.34246575342466%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAIAAADKYVtkAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABCUlEQVQY02WLPUsDQRiEX2UvsbcUG5tFbGws8gsUCShREYNYK4KC/iqL9WTPQmW3UBA0RCG5FCoKJkWwMN6+d5fPW3dNlIjg8DDMDAzYoYwx7aSD7ainE/tPxti4q7Gj/45gW09h9FDGt5KqFz+qN++P98FLBWs+vvoD7/qo+5RRFxq920byU0tKP8efYO9mz+TECN9K8/yYt5Hy8g5fIXyV8Bzhm4TXCI8JDwhXKQ/THn4HBW6QuYzAFmdOL8bhZN1xlx13CVgW2AKwRWDzwHLAqsCawBQwHDqOHiMcqTnZP1eyV9eZKXlIxT4VewPkDpW7VGxTcUBFnYoWFSEV0S/TIpo8D9cKzS/O+8qx0Wz9lAAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 06 22 17 33 20"\n        title=""\n        src="/static/2021-06-22-17-33-20-2f6165964bc33e840bb4189e0d8025af-571e1.png"\n        srcset="/static/2021-06-22-17-33-20-2f6165964bc33e840bb4189e0d8025af-2fa92.png 200w,\n/static/2021-06-22-17-33-20-2f6165964bc33e840bb4189e0d8025af-52932.png 400w,\n/static/2021-06-22-17-33-20-2f6165964bc33e840bb4189e0d8025af-571e1.png 584w"\n        sizes="(max-width: 584px) 100vw, 584px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </li>\n<li>对象 B 和对象 C 此时依旧处于活跃状态，因此会被复制到 To 空间中进行保存 \n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-06-22-17-33-35-532bf93b525ee571272d1f5bf6026881-571e1.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 584px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 34.24657534246575%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAIAAACHqfpvAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABH0lEQVQY022Qv0vDQBiGv4oKLU76J0nVJorxB/a/ERUUcXLVtIODLtK7tJMNHQTNZauTIC65DB3UCmm0TS6Xu9hEBxv68PAN78e7vJD8ImUUMz/4CjlLpsF47I0iLuT/EHq960v6WKMPF8697nR0x6zTTqapO+9XlN+6/o070inTnbBGwzplNTe9zwMO7fYi4L0C3ilgDdAWIAWQCmgd0Apgu2iMisZbCfcBeTnPXwO4M5dmmtVZvD1vaNDYBFT56zfKc4a90ApKzX4RfwIaTJqVn7rVZetsjZyuWscqOamQA4UcVsiRSvbL1suGFWjkY9f2FPs7Z6vHIB1LJCIzh5AyllKmDzl1RZDjoRMZCeGHfBjFk4ohFz6LZdbOOeYHsMw+uzrT6Q8AAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 06 22 17 33 35"\n        title=""\n        src="/static/2021-06-22-17-33-35-532bf93b525ee571272d1f5bf6026881-571e1.png"\n        srcset="/static/2021-06-22-17-33-35-532bf93b525ee571272d1f5bf6026881-2fa92.png 200w,\n/static/2021-06-22-17-33-35-532bf93b525ee571272d1f5bf6026881-52932.png 400w,\n/static/2021-06-22-17-33-35-532bf93b525ee571272d1f5bf6026881-571e1.png 584w"\n        sizes="(max-width: 584px) 100vw, 584px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </li>\n<li>接下来将 From 空间中的所有非存活对象全部清除 \n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-06-22-17-33-52-9726ff4c9a383916935205fc1e8700ef-571e1.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 584px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 23.972602739726025%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAIAAADKYVtkAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAA/UlEQVQY023LP0vDQBgG8JdGF6X4LVwczGFXBRFEUOvSD+HgoA5+GKm9ditW7xKc1Jg3o+5+gOS2Ev8kvdR4ucZ6DQgKPvyG533hgelP9ETLzywv8ul/mZRfaV58FOXvJ7Qjryt8KvyL8N7oRB6dnUjFHY3CniiZkAMx7grVDlUnUlSonlDnocJYA1xt1/g+sF3gxt6M6awJbBN4f57rRWe44MQWfwOeAk+AJZYpl++txwzgeqfmNMHs/zgAvjXn9pdudN2N6+5rNR5V+9RyUhgkracxrDwcETyx8ZhU7ArBU4KHq3i75usNHK4HL41gZGNGUBqNQC578uw5/wZY0MHuZAOPuwAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 06 22 17 33 52"\n        title=""\n        src="/static/2021-06-22-17-33-52-9726ff4c9a383916935205fc1e8700ef-571e1.png"\n        srcset="/static/2021-06-22-17-33-52-9726ff4c9a383916935205fc1e8700ef-2fa92.png 200w,\n/static/2021-06-22-17-33-52-9726ff4c9a383916935205fc1e8700ef-52932.png 400w,\n/static/2021-06-22-17-33-52-9726ff4c9a383916935205fc1e8700ef-571e1.png 584w"\n        sizes="(max-width: 584px) 100vw, 584px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </li>\n<li>此时 From 空间中的内存已经清空，开始和 To 空间完成一次角色互换 \n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-06-22-17-34-05-dfb5e2816d2666ed74381a7d779e1c1f-571e1.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 584px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 24.315068493150687%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAIAAADKYVtkAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAA4klEQVQY02P4DwO/f//++O3z379//2MB/378/vPh+++vP/8gizKsenJ07dPjQARkrHpyZM2TYxDu2qdHVj99veHZnz3PPm979m35k58rnvxc/eTn2mcgtOrpz+uf/jIwrPVgWu/PsN4XhDb4gRlAEijixrB+H8fGH9wbX/FseMO44QMDBK3/wLT+A8Pa983XvzMwrPNk2uAP0oaCAhg2uLFt2i+w+Sff5nc8G9+CNX+EICYgue4jSLPUjgTlXWmKu1JREVAkTmHXCY1dPwx2v9Df9Vp51yclGAKypXd8mnrnOwDyl8LlqpLmtQAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 06 22 17 34 05"\n        title=""\n        src="/static/2021-06-22-17-34-05-dfb5e2816d2666ed74381a7d779e1c1f-571e1.png"\n        srcset="/static/2021-06-22-17-34-05-dfb5e2816d2666ed74381a7d779e1c1f-2fa92.png 200w,\n/static/2021-06-22-17-34-05-dfb5e2816d2666ed74381a7d779e1c1f-52932.png 400w,\n/static/2021-06-22-17-34-05-dfb5e2816d2666ed74381a7d779e1c1f-571e1.png 584w"\n        sizes="(max-width: 584px) 100vw, 584px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </li>\n<li>当程序主线程在执行第二个任务时，在 From 空间中分配了一个新对象 D \n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-06-22-17-34-18-9d784133a4d66dd33c7d1041f7949f0f-571e1.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 584px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 24.315068493150687%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAIAAADKYVtkAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAA8UlEQVQY02WLzUrDQBSFL1koKhG1PztxLV35FAU32p24se/i3keJM0mTuXUTXLiQ6NaFICJIZmJJm4yxY/PTNKUUWzx8HO498EG5TJqlo7HMi6L8l2k5/cmKkcq+J/nqDg73UDxX2Nyz/EfGnxYvCo+JsC8yN0juA3nHE8dXPX+CIq1wePqW5ADGqUbOgZzNocuDdIC0gbjbVO3Qrxr90M3BFh0CiYFEGonAiK5fxuvyHx24bW+Y7l7vV7fCuvm5bw03yUKOtaqNeC7r9mWTdevsap1ug10cOA+HTLVQnOD7MQZHGNZQNlA2mdy15c2rmgHmKMMDEqw7bAAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 06 22 17 34 18"\n        title=""\n        src="/static/2021-06-22-17-34-18-9d784133a4d66dd33c7d1041f7949f0f-571e1.png"\n        srcset="/static/2021-06-22-17-34-18-9d784133a4d66dd33c7d1041f7949f0f-2fa92.png 200w,\n/static/2021-06-22-17-34-18-9d784133a4d66dd33c7d1041f7949f0f-52932.png 400w,\n/static/2021-06-22-17-34-18-9d784133a4d66dd33c7d1041f7949f0f-571e1.png 584w"\n        sizes="(max-width: 584px) 100vw, 584px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </li>\n<li>任务执行完毕后再次进入垃圾回收，发现对象 D 已经没有其他引用，表示可以对其进行回收 \n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-06-22-17-34-36-959fd55b7df97865b42353996491ecc0-571e1.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 584px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 24.315068493150687%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAIAAADKYVtkAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABAUlEQVQY02P4DwO/f//++O3T379//2OAP//+v/71/933P99+/UEWZ1j15Ojap8eBCMhY9eTImifHINy1T4+sfvp647Nf25/9uP/y7O+Xq7Y9ebf8yZ91T3+uffZr1dNfNz79YWBY68G03p9hvS8IbfADM4AkUMSNYf0+no1fGDb87NmZ9f8Qg/bmMwzrfzKtf8+0/iPD2o8t178zMKzzZNrgD9KGggIYNrixbdovvPkrw8bfPbvz/x9m1d50mmH9L6YN75k2fGRY97HlxncGqR0JyrvSFHeloiKgSJzizuPau74o7vo691DN/xNy7nsvS+76qbLrg/KuT9I7Pk298wMAM/vDh7TLzdUAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 06 22 17 34 36"\n        title=""\n        src="/static/2021-06-22-17-34-36-959fd55b7df97865b42353996491ecc0-571e1.png"\n        srcset="/static/2021-06-22-17-34-36-959fd55b7df97865b42353996491ecc0-2fa92.png 200w,\n/static/2021-06-22-17-34-36-959fd55b7df97865b42353996491ecc0-52932.png 400w,\n/static/2021-06-22-17-34-36-959fd55b7df97865b42353996491ecc0-571e1.png 584w"\n        sizes="(max-width: 584px) 100vw, 584px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </li>\n<li>对象 B 和对象 C 此时依旧处于活跃状态，再次被复制到 To 空间中进行保存 \n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-06-22-17-35-11-e67af06ef83021cdef540c743494d024-571e1.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 584px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 33.9041095890411%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAIAAACHqfpvAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABRElEQVQY023QzUoCURjG8RctKKRF61yKFEGrClq2iYo+hC7BRRFto9p4AXUBXUQ4Hxbm6Exi2cbMTS2ioKXOoOU4OnNmzjlzToOQVPbnt3t2D/DvMMWmY1Gf8qF8xpuYfyDa9X6tUNCrJaNWNGrZxsNVvZJrPOb1mmIEqoreUg2i6d5764U2s6X6Z6bhFwwcuNbJa5fCiLgWkRMReROk7b6tvgRIKyDlJ2QbJC+lHPNbWLwsg0jCUjskdyBtHj0jCAur43JiTFoH4acNEJZHpdxkxgERp3In/A4W5BKkSVhoh8QOXJiHTwhm8sklbXf+Zi+m7scHtIO4loxp93OqM6ui8/Ipr0R3itUpFU+r5rRmRZXO2ZsLlo2snmO7roO9P3oudonvEeoHLzJCGSOMD/icQXCa6xGEqOf5QyjGxEaEMf5vX5/wO02KVqrnAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 06 22 17 35 11"\n        title=""\n        src="/static/2021-06-22-17-35-11-e67af06ef83021cdef540c743494d024-571e1.png"\n        srcset="/static/2021-06-22-17-35-11-e67af06ef83021cdef540c743494d024-2fa92.png 200w,\n/static/2021-06-22-17-35-11-e67af06ef83021cdef540c743494d024-52932.png 400w,\n/static/2021-06-22-17-35-11-e67af06ef83021cdef540c743494d024-571e1.png 584w"\n        sizes="(max-width: 584px) 100vw, 584px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </li>\n<li>再次将 From 空间中的所有非存活对象全部清除 \n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-06-22-17-35-24-54e071248ddf02c21edc35bb5abb15ab-571e1.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 584px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 24.315068493150687%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAIAAADKYVtkAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAA3ElEQVQY02XLQUrDQBQG4CddNUKFkhEP4M5ztLgQGxd1U7DewAt4JvOiSWYWltKlad3oIjeYTHFhOoXEJJPEGKIk+PPx+OHxQ/mbRKVhJFWuyn8piuIrU2Gc7pPOF5jwltvNQqztYG3zFxpsmHiteUx8MFEwkTKR2Tx95InDk6pX3CDzZQ498/zQMjS8BHMC+McAHAE+A2aAn4A7sGr446C6D7u79wj6eDF4mmpWe1m5Ahx3xi3N+C2GE+f6jM1O6Wzozol7ozdudXdK6IpQRWhIqGw7pvLIkfd+/A3OMMJ+pq0diAAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 06 22 17 35 24"\n        title=""\n        src="/static/2021-06-22-17-35-24-54e071248ddf02c21edc35bb5abb15ab-571e1.png"\n        srcset="/static/2021-06-22-17-35-24-54e071248ddf02c21edc35bb5abb15ab-2fa92.png 200w,\n/static/2021-06-22-17-35-24-54e071248ddf02c21edc35bb5abb15ab-52932.png 400w,\n/static/2021-06-22-17-35-24-54e071248ddf02c21edc35bb5abb15ab-571e1.png 584w"\n        sizes="(max-width: 584px) 100vw, 584px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </li>\n<li>From 空间和 To 空间继续完成一次角色互换 \n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-06-22-17-35-36-248fd62ae00932abd9aaca76d671adcf-571e1.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 584px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 24.315068493150687%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAIAAADKYVtkAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAA1klEQVQY02P4Dwb//v378fvH+28fv/36AeL+Rwc/fv99++3Xzz9/kQUZdr44deDlmb0vzmx6dnLTsxNbnp/e/uIsGJ3e8eLNjhf/drz4tePF723Pf29+9mv7899ANoR798tfBpb1ntybArg2+jJs8EdCAQwb3Bk27GPY8Ithw3uGDR+REROQXPex5cZ3Bs6NfjybQ4EkquZAsOb9DBt+49D8oeXGDwbJbRHaO6JVtkcLbosX3RYnAkXxItvCRbcfFd3+W3T7B9Htn5CR2PZPfFs/9t/+CQDeY8LYROTmQQAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 06 22 17 35 36"\n        title=""\n        src="/static/2021-06-22-17-35-36-248fd62ae00932abd9aaca76d671adcf-571e1.png"\n        srcset="/static/2021-06-22-17-35-36-248fd62ae00932abd9aaca76d671adcf-2fa92.png 200w,\n/static/2021-06-22-17-35-36-248fd62ae00932abd9aaca76d671adcf-52932.png 400w,\n/static/2021-06-22-17-35-36-248fd62ae00932abd9aaca76d671adcf-571e1.png 584w"\n        sizes="(max-width: 584px) 100vw, 584px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </li>\n</ul>\n<p>通过以上的流程图，我们可以很清楚地看到，Scavenge 算法的垃圾回收过程主要就是将存活对象在 From 空间和 To 空间之间进行复制，同时完成两个空间之间的角色互换，因此该算法的缺点也比较明显，浪费了一半的内存用于复制。</p>\n<h2 id="对象晋升"><a href="#%E5%AF%B9%E8%B1%A1%E6%99%8B%E5%8D%87" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>对象晋升</h2>\n<p>当一个对象在经过多次复制之后依旧存活，那么它会被认为是一个生命周期较长的对象，在下一次进行垃圾回收时，该对象会被直接转移到老生代中，这种对象从新生代转移到老生代的过程我们称之为晋升。</p>\n<p>对象晋升的条件主要有以下两个：</p>\n<ul>\n<li>对象是否经历过一次 Scavenge 算法</li>\n<li>To 空间的内存占比是否已经超过 25%</li>\n</ul>\n<p>默认情况下，我们创建的对象都会分配在 From 空间中，当进行垃圾回收时，在将对象从 From 空间复制到 To 空间之前，会先检查该对象的内存地址来判断是否已经经历过一次 Scavenge 算法，如果地址已经发生变动则会将该对象转移到老生代中，不会再被复制到 To 空间，可以用以下的流程图来表示：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-06-22-17-38-03-5132fb1d614bd6aba9022cd968c15c8b-700d4.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 540px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 74.07407407407408%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAIAAABr+ngCAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABqElEQVQoz5VSS0tCQRT2DwT9iX5A1KpN1NaNiwJxE0QQLQoqWgjRQohqJYRlRAWS5SJEgiIqKrTS3mZWVvbU8oVdX/eq1ztzprla4oPMvjkMzJzzzTfnISFZAF2E3Ef2D/y6o4DB6l88D5kyKPnt/AWSQrLxcXjirHXaIddctk052uN8KO/6m7z5ptY65TpXz8JNl/6ul80wVZFzSApxqhbmfDE+wAoMACYVISk+iiIZnNeCAgfGIOQNAMrJYhgXuwXEVS5VibIYB6wTu4fQST12ygizQQDRS04Qd0/8wvQ4sv48vvYyvvqk8rG3P+RsbsBsgaUGzLXILkXWOrIjwa8qHgiTSgmYWP1G1XEjbcTMlWL0tMnF7BZ/GxDEDsGlwCcN2N5CgksEseJ19ml3xKa/71txK6kZHgY8CUdpziCGIj5qBVrq/+ScAxWBKE8S9LsEF1NpfXGBlVWbR8mkEAlywViaSaN4tX3OvbTj1cxdd+jv+nWubsPDICdEqhvPbNONbuXYafO8s1Ntl046ZIlM+B+zffO5vefVWj7mzO+zNv8y/9eofAHFKkK/3tdHPwAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 06 22 17 38 03"\n        title=""\n        src="/static/2021-06-22-17-38-03-5132fb1d614bd6aba9022cd968c15c8b-700d4.png"\n        srcset="/static/2021-06-22-17-38-03-5132fb1d614bd6aba9022cd968c15c8b-555fa.png 200w,\n/static/2021-06-22-17-38-03-5132fb1d614bd6aba9022cd968c15c8b-eb4c6.png 400w,\n/static/2021-06-22-17-38-03-5132fb1d614bd6aba9022cd968c15c8b-700d4.png 540w"\n        sizes="(max-width: 540px) 100vw, 540px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>如果对象没有经历过 Scavenge 算法，会被复制到 To 空间，但是如果此时 To 空间的内存占比已经超过 25%，则该对象依旧会被转移到老生代，如下图所示:</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-06-22-17-38-13-8d8e70e500ab9e2fb9b84d9218f2d765-cf31b.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 480px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 83.33333333333334%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAIAAABSJhvpAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAB4klEQVQ4y5VTzUsbQRTPVaR/gr37H3jopUoL6tWDBz8qKRS8+HFS/wOVaC8VmjSBUtKSSiuo+AkmQTC2um5Ndm1XEtpYw7abjYkxrsnOvDedaCIJhroZfjAzb95v3u+9x7MhQ8ZYLPNF0BZEbVlMLgp/P59kw9x48/SfZUMGfJuPTjgO2uci3W+kAYfYsR6fKZIRLJE/RsdmxHaX1OeW7LNi53rcYZFc1Kakt0Pq+5Dq21V9IdX781ywJLvyQoDRe/xrkQEJIjWAFXg4JIDUOrkU7kpbLZwFy5YKDTx7BA4so1p2dg++98JuM3xtwegou5RLZpPwP5JGzKsMe5WRD8ooh/fHUDqfKJFRdeOWDQONVOyk37rQ/4AFGqi+lEemG0aBsuPM4ZTw9NVh11t50BnpnxJaNSNWjkwvWXIRxUew8xB2mjD8hJ1tIeQBS91K5BSX/MwjD3iOnnuO7E6pL3V1Up0zEvLnHSQX7haGIsmZqQszlbvGhanzAldW2+Q+BmUZwn+iAKSOVt2sAmHn+ZpuiNW4JRdPv7KCpK/sa2thfSOiryZych2D8Sk6Pi20OaXe15Geyf3Hm/HZOgaDk/lgeOQXbtk+fdC2GX9Zx2Bwqf7fc8FTZ/DUxQ/H6W0rsv8Bj0aod/QbzHgAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 06 22 17 38 13"\n        title=""\n        src="/static/2021-06-22-17-38-13-8d8e70e500ab9e2fb9b84d9218f2d765-cf31b.png"\n        srcset="/static/2021-06-22-17-38-13-8d8e70e500ab9e2fb9b84d9218f2d765-ad6a6.png 200w,\n/static/2021-06-22-17-38-13-8d8e70e500ab9e2fb9b84d9218f2d765-552c4.png 400w,\n/static/2021-06-22-17-38-13-8d8e70e500ab9e2fb9b84d9218f2d765-cf31b.png 480w"\n        sizes="(max-width: 480px) 100vw, 480px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>之所以有 25% 的内存限制是因为 To 空间在经历过一次 Scavenge 算法后会和 From 空间完成角色互换，会变为 From 空间，后续的内存分配都是在 From 空间中进行的，如果内存使用过高甚至溢出，则会影响后续对象的分配，因此超过这个限制之后对象会被直接转移到老生代来进行管理。</p>\n<h2 id="老生代"><a href="#%E8%80%81%E7%94%9F%E4%BB%A3" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>老生代</h2>\n<p>在老生代中，因为管理着大量的存活对象，如果依旧使用 Scavenge 算法的话，很明显会浪费一半的内存，因此已经不再使用 Scavenge 算法，而是采用新的算法 Mark-Sweep(标记清除) 和 Mark-Compact(标记整理) 来进行管理。</p>\n<p>在早前我们可能听说过一种算法叫做引用计数，该算法的原理比较简单，就是看对象是否还有其他引用指向它，如果没有指向该对象的引用，则该对象会被视为垃圾并被垃圾回收器回收，示例如下：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="36389057013634105000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// 创建了两个对象 obj1 和 obj2，其中 obj2 作为 obj1 的属性被 obj1 引用，因此不会被垃圾回收\nlet obj1 = {\n  obj2: {\n    a: 1\n  }\n};\n\n// 创建 obj3 并将 obj1 赋值给 obj3，让两个对象指向同一个内存地址\nlet obj3 = obj1;\n\n// 将 obj1 重新赋值，此时原来 obj1 指向的对象现在只由 obj3 来表示\nobj1 = null;\n\n// 创建 obj4 并将 obj3.obj2 赋值给 obj4\n// 此时 obj2 所指向的对象有两个引用：一个是作为 obj3 的属性，另一个是变量 obj4\nlet obj4 = obj3.obj2;\n\n// 将 obj3 重新赋值，此时本可以对 obj3 指向的对象进行回收，但是因为 obj3.obj2 被 obj4 所引用，因此依旧不能被回收\nobj3 = null;\n\n// 此时 obj3.obj2 已经没有指向它的引用，因此 obj3 指向的对象在此时可以被回收\nobj4 = null;`, `36389057013634105000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">// 创建了两个对象 obj1 和 obj2，其中 obj2 作为 obj1 的属性被 obj1 引用，因此不会被垃圾回收</span>\n<span class="token keyword">let</span> obj1 <span class="token operator">=</span> <span class="token punctuation">{</span>\n  obj2<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n    a<span class="token punctuation">:</span> <span class="token number">1</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n<span class="token comment">// 创建 obj3 并将 obj1 赋值给 obj3，让两个对象指向同一个内存地址</span>\n<span class="token keyword">let</span> obj3 <span class="token operator">=</span> obj1<span class="token punctuation">;</span>\n\n<span class="token comment">// 将 obj1 重新赋值，此时原来 obj1 指向的对象现在只由 obj3 来表示</span>\nobj1 <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n\n<span class="token comment">// 创建 obj4 并将 obj3.obj2 赋值给 obj4</span>\n<span class="token comment">// 此时 obj2 所指向的对象有两个引用：一个是作为 obj3 的属性，另一个是变量 obj4</span>\n<span class="token keyword">let</span> obj4 <span class="token operator">=</span> obj3<span class="token punctuation">.</span>obj2<span class="token punctuation">;</span>\n\n<span class="token comment">// 将 obj3 重新赋值，此时本可以对 obj3 指向的对象进行回收，但是因为 obj3.obj2 被 obj4 所引用，因此依旧不能被回收</span>\nobj3 <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n\n<span class="token comment">// 此时 obj3.obj2 已经没有指向它的引用，因此 obj3 指向的对象在此时可以被回收</span>\nobj4 <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>上述例子在经过一系列操作后最终对象会被垃圾回收，但是一旦我们碰到循环引用的场景，就会出现问题，我们看下面的例子：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="9627602830723482000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function foo() {\n  let a = {};\n  let b = {};\n  a.a1 = b;\n  b.b1 = a;\n}\nfoo();`, `9627602830723482000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\n  <span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\n  a<span class="token punctuation">.</span>a1 <span class="token operator">=</span> b<span class="token punctuation">;</span>\n  b<span class="token punctuation">.</span>b1 <span class="token operator">=</span> a<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>这个例子中我们将对象 a 的 a1 属性指向对象 b，将对象 b 的 b1 属性指向对象 a，形成两个对象相互引用，在 foo 函数执行完毕后，函数的作用域已经被销毁，作用域中包含的变量 a 和 b 本应该可以被回收，但是因为采用了引用计数的算法，两个变量均存在指向自身的引用，因此依旧无法被回收，导致内存泄漏。</p>\n<p>因此为了避免循环引用导致的内存泄漏问题，截至 2012 年所有的现代浏览器均放弃了这种算法，转而采用新的 Mark-Sweep(标记清除) 和 Mark-Compact(标记整理) 算法。在上面循环引用的例子中，因为变量 a 和变量 b 无法从 window 全局对象访问到，因此无法对其进行标记，所以最终会被回收。</p>\n<p>Mark-Sweep(标记清除) 分为标记和清除两个阶段，在标记阶段会遍历堆中的所有对象，然后标记活着的对象，在清除阶段中，会将死亡的对象进行清除。Mark-Sweep 算法主要是通过判断某个对象是否可以被访问到，从而知道该对象是否应该被回收，具体步骤如下：</p>\n<ul>\n<li>垃圾回收器会在内部构建一个根列表，用于从根节点出发去寻找那些可以被访问到的变量。比如在 JavaScript 中，window 全局对象可以看成一个根节点。</li>\n<li>然后，垃圾回收器从所有根节点出发，遍历其可以访问到的子节点，并将其标记为活动的，根节点不能到达的地方即为非活动的，将会被视为垃圾。</li>\n<li>最后，垃圾回收器将会释放所有非活动的内存块，并将其归还给操作系统。</li>\n</ul>\n<blockquote>\n<p>以下几种情况都可以作为根节点：</p>\n<ol>\n<li>全局对象</li>\n<li>本地函数的局部变量和参数</li>\n<li>当前嵌套调用链上的其他函数的变量和参数</li>\n</ol>\n</blockquote>\n<p><img src="/static/mark-and-sweep-4001ac135e9b2a0b54eae529b54de40b.gif"></p>\n<p>但是 Mark-Sweep 算法存在一个问题，就是在经历过一次标记清除后，内存空间可能会出现不连续的状态，因为我们所清理的对象的内存地址可能不是连续的，所以就会出现内存碎片的问题，导致后面如果需要分配一个大对象而空闲内存不足以分配，就会提前触发垃圾回收，而这次垃圾回收其实是没必要的，因为我们确实有很多空闲内存，只不过是不连续的。</p>\n<p>为了解决这种内存碎片的问题，Mark-Compact(标记整理) 算法被提了出来，该算法主要就是用来解决内存的碎片化问题的，回收过程中将死亡对象清除后，在整理的过程中，会将活动的对象往堆内存的一端进行移动，移动完成后再清理掉边界外的全部内存，我们可以用如下流程图来表示：</p>\n<ul>\n<li>假设在老生代中有 A、B、C、D 四个对象 \n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-06-22-17-42-58-02146b35347e02606a5aa6bdcca1c15f-571e1.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 584px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 24.315068493150687%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAIAAADKYVtkAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAAvUlEQVQY02P4jwN8+fnn+68/f//9+48bMKx6embNs3NrnkLQqbVPH6999nvds+9LHn1b9PDbqqc/1j37sRYDAcWvf/rNwLA2kHljGOP6UMYNIUwbfBjWz2NY/4th/TuGDR9AaD0WxAQk135ovv6NgWF9IPemSLaNYeybQnk2+zNvmM+w4TfDhvcMGz7iQkxAct1HkGbJ7dmKOwvkd+Yr7MyV35GmuHOt8q5fyrs+KO/6hAup7Poks+PTlDvfAdL8yzJg2bK4AAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 06 22 17 42 58"\n        title=""\n        src="/static/2021-06-22-17-42-58-02146b35347e02606a5aa6bdcca1c15f-571e1.png"\n        srcset="/static/2021-06-22-17-42-58-02146b35347e02606a5aa6bdcca1c15f-2fa92.png 200w,\n/static/2021-06-22-17-42-58-02146b35347e02606a5aa6bdcca1c15f-52932.png 400w,\n/static/2021-06-22-17-42-58-02146b35347e02606a5aa6bdcca1c15f-571e1.png 584w"\n        sizes="(max-width: 584px) 100vw, 584px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </li>\n<li>在垃圾回收的标记阶段，将对象 A 和对象 C 标记为活动的 \n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-06-22-17-43-11-8ba8a885a323c9afe3d52c7ccb040825-571e1.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 584px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 24.315068493150687%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAIAAADKYVtkAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAAyUlEQVQY02P4jwF+//33+cfvn7//fvv55823X99+/fmPAzC8e7lx+dPzj1/u+PNq3Zqnh9Y+fbD66d9FD78vffRjyaMf8+4DyZ9rn/1CQ6ue/rr+6Q/Dyd2cDOsjVuyS/XaAlXmjC8P6+QzrfzNseM+w4SMCrUdBTEBy7cfma98YTu7hY9gUuWqPwpdDPLybPRg3LGTYgKEZFTEByXVgzRcPa4nuKNhy2PrHcTWlXQnyu9Yp7fqltOuD0q5PuJDyrk/SOz5NufMdAC9x0C83XvdEAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 06 22 17 43 11"\n        title=""\n        src="/static/2021-06-22-17-43-11-8ba8a885a323c9afe3d52c7ccb040825-571e1.png"\n        srcset="/static/2021-06-22-17-43-11-8ba8a885a323c9afe3d52c7ccb040825-2fa92.png 200w,\n/static/2021-06-22-17-43-11-8ba8a885a323c9afe3d52c7ccb040825-52932.png 400w,\n/static/2021-06-22-17-43-11-8ba8a885a323c9afe3d52c7ccb040825-571e1.png 584w"\n        sizes="(max-width: 584px) 100vw, 584px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </li>\n<li>在垃圾回收的整理阶段，将活动的对象往堆内存的一端移动 \n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-06-22-17-43-27-f2581df55e79c7e62233e8ef412aeef6-571e1.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 584px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 32.19178082191781%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAIAAABM9SnKAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABDElEQVQY03WQvU7DMBRGbymv0xkkWJB4nzLQpi1VAi/AyNQyVGzELrAw8CPEQodOyI4FKVSiZUwUCcVp7NgmCSpiKFdnuMN3pHs/MKtGZEoIaZSKuAi5MFqvjMHJe9amn7Z3ZrO5zYKu13OYf+DJFok7lFuENwnvetxhySHjbaYGL8xMO8nb0WLeh9pdCuejNbxbwU8V7K8Pt8C9BiQAh4CiAhz9LFUUgpvtXGLzAMkNpONNqN2n4I6qF6U8zOVtQKWMljL6lYNCvsLmERa3IMcbcDyR9edZkw4aZLZPggY9tahvUWnR2MrP/kOLxnsk6zGiJvWvVyf+6EP5edGH1kortexC/0eeSLWRJd96Tg9jQCpIhwAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 06 22 17 43 27"\n        title=""\n        src="/static/2021-06-22-17-43-27-f2581df55e79c7e62233e8ef412aeef6-571e1.png"\n        srcset="/static/2021-06-22-17-43-27-f2581df55e79c7e62233e8ef412aeef6-2fa92.png 200w,\n/static/2021-06-22-17-43-27-f2581df55e79c7e62233e8ef412aeef6-52932.png 400w,\n/static/2021-06-22-17-43-27-f2581df55e79c7e62233e8ef412aeef6-571e1.png 584w"\n        sizes="(max-width: 584px) 100vw, 584px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </li>\n<li>在垃圾回收的清除阶段，将活动对象左侧的内存全部回收 \n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-06-22-17-43-41-a1930246745280684fe2f5a24dada040-571e1.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 584px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 24.315068493150687%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAIAAADKYVtkAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAAtElEQVQY02P4jwH+/P335efvP3//fv7x++XX399///2PAzCsevpr7TMEWvfsF1Bk/v0fix/9mH//+4y73xY+/LEOKvtz1bN/b1/u+/96zY+XO39+vsPAsPYD0/qPDGhoAxB9AJEbP4FIkCBQ2TuG9b+P7LH+f5Dh+z6Wb7ebwJo3QFQTQEwb3oM073P8f5j55wH2b3eaGKR2fFLZ9VmJCKS866P0zr9nj4b8P6Hw+ZjGl/vTAAym1oKnkiXRAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 06 22 17 43 41"\n        title=""\n        src="/static/2021-06-22-17-43-41-a1930246745280684fe2f5a24dada040-571e1.png"\n        srcset="/static/2021-06-22-17-43-41-a1930246745280684fe2f5a24dada040-2fa92.png 200w,\n/static/2021-06-22-17-43-41-a1930246745280684fe2f5a24dada040-52932.png 400w,\n/static/2021-06-22-17-43-41-a1930246745280684fe2f5a24dada040-571e1.png 584w"\n        sizes="(max-width: 584px) 100vw, 584px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </li>\n</ul>\n<p>至此就完成了一次老生代垃圾回收的全部过程，我们在前文中说过，由于 JS 的单线程机制，垃圾回收的过程会阻碍主线程同步任务的执行，待执行完垃圾回收后才会再次恢复执行主任务的逻辑，这种行为被称为全停顿(stop-the-world)。在标记阶段同样会阻碍主线程的执行，一般来说，老生代会保存大量存活的对象，如果在标记阶段将整个堆内存遍历一遍，那么势必会造成严重的卡顿。</p>\n<p>因此，为了减少垃圾回收带来的停顿时间，V8 引擎又引入了 Incremental Marking(增量标记) 的概念，即将原本需要一次性遍历堆内存的操作改为增量标记的方式，先标记堆内存中的一部分对象，然后暂停，将执行权重新交给 JS 主线程，待主线程任务执行完毕后再从原来暂停标记的地方继续标记，直到标记完整个堆内存。这个理念其实有点像 React 框架中的 Fiber 架构，只有在浏览器的空闲时间才会去遍历 Fiber Tree 执行对应的任务，否则延迟执行，尽可能少地影响主线程的任务，避免应用卡顿，提升应用性能。</p>\n<p>得益于增量标记的好处，V8 引擎后续继续引入了延迟清理(lazy sweeping)和增量式整理(incremental compaction)，让清理和整理的过程也变成增量式的。同时为了充分利用多核 CPU 的性能，也将引入并行标记和并行清理，进一步地减少垃圾回收对主线程的影响，为应用提升更多的性能。</p>\n<h1 id="如何避免内存泄漏"><a href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>如何避免内存泄漏</h1>\n<p>在我们写代码的过程中，基本上都不太会关注写出怎样的代码才能有效地避免内存泄漏，或者说浏览器和大部分的前端框架在底层已经帮助我们处理了常见的内存泄漏问题，但是我们还是有必要了解一下常见的几种避免内存泄漏的方式，毕竟在面试过程中也是经常考察的要点。</p>\n<h2 id="尽可能少地创建全局变量"><a href="#%E5%B0%BD%E5%8F%AF%E8%83%BD%E5%B0%91%E5%9C%B0%E5%88%9B%E5%BB%BA%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>尽可能少地创建全局变量</h2>\n<p>在 ES5 中以 var 声明的方式在全局作用域中创建一个变量时，或者在函数作用域中不以任何声明的方式创建一个变量时，都会无形地挂载到 window 全局对象上，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="10786815199904897000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`var a = 1; // 等价于 window.a = 1;`, `10786815199904897000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 等价于 window.a = 1;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="21804344376189034000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function foo() {\n  a = 1;\n}`, `21804344376189034000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span></span></pre></div>\n<p>等价于</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="17990029739333170000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function foo() {\n  window.a = 1;\n}`, `17990029739333170000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  window<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span></span></pre></div>\n<p>我们在 foo 函数中创建了一个变量 a 但是忘记使用 var 来声明，此时会意想不到地创建一个全局变量并挂载到 window 对象上，另外还有一种比较隐蔽的方式来创建全局变量：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="79516927381466190000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function foo() {\n  this.a = 1;\n}\nfoo(); // 相当于 window.foo()`, `79516927381466190000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 相当于 window.foo()</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>当 foo 函数在调用时，它所指向的运行上下文环境为 window 全局对象，因此函数中的 this 指向的其实是 window，也就无意创建了一个全局变量。当进行垃圾回收时，在标记阶段因为 window 对象可以作为根节点，在 window 上挂载的属性均可以被访问到，并将其标记为活动的从而常驻内存，因此也就不会被垃圾回收，只有在整个进程退出时全局作用域才会被销毁。如果你遇到需要必须使用全局变量的场景，那么请保证一定要在全局变量使用完毕后将其设置为 null 从而触发回收机制。</p>\n<h2 id="手动清除定时器"><a href="#%E6%89%8B%E5%8A%A8%E6%B8%85%E9%99%A4%E5%AE%9A%E6%97%B6%E5%99%A8" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>手动清除定时器</h2>\n<p>在我们的应用中经常会有使用 setTimeout 或者 setInterval 等定时器的场景，定时器本身是一个非常有用的功能，但是如果我们稍不注意，忘记在适当的时间手动清除定时器，那么很有可能就会导致内存泄漏，示例如下：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="97695769262818070000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`const numbers = [];\nconst foo = function() {\n  for (let i = 0; i < 100000; i++) {\n    numbers.push(i);\n  }\n};\nwindow.setInterval(foo, 1000);`, `97695769262818070000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">const</span> numbers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n<span class="token keyword">const</span> <span class="token function-variable function">foo</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    numbers<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\nwindow<span class="token punctuation">.</span><span class="token function">setInterval</span><span class="token punctuation">(</span>foo<span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>在这个示例中，由于我们没有手动清除定时器，导致回调任务会不断地执行下去，回调中所引用的 numbers 变量也不会被垃圾回收，最终导致 numbers 数组长度无限递增，从而引发内存泄漏。</p>\n<h2 id="少用闭包"><a href="#%E5%B0%91%E7%94%A8%E9%97%AD%E5%8C%85" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>少用闭包</h2>\n<p>闭包是 JS 中的一个高级特性，巧妙地利用闭包可以帮助我们实现很多高级功能。一般来说，我们在查找变量时，在本地作用域中查找不到就会沿着作用域链从内向外单向查找，但是闭包的特性可以让我们在外部作用域访问内部作用域中的变量，示例如下：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="75042538845628530000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function foo() {\n  let local = 123;\n  return function() {\n    return local;\n  };\n}\nconst bar = foo();\nconsole.log(bar()); // -> 123`, `75042538845628530000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">let</span> local <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>\n  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> local<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">const</span> bar <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// -> 123</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>在这个示例中，foo 函数执行完毕后会返回一个匿名函数，该函数内部引用了 foo 函数中的局部变量 local，并且通过变量 bar 来引用这个匿名的函数定义，通过这种闭包的方式我们就可以在 foo 函数的外部作用域中访问到它的局部变量 local。一般情况下，当 foo 函数执行完毕后，它的作用域会被销毁，但是由于存在变量引用其返回的匿名函数，导致作用域无法得到释放，也就导致 local 变量无法回收，只有当我们取消掉对匿名函数的引用才会进入垃圾回收阶段。</p>\n<h2 id="清除-dom-引用"><a href="#%E6%B8%85%E9%99%A4-dom-%E5%BC%95%E7%94%A8" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>清除 DOM 引用</h2>\n<p>以往我们在操作 DOM 元素时，为了避免多次获取 DOM 元素，我们会将 DOM 元素存储在一个数据字典中，示例如下：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="66240967820462980000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`const elements = {\n  button: document.getElementById(\'button\')\n};\n\nfunction removeButton() {\n  document.body.removeChild(document.getElementById(\'button\'));\n}`, `66240967820462980000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">const</span> elements <span class="token operator">=</span> <span class="token punctuation">{</span>\n  button<span class="token punctuation">:</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">\'button\'</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n<span class="token keyword">function</span> <span class="token function">removeButton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">\'button\'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>在这个示例中，我们想调用 removeButton 方法来清除 button 元素，但是由于在 elements 字典中存在对 button 元素的引用，所以即使我们通过 removeChild 方法移除了 button 元素，它其实还是依旧存储在内存中无法得到释放，只有我们手动清除对 button 元素的引用才会被垃圾回收。</p>\n<h2 id="弱引用"><a href="#%E5%BC%B1%E5%BC%95%E7%94%A8" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>弱引用</h2>\n<p>通过前几个示例我们会发现如果我们一旦疏忽，就会容易地引发内存泄漏的问题，为此，在 ES6 中为我们新增了两个有效的数据结构 WeakMap 和 WeakSet，就是为了解决内存泄漏的问题而诞生的。其表示弱引用，它的键名所引用的对象均是弱引用，弱引用是指垃圾回收的过程中不会将键名对该对象的引用考虑进去，只要所引用的对象没有其他的引用了，垃圾回收机制就会释放该对象所占用的内存。这也就意味着我们不需要关心 WeakMap 中键名对其他对象的引用，也不需要手动地进行引用清除，我们尝试在 node 中演示一下过程(参考阮一峰 ES6 标准入门中的示例，自己手动实现了一遍)。</p>\n<p>首先打开 node 命令行，输入以下命令：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="6782928566249535000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`node --expose-gc // --expose-gc 表示允许手动执行垃圾回收机制`, `6782928566249535000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                bash 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="bash"><pre style="counter-reset: linenumber NaN" class="language-bash line-numbers"><code class="language-bash">node --expose-gc // --expose-gc 表示允许手动执行垃圾回收机制</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>然后我们执行下面的代码</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="61497809493791465000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// 手动执行一次垃圾回收保证内存数据准确\n> global.gc();\nundefined\n\n// 查看当前占用的内存，主要关心 heapUsed 字段，大小约为 4.4MB\n> process.memoryUsage();\n{ rss: 21626880,\n  heapTotal: 7585792,\n  heapUsed: 4708440,\n  external: 8710 }\n\n// 创建一个 WeakMap\n> let wm = new WeakMap();\nundefined\n\n// 创建一个数组并赋值给变量 key\n> let key = new Array(1000000);\nundefined\n\n// 将 WeakMap 的键名指向该数组\n// 此时该数组存在两个引用，一个是 key，一个是 WeakMap 的键名\n// 注意 WeakMap 是弱引用\n> wm.set(key, 1);\nWeakMap { [items unknown] }\n\n// 手动执行一次垃圾回收\n> global.gc();\nundefined\n\n// 再次查看内存占用大小，heapUsed 已经增加到约 12MB\n> process.memoryUsage();\n{ rss: 30232576,\n  heapTotal: 17694720,\n  heapUsed: 13068464,\n  external: 8688 }\n\n// 手动清除变量 key 对数组的引用\n// 注意这里并没有清除 WeakMap 中键名对数组的引用\n> key = null;\nnull\n\n// 再次执行垃圾回收\n> global.gc()\nundefined\n\n// 查看内存占用大小，发现 heapUsed 已经回到了之前的大小(这里约为 4.8M，原来为 4.4M，稍微有些浮动)\n> process.memoryUsage();\n{ rss: 22110208,\n  heapTotal: 9158656,\n  heapUsed: 5089752,\n  external: 8698 }`, `61497809493791465000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">// 手动执行一次垃圾回收保证内存数据准确</span>\n<span class="token operator">></span> global<span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">undefined</span>\n\n<span class="token comment">// 查看当前占用的内存，主要关心 heapUsed 字段，大小约为 4.4MB</span>\n<span class="token operator">></span> process<span class="token punctuation">.</span><span class="token function">memoryUsage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">{</span> rss<span class="token punctuation">:</span> <span class="token number">21626880</span><span class="token punctuation">,</span>\n  heapTotal<span class="token punctuation">:</span> <span class="token number">7585792</span><span class="token punctuation">,</span>\n  heapUsed<span class="token punctuation">:</span> <span class="token number">4708440</span><span class="token punctuation">,</span>\n  external<span class="token punctuation">:</span> <span class="token number">8710</span> <span class="token punctuation">}</span>\n\n<span class="token comment">// 创建一个 WeakMap</span>\n<span class="token operator">></span> <span class="token keyword">let</span> wm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">undefined</span>\n\n<span class="token comment">// 创建一个数组并赋值给变量 key</span>\n<span class="token operator">></span> <span class="token keyword">let</span> key <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token number">1000000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">undefined</span>\n\n<span class="token comment">// 将 WeakMap 的键名指向该数组</span>\n<span class="token comment">// 此时该数组存在两个引用，一个是 key，一个是 WeakMap 的键名</span>\n<span class="token comment">// 注意 WeakMap 是弱引用</span>\n<span class="token operator">></span> wm<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nWeakMap <span class="token punctuation">{</span> <span class="token punctuation">[</span>items unknown<span class="token punctuation">]</span> <span class="token punctuation">}</span>\n\n<span class="token comment">// 手动执行一次垃圾回收</span>\n<span class="token operator">></span> global<span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">undefined</span>\n\n<span class="token comment">// 再次查看内存占用大小，heapUsed 已经增加到约 12MB</span>\n<span class="token operator">></span> process<span class="token punctuation">.</span><span class="token function">memoryUsage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">{</span> rss<span class="token punctuation">:</span> <span class="token number">30232576</span><span class="token punctuation">,</span>\n  heapTotal<span class="token punctuation">:</span> <span class="token number">17694720</span><span class="token punctuation">,</span>\n  heapUsed<span class="token punctuation">:</span> <span class="token number">13068464</span><span class="token punctuation">,</span>\n  external<span class="token punctuation">:</span> <span class="token number">8688</span> <span class="token punctuation">}</span>\n\n<span class="token comment">// 手动清除变量 key 对数组的引用</span>\n<span class="token comment">// 注意这里并没有清除 WeakMap 中键名对数组的引用</span>\n<span class="token operator">></span> key <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n<span class="token keyword">null</span>\n\n<span class="token comment">// 再次执行垃圾回收</span>\n<span class="token operator">></span> global<span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n<span class="token keyword">undefined</span>\n\n<span class="token comment">// 查看内存占用大小，发现 heapUsed 已经回到了之前的大小(这里约为 4.8M，原来为 4.4M，稍微有些浮动)</span>\n<span class="token operator">></span> process<span class="token punctuation">.</span><span class="token function">memoryUsage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">{</span> rss<span class="token punctuation">:</span> <span class="token number">22110208</span><span class="token punctuation">,</span>\n  heapTotal<span class="token punctuation">:</span> <span class="token number">9158656</span><span class="token punctuation">,</span>\n  heapUsed<span class="token punctuation">:</span> <span class="token number">5089752</span><span class="token punctuation">,</span>\n  external<span class="token punctuation">:</span> <span class="token number">8698</span> <span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>在上述示例中，我们发现虽然我们没有手动清除 WeakMap 中的键名对数组的引用，但是内存依旧已经回到原始的大小，说明该数组已经被回收，那么这个也就是弱引用的具体含义了。</p>',
id:"/github/workspace/blog/一文搞懂V8引擎的垃圾回收/index.md absPath of file >>> MarkdownRemark",timeToRead:10,frontmatter:{date:"2021-06-22 17:21:47",path:"/v8-garbage-collection/",tags:"前端, 高级前端, 垃圾回收",title:"一文搞懂V8引擎的垃圾回收",draft:null}},{excerpt:"Diff 算法 概览 在 beginWork 一节我们提到 对于 update 的组件，他会将当前组件与该组件在上次更新时对应的 Fiber 节点比较（也就是俗称的 Diff 算法），将比较的结果生成新 Fiber 节点。 这一章我们讲解 Diff 算法的实现。 你可以从 这里 看到 Diff 算法的介绍。 为了防止概念混淆，这里再强调下 一个 DOM 节点在某一时刻最多会有 4 个节点和他相关。 current Fiber。如果该 DOM 节点已在页面中，current Fiber…",html:'<h1 id="diff-算法"><a href="#diff-%E7%AE%97%E6%B3%95" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Diff 算法</h1>\n<h2 id="概览"><a href="#%E6%A6%82%E8%A7%88" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>概览</h2>\n<p>在 beginWork 一节我们提到</p>\n<blockquote>\n<p>对于 update 的组件，他会将当前组件与该组件在上次更新时对应的 Fiber 节点比较（也就是俗称的 Diff 算法），将比较的结果生成新 Fiber 节点。</p>\n</blockquote>\n<p>这一章我们讲解 Diff 算法的实现。</p>\n<p>你可以从<a href="https://zh-hans.reactjs.org/docs/reconciliation.html#the-diffing-algorithm" target="_blank" rel="nofollow noreferrer noopener">这里</a>看到 Diff 算法的介绍。</p>\n<p>为了防止概念混淆，这里再强调下</p>\n<p>一个 DOM 节点在某一时刻最多会有 4 个节点和他相关。</p>\n<ol>\n<li>current Fiber。如果该 DOM 节点已在页面中，current Fiber 代表该 DOM 节点对应的 Fiber 节点。</li>\n<li>workInProgress Fiber。如果该 DOM 节点将在本次更新中渲染到页面中，workInProgress Fiber 代表该 DOM 节点对应的 Fiber 节点。</li>\n<li>DOM 节点本身。</li>\n<li>JSX 对象。即 ClassComponent 的 render 方法的返回结果，或 FunctionComponent 的调用结果。JSX 对象中包含描述 DOM 节点的信息。</li>\n</ol>\n<p>Diff 算法的本质是对比 1 和 4，生成 2。</p>\n<h3 id="diff-的瓶颈以及-react-如何应对"><a href="#diff-%E7%9A%84%E7%93%B6%E9%A2%88%E4%BB%A5%E5%8F%8A-react-%E5%A6%82%E4%BD%95%E5%BA%94%E5%AF%B9" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Diff 的瓶颈以及 React 如何应对</h3>\n<p>由于 Diff 操作本身也会带来性能损耗，React 文档中提到，即使在最前沿的算法中，将前后两棵树完全比对的算法的复杂程度为 <code class="language-text">O(n^3)</code>，其中 n 是树中元素的数量。</p>\n<p>如果在 React 中使用了该算法，那么展示 1000 个元素所需要执行的计算量将在十亿的量级范围。这个开销实在是太过高昂。</p>\n<p>为了降低算法复杂度，React 的 diff 会预设三个限制：</p>\n<ol>\n<li>只对同级元素进行 Diff。如果一个 DOM 节点在前后两次更新中跨越了层级，那么 React 不会尝试复用他。</li>\n<li>两个不同类型的元素会产生出不同的树。如果元素由 div 变为 p，React 会销毁 div 及其子孙节点，并新建 p 及其子孙节点。</li>\n<li>开发者可以通过 key prop 来暗示哪些子元素在不同的渲染下能保持稳定。考虑如下例子：</li>\n</ol>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="74714284634090820000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// 更新前\n<div>\n  <p key=&quot;ka&quot;>ka</p>\n  <h3 key=&quot;song&quot;>song</h3>\n</div>\n\n// 更新后\n<div>\n  <h3 key=&quot;song&quot;>song</h3>\n  <p key=&quot;ka&quot;>ka</p>\n</div>`, `74714284634090820000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">// 更新前</span>\n<span class="token operator">&lt;</span>div<span class="token operator">></span>\n  <span class="token operator">&lt;</span>p key<span class="token operator">=</span><span class="token string">"ka"</span><span class="token operator">></span>ka<span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">></span>\n  <span class="token operator">&lt;</span>h3 key<span class="token operator">=</span><span class="token string">"song"</span><span class="token operator">></span>song<span class="token operator">&lt;</span><span class="token operator">/</span>h3<span class="token operator">></span>\n<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>\n\n<span class="token comment">// 更新后</span>\n<span class="token operator">&lt;</span>div<span class="token operator">></span>\n  <span class="token operator">&lt;</span>h3 key<span class="token operator">=</span><span class="token string">"song"</span><span class="token operator">></span>song<span class="token operator">&lt;</span><span class="token operator">/</span>h3<span class="token operator">></span>\n  <span class="token operator">&lt;</span>p key<span class="token operator">=</span><span class="token string">"ka"</span><span class="token operator">></span>ka<span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">></span>\n<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>如果没有 key，React 会认为 div 的第一个子节点由 p 变为 h3，第二个子节点由 h3 变为 p。这符合限制 2 的设定，会销毁并新建。</p>\n<p>但是当我们用 key 指明了节点前后对应关系后，React 知道 <code class="language-text">key === &quot;ka&quot;</code> 的 p 在更新后还存在，所以 DOM 节点可以复用，只是需要交换下顺序。</p>\n<p>这就是 React 为了应对算法性能瓶颈做出的三条限制。</p>\n<h3 id="diff-是如何实现的"><a href="#diff-%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Diff 是如何实现的</h3>\n<p>我们从 Diff 的入口函数 reconcileChildFibers 出发，该函数会根据 newChild（即 JSX 对象）类型调用不同的处理函数。</p>\n<blockquote>\n<p>你可以从<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactChildFiber.new.js#L1280" target="_blank" rel="nofollow noreferrer noopener">这里</a>看到 reconcileChildFibers 的源码。</p>\n</blockquote>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="31023547791691050000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// 根据 newChild 类型选择不同 diff 函数处理\nfunction reconcileChildFibers(returnFiber: Fiber, currentFirstChild: Fiber | null, newChild: any): Fiber | null {\n  const isObject = typeof newChild === \'object\' && newChild !== null;\n\n  if (isObject) {\n    // object 类型，可能是 REACT_ELEMENT_TYPE 或 REACT_PORTAL_TYPE\n    switch (newChild.\\$\\$typeof) {\n      case REACT_ELEMENT_TYPE:\n      // 调用 reconcileSingleElement 处理\n      // // ...省略其他 case\n    }\n  }\n\n  if (typeof newChild === \'string\' || typeof newChild === \'number\') {\n    // 调用 reconcileSingleTextNode 处理\n    // ...省略\n  }\n\n  if (isArray(newChild)) {\n    // 调用 reconcileChildrenArray 处理\n    // ...省略\n  }\n\n  // 一些其他情况调用处理函数\n  // ...省略\n\n  // 以上都没有命中，删除节点\n  return deleteRemainingChildren(returnFiber, currentFirstChild);\n}`, `31023547791691050000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">// 根据 newChild 类型选择不同 diff 函数处理</span>\n<span class="token keyword">function</span> <span class="token function">reconcileChildFibers</span><span class="token punctuation">(</span><span class="token parameter">returnFiber<span class="token punctuation">:</span> Fiber<span class="token punctuation">,</span> currentFirstChild<span class="token punctuation">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span> newChild<span class="token punctuation">:</span> any</span><span class="token punctuation">)</span><span class="token punctuation">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> isObject <span class="token operator">=</span> <span class="token keyword">typeof</span> newChild <span class="token operator">===</span> <span class="token string">\'object\'</span> <span class="token operator">&amp;&amp;</span> newChild <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>isObject<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// object 类型，可能是 REACT_ELEMENT_TYPE 或 REACT_PORTAL_TYPE</span>\n    <span class="token keyword">switch</span> <span class="token punctuation">(</span>newChild<span class="token punctuation">.</span>$$<span class="token keyword">typeof</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">case</span> <span class="token constant">REACT_ELEMENT_TYPE</span><span class="token punctuation">:</span>\n      <span class="token comment">// 调用 reconcileSingleElement 处理</span>\n      <span class="token comment">// // ...省略其他 case</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> newChild <span class="token operator">===</span> <span class="token string">\'string\'</span> <span class="token operator">||</span> <span class="token keyword">typeof</span> newChild <span class="token operator">===</span> <span class="token string">\'number\'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 调用 reconcileSingleTextNode 处理</span>\n    <span class="token comment">// ...省略</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isArray</span><span class="token punctuation">(</span>newChild<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 调用 reconcileChildrenArray 处理</span>\n    <span class="token comment">// ...省略</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token comment">// 一些其他情况调用处理函数</span>\n  <span class="token comment">// ...省略</span>\n\n  <span class="token comment">// 以上都没有命中，删除节点</span>\n  <span class="token keyword">return</span> <span class="token function">deleteRemainingChildren</span><span class="token punctuation">(</span>returnFiber<span class="token punctuation">,</span> currentFirstChild<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>我们可以从同级的节点数量将 Diff 分为两类：</p>\n<ol>\n<li>当 newChild 类型为 object、number、string，代表同级只有一个节点</li>\n<li>当 newChild 类型为 Array，同级有多个节点</li>\n</ol>\n<p>在接下来两节我们会分别讨论这两类节点的 Diff。</p>\n<h2 id="单节点-diff"><a href="#%E5%8D%95%E8%8A%82%E7%82%B9-diff" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>单节点 Diff</h2>\n<p>对于单个节点，我们以类型 object 为例，会进入 reconcileSingleElement</p>\n<blockquote>\n<p>你可以从<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactChildFiber.new.js#L1141" target="_blank" rel="nofollow noreferrer noopener">这里</a>看到 reconcileSingleElement 源码</p>\n</blockquote>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="45309974283912790000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`const isObject = typeof newChild === \'object\' && newChild !== null;\n\nif (isObject) {\n  // 对象类型，可能是 REACT_ELEMENT_TYPE 或 REACT_PORTAL_TYPE\n  switch (newChild.\\$\\$typeof) {\n    case REACT_ELEMENT_TYPE:\n    // 调用 reconcileSingleElement 处理\n    // ...其他 case\n  }\n}`, `45309974283912790000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">const</span> isObject <span class="token operator">=</span> <span class="token keyword">typeof</span> newChild <span class="token operator">===</span> <span class="token string">\'object\'</span> <span class="token operator">&amp;&amp;</span> newChild <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n\n<span class="token keyword">if</span> <span class="token punctuation">(</span>isObject<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 对象类型，可能是 REACT_ELEMENT_TYPE 或 REACT_PORTAL_TYPE</span>\n  <span class="token keyword">switch</span> <span class="token punctuation">(</span>newChild<span class="token punctuation">.</span>$$<span class="token keyword">typeof</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">case</span> <span class="token constant">REACT_ELEMENT_TYPE</span><span class="token punctuation">:</span>\n    <span class="token comment">// 调用 reconcileSingleElement 处理</span>\n    <span class="token comment">// ...其他 case</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>这个函数会做如下事情：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-01-29-14-33-49-aa6f372038f19dc1f6e0686e17c0fbd1-4114c.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 76.99115044247787%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAIAAABr+ngCAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABfElEQVQoz42SDU/CMBCG+f//w4RgQgSjYYnJwBgwfiCKDAGRCIPwMXFs6z7au6sdE1AggVvTNb0+ubfvNSV3IhBoeaFAlIcilfxIDZJIcsFlpd7KanrLtKJ4kw7DAkgAAko7wpuqcVm6bQ+t8Hh4fYxFYimbjpWtyq5hzoXrecldjoKVYFpdnoG0QfLDfq1gVQpAVZdWgE/vA/2uZgxmDGNFQNIPQo/5EDtKe+CIiyTBBPWmdq1rjmzGSQmJd3EZCgakvbI3hikFyrNdkerIfjhxW32uYPPQmXpzFzwfwmPheEbQO+XCq567L2TKOWPSlstWL8UTEKpnl6z3V5741sidmIvx0BnbkfO/stzq/fYjCSFiEPrIAwg58tgCQheYGgvBbO45gjnAIuB/YCQ1AoBiu3JRu8o/aJpRfJt1VcqJvPOqli5m06Vs/lHLXJ+d6Kcf1ucG/vWZ0GTjjtWrD5o9x7SC77iLwI1Ru95vvvSNxrCl1s/9xpcfp34ACeNlJbpoUCgAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 01 29 14 33 49"\n        title=""\n        src="/static/2021-01-29-14-33-49-aa6f372038f19dc1f6e0686e17c0fbd1-fee1c.png"\n        srcset="/static/2021-01-29-14-33-49-aa6f372038f19dc1f6e0686e17c0fbd1-a67b7.png 200w,\n/static/2021-01-29-14-33-49-aa6f372038f19dc1f6e0686e17c0fbd1-0b187.png 400w,\n/static/2021-01-29-14-33-49-aa6f372038f19dc1f6e0686e17c0fbd1-fee1c.png 800w,\n/static/2021-01-29-14-33-49-aa6f372038f19dc1f6e0686e17c0fbd1-b1a91.png 1200w,\n/static/2021-01-29-14-33-49-aa6f372038f19dc1f6e0686e17c0fbd1-4114c.png 1582w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>让我们看看第二步判断 DOM 节点是否可以复用是如何实现的。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="6400387690772336000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function reconcileSingleElement(returnFiber: Fiber, currentFirstChild: Fiber | null, element: ReactElement): Fiber {\n  const key = element.key;\n  let child = currentFirstChild;\n\n  // 首先判断是否存在对应 DOM 节点\n  while (child !== null) {\n    // 上一次更新存在 DOM 节点，接下来判断是否可复用\n\n    // 首先比较 key 是否相同\n    if (child.key === key) {\n      // key 相同，接下来比较 type 是否相同\n\n      switch (child.tag) {\n        // ...省略 case\n\n        default: {\n          if (child.elementType === element.type) {\n            // type 相同则表示可以复用\n            // 返回复用的 fiber\n            return existing;\n          }\n\n          // type 不同则跳出 switch\n          break;\n        }\n      }\n      // 代码执行到这里代表：key 相同但是 type 不同\n      // 将该 fiber 及其兄弟 fiber 标记为删除\n      deleteRemainingChildren(returnFiber, child);\n      break;\n    } else {\n      // key 不同，将该 fiber 标记为删除\n      deleteChild(returnFiber, child);\n    }\n    child = child.sibling;\n  }\n\n  // 创建新Fiber，并返回 ...省略\n}`, `6400387690772336000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span> <span class="token function">reconcileSingleElement</span><span class="token punctuation">(</span><span class="token parameter">returnFiber<span class="token punctuation">:</span> Fiber<span class="token punctuation">,</span> currentFirstChild<span class="token punctuation">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span> element<span class="token punctuation">:</span> ReactElement</span><span class="token punctuation">)</span><span class="token punctuation">:</span> Fiber <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> key <span class="token operator">=</span> element<span class="token punctuation">.</span>key<span class="token punctuation">;</span>\n  <span class="token keyword">let</span> child <span class="token operator">=</span> currentFirstChild<span class="token punctuation">;</span>\n\n  <span class="token comment">// 首先判断是否存在对应 DOM 节点</span>\n  <span class="token keyword">while</span> <span class="token punctuation">(</span>child <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 上一次更新存在 DOM 节点，接下来判断是否可复用</span>\n\n    <span class="token comment">// 首先比较 key 是否相同</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>child<span class="token punctuation">.</span>key <span class="token operator">===</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token comment">// key 相同，接下来比较 type 是否相同</span>\n\n      <span class="token keyword">switch</span> <span class="token punctuation">(</span>child<span class="token punctuation">.</span>tag<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token comment">// ...省略 case</span>\n\n        <span class="token keyword">default</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>\n          <span class="token keyword">if</span> <span class="token punctuation">(</span>child<span class="token punctuation">.</span>elementType <span class="token operator">===</span> element<span class="token punctuation">.</span>type<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token comment">// type 相同则表示可以复用</span>\n            <span class="token comment">// 返回复用的 fiber</span>\n            <span class="token keyword">return</span> existing<span class="token punctuation">;</span>\n          <span class="token punctuation">}</span>\n\n          <span class="token comment">// type 不同则跳出 switch</span>\n          <span class="token keyword">break</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n      <span class="token punctuation">}</span>\n      <span class="token comment">// 代码执行到这里代表：key 相同但是 type 不同</span>\n      <span class="token comment">// 将该 fiber 及其兄弟 fiber 标记为删除</span>\n      <span class="token function">deleteRemainingChildren</span><span class="token punctuation">(</span>returnFiber<span class="token punctuation">,</span> child<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token keyword">break</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n      <span class="token comment">// key 不同，将该 fiber 标记为删除</span>\n      <span class="token function">deleteChild</span><span class="token punctuation">(</span>returnFiber<span class="token punctuation">,</span> child<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n    child <span class="token operator">=</span> child<span class="token punctuation">.</span>sibling<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token comment">// 创建新Fiber，并返回 ...省略</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>还记得我们刚才提到的，React 预设的限制么，</p>\n<p>从代码可以看出，React 通过先判断 key 是否相同，如果 key 相同则判断 type 是否相同，只有都相同时一个 DOM 节点才能复用。</p>\n<p>这里有个细节需要关注下：</p>\n<ul>\n<li>当 child !== null 且 key 相同且 type 不同时执行 deleteRemainingChildren 将 child 及其兄弟 fiber 都标记删除。</li>\n<li>当 child !== null 且 key 不同时仅将 child 标记删除。</li>\n</ul>\n<p>考虑如下例子：</p>\n<p>当前页面有 3 个 li，我们要全部删除，再插入一个 p。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="54574193807012540000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// 当前页面显示的\nul > li * 3\n\n// 这次需要更新的\nul > p`, `54574193807012540000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">// 当前页面显示的\nul &gt; li * 3\n\n// 这次需要更新的\nul &gt; p</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>由于本次更新时只有一个 p，属于单一节点的 Diff，会走上面介绍的代码逻辑。</p>\n<p>在 reconcileSingleElement 中遍历之前的 3 个 fiber（对应的 DOM 为 3 个 li），寻找本次更新的 p 是否可以复用之前的 3 个 fiber 中某个的 DOM。</p>\n<p>当 key 相同且 type 不同时，代表我们已经找到本次更新的 p 对应的上次的 fiber，但是 p 与 li type 不同，不能复用。既然唯一的可能性已经不能复用，则剩下的 fiber 都没有机会了，所以都需要标记删除。</p>\n<p>当 key 不同时只代表遍历到的该 fiber 不能被 p 复用，后面还有兄弟 fiber 还没有遍历到。所以仅仅标记该 fiber 删除。</p>\n<h3 id="练习题"><a href="#%E7%BB%83%E4%B9%A0%E9%A2%98" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>练习题</h3>\n<p>让我们来做几道习题巩固下吧：</p>\n<p>请判断如下 JSX 对象对应的 DOM 元素是否可以复用：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="61289464068770650000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// 习题1 更新前\n<div>ka song</div>\n// 更新后\n<p>ka song</p>\n\n// 习题2 更新前\n<div key=&quot;xxx&quot;>ka song</div>\n// 更新后\n<div key=&quot;ooo&quot;>ka song</div>\n\n// 习题3 更新前\n<div key=&quot;xxx&quot;>ka song</div>\n// 更新后\n<p key=&quot;ooo&quot;>ka song</p>\n\n// 习题4 更新前\n<div key=&quot;xxx&quot;>ka song</div>\n// 更新后\n<div key=&quot;xxx&quot;>xiao bei</div>`, `61289464068770650000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                jsx 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="jsx"><pre style="counter-reset: linenumber NaN" class="language-jsx line-numbers"><code class="language-jsx"><span class="token comment">// 习题1 更新前</span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span><span class="token plain-text">ka song</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n<span class="token comment">// 更新后</span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span><span class="token plain-text">ka song</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>\n\n<span class="token comment">// 习题2 更新前</span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>xxx<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">ka song</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n<span class="token comment">// 更新后</span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ooo<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">ka song</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n\n<span class="token comment">// 习题3 更新前</span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>xxx<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">ka song</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n<span class="token comment">// 更新后</span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ooo<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">ka song</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>\n\n<span class="token comment">// 习题4 更新前</span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>xxx<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">ka song</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n<span class="token comment">// 更新后</span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>xxx<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">xiao bei</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>公布答案：</p>\n<p>习题 1: 未设置 key prop 默认 key = null;，所以更新前后 key 相同，都为 null，但是更新前 type 为 div，更新后为 p，type 改变则不能复用。</p>\n<p>习题 2: 更新前后 key 改变，不需要再判断 type，不能复用。</p>\n<p>习题 3: 更新前后 key 改变，不需要再判断 type，不能复用。</p>\n<p>习题 4: 更新前后 key 与 type 都未改变，可以复用。children 变化，DOM 的子元素需要更新。</p>\n<h2 id="多节点-diff"><a href="#%E5%A4%9A%E8%8A%82%E7%82%B9-diff" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>多节点 Diff</h2>\n<p>上一节我们介绍了单一节点的 Diff，现在考虑我们有一个 FunctionComponent：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="23242963097755197000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function List() {\n  return (\n    <ul>\n      <li key=\'0\'>0</li>\n      <li key=\'1\'>1</li>\n      <li key=\'2\'>2</li>\n      <li key=\'3\'>3</li>\n    </ul>\n  );\n}`, `23242963097755197000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                jsx 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="jsx"><pre style="counter-reset: linenumber NaN" class="language-jsx line-numbers"><code class="language-jsx"><span class="token keyword">function</span> <span class="token function">List</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token punctuation">(</span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span><span class="token plain-text">\n      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">\'</span>0<span class="token punctuation">\'</span></span><span class="token punctuation">></span></span><span class="token plain-text">0</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token plain-text">\n      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">\'</span>1<span class="token punctuation">\'</span></span><span class="token punctuation">></span></span><span class="token plain-text">1</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token plain-text">\n      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">\'</span>2<span class="token punctuation">\'</span></span><span class="token punctuation">></span></span><span class="token plain-text">2</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token plain-text">\n      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">\'</span>3<span class="token punctuation">\'</span></span><span class="token punctuation">></span></span><span class="token plain-text">3</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token plain-text">\n    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span>\n  <span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>他的返回值 JSX 对象的 children 属性不是单一节点，而是包含四个对象的数组</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="20786201062757280000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`{\n  \\$\\$typeof: Symbol(react.element),\n  key: null,\n  props: {\n    children: [\n      {\\$\\$typeof: Symbol(react.element), type: &quot;li&quot;, key: &quot;0&quot;, ref: null, props: {…}, …}\n      {\\$\\$typeof: Symbol(react.element), type: &quot;li&quot;, key: &quot;1&quot;, ref: null, props: {…}, …}\n      {\\$\\$typeof: Symbol(react.element), type: &quot;li&quot;, key: &quot;2&quot;, ref: null, props: {…}, …}\n      {\\$\\$typeof: Symbol(react.element), type: &quot;li&quot;, key: &quot;3&quot;, ref: null, props: {…}, …}\n    ]\n  },\n  ref: null,\n  type: &quot;ul&quot;\n}`, `20786201062757280000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token punctuation">{</span>\n  $$<span class="token keyword">typeof</span><span class="token punctuation">:</span> <span class="token function">Symbol</span><span class="token punctuation">(</span>react<span class="token punctuation">.</span>element<span class="token punctuation">)</span><span class="token punctuation">,</span>\n  key<span class="token punctuation">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>\n  props<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n    children<span class="token punctuation">:</span> <span class="token punctuation">[</span>\n      <span class="token punctuation">{</span>$$<span class="token keyword">typeof</span><span class="token punctuation">:</span> <span class="token function">Symbol</span><span class="token punctuation">(</span>react<span class="token punctuation">.</span>element<span class="token punctuation">)</span><span class="token punctuation">,</span> type<span class="token punctuation">:</span> <span class="token string">"li"</span><span class="token punctuation">,</span> key<span class="token punctuation">:</span> <span class="token string">"0"</span><span class="token punctuation">,</span> ref<span class="token punctuation">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span> props<span class="token punctuation">:</span> <span class="token punctuation">{</span>…<span class="token punctuation">}</span><span class="token punctuation">,</span> …<span class="token punctuation">}</span>\n      <span class="token punctuation">{</span>$$<span class="token keyword">typeof</span><span class="token punctuation">:</span> <span class="token function">Symbol</span><span class="token punctuation">(</span>react<span class="token punctuation">.</span>element<span class="token punctuation">)</span><span class="token punctuation">,</span> type<span class="token punctuation">:</span> <span class="token string">"li"</span><span class="token punctuation">,</span> key<span class="token punctuation">:</span> <span class="token string">"1"</span><span class="token punctuation">,</span> ref<span class="token punctuation">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span> props<span class="token punctuation">:</span> <span class="token punctuation">{</span>…<span class="token punctuation">}</span><span class="token punctuation">,</span> …<span class="token punctuation">}</span>\n      <span class="token punctuation">{</span>$$<span class="token keyword">typeof</span><span class="token punctuation">:</span> <span class="token function">Symbol</span><span class="token punctuation">(</span>react<span class="token punctuation">.</span>element<span class="token punctuation">)</span><span class="token punctuation">,</span> type<span class="token punctuation">:</span> <span class="token string">"li"</span><span class="token punctuation">,</span> key<span class="token punctuation">:</span> <span class="token string">"2"</span><span class="token punctuation">,</span> ref<span class="token punctuation">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span> props<span class="token punctuation">:</span> <span class="token punctuation">{</span>…<span class="token punctuation">}</span><span class="token punctuation">,</span> …<span class="token punctuation">}</span>\n      <span class="token punctuation">{</span>$$<span class="token keyword">typeof</span><span class="token punctuation">:</span> <span class="token function">Symbol</span><span class="token punctuation">(</span>react<span class="token punctuation">.</span>element<span class="token punctuation">)</span><span class="token punctuation">,</span> type<span class="token punctuation">:</span> <span class="token string">"li"</span><span class="token punctuation">,</span> key<span class="token punctuation">:</span> <span class="token string">"3"</span><span class="token punctuation">,</span> ref<span class="token punctuation">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span> props<span class="token punctuation">:</span> <span class="token punctuation">{</span>…<span class="token punctuation">}</span><span class="token punctuation">,</span> …<span class="token punctuation">}</span>\n    <span class="token punctuation">]</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  ref<span class="token punctuation">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>\n  type<span class="token punctuation">:</span> <span class="token string">"ul"</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>这种情况下，reconcileChildFibers 的 newChild 参数类型为 Array，在 reconcileChildFibers 函数内部对应如下情况：</p>\n<blockquote>\n<p>你可以在<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactChildFiber.new.js#L1352" target="_blank" rel="nofollow noreferrer noopener">这里</a>看到这段源码逻辑</p>\n</blockquote>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="50273937551073700000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`if (isArray(newChild)) {\n  // 调用 reconcileChildrenArray 处理\n  // ...省略\n}`, `50273937551073700000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isArray</span><span class="token punctuation">(</span>newChild<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 调用 reconcileChildrenArray 处理</span>\n  <span class="token comment">// ...省略</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>这一节我们来看看，如何处理同级多个节点的 Diff。</p>\n<h3 id="概览-1"><a href="#%E6%A6%82%E8%A7%88-1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>概览</h3>\n<p>首先归纳下我们需要处理的情况：</p>\n<p>我们以之前代表更新前的 JSX 对象，之后代表更新后的 JSX 对象</p>\n<h4 id="情况-1：节点更新"><a href="#%E6%83%85%E5%86%B5-1%EF%BC%9A%E8%8A%82%E7%82%B9%E6%9B%B4%E6%96%B0" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>情况 1：节点更新</h4>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="30065333623977010000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// 之前\n<ul>\n  <li key=&quot;0&quot; className=&quot;before&quot;>0<li>\n  <li key=&quot;1&quot;>1<li>\n</ul>\n\n// 之后 情况1 —— 节点属性变化\n<ul>\n  <li key=&quot;0&quot; className=&quot;after&quot;>0<li>\n  <li key=&quot;1&quot;>1<li>\n</ul>\n\n// 之后 情况2 —— 节点类型更新\n<ul>\n  <div key=&quot;0&quot;>0</div>\n  <li key=&quot;1&quot;>1<li>\n</ul>`, `30065333623977010000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                jsx 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="jsx"><pre style="counter-reset: linenumber NaN" class="language-jsx line-numbers"><code class="language-jsx"><span class="token comment">// 之前</span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span> <span class="token attr-name">className</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>before<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">0</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">1</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span><span class="token plain-text">\n</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span><span class="token plain-text">\n\n// 之后 情况1 —— 节点属性变化\n</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span> <span class="token attr-name">className</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>after<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">0</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">1</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span><span class="token plain-text">\n</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span><span class="token plain-text">\n\n// 之后 情况2 —— 节点类型更新\n</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">0</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">1</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span><span class="token plain-text">\n</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h4 id="情况-2：节点新增或减少"><a href="#%E6%83%85%E5%86%B5-2%EF%BC%9A%E8%8A%82%E7%82%B9%E6%96%B0%E5%A2%9E%E6%88%96%E5%87%8F%E5%B0%91" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>情况 2：节点新增或减少</h4>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="1220027108362398200"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// 之前\n<ul>\n  <li key=&quot;0&quot;>0<li>\n  <li key=&quot;1&quot;>1<li>\n</ul>\n\n// 之后 情况1 —— 新增节点\n<ul>\n  <li key=&quot;0&quot;>0<li>\n  <li key=&quot;1&quot;>1<li>\n  <li key=&quot;2&quot;>2<li>\n</ul>\n\n// 之后 情况2 —— 删除节点\n<ul>\n  <li key=&quot;1&quot;>1<li>\n</ul>`, `1220027108362398200`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                jsx 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="jsx"><pre style="counter-reset: linenumber NaN" class="language-jsx line-numbers"><code class="language-jsx"><span class="token comment">// 之前</span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">0</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">1</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span><span class="token plain-text">\n</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span><span class="token plain-text">\n\n// 之后 情况1 —— 新增节点\n</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">0</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">1</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>2<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">2</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span><span class="token plain-text">\n</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span><span class="token plain-text">\n\n// 之后 情况2 —— 删除节点\n</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">1</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span><span class="token plain-text">\n</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h4 id="情况-3：节点位置变化"><a href="#%E6%83%85%E5%86%B5-3%EF%BC%9A%E8%8A%82%E7%82%B9%E4%BD%8D%E7%BD%AE%E5%8F%98%E5%8C%96" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>情况 3：节点位置变化</h4>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="48236325884081020000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// 之前\n<ul>\n  <li key=&quot;0&quot;>0<li>\n  <li key=&quot;1&quot;>1<li>\n</ul>\n\n// 之后\n<ul>\n  <li key=&quot;1&quot;>1<li>\n  <li key=&quot;0&quot;>0<li>\n</ul>`, `48236325884081020000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                jsx 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="jsx"><pre style="counter-reset: linenumber NaN" class="language-jsx line-numbers"><code class="language-jsx"><span class="token comment">// 之前</span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">0</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">1</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span><span class="token plain-text">\n</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span><span class="token plain-text">\n\n// 之后\n</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">1</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">0</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span><span class="token plain-text">\n</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>同级多个节点的 Diff，一定属于以上三种情况中的一种或多种。</p>\n<h3 id="diff-的思路"><a href="#diff-%E7%9A%84%E6%80%9D%E8%B7%AF" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Diff 的思路</h3>\n<p>该如何设计算法呢？如果让我设计一个 Diff 算法，我首先想到的方案是：</p>\n<ol>\n<li>判断当前节点的更新属于哪种情况</li>\n<li>如果是新增，执行新增逻辑</li>\n<li>如果是删除，执行删除逻辑</li>\n<li>如果是更新，执行更新逻辑</li>\n</ol>\n<p>按这个方案，其实有个隐含的前提——不同操作的优先级是相同的</p>\n<p>但是 React 团队发现，在日常开发中，相较于新增和删除，更新组件发生的频率更高。所以 Diff 会优先判断当前节点是否属于更新。</p>\n<blockquote>\n<p>注意</p>\n<p>在我们做数组相关的算法题时，经常使用双指针从数组头和尾同时遍历以提高效率，但是这里却不行。</p>\n<p>虽然本次更新的 JSX 对象 newChildren 为数组形式，但是和 newChildren 中每个组件进行比较的是 current fiber，同级的 Fiber 节点是由 sibling 指针链接形成的单链表，即不支持双指针遍历。</p>\n<p>即 <code class="language-text">newChildren[0]</code> 与 fiber 比较，<code class="language-text">newChildren[1]</code> 与 fiber.sibling 比较。</p>\n<p>所以无法使用双指针优化。</p>\n</blockquote>\n<p>基于以上原因，Diff 算法的整体逻辑会经历两轮遍历：</p>\n<p>第一轮遍历：处理更新的节点。</p>\n<p>第二轮遍历：处理剩下的不属于更新的节点。</p>\n<h3 id="第一轮遍历"><a href="#%E7%AC%AC%E4%B8%80%E8%BD%AE%E9%81%8D%E5%8E%86" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>第一轮遍历</h3>\n<p>第一轮遍历步骤如下：</p>\n<ol>\n<li>let i = 0，遍历 newChildren，将 <code class="language-text">newChildren[i]</code> 与 oldFiber 比较，判断 DOM 节点是否可复用。</li>\n<li>如果可复用，i++，继续比较 <code class="language-text">newChildren[i]</code> 与 oldFiber.sibling，可以复用则继续遍历。</li>\n<li>\n<p>如果不可复用，分两种情况：</p>\n<ol>\n<li>key 不同导致不可复用，立即跳出整个遍历，第一轮遍历结束。</li>\n<li>key 相同 type 不同导致不可复用，会将 oldFiber 标记为 DELETION，并继续遍历</li>\n</ol>\n</li>\n<li>如果 newChildren 遍历完（即 i === newChildren.length - 1）或者 oldFiber 遍历完（即 oldFiber.sibling === null），跳出遍历，第一轮遍历结束。</li>\n</ol>\n<blockquote>\n<p>你可以从<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactChildFiber.new.js#L818" target="_blank" rel="nofollow noreferrer noopener">这里</a>看到这轮遍历的源码</p>\n</blockquote>\n<p>当遍历结束后，会有两种结果：</p>\n<h4 id="步骤-3-跳出的遍历"><a href="#%E6%AD%A5%E9%AA%A4-3-%E8%B7%B3%E5%87%BA%E7%9A%84%E9%81%8D%E5%8E%86" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>步骤 3 跳出的遍历</h4>\n<p>此时 newChildren 没有遍历完，oldFiber 也没有遍历完。</p>\n<p>举个例子，考虑如下代码：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="50427889701452400000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// 之前\n<li key=&quot;0&quot;>0</li>\n<li key=&quot;1&quot;>1</li>\n<li key=&quot;2&quot;>2</li>\n\n// 之后\n<li key=&quot;0&quot;>0</li>\n<li key=&quot;2&quot;>1</li>\n<li key=&quot;1&quot;>2</li>`, `50427889701452400000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                jsx 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="jsx"><pre style="counter-reset: linenumber NaN" class="language-jsx line-numbers"><code class="language-jsx"><span class="token comment">// 之前</span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">0</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">1</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>2<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">2</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>\n\n<span class="token comment">// 之后</span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">0</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>2<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">1</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">2</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>第一个节点可复用，遍历到 key === 2 的节点发现 key 改变，不可复用，跳出遍历，等待第二轮遍历处理。</p>\n<p>此时 oldFiber 剩下 key === 1、key === 2 未遍历，newChildren 剩下 key === 2、key === 1 未遍历。</p>\n<h4 id="步骤-4-跳出的遍历"><a href="#%E6%AD%A5%E9%AA%A4-4-%E8%B7%B3%E5%87%BA%E7%9A%84%E9%81%8D%E5%8E%86" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>步骤 4 跳出的遍历</h4>\n<p>可能 newChildren 遍历完，或 oldFiber 遍历完，或他们同时遍历完。</p>\n<p>举个例子，考虑如下代码：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="62983636750062600000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// 之前\n<li key=&quot;0&quot; className=&quot;a&quot;>0</li>\n<li key=&quot;1&quot; className=&quot;b&quot;>1</li>\n\n// 之后 情况1 —— newChildren 与 oldFiber 都遍历完\n<li key=&quot;0&quot; className=&quot;aa&quot;>0</li>\n<li key=&quot;1&quot; className=&quot;bb&quot;>1</li>\n\n// 之后 情况2 —— newChildren 没遍历完，oldFiber 遍历完\n// newChildren 剩下 key === &quot;2&quot; 未遍历\n<li key=&quot;0&quot; className=&quot;aa&quot;>0</li>\n<li key=&quot;1&quot; className=&quot;bb&quot;>1</li>\n<li key=&quot;2&quot; className=&quot;cc&quot;>2</li>\n\n// 之后 情况3 —— newChildren 遍历完，oldFiber 没遍历完\n// oldFiber 剩下 key === &quot;1&quot; 未遍历\n<li key=&quot;0&quot; className=&quot;aa&quot;>0</li>`, `62983636750062600000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                jsx 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="jsx"><pre style="counter-reset: linenumber NaN" class="language-jsx line-numbers"><code class="language-jsx"><span class="token comment">// 之前</span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span> <span class="token attr-name">className</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>a<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">0</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span> <span class="token attr-name">className</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>b<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">1</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>\n\n<span class="token comment">// 之后 情况1 —— newChildren 与 oldFiber 都遍历完</span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span> <span class="token attr-name">className</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aa<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">0</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span> <span class="token attr-name">className</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>bb<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">1</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>\n\n<span class="token comment">// 之后 情况2 —— newChildren 没遍历完，oldFiber 遍历完</span>\n<span class="token comment">// newChildren 剩下 key === "2" 未遍历</span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span> <span class="token attr-name">className</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aa<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">0</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span> <span class="token attr-name">className</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>bb<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">1</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>2<span class="token punctuation">"</span></span> <span class="token attr-name">className</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>cc<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">2</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>\n\n<span class="token comment">// 之后 情况3 —— newChildren 遍历完，oldFiber 没遍历完</span>\n<span class="token comment">// oldFiber 剩下 key === "1" 未遍历</span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span> <span class="token attr-name">className</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aa<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">0</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>带着第一轮遍历的结果，我们开始第二轮遍历。</p>\n<h3 id="第二轮遍历"><a href="#%E7%AC%AC%E4%BA%8C%E8%BD%AE%E9%81%8D%E5%8E%86" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>第二轮遍历</h3>\n<p>对于第一轮遍历的结果，我们分别讨论：</p>\n<h4 id="newchildren-与-oldfiber-同时遍历完"><a href="#newchildren-%E4%B8%8E-oldfiber-%E5%90%8C%E6%97%B6%E9%81%8D%E5%8E%86%E5%AE%8C" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>newChildren 与 oldFiber 同时遍历完</h4>\n<p>那就是最理想的情况：只需在第一轮遍历进行组件更新。此时 Diff 结束。</p>\n<h4 id="newchildren-没遍历完，oldfiber-遍历完"><a href="#newchildren-%E6%B2%A1%E9%81%8D%E5%8E%86%E5%AE%8C%EF%BC%8Coldfiber-%E9%81%8D%E5%8E%86%E5%AE%8C" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>newChildren 没遍历完，oldFiber 遍历完</h4>\n<p>已有的 DOM 节点都复用了，这时还有新加入的节点，意味着本次更新有新节点插入，我们只需要遍历剩下的 newChildren 为生成的 workInProgress fiber 依次标记 Placement。</p>\n<blockquote>\n<p>你可以在<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactChildFiber.new.js#L869" target="_blank" rel="nofollow noreferrer noopener">这里</a>看到这段源码逻辑</p>\n</blockquote>\n<h4 id="newchildren-遍历完，oldfiber-没遍历完"><a href="#newchildren-%E9%81%8D%E5%8E%86%E5%AE%8C%EF%BC%8Coldfiber-%E6%B2%A1%E9%81%8D%E5%8E%86%E5%AE%8C" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>newChildren 遍历完，oldFiber 没遍历完</h4>\n<p>意味着本次更新比之前的节点数量少，有节点被删除了。所以需要遍历剩下的 oldFiber，依次标记 Deletion。</p>\n<blockquote>\n<p>你可以在<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactChildFiber.new.js#L863" target="_blank" rel="nofollow noreferrer noopener">这里</a>看到这段源码逻辑</p>\n</blockquote>\n<h4 id="newchildren-与-oldfiber-都没遍历完"><a href="#newchildren-%E4%B8%8E-oldfiber-%E9%83%BD%E6%B2%A1%E9%81%8D%E5%8E%86%E5%AE%8C" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>newChildren 与 oldFiber 都没遍历完</h4>\n<p>这意味着有节点在这次更新中改变了位置。</p>\n<p>这是 Diff 算法最精髓也是最难懂的部分。我们接下来会重点讲解。</p>\n<blockquote>\n<p>你可以在<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactChildFiber.new.js#L893" target="_blank" rel="nofollow noreferrer noopener">这里</a>看到这段源码逻辑</p>\n</blockquote>\n<h3 id="处理移动的节点"><a href="#%E5%A4%84%E7%90%86%E7%A7%BB%E5%8A%A8%E7%9A%84%E8%8A%82%E7%82%B9" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>处理移动的节点</h3>\n<p>由于有节点改变了位置，所以不能再用位置索引 i 对比前后的节点，那么如何才能将同一个节点在两次更新中对应上呢？</p>\n<p>我们需要使用 key。</p>\n<p>为了快速的找到 key 对应的 oldFiber，我们将所有还未处理的 oldFiber 存入以 key 为 key，oldFiber 为 value 的 Map 中。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="14393186263347313000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`const existingChildren = mapRemainingChildren(returnFiber, oldFiber);`, `14393186263347313000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">const</span> existingChildren <span class="token operator">=</span> <span class="token function">mapRemainingChildren</span><span class="token punctuation">(</span>returnFiber<span class="token punctuation">,</span> oldFiber<span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<blockquote>\n<p>你可以在<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactChildFiber.new.js#L890" target="_blank" rel="nofollow noreferrer noopener">这里</a>看到这段源码逻辑</p>\n</blockquote>\n<p>接下来遍历剩余的 newChildren，通过 <code class="language-text">newChildren[i].key</code> 就能在 existingChildren 中找到 key 相同的 oldFiber。</p>\n<h3 id="标记节点是否移动"><a href="#%E6%A0%87%E8%AE%B0%E8%8A%82%E7%82%B9%E6%98%AF%E5%90%A6%E7%A7%BB%E5%8A%A8" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>标记节点是否移动</h3>\n<p>既然我们的目标是寻找移动的节点，那么我们需要明确：节点是否移动是以什么为参照物？</p>\n<p>我们的参照物是：最后一个可复用的节点在 oldFiber 中的位置索引（用变量 lastPlacedIndex 表示）。</p>\n<p>由于本次更新中节点是按 newChildren 的顺序排列。在遍历 newChildren 过程中，每个遍历到的可复用节点一定是当前遍历到的所有可复用节点中最靠右的那个，即一定在 lastPlacedIndex 对应的可复用的节点在本次更新中位置的后面。</p>\n<p>那么我们只需要比较遍历到的可复用节点在上次更新时是否也在 lastPlacedIndex 对应的 oldFiber 后面，就能知道两次更新中这两个节点的相对位置改变没有。</p>\n<p>我们用变量 oldIndex 表示遍历到的可复用节点在 oldFiber 中的位置索引。如果 oldIndex &#x3C; lastPlacedIndex，代表本次更新该节点需要向右移动。</p>\n<p>lastPlacedIndex 初始为 0，每遍历一个可复用的节点，如果 oldIndex >= lastPlacedIndex，则 lastPlacedIndex = oldIndex。</p>\n<p>单纯文字表达比较晦涩，这里我们提供两个 Demo，你可以对照着理解。</p>\n<h3 id="demo1"><a href="#demo1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Demo1</h3>\n<p>在 Demo 中我们简化下书写，每个字母代表一个节点，字母的值代表节点的 key</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="51539158941307360000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// 之前\nabcd\n\n// 之后\nacdb\n\n===第一轮遍历开始===\na（之后）vs a（之前）\nkey 不变，可复用\n此时 a 对应的 oldFiber（之前的 a）在之前的数组（abcd）中索引为 0\n所以 lastPlacedIndex = 0;\n\n继续第一轮遍历...\n\nc（之后）vs b（之前）\nkey 改变，不能复用，跳出第一轮遍历\n此时 lastPlacedIndex === 0;\n===第一轮遍历结束===\n\n===第二轮遍历开始===\nnewChildren === cdb，没用完，不需要执行删除旧节点\noldFiber === bcd，没用完，不需要执行插入新节点\n\n将剩余 oldFiber（bcd）保存为 map\n\n// 当前 oldFiber：bcd\n// 当前 newChildren：cdb\n\n继续遍历剩余 newChildren\n\nkey === c 在 oldFiber 中存在\nconst oldIndex = c（之前）.index;\n此时 oldIndex === 2;  // 之前节点为 abcd，所以c.index === 2\n比较 oldIndex 与 lastPlacedIndex;\n\n如果 oldIndex >= lastPlacedIndex 代表该可复用节点不需要移动\n并将 lastPlacedIndex = oldIndex;\n如果 oldIndex < lastplacedIndex 该可复用节点之前插入的位置索引小于这次更新需要插入的位置索引，代表该节点需要向右移动\n\n在例子中，oldIndex 2 > lastPlacedIndex 0，\n则 lastPlacedIndex = 2;\nc 节点位置不变\n\n继续遍历剩余 newChildren\n\n// 当前oldFiber：bd\n// 当前newChildren：db\n\nkey === d 在 oldFiber 中存在\nconst oldIndex = d（之前）.index;\noldIndex 3 > lastPlacedIndex 2 // 之前节点为 abcd，所以 d.index === 3\n则 lastPlacedIndex = 3;\nd 节点位置不变\n\n继续遍历剩余 newChildren\n\n// 当前 oldFiber：b\n// 当前 newChildren：b\n\nkey === b 在 oldFiber 中存在\nconst oldIndex = b（之前）.index;\noldIndex 1 < lastPlacedIndex 3 // 之前节点为 abcd，所以 b.index === 1\n则 b 节点需要向右移动\n===第二轮遍历结束===\n\n最终 acd 3 个节点都没有移动，b 节点被标记为移动`, `51539158941307360000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">// 之前\nabcd\n\n// 之后\nacdb\n\n===第一轮遍历开始===\na（之后）vs a（之前）\nkey 不变，可复用\n此时 a 对应的 oldFiber（之前的 a）在之前的数组（abcd）中索引为 0\n所以 lastPlacedIndex = 0;\n\n继续第一轮遍历...\n\nc（之后）vs b（之前）\nkey 改变，不能复用，跳出第一轮遍历\n此时 lastPlacedIndex === 0;\n===第一轮遍历结束===\n\n===第二轮遍历开始===\nnewChildren === cdb，没用完，不需要执行删除旧节点\noldFiber === bcd，没用完，不需要执行插入新节点\n\n将剩余 oldFiber（bcd）保存为 map\n\n// 当前 oldFiber：bcd\n// 当前 newChildren：cdb\n\n继续遍历剩余 newChildren\n\nkey === c 在 oldFiber 中存在\nconst oldIndex = c（之前）.index;\n此时 oldIndex === 2;  // 之前节点为 abcd，所以c.index === 2\n比较 oldIndex 与 lastPlacedIndex;\n\n如果 oldIndex &gt;= lastPlacedIndex 代表该可复用节点不需要移动\n并将 lastPlacedIndex = oldIndex;\n如果 oldIndex &lt; lastplacedIndex 该可复用节点之前插入的位置索引小于这次更新需要插入的位置索引，代表该节点需要向右移动\n\n在例子中，oldIndex 2 &gt; lastPlacedIndex 0，\n则 lastPlacedIndex = 2;\nc 节点位置不变\n\n继续遍历剩余 newChildren\n\n// 当前oldFiber：bd\n// 当前newChildren：db\n\nkey === d 在 oldFiber 中存在\nconst oldIndex = d（之前）.index;\noldIndex 3 &gt; lastPlacedIndex 2 // 之前节点为 abcd，所以 d.index === 3\n则 lastPlacedIndex = 3;\nd 节点位置不变\n\n继续遍历剩余 newChildren\n\n// 当前 oldFiber：b\n// 当前 newChildren：b\n\nkey === b 在 oldFiber 中存在\nconst oldIndex = b（之前）.index;\noldIndex 1 &lt; lastPlacedIndex 3 // 之前节点为 abcd，所以 b.index === 1\n则 b 节点需要向右移动\n===第二轮遍历结束===\n\n最终 acd 3 个节点都没有移动，b 节点被标记为移动</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h3 id="demo2"><a href="#demo2" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Demo2</h3>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="20271423045891113000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// 之前\nabcd\n\n// 之后\ndabc\n\n===第一轮遍历开始===\nd（之后）vs a（之前）\nkey 改变，不能复用，跳出遍历\n===第一轮遍历结束===\n\n===第二轮遍历开始===\nnewChildren === dabc，没用完，不需要执行删除旧节点\noldFiber === abcd，没用完，不需要执行插入新节点\n\n将剩余 oldFiber（abcd）保存为 map\n\n继续遍历剩余 newChildren\n\n// 当前 oldFiber：abcd\n// 当前 newChildren：dabc\n\nkey === d 在 oldFiber 中存在\nconst oldIndex = d（之前）.index;\n此时 oldIndex === 3; // 之前节点为 abcd，所以 d.index === 3\n比较 oldIndex 与 lastPlacedIndex;\noldIndex 3 > lastPlacedIndex 0\n则 lastPlacedIndex = 3;\nd 节点位置不变\n\n继续遍历剩余 newChildren\n\n// 当前 oldFiber：abc\n// 当前 newChildren：abc\n\nkey === a 在 oldFiber 中存在\nconst oldIndex = a（之前）.index; // 之前节点为 abcd，所以 a.index === 0\n此时 oldIndex === 0;\n比较 oldIndex 与 lastPlacedIndex;\noldIndex 0 < lastPlacedIndex 3\n则 a 节点需要向右移动\n\n继续遍历剩余 newChildren\n\n// 当前 oldFiber：bc\n// 当前 newChildren：bc\n\nkey === b 在 oldFiber 中存在\nconst oldIndex = b（之前）.index; // 之前节点为 abcd，所以 b.index === 1\n此时 oldIndex === 1;\n比较 oldIndex 与 lastPlacedIndex;\noldIndex 1 < lastPlacedIndex 3\n则 b 节点需要向右移动\n\n继续遍历剩余 newChildren\n\n// 当前 oldFiber：c\n// 当前 newChildren：c\n\nkey === c 在 oldFiber 中存在\nconst oldIndex = c（之前）.index; // 之前节点为 abcd，所以 c.index === 2\n此时 oldIndex === 2;\n比较 oldIndex 与 lastPlacedIndex;\noldIndex 2 < lastPlacedIndex 3\n则 c 节点需要向右移动\n\n===第二轮遍历结束===`, `20271423045891113000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">// 之前\nabcd\n\n// 之后\ndabc\n\n===第一轮遍历开始===\nd（之后）vs a（之前）\nkey 改变，不能复用，跳出遍历\n===第一轮遍历结束===\n\n===第二轮遍历开始===\nnewChildren === dabc，没用完，不需要执行删除旧节点\noldFiber === abcd，没用完，不需要执行插入新节点\n\n将剩余 oldFiber（abcd）保存为 map\n\n继续遍历剩余 newChildren\n\n// 当前 oldFiber：abcd\n// 当前 newChildren：dabc\n\nkey === d 在 oldFiber 中存在\nconst oldIndex = d（之前）.index;\n此时 oldIndex === 3; // 之前节点为 abcd，所以 d.index === 3\n比较 oldIndex 与 lastPlacedIndex;\noldIndex 3 &gt; lastPlacedIndex 0\n则 lastPlacedIndex = 3;\nd 节点位置不变\n\n继续遍历剩余 newChildren\n\n// 当前 oldFiber：abc\n// 当前 newChildren：abc\n\nkey === a 在 oldFiber 中存在\nconst oldIndex = a（之前）.index; // 之前节点为 abcd，所以 a.index === 0\n此时 oldIndex === 0;\n比较 oldIndex 与 lastPlacedIndex;\noldIndex 0 &lt; lastPlacedIndex 3\n则 a 节点需要向右移动\n\n继续遍历剩余 newChildren\n\n// 当前 oldFiber：bc\n// 当前 newChildren：bc\n\nkey === b 在 oldFiber 中存在\nconst oldIndex = b（之前）.index; // 之前节点为 abcd，所以 b.index === 1\n此时 oldIndex === 1;\n比较 oldIndex 与 lastPlacedIndex;\noldIndex 1 &lt; lastPlacedIndex 3\n则 b 节点需要向右移动\n\n继续遍历剩余 newChildren\n\n// 当前 oldFiber：c\n// 当前 newChildren：c\n\nkey === c 在 oldFiber 中存在\nconst oldIndex = c（之前）.index; // 之前节点为 abcd，所以 c.index === 2\n此时 oldIndex === 2;\n比较 oldIndex 与 lastPlacedIndex;\noldIndex 2 &lt; lastPlacedIndex 3\n则 c 节点需要向右移动\n\n===第二轮遍历结束===</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>可以看到，我们以为从 abcd 变为 dabc，只需要将 d 移动到前面。</p>\n<p>但实际上 React 保持 d 不变，将 abc 分别移动到了 d 的后面。</p>\n<p>从这点可以看出，考虑性能，我们要尽量减少将节点从后面移动到前面的操作。</p>\n<h1 id="状态更新"><a href="#%E7%8A%B6%E6%80%81%E6%9B%B4%E6%96%B0" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>状态更新</h1>\n<h2 id="流程概览"><a href="#%E6%B5%81%E7%A8%8B%E6%A6%82%E8%A7%88" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>流程概览</h2>\n<p>经过前几章的学习，我们终于有足够的前置知识理解状态更新的整个流程。</p>\n<p>这一章我们看看几种常见的触发状态更新的方法是如何完成工作的。</p>\n<h3 id="几个关键节点"><a href="#%E5%87%A0%E4%B8%AA%E5%85%B3%E9%94%AE%E8%8A%82%E7%82%B9" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>几个关键节点</h3>\n<p>在开始学习前，我们先了解源码中几个关键节点（即几个关键函数的调用）。通过这章的学习，我们会将这些关键节点的调用路径串起来。</p>\n<p>先从我们所熟知的概念开始。</p>\n<h4 id="render-阶段的开始"><a href="#render-%E9%98%B6%E6%AE%B5%E7%9A%84%E5%BC%80%E5%A7%8B" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>render 阶段的开始</h4>\n<p>我们在 render 阶段流程概览一节讲到，</p>\n<p>render 阶段开始于 performSyncWorkOnRoot 或 performConcurrentWorkOnRoot 方法的调用。这取决于本次更新是同步更新还是异步更新。</p>\n<h4 id="commit-阶段的开始"><a href="#commit-%E9%98%B6%E6%AE%B5%E7%9A%84%E5%BC%80%E5%A7%8B" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>commit 阶段的开始</h4>\n<p>我们在 commit 阶段流程概览一节讲到，</p>\n<p>commit 阶段开始于 commitRoot 方法的调用。其中 rootFiber 会作为传参。</p>\n<p>我们已经知道，render 阶段完成后会进入 commit 阶段，让我们继续补全从触发状态更新到 render 阶段的路径。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="87963735123680280000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`触发状态更新（根据场景调用不同方法）\n\n    |\n    |\n    v\n\n    ？\n\n    |\n    |\n    v\n\nrender阶段（\\`performSyncWorkOnRoot\\` 或 \\`performConcurrentWorkOnRoot\\`）\n\n    |\n    |\n    v\n\ncommit阶段（\\`commitRoot\\`）`, `87963735123680280000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">触发状态更新（根据场景调用不同方法）\n\n    |\n    |\n    v\n\n    ？\n\n    |\n    |\n    v\n\nrender阶段（`performSyncWorkOnRoot` 或 `performConcurrentWorkOnRoot`）\n\n    |\n    |\n    v\n\ncommit阶段（`commitRoot`）</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h4 id="创建-update-对象"><a href="#%E5%88%9B%E5%BB%BA-update-%E5%AF%B9%E8%B1%A1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>创建 Update 对象</h4>\n<p>在 React 中，有如下方法可以触发状态更新（排除 SSR 相关）：</p>\n<ul>\n<li>ReactDOM.render</li>\n<li>this.setState</li>\n<li>this.forceUpdate</li>\n<li>useState</li>\n<li>useReducer</li>\n</ul>\n<p>这些方法调用的场景各不相同，他们是如何接入同一套状态更新机制呢？</p>\n<p>答案是：每次状态更新都会创建一个保存更新状态相关内容的对象，我们叫他 Update。在 render 阶段的 beginWork 中会根据 Update 计算新的 state。</p>\n<p>我们会在下一节详细讲解 Update。</p>\n<h4 id="从-fiber-到-root"><a href="#%E4%BB%8E-fiber-%E5%88%B0-root" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>从 fiber 到 root</h4>\n<p>现在触发状态更新的 fiber 上已经包含 Update 对象。</p>\n<p>我们知道，render 阶段是从 rootFiber 开始向下遍历。那么如何从触发状态更新的 fiber 得到 rootFiber 呢？</p>\n<p>答案是：调用 markUpdateLaneFromFiberToRoot 方法。</p>\n<blockquote>\n<p>你可以从<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L636" target="_blank" rel="nofollow noreferrer noopener">这里</a>看到 markUpdateLaneFromFiberToRoot 的源码</p>\n</blockquote>\n<p>该方法做的工作可以概括为：从触发状态更新的 fiber 一直向上遍历到 rootFiber，并返回 rootFiber。</p>\n<p>由于不同更新优先级不尽相同，所以过程中还会更新遍历到的 fiber 的优先级。这对于我们当前属于超纲内容。</p>\n<h4 id="调度更新"><a href="#%E8%B0%83%E5%BA%A6%E6%9B%B4%E6%96%B0" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>调度更新</h4>\n<p>现在我们拥有一个 rootFiber，该 rootFiber 对应的 Fiber 树中某个 Fiber 节点包含一个 Update。</p>\n<p>接下来通知 Scheduler 根据更新的优先级，决定以同步还是异步的方式调度本次更新。</p>\n<p>这里调用的方法是 ensureRootIsScheduled。</p>\n<p>以下是 ensureRootIsScheduled 最核心的一段代码：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="37910184590537875000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`if (newCallbackPriority === SyncLanePriority) {\n  // 任务已经过期，需要同步执行 render 阶段\n  newCallbackNode = scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root));\n} else {\n  // 根据任务优先级异步执行 render 阶段\n  var schedulerPriorityLevel = lanePriorityToSchedulerPriority(newCallbackPriority);\n  newCallbackNode = scheduleCallback(schedulerPriorityLevel, performConcurrentWorkOnRoot.bind(null, root));\n}`, `37910184590537875000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">if</span> <span class="token punctuation">(</span>newCallbackPriority <span class="token operator">===</span> SyncLanePriority<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 任务已经过期，需要同步执行 render 阶段</span>\n  newCallbackNode <span class="token operator">=</span> <span class="token function">scheduleSyncCallback</span><span class="token punctuation">(</span><span class="token function">performSyncWorkOnRoot</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 根据任务优先级异步执行 render 阶段</span>\n  <span class="token keyword">var</span> schedulerPriorityLevel <span class="token operator">=</span> <span class="token function">lanePriorityToSchedulerPriority</span><span class="token punctuation">(</span>newCallbackPriority<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  newCallbackNode <span class="token operator">=</span> <span class="token function">scheduleCallback</span><span class="token punctuation">(</span>schedulerPriorityLevel<span class="token punctuation">,</span> <span class="token function">performConcurrentWorkOnRoot</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<blockquote>\n<p>你可以从<a href="https://github.com/facebook/react/blob/b6df4417c79c11cfb44f965fab55b573882b1d54/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L602" target="_blank" rel="nofollow noreferrer noopener">这里</a>看到 ensureRootIsScheduled 的源码</p>\n</blockquote>\n<p>其中，scheduleCallback 和 scheduleSyncCallback 会调用 Scheduler 提供的调度方法根据优先级调度回调函数执行。</p>\n<p>可以看到，这里调度的回调函数为：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="35813854478646514000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`performSyncWorkOnRoot.bind(null, root);\nperformConcurrentWorkOnRoot.bind(null, root);`, `35813854478646514000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token function">performSyncWorkOnRoot</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token function">performConcurrentWorkOnRoot</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span></span></pre></div>\n<p>即 render 阶段的入口函数。</p>\n<p>至此，状态更新就和我们所熟知的 render 阶段连接上了。</p>\n<h3 id="总结"><a href="#%E6%80%BB%E7%BB%93" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总结</h3>\n<p>让我们梳理下状态更新的整个调用路径的关键节点：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="29047777536082563000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`触发状态更新（根据场景调用不同方法）\n\n    |\n    |\n    v\n\n创建 Update 对象（接下来三节详解）\n\n    |\n    |\n    v\n\n从 fiber 到 root（\\`markUpdateLaneFromFiberToRoot\\`）\n\n    |\n    |\n    v\n\n调度更新（\\`ensureRootIsScheduled\\`）\n\n    |\n    |\n    v\n\nrender阶段（\\`performSyncWorkOnRoot\\` 或 \\`performConcurrentWorkOnRoot\\`）\n\n    |\n    |\n    v\n\ncommit阶段（\\`commitRoot\\`）`, `29047777536082563000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js">触发状态更新（根据场景调用不同方法）\n\n    <span class="token operator">|</span>\n    <span class="token operator">|</span>\n    v\n\n创建 Update 对象（接下来三节详解）\n\n    <span class="token operator">|</span>\n    <span class="token operator">|</span>\n    v\n\n从 fiber 到 root（<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">markUpdateLaneFromFiberToRoot</span><span class="token template-punctuation string">`</span></span>）\n\n    <span class="token operator">|</span>\n    <span class="token operator">|</span>\n    v\n\n调度更新（<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">ensureRootIsScheduled</span><span class="token template-punctuation string">`</span></span>）\n\n    <span class="token operator">|</span>\n    <span class="token operator">|</span>\n    v\n\nrender阶段（<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">performSyncWorkOnRoot</span><span class="token template-punctuation string">`</span></span> 或 <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">performConcurrentWorkOnRoot</span><span class="token template-punctuation string">`</span></span>）\n\n    <span class="token operator">|</span>\n    <span class="token operator">|</span>\n    v\n\ncommit阶段（<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">commitRoot</span><span class="token template-punctuation string">`</span></span>）</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>本节我们了解了状态更新的整个流程。</p>\n<p>在接下来三节中，我们会花大量篇幅讲解 Update 的工作机制，因为他是构成 React concurrent mode 的核心机制之一。</p>\n<h2 id="心智模型"><a href="#%E5%BF%83%E6%99%BA%E6%A8%A1%E5%9E%8B" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>心智模型</h2>\n<p>在深入源码前，让我们先建立更新机制的心智模型。</p>\n<p>在后面两节讲解源码时，我们会将代码与心智模型联系上，方便你更好理解。</p>\n<h3 id="同步更新的-react"><a href="#%E5%90%8C%E6%AD%A5%E6%9B%B4%E6%96%B0%E7%9A%84-react" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>同步更新的 React</h3>\n<p>我们可以将更新机制类比代码版本控制。</p>\n<p>在没有代码版本控制前，我们在代码中逐步叠加功能。一切看起来井然有序，直到我们遇到了一个紧急线上 bug（红色节点）。</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-02-01-11-03-04-fe04d9bfbba59061f0fa80a63494dbe0-506c4.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 27.51937984496124%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAIAAABM9SnKAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAA60lEQVQY02P4////v3//oeAfEPyF8zC5///9haoGkwwQ8SevP3369hOu7OHLj19//IKw//779+Dlxx+//kBN+PXr87Xrf3/+hGq++vC1e9XKuiXH/nx7+vXRmhPXHrhWruxZd/bv1/vfHq/be/6+XcnSOTuu/v90/ePr3Q+mz97IxHantx+qGWhPXPfmyZvO/f/z5efbU9cePI/q2Dx/99X/fz7+fnv69K1noa0b1h298//X629frjxbu363vNLjJcsQzv71+88fJN/9/P3nLzL3159/iID5//f7d4SfkYIASP2FcWEUKhdZNQDS40k1FGZh6QAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 02 01 11 03 04"\n        title=""\n        src="/static/2021-02-01-11-03-04-fe04d9bfbba59061f0fa80a63494dbe0-fee1c.png"\n        srcset="/static/2021-02-01-11-03-04-fe04d9bfbba59061f0fa80a63494dbe0-a67b7.png 200w,\n/static/2021-02-01-11-03-04-fe04d9bfbba59061f0fa80a63494dbe0-0b187.png 400w,\n/static/2021-02-01-11-03-04-fe04d9bfbba59061f0fa80a63494dbe0-fee1c.png 800w,\n/static/2021-02-01-11-03-04-fe04d9bfbba59061f0fa80a63494dbe0-b1a91.png 1200w,\n/static/2021-02-01-11-03-04-fe04d9bfbba59061f0fa80a63494dbe0-506c4.png 1548w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>为了修复这个 bug，我们需要首先将之前的代码提交。</p>\n<p>在 React 中，所有通过 ReactDOM.render 创建的应用（其他创建应用的方式参考 ReactDOM.render 一节）都是通过类似的方式更新状态。</p>\n<p>即没有优先级概念，高优更新（红色节点）需要排在其他更新后面执行。</p>\n<h3 id="并发更新的-react"><a href="#%E5%B9%B6%E5%8F%91%E6%9B%B4%E6%96%B0%E7%9A%84-react" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>并发更新的 React</h3>\n<p>当有了代码版本控制，有紧急线上 bug 需要修复时，我们暂存当前分支的修改，在 master 分支修复 bug 并紧急上线。</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-02-01-11-03-44-0d76cff9f84aecc7d14910dd9d910799-446cc.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 47.008547008547005%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAIAAAC9o5sfAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABTElEQVQoz6VQuU7DQBB1i0RBQ49EQcE30NDyATQ0lLR8BxIVFQ0IEB/AFSXgRELKJUTiXE5QQg4rtnPZ8Tre+NiDtR2cBmiY3eLNm3k7b5ajQRB2QkAW4IeISt+Ai5QDvd8bNv9Wzpots/ERpVw4amSox+f7h6e71e4bSx3P9rC7vK6NKQWiyG9tJzY2p+8FX44xEzOeSuPPo7O9g5OdtJhAFBlwYtpT09bBXGcAQA1Sd5zLPK6t362sjvikL0aIi/Ysd7LZevx3137P5Ck2erhf2o5qDcmstIHj4SBDmJBCU83XZddDgUmEMC6pVlGZeQgHP+Xv7IvHBrx5KV/EhZask7liKbmBZt4ma1fPlbZqEChDNa9o5nWidBkTpCEI5y0mI0QytT5f7Fq2S7GDHMCeT1ellNCFjscY7AJm4bXSSwm9OWMC4xz9R3wBFOj08p8CDn4AAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 02 01 11 03 44"\n        title=""\n        src="/static/2021-02-01-11-03-44-0d76cff9f84aecc7d14910dd9d910799-fee1c.png"\n        srcset="/static/2021-02-01-11-03-44-0d76cff9f84aecc7d14910dd9d910799-a67b7.png 200w,\n/static/2021-02-01-11-03-44-0d76cff9f84aecc7d14910dd9d910799-0b187.png 400w,\n/static/2021-02-01-11-03-44-0d76cff9f84aecc7d14910dd9d910799-fee1c.png 800w,\n/static/2021-02-01-11-03-44-0d76cff9f84aecc7d14910dd9d910799-446cc.png 1170w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>bug 修复上线后通过 git rebase 命令和开发分支连接上。开发分支基于修复 bug 的版本继续开发。</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-02-01-11-03-59-e8d7c3d9dcf64ee9ddb4d327b455516c-69be6.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 63.829787234042556%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAIAAAAmMtkJAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABf0lEQVQoz2P4TwFg+PcPRO278LB95fH7Lz4A2f8gQsRoBuInrz951652q1pZMGMPSDPxNgPxu0/f47q3OJUv71h1nDSbIUofvPiw68ydz99/gTWTYDNI7b+f7/58OPufJK0gzf/+AqkPTw/d3Z/y6+c3mLP//v33/89fEBNIglUCyX8QQaDwX7Ag1OafPz69eXEZoujfvz8QwV+//3798QtJEAR+/PrzDSoIDjCgMRPWn43s3Lnr7H0g9/ev7/9+vf/282/jkiPAgDx98xlI8OeX/38+v/n0o3jW3tQJ228+eQvVfPf5e2BQe9WsTO7f+e/Xhyfn2t6cqzx566196RLfutXl8w7///vm/rHSz9d7N595YVO0yKViRc+ak1DNv//8bV521L9h7YZjt0AO+/ryz9dHn77/KZm9L6R5/cFLj4CC3z8/+f/jxfN339Mnbo/q2HTx3kuoZoj+d5+/owUm0Hvvv/xAEwSGwsevPxB+hqcqWPL4B40/rIL/ECQAcdnUxVxZmBAAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 02 01 11 03 59"\n        title=""\n        src="/static/2021-02-01-11-03-59-e8d7c3d9dcf64ee9ddb4d327b455516c-fee1c.png"\n        srcset="/static/2021-02-01-11-03-59-e8d7c3d9dcf64ee9ddb4d327b455516c-a67b7.png 200w,\n/static/2021-02-01-11-03-59-e8d7c3d9dcf64ee9ddb4d327b455516c-0b187.png 400w,\n/static/2021-02-01-11-03-59-e8d7c3d9dcf64ee9ddb4d327b455516c-fee1c.png 800w,\n/static/2021-02-01-11-03-59-e8d7c3d9dcf64ee9ddb4d327b455516c-69be6.png 1034w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>在 React 中，通过 ReactDOM.createBlockingRoot 和 ReactDOM.createRoot 创建的应用会采用并发的方式更新状态。</p>\n<p>高优更新（红色节点）中断正在进行中的低优更新（蓝色节点），先完成 render - commit 流程。</p>\n<p>待高优更新完成后，低优更新基于高优更新的结果重新更新。</p>\n<p>接下来两节我们会从源码角度讲解这套并发更新是如何实现的。</p>\n<h2 id="update"><a href="#update" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Update</h2>\n<p>通过本章第一节学习，我们知道状态更新流程开始后首先会创建 Update 对象。</p>\n<p>本节我们学习 Update 的结构与工作流程。</p>\n<blockquote>\n<p>你可以将 Update 类比心智模型中的一次 commit。</p>\n</blockquote>\n<h3 id="update-的分类"><a href="#update-%E7%9A%84%E5%88%86%E7%B1%BB" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Update 的分类</h3>\n<p>我们先来了解 Update 的结构。</p>\n<p>首先，我们将可以触发更新的方法所隶属的组件分类：</p>\n<ul>\n<li>ReactDOM.render —— HostRoot</li>\n<li>this.setState —— ClassComponent</li>\n<li>this.forceUpdate —— ClassComponent</li>\n<li>useState —— FunctionComponent</li>\n<li>useReducer —— FunctionComponent</li>\n</ul>\n<p>可以看到，一共三种组件（HostRoot | ClassComponent | FunctionComponent）可以触发更新。</p>\n<p>由于不同类型组件工作方式不同，所以存在两种不同结构的 Update，其中 ClassComponent 与 HostRoot 共用一套 Update 结构，FunctionComponent 单独使用一种 Update 结构。</p>\n<p>虽然他们的结构不同，但是他们工作机制与工作流程大体相同。在本节我们介绍前一种 Update，FunctionComponent 对应的 Update 在 Hooks 章节介绍。</p>\n<h3 id="update-的结构"><a href="#update-%E7%9A%84%E7%BB%93%E6%9E%84" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Update 的结构</h3>\n<p>ClassComponent 与 HostRoot（即 rootFiber.tag 对应类型）共用同一种 Update 结构。</p>\n<p>对应的结构如下：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="26615083615051070000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`const update: Update<*> = {\n  eventTime,\n  lane,\n  suspenseConfig,\n  tag: UpdateState,\n  payload: null,\n  callback: null,\n\n  next: null\n};`, `26615083615051070000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">const</span> update<span class="token punctuation">:</span> Update<span class="token operator">&lt;</span><span class="token operator">*</span><span class="token operator">></span> <span class="token operator">=</span> <span class="token punctuation">{</span>\n  eventTime<span class="token punctuation">,</span>\n  lane<span class="token punctuation">,</span>\n  suspenseConfig<span class="token punctuation">,</span>\n  tag<span class="token punctuation">:</span> UpdateState<span class="token punctuation">,</span>\n  payload<span class="token punctuation">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>\n  callback<span class="token punctuation">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>\n\n  next<span class="token punctuation">:</span> <span class="token keyword">null</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<blockquote>\n<p>Update 由 createUpdate 方法返回，你可以从<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactUpdateQueue.old.js#L189" target="_blank" rel="nofollow noreferrer noopener">这里</a>看到 createUpdate 的源码</p>\n</blockquote>\n<p>字段意义如下：</p>\n<ul>\n<li>eventTime：任务时间，通过 performance.now() 获取的毫秒数。由于该字段在未来会重构，当前我们不需要理解他。</li>\n<li>\n<p>lane：优先级相关字段。当前还不需要掌握他，只需要知道不同 Update 优先级可能是不同的。</p>\n<blockquote>\n<p>你可以将 lane 类比心智模型中需求的紧急程度。</p>\n</blockquote>\n</li>\n<li>suspenseConfig：Suspense 相关，暂不关注。</li>\n<li>tag：更新的类型，包括 UpdateState | ReplaceState | ForceUpdate | CaptureUpdate。</li>\n<li>payload：更新挂载的数据，不同类型组件挂载的数据不同。对于 ClassComponent，payload 为 this.setState 的第一个传参。对于 HostRoot，payload 为 ReactDOM.render 的第一个传参。</li>\n<li>callback：更新的回调函数。即在 commit 阶段的 layout 子阶段一节中提到的回调函数。</li>\n<li>next：与其他 Update 连接形成链表。</li>\n</ul>\n<h3 id="update-与-fiber-的联系"><a href="#update-%E4%B8%8E-fiber-%E7%9A%84%E8%81%94%E7%B3%BB" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Update 与 Fiber 的联系</h3>\n<p>我们发现，Update 存在一个连接其他 Update 形成链表的字段 next。联系 React 中另一种以链表形式组成的结构 Fiber，他们之间有什么关联么？</p>\n<p>答案是肯定的。</p>\n<p>从双缓存机制一节我们知道，Fiber 节点组成 Fiber 树，页面中最多同时存在两棵 Fiber 树：</p>\n<ul>\n<li>代表当前页面状态的 current Fiber 树</li>\n<li>代表正在 render 阶段的 workInProgress Fiber 树</li>\n</ul>\n<p>类似 Fiber 节点组成 Fiber 树，Fiber 节点上的多个 Update 会组成链表并被包含在 fiber.updateQueue 中。</p>\n<blockquote>\n<p>什么情况下一个 Fiber 节点会存在多个 Update？</p>\n<p>你可能疑惑为什么一个 Fiber 节点会存在多个 Update。这其实是很常见的情况。</p>\n<p>在这里介绍一种最简单的情况：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="26287486211043774000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`onClick() {\nthis.setState({\n  a: 1\n})\n\nthis.setState({\n  b: 2\n})\n}`, `26287486211043774000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token function">onClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n<span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  a<span class="token punctuation">:</span> <span class="token number">1</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n\n<span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  b<span class="token punctuation">:</span> <span class="token number">2</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>在一个 ClassComponent 中触发 this.onClick 方法，方法内部调用了两次 this.setState。这会在该 fiber 中产生两个 Update。</p>\n</blockquote>\n<p>Fiber 节点最多同时存在两个 updateQueue：</p>\n<ul>\n<li>current fiber 保存的 updateQueue 即 current updateQueue</li>\n<li>workInProgress fiber 保存的 updateQueue 即 workInProgress updateQueue</li>\n</ul>\n<p>在 commit 阶段完成页面渲染后，workInProgress Fiber 树变为 current Fiber 树，workInProgress Fiber 树内 Fiber 节点的 updateQueue 就变成 current updateQueue。</p>\n<h3 id="updatequeue"><a href="#updatequeue" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>updateQueue</h3>\n<p>updateQueue 有三种类型，其中针对 HostComponent 的类型我们在 completeWork 一节介绍过。</p>\n<p>剩下两种类型和 Update 的两种类型对应。</p>\n<p>ClassComponent 与 HostRoot 使用的 UpdateQueue 结构如下：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="2418971381523471400"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`const queue: UpdateQueue<State> = {\n  baseState: fiber.memoizedState,\n  firstBaseUpdate: null,\n  lastBaseUpdate: null,\n  shared: {\n    pending: null\n  },\n  effects: null\n};`, `2418971381523471400`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">const</span> queue<span class="token punctuation">:</span> UpdateQueue<span class="token operator">&lt;</span>State<span class="token operator">></span> <span class="token operator">=</span> <span class="token punctuation">{</span>\n  baseState<span class="token punctuation">:</span> fiber<span class="token punctuation">.</span>memoizedState<span class="token punctuation">,</span>\n  firstBaseUpdate<span class="token punctuation">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>\n  lastBaseUpdate<span class="token punctuation">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>\n  shared<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n    pending<span class="token punctuation">:</span> <span class="token keyword">null</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  effects<span class="token punctuation">:</span> <span class="token keyword">null</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<blockquote>\n<p>UpdateQueue 由 initializeUpdateQueue 方法返回，你可以从这里看到 initializeUpdateQueue 的源码</p>\n</blockquote>\n<p>字段说明如下：</p>\n<ul>\n<li>\n<p>baseState：本次更新前该 Fiber 节点的 state，Update 基于该 state 计算更新后的 state。</p>\n<blockquote>\n<p>你可以将 baseState 类比心智模型中的 master 分支。</p>\n</blockquote>\n</li>\n<li>\n<p>firstBaseUpdate 与 lastBaseUpdate：本次更新前该 Fiber 节点已保存的 Update。以链表形式存在，链表头为 firstBaseUpdate，链表尾为 lastBaseUpdate。之所以在更新产生前该 Fiber 节点内就存在 Update，是由于某些 Update 优先级较低所以在上次 render 阶段由 Update 计算 state 时被跳过。</p>\n<blockquote>\n<p>你可以将 baseUpdate 类比心智模型中执行 git rebase 基于的 commit（节点 D）。</p>\n</blockquote>\n</li>\n<li>\n<p>shared.pending：触发更新时，产生的 Update 会保存在 shared.pending 中形成单向环状链表。当由 Update 计算 state 时这个环会被剪开并连接在 lastBaseUpdate 后面。</p>\n<blockquote>\n<p>你可以将 shared.pending 类比心智模型中本次需要提交的 commit（节点 ABC）。</p>\n</blockquote>\n</li>\n<li>\n<p>effects：数组。保存 update.callback !== null 的 Update。</p>\n</li>\n</ul>\n<h3 id="例子"><a href="#%E4%BE%8B%E5%AD%90" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>例子</h3>\n<p>updateQueue 相关代码逻辑涉及到大量链表操作，比较难懂。在此我们举例对 updateQueue 的工作流程讲解下。</p>\n<p>假设有一个 fiber 刚经历 commit 阶段完成渲染。</p>\n<p>该 fiber 上有两个由于优先级过低所以在上次的 render 阶段并没有处理的 Update。他们会成为下次更新的 baseUpdate。</p>\n<p>我们称其为 u1 和 u2，其中 u1.next === u2。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="67351343092171590000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`fiber.updateQueue.firstBaseUpdate === u1;\nfiber.updateQueue.lastBaseUpdate === u2;\nu1.next === u2;`, `67351343092171590000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js">fiber<span class="token punctuation">.</span>updateQueue<span class="token punctuation">.</span>firstBaseUpdate <span class="token operator">===</span> u1<span class="token punctuation">;</span>\nfiber<span class="token punctuation">.</span>updateQueue<span class="token punctuation">.</span>lastBaseUpdate <span class="token operator">===</span> u2<span class="token punctuation">;</span>\nu1<span class="token punctuation">.</span>next <span class="token operator">===</span> u2<span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span></span></pre></div>\n<p>我们用 —> 表示链表的指向：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="86556036399080360000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`fiber.updateQueue.baseUpdate: u1 --> u2`, `86556036399080360000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js">fiber<span class="token punctuation">.</span>updateQueue<span class="token punctuation">.</span>baseUpdate<span class="token punctuation">:</span> u1 <span class="token operator">--</span><span class="token operator">></span> u2</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>现在我们在 fiber 上触发两次状态更新，这会产生两个新 Update。</p>\n<p>我们称其为 u3 和 u4。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="35481177549902500000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`fiber.updateQueue.shared.pending === u3;\nu3.next === u4;\nu4.next === u3;`, `35481177549902500000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js">fiber<span class="token punctuation">.</span>updateQueue<span class="token punctuation">.</span>shared<span class="token punctuation">.</span>pending <span class="token operator">===</span> u3<span class="token punctuation">;</span>\nu3<span class="token punctuation">.</span>next <span class="token operator">===</span> u4<span class="token punctuation">;</span>\nu4<span class="token punctuation">.</span>next <span class="token operator">===</span> u3<span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span></span></pre></div>\n<p>由于 shared.pending 是环状链表，用图表示为：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="34706864560619910000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`fiber.updateQueue.shared.pending:   u3 --> u4\n                                     ^      |\n                                     |______|`, `34706864560619910000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js">fiber<span class="token punctuation">.</span>updateQueue<span class="token punctuation">.</span>shared<span class="token punctuation">.</span>pending<span class="token punctuation">:</span>   u3 <span class="token operator">--</span><span class="token operator">></span> u4\n                                     <span class="token operator">^</span>      <span class="token operator">|</span>\n                                     <span class="token operator">|</span>______<span class="token operator">|</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span></span></pre></div>\n<p>更新调度完成后进入 render 阶段。</p>\n<p>此时 shared.pending 的环被剪开并连接在 updateQueue.lastBaseUpdate 后面：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="96526243604448220000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`fiber.updateQueue.baseUpdate: u1 --> u2 --> u3 --> u4`, `96526243604448220000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js">fiber<span class="token punctuation">.</span>updateQueue<span class="token punctuation">.</span>baseUpdate<span class="token punctuation">:</span> u1 <span class="token operator">--</span><span class="token operator">></span> u2 <span class="token operator">--</span><span class="token operator">></span> u3 <span class="token operator">--</span><span class="token operator">></span> u4</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>接下来遍历 updateQueue.baseUpdate 链表，以 fiber.updateQueue.baseState 为初始 state，依次与遍历到的每个 Update 计算并产生新的 state（该操作类比 Array.prototype.reduce）。</p>\n<p>在遍历时如果有优先级低的 Update 会被跳过。</p>\n<p>当遍历完成后获得的 state，就是该 Fiber 节点在本次更新的 state（源码中叫做 memoizedState）。</p>\n<blockquote>\n<p>render 阶段的 Update 操作由 processUpdateQueue 完成，你可以从<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactUpdateQueue.new.js#L405" target="_blank" rel="nofollow noreferrer noopener">这里</a>看到 processUpdateQueue 的源码</p>\n</blockquote>\n<p>state 的变化在 render 阶段产生与上次更新不同的 JSX 对象，通过 Diff 算法产生 effectTag，在 commit 阶段渲染在页面上。</p>\n<p>渲染完成后 workInProgress Fiber 树变为 current Fiber 树，整个更新流程结束。</p>\n<h2 id="深入理解优先级"><a href="#%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%BC%98%E5%85%88%E7%BA%A7" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>深入理解优先级</h2>\n<p>通过更新的心智模型，我们了解到更新具有优先级。</p>\n<p>那么什么是优先级？优先级以什么为依据？如何通过优先级决定哪个状态应该先被更新？</p>\n<p>本节我们会详细讲解。</p>\n<h3 id="什么是优先级"><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BC%98%E5%85%88%E7%BA%A7" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>什么是优先级</h3>\n<p>在 React 理念一节我们聊到 React 将人机交互研究的结果整合到真实的 UI 中。具体到 React 运行上这是什么意思呢？</p>\n<p>状态更新由用户交互产生，用户心里对交互执行顺序有个预期。React 根据人机交互研究的结果中用户对交互的预期顺序为交互产生的状态更新赋予不同优先级。</p>\n<p>具体如下：</p>\n<ul>\n<li>生命周期方法：同步执行。</li>\n<li>受控的用户输入：比如输入框内输入文字，同步执行。</li>\n<li>交互事件：比如动画，高优先级执行。</li>\n<li>其他：比如数据请求，低优先级执行。</li>\n</ul>\n<h3 id="如何调度优先级"><a href="#%E5%A6%82%E4%BD%95%E8%B0%83%E5%BA%A6%E4%BC%98%E5%85%88%E7%BA%A7" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>如何调度优先级</h3>\n<p>我们在新的 React 结构一节讲到，React 通过 Scheduler 调度任务。</p>\n<p>具体到代码，每当需要调度任务时，React 会调用 Scheduler 提供的方法 runWithPriority。</p>\n<p>该方法接收一个优先级常量与一个回调函数作为参数。回调函数会以优先级高低为顺序排列在一个定时器中并在合适的时间触发。</p>\n<p>对于更新来讲，传递的回调函数一般为状态更新流程概览一节讲到的 render 阶段的入口函数。</p>\n<blockquote>\n<p>你可以在 <code class="language-text">==unstable_runWithPriority==</code> <a href="https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/scheduler/src/Scheduler.js#L217" target="_blank" rel="nofollow noreferrer noopener">这里</a>看到 runWithPriority 方法的定义。在<a href="https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/scheduler/src/SchedulerPriorities.js" target="_blank" rel="nofollow noreferrer noopener">这里</a>看到 Scheduler 对优先级常量的定义。</p>\n</blockquote>\n<h3 id="例子-1"><a href="#%E4%BE%8B%E5%AD%90-1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>例子</h3>\n<p>优先级最终会反映到 update.lane 变量上。当前我们只需要知道这个变量能够区分 Update 的优先级。</p>\n<p>接下来我们通过一个例子结合上一节介绍的 Update 相关字段讲解优先级如何决定更新的顺序。</p>\n<blockquote>\n<p>该例子来自 React Core Team Andrew 向网友讲解 Update 工作流程的<a href="https://twitter.com/acdlite/status/978412930973687808" target="_blank" rel="nofollow noreferrer noopener">推文</a></p>\n</blockquote>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-02-01-11-17-25-4eaa8f94b2c9b4131bee3b82d9e67b4e-dc1fc.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 56.30914826498423%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAB40lEQVQoz11SyW7bMBTU1xborZ/QW4H8QIEeChToIY1/IQ1gO0AKtKl3y1LjpZZky1q4SBQl7qEkH4q+A5fBzDxySMe0pdtBYhHf1Uw0XNhRqg68Vk8gGj1pbZRSuitHHm54FTNhVJM8Dj9+uV8Oxv7t0HWPmeVbVivVnRM/F+v3ACAIQZIklFKnDm5hHqUZgBCTRilj0PZT5A8upckswKX5/wBaKtk3d7ptC0KM//gbjPAx2n37/uNu7H99WAZpwRnfeNswjHq5EAISzVhrasWqtVEyS9PlcnGJz10H3VnbcxgSj9b3b/bHoG8sGMHuh4aEvdgATF7+ni55UUtDhc5KBmuRNxISlhYMwJCgecF1UQtMJSIEh4MLispGtmJKa4hwBlBREiE1qurEe+GjR1jR4XA0/vlEOLdhcGUAKk+XOKmoajO3nTW7BtGV7PPNY+X57UIpIRs7dfe1edbW3bJ6sqM2bwU9WYRzXpKK2XhVxfx3KTolSU5IyaUmJS6oqQ+f4foGVgZCaAOyfCc+Tqaz2XzlPT//WiwWQRAIwbNo7q4W08l0vz8E0Wm3253PcU2R586WK/f3ZGIRG7OT5dD1fM/3t9stxhgAkOcgy4sgCOMUBGHoe14URfZL/PPc12u+AiEjZw0BynDwAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 02 01 11 17 25"\n        title=""\n        src="/static/2021-02-01-11-17-25-4eaa8f94b2c9b4131bee3b82d9e67b4e-fee1c.png"\n        srcset="/static/2021-02-01-11-17-25-4eaa8f94b2c9b4131bee3b82d9e67b4e-a67b7.png 200w,\n/static/2021-02-01-11-17-25-4eaa8f94b2c9b4131bee3b82d9e67b4e-0b187.png 400w,\n/static/2021-02-01-11-17-25-4eaa8f94b2c9b4131bee3b82d9e67b4e-fee1c.png 800w,\n/static/2021-02-01-11-17-25-4eaa8f94b2c9b4131bee3b82d9e67b4e-b1a91.png 1200w,\n/static/2021-02-01-11-17-25-4eaa8f94b2c9b4131bee3b82d9e67b4e-95179.png 1600w,\n/static/2021-02-01-11-17-25-4eaa8f94b2c9b4131bee3b82d9e67b4e-5d5ba.png 2400w,\n/static/2021-02-01-11-17-25-4eaa8f94b2c9b4131bee3b82d9e67b4e-dc1fc.png 2536w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>在这个例子中，有两个 Update。我们将“关闭黑夜模式”产生的 Update 称为 u1，输入字母 “I” 产生的 Update 称为 u2。</p>\n<p>其中 u1 先触发并进入 render 阶段。其优先级较低，执行时间较长。此时：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="67120195074414420000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`fiber.updateQueue = {\n  baseState: {\n    blackTheme: true,\n    text: \'H\'\n  },\n  firstBaseUpdate: null,\n  lastBaseUpdate: null\n  shared: {\n    pending: u1\n  },\n  effects: null\n};`, `67120195074414420000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js">fiber<span class="token punctuation">.</span>updateQueue <span class="token operator">=</span> <span class="token punctuation">{</span>\n  baseState<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n    blackTheme<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>\n    text<span class="token punctuation">:</span> <span class="token string">\'H\'</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  firstBaseUpdate<span class="token punctuation">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>\n  lastBaseUpdate<span class="token punctuation">:</span> <span class="token keyword">null</span>\n  shared<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n    pending<span class="token punctuation">:</span> u1\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  effects<span class="token punctuation">:</span> <span class="token keyword">null</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>在 u1 完成 render 阶段前用户通过键盘输入字母“I”，产生了 u2。u2 属于受控的用户输入，优先级高于 u1，于是中断 u1 产生的 render 阶段。</p>\n<p>此时：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="38088914180488320000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`fiber.updateQueue.shared.pending === u2 ----> u1\n                                     ^        |\n                                     |________|\n// 即\nu2.next === u1;\nu1.next === u2;`, `38088914180488320000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js">fiber<span class="token punctuation">.</span>updateQueue<span class="token punctuation">.</span>shared<span class="token punctuation">.</span>pending <span class="token operator">===</span> u2 <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">></span> u1\n                                     <span class="token operator">^</span>        <span class="token operator">|</span>\n                                     <span class="token operator">|</span>________<span class="token operator">|</span>\n<span class="token comment">// 即</span>\nu2<span class="token punctuation">.</span>next <span class="token operator">===</span> u1<span class="token punctuation">;</span>\nu1<span class="token punctuation">.</span>next <span class="token operator">===</span> u2<span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>其中 u2 优先级高于 u1。</p>\n<p>接下来进入 u2 产生的 render 阶段。</p>\n<p>在 processUpdateQueue 方法中，shared.pending 环状链表会被剪开并拼接在 baseUpdate 后面。</p>\n<p>需要明确一点，shared.pending 指向最后一个 pending 的 update，所以实际执行时 update 的顺序为：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="56716941361023010000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`u1 -- u2`, `56716941361023010000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js">u1 <span class="token operator">--</span> u2</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>接下来遍历 baseUpdate，处理优先级合适的 Update（这一次处理的是更高优的 u2）。</p>\n<p>由于 u2 不是 baseUpdate 中的第一个 update，在其之前的 u1 由于优先级不够被跳过。</p>\n<p>update 之间可能有依赖关系，所以被跳过的 update 及其后面所有 update 会成为下次更新的 baseUpdate。（即 u1 — u2）。</p>\n<p>最终 u2 完成 render - commit 阶段。</p>\n<p>此时：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="28442204875633558000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`fiber.updateQueue = {\n  baseState: {\n    blackTheme: true,\n    text: \'HI\'\n  },\n  firstBaseUpdate: u1,\n  lastBaseUpdate: u2\n  shared: {\n    pending: null\n  },\n  effects: null\n};`, `28442204875633558000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js">fiber<span class="token punctuation">.</span>updateQueue <span class="token operator">=</span> <span class="token punctuation">{</span>\n  baseState<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n    blackTheme<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>\n    text<span class="token punctuation">:</span> <span class="token string">\'HI\'</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  firstBaseUpdate<span class="token punctuation">:</span> u1<span class="token punctuation">,</span>\n  lastBaseUpdate<span class="token punctuation">:</span> u2\n  shared<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n    pending<span class="token punctuation">:</span> <span class="token keyword">null</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  effects<span class="token punctuation">:</span> <span class="token keyword">null</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>在 commit 阶段结尾会再调度一次更新。在该次更新中会基于 baseState 中 firstBaseUpdate 保存的 u1，开启一次新的 render 阶段。</p>\n<p>最终两次 Update 都完成后的结果如下：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="7184473397074820000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`fiber.updateQueue = {\n  baseState: {\n    blackTheme: false,\n    text: \'HI\'\n  },\n  firstBaseUpdate: null,\n  lastBaseUpdate: null\n  shared: {\n    pending: null\n  },\n  effects: null\n};`, `7184473397074820000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js">fiber<span class="token punctuation">.</span>updateQueue <span class="token operator">=</span> <span class="token punctuation">{</span>\n  baseState<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n    blackTheme<span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>\n    text<span class="token punctuation">:</span> <span class="token string">\'HI\'</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  firstBaseUpdate<span class="token punctuation">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>\n  lastBaseUpdate<span class="token punctuation">:</span> <span class="token keyword">null</span>\n  shared<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n    pending<span class="token punctuation">:</span> <span class="token keyword">null</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  effects<span class="token punctuation">:</span> <span class="token keyword">null</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>我们可以看见，u2 对应的更新执行了两次，相应的 render 阶段的生命周期勾子 componentWillXXX 也会触发两次。这也是为什么这些勾子会被标记为 unsafe_。</p>\n<h3 id="如何保证状态正确"><a href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%8A%B6%E6%80%81%E6%AD%A3%E7%A1%AE" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>如何保证状态正确</h3>\n<p>现在我们基本掌握了 updateQueue 的工作流程。还有两个疑问：</p>\n<ul>\n<li>render 阶段可能被中断。如何保证 updateQueue 中保存的 Update 不丢失？</li>\n<li>有时候当前状态需要依赖前一个状态。如何在支持跳过低优先级状态的同时保证状态依赖的连续性？</li>\n</ul>\n<p>我们分别讲解下。</p>\n<h4 id="如何保证-update-不丢失"><a href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81-update-%E4%B8%8D%E4%B8%A2%E5%A4%B1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>如何保证 Update 不丢失</h4>\n<p>在上一节例子中我们讲到，在 render 阶段，shared.pending 的环被剪开并连接在 updateQueue.lastBaseUpdate 后面。</p>\n<p>实际上 shared.pending 会被同时连接在 workInProgress updateQueue.lastBaseUpdate 与 current updateQueue.lastBaseUpdate 后面。</p>\n<blockquote>\n<p>具体代码见<a href="https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactUpdateQueue.new.js#L424" target="_blank" rel="nofollow noreferrer noopener">这里</a></p>\n</blockquote>\n<p>当 render 阶段被中断后重新开始时，会基于 current updateQueue 克隆出 workInProgress updateQueue。由于 current updateQueue.lastBaseUpdate 已经保存了上一次的 Update，所以不会丢失。</p>\n<p>当 commit 阶段完成渲染，由于 workInProgress updateQueue.lastBaseUpdate 中保存了上一次的 Update，所以 workInProgress Fiber 树变成 current Fiber 树后也不会造成 Update 丢失。</p>\n<h4 id="如何保证状态依赖的连续性"><a href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%8A%B6%E6%80%81%E4%BE%9D%E8%B5%96%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%80%A7" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>如何保证状态依赖的连续性</h4>\n<p>当某个 Update 由于优先级低而被跳过时，保存在 baseUpdate 中的不仅是该 Update，还包括链表中该 Update 之后的所有 Update。</p>\n<p>考虑如下例子：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="75386454871326130000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`baseState: \'\'\nshared.pending: A1 --> B2 --> C1 --> D2`, `75386454871326130000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js">baseState<span class="token punctuation">:</span> <span class="token string">\'\'</span>\nshared<span class="token punctuation">.</span>pending<span class="token punctuation">:</span> <span class="token constant">A1</span> <span class="token operator">--</span><span class="token operator">></span> <span class="token constant">B2</span> <span class="token operator">--</span><span class="token operator">></span> <span class="token constant">C1</span> <span class="token operator">--</span><span class="token operator">></span> <span class="token constant">D2</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span></span></pre></div>\n<p>其中字母代表该 Update 要在页面插入的字母，数字代表优先级，值越低优先级越高。</p>\n<p>第一次 render，优先级为 1。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="24635755514295845000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`baseState: \'\';\nbaseUpdate: null;\nrender阶段使用的Update: [A1, C1];\nmemoizedState: \'AC\';`, `24635755514295845000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js">baseState<span class="token punctuation">:</span> <span class="token string">\'\'</span><span class="token punctuation">;</span>\nbaseUpdate<span class="token punctuation">:</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\nrender阶段使用的Update<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token constant">A1</span><span class="token punctuation">,</span> <span class="token constant">C1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\nmemoizedState<span class="token punctuation">:</span> <span class="token string">\'AC\'</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>其中 B2 由于优先级为 2，低于当前优先级，所以他及其后面的所有 Update 会被保存在 baseUpdate 中作为下次更新的 Update（即 B2 C1 D2）。</p>\n<p>这么做是为了保持状态的前后依赖顺序。</p>\n<p>第二次 render，优先级为 2。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="75305059638152460000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`baseState: \'A\';\nbaseUpdate: B2-- > C1-- > D2;\nrender阶段使用的Update: [B2, C1, D2];\nmemoizedState: \'ABCD\';`, `75305059638152460000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js">baseState<span class="token punctuation">:</span> <span class="token string">\'A\'</span><span class="token punctuation">;</span>\nbaseUpdate<span class="token punctuation">:</span> <span class="token constant">B2</span><span class="token operator">--</span> <span class="token operator">></span> <span class="token constant">C1</span><span class="token operator">--</span> <span class="token operator">></span> <span class="token constant">D2</span><span class="token punctuation">;</span>\nrender阶段使用的Update<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token constant">B2</span><span class="token punctuation">,</span> <span class="token constant">C1</span><span class="token punctuation">,</span> <span class="token constant">D2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\nmemoizedState<span class="token punctuation">:</span> <span class="token string">\'ABCD\'</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>注意这里 baseState 并不是上一次更新的 memoizedState。这是由于 B2 被跳过了。</p>\n<p>即当有 Update 被跳过时，下次更新的 baseState !== 上次更新的 memoizedState。</p>\n<blockquote>\n<p>跳过 B2 的逻辑见<a href="https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactUpdateQueue.new.js#L479" target="_blank" rel="nofollow noreferrer noopener">这里</a></p>\n</blockquote>\n<p>通过以上例子我们可以发现，React 保证最终的状态一定和用户触发的交互一致，但是中间过程状态可能由于设备不同而不同。</p>\n<h2 id="reactdomrender"><a href="#reactdomrender" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>ReactDOM.render</h2>\n<p>经过五章的学习，我们终于回到了 React 应用的起点。</p>\n<p>这一节我们完整的走通 ReactDOM.render 完成页面渲染的整个流程。</p>\n<h3 id="创建-fiber"><a href="#%E5%88%9B%E5%BB%BA-fiber" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>创建 fiber</h3>\n<p>从<a href="https://react.iamkasong.com/process/doubleBuffer.html#mount%E6%97%B6" target="_blank" rel="nofollow noreferrer noopener">双缓存机制一节</a>我们知道，首次执行 ReactDOM.render 会创建 fiberRootNode 和 rootFiber。其中 fiberRootNode 是整个应用的根节点，rootFiber 是要渲染组件所在组件树的根节点。</p>\n<p>这一步发生在调用 ReactDOM.render 后进入的 legacyRenderSubtreeIntoContainer 方法中。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="31795307289885843000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// container 指 ReactDOM.render 的第二个参数（即应用挂载的 DOM 节点）\nroot = container._reactRootContainer = legacyCreateRootFromDOMContainer(container, forceHydrate);\nfiberRoot = root._internalRoot;`, `31795307289885843000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">// container 指 ReactDOM.render 的第二个参数（即应用挂载的 DOM 节点）</span>\nroot <span class="token operator">=</span> container<span class="token punctuation">.</span>_reactRootContainer <span class="token operator">=</span> <span class="token function">legacyCreateRootFromDOMContainer</span><span class="token punctuation">(</span>container<span class="token punctuation">,</span> forceHydrate<span class="token punctuation">)</span><span class="token punctuation">;</span>\nfiberRoot <span class="token operator">=</span> root<span class="token punctuation">.</span>_internalRoot<span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span></span></pre></div>\n<blockquote>\n<p>你可以从<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-dom/src/client/ReactDOMLegacy.js#L193" target="_blank" rel="nofollow noreferrer noopener">这里</a>看到这一步的代码</p>\n</blockquote>\n<p>legacyCreateRootFromDOMContainer 方法内部会调用 createFiberRoot 方法完成 fiberRootNode 和 rootFiber 的创建以及关联并初始化 updateQueue。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="88525707458415970000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`export function createFiberRoot(\n  containerInfo: any,\n  tag: RootTag,\n  hydrate: boolean,\n  hydrationCallbacks: null | SuspenseHydrationCallbacks\n): FiberRoot {\n  // 创建 fiberRootNode\n  const root: FiberRoot = (new FiberRootNode(containerInfo, tag, hydrate): any);\n\n  // 创建 rootFiber\n  const uninitializedFiber = createHostRootFiber(tag);\n\n  // 连接 rootFiber 与 fiberRootNode\n  root.current = uninitializedFiber;\n  uninitializedFiber.stateNode = root;\n\n  // 初始化 updateQueue\n  initializeUpdateQueue(uninitializedFiber);\n\n  return root;\n}`, `88525707458415970000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">createFiberRoot</span><span class="token punctuation">(</span>\n  <span class="token parameter">containerInfo<span class="token punctuation">:</span> any<span class="token punctuation">,</span>\n  tag<span class="token punctuation">:</span> RootTag<span class="token punctuation">,</span>\n  hydrate<span class="token punctuation">:</span> boolean<span class="token punctuation">,</span>\n  hydrationCallbacks<span class="token punctuation">:</span> <span class="token keyword">null</span> <span class="token operator">|</span> SuspenseHydrationCallbacks</span>\n<span class="token punctuation">)</span><span class="token punctuation">:</span> FiberRoot <span class="token punctuation">{</span>\n  <span class="token comment">// 创建 fiberRootNode</span>\n  <span class="token keyword">const</span> root<span class="token punctuation">:</span> FiberRoot <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FiberRootNode</span><span class="token punctuation">(</span>containerInfo<span class="token punctuation">,</span> tag<span class="token punctuation">,</span> hydrate<span class="token punctuation">)</span><span class="token punctuation">:</span> any<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token comment">// 创建 rootFiber</span>\n  <span class="token keyword">const</span> uninitializedFiber <span class="token operator">=</span> <span class="token function">createHostRootFiber</span><span class="token punctuation">(</span>tag<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token comment">// 连接 rootFiber 与 fiberRootNode</span>\n  root<span class="token punctuation">.</span>current <span class="token operator">=</span> uninitializedFiber<span class="token punctuation">;</span>\n  uninitializedFiber<span class="token punctuation">.</span>stateNode <span class="token operator">=</span> root<span class="token punctuation">;</span>\n\n  <span class="token comment">// 初始化 updateQueue</span>\n  <span class="token function">initializeUpdateQueue</span><span class="token punctuation">(</span>uninitializedFiber<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token keyword">return</span> root<span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>根据以上代码，现在我们可以在双缓存机制一节基础上补充上 rootFiber 到 fiberRootNode 的引用。</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-02-02-10-21-45-dd7cf95a74dcc5313ae8aaa4a533df5b-9f160.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 734px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 63.48773841961852%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAIAAAAmMtkJAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABC0lEQVQoz6VSi07DMAzc//8XmqbxEKIMWFvKkKbSLV3TJmmedkimgSYW0NAsK3Js3cW+eOIvsEkyC5hIIv7MJ8DaodDQdgPphg3pWsqaeHI26tGgOyL4BmOkxliQGpT12ePiajq7vruf39yGYDqbr+sP6by28NfLgVoZGBQQ7nqFh4a9Nw4DEvGkbWUkkz0VO+tMqDLl6GiF0lxSNlIq2hAAurRglJM1qeq24pIP0lFhHETGVZO/b8vVpgiurUqAcS9S6CeMtFO+Vz4IBknFT8HWgTRICMmeXh6yRV6UUumQiRrGeQ/+GxiFwbohz8sif31bllX4FWng3CUBPFZxf0X874bhl1+wnmfaJy7B+xd+on5sAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 02 02 10 21 45"\n        title=""\n        src="/static/2021-02-02-10-21-45-dd7cf95a74dcc5313ae8aaa4a533df5b-9f160.png"\n        srcset="/static/2021-02-02-10-21-45-dd7cf95a74dcc5313ae8aaa4a533df5b-6716a.png 200w,\n/static/2021-02-02-10-21-45-dd7cf95a74dcc5313ae8aaa4a533df5b-f6bb6.png 400w,\n/static/2021-02-02-10-21-45-dd7cf95a74dcc5313ae8aaa4a533df5b-9f160.png 734w"\n        sizes="(max-width: 734px) 100vw, 734px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<blockquote>\n<p>你可以从<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberRoot.new.js#L97" target="_blank" rel="nofollow noreferrer noopener">这里</a>看到这一步的代码</p>\n</blockquote>\n<h3 id="创建-update"><a href="#%E5%88%9B%E5%BB%BA-update" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>创建 update</h3>\n<p>我们已经做好了组件的初始化工作，接下来就等待创建 Update 来开启一次更新。</p>\n<p>这一步发生在 updateContainer 方法中。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="19081254272308556000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`export function updateContainer(\n  element: ReactNodeList,\n  container: OpaqueRoot,\n  parentComponent: ?React\\$Component<any, any>,\n  callback: ?Function\n): Lane {\n  // ...省略与逻辑不相关代码\n\n  // 创建 update\n  const update = createUpdate(eventTime, lane, suspenseConfig);\n\n  // update.payload 为需要挂载在根节点的组件\n  update.payload = { element };\n\n  // callback 为 ReactDOM.render 的第三个参数 —— 回调函数\n  callback = callback === undefined ? null : callback;\n  if (callback !== null) {\n    update.callback = callback;\n  }\n\n  // 将生成的 update 加入 updateQueue\n  enqueueUpdate(current, update);\n  // 调度更新\n  scheduleUpdateOnFiber(current, lane, eventTime);\n\n  // ...省略与逻辑不相关代码\n}`, `19081254272308556000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">updateContainer</span><span class="token punctuation">(</span>\n  <span class="token parameter">element<span class="token punctuation">:</span> ReactNodeList<span class="token punctuation">,</span>\n  container<span class="token punctuation">:</span> OpaqueRoot<span class="token punctuation">,</span>\n  parentComponent<span class="token punctuation">:</span> <span class="token operator">?</span>React$Component<span class="token operator">&lt;</span>any<span class="token punctuation">,</span> any<span class="token operator">></span><span class="token punctuation">,</span>\n  callback<span class="token punctuation">:</span> <span class="token operator">?</span>Function</span>\n<span class="token punctuation">)</span><span class="token punctuation">:</span> Lane <span class="token punctuation">{</span>\n  <span class="token comment">// ...省略与逻辑不相关代码</span>\n\n  <span class="token comment">// 创建 update</span>\n  <span class="token keyword">const</span> update <span class="token operator">=</span> <span class="token function">createUpdate</span><span class="token punctuation">(</span>eventTime<span class="token punctuation">,</span> lane<span class="token punctuation">,</span> suspenseConfig<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token comment">// update.payload 为需要挂载在根节点的组件</span>\n  update<span class="token punctuation">.</span>payload <span class="token operator">=</span> <span class="token punctuation">{</span> element <span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n  <span class="token comment">// callback 为 ReactDOM.render 的第三个参数 —— 回调函数</span>\n  callback <span class="token operator">=</span> callback <span class="token operator">===</span> <span class="token keyword">undefined</span> <span class="token operator">?</span> <span class="token keyword">null</span> <span class="token punctuation">:</span> callback<span class="token punctuation">;</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>callback <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    update<span class="token punctuation">.</span>callback <span class="token operator">=</span> callback<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token comment">// 将生成的 update 加入 updateQueue</span>\n  <span class="token function">enqueueUpdate</span><span class="token punctuation">(</span>current<span class="token punctuation">,</span> update<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token comment">// 调度更新</span>\n  <span class="token function">scheduleUpdateOnFiber</span><span class="token punctuation">(</span>current<span class="token punctuation">,</span> lane<span class="token punctuation">,</span> eventTime<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token comment">// ...省略与逻辑不相关代码</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<blockquote>\n<p>你可以从<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberReconciler.new.js#L255" target="_blank" rel="nofollow noreferrer noopener">这里</a>看到 updateContainer 的代码</p>\n</blockquote>\n<p>值得注意的是其中 <code class="language-text">update.payload = {element}</code>;</p>\n<p>这就是我们在 Update 一节介绍的，对于 HostRoot，payload 为 ReactDOM.render 的第一个传参。</p>\n<h3 id="流程概览-1"><a href="#%E6%B5%81%E7%A8%8B%E6%A6%82%E8%A7%88-1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>流程概览</h3>\n<p>至此，ReactDOM.render 的流程就和我们已知的流程连接上了。</p>\n<p>整个流程如下：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="64255853431490585000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`创建 fiberRootNode、rootFiber、updateQueue（\\`legacyCreateRootFromDOMContainer\\`）\n\n    |\n    |\n    v\n\n创建 Update 对象（\\`updateContainer\\`）\n\n    |\n    |\n    v\n\n从 fiber 到 root（\\`markUpdateLaneFromFiberToRoot\\`）\n\n    |\n    |\n    v\n\n调度更新（\\`ensureRootIsScheduled\\`）\n\n    |\n    |\n    v\n\nrender 阶段（\\`performSyncWorkOnRoot\\` 或 \\`performConcurrentWorkOnRoot\\`）\n\n    |\n    |\n    v\n\ncommit 阶段（\\`commitRoot\\`）`, `64255853431490585000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js">创建 fiberRootNode、rootFiber、updateQueue（<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">legacyCreateRootFromDOMContainer</span><span class="token template-punctuation string">`</span></span>）\n\n    <span class="token operator">|</span>\n    <span class="token operator">|</span>\n    v\n\n创建 Update 对象（<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">updateContainer</span><span class="token template-punctuation string">`</span></span>）\n\n    <span class="token operator">|</span>\n    <span class="token operator">|</span>\n    v\n\n从 fiber 到 root（<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">markUpdateLaneFromFiberToRoot</span><span class="token template-punctuation string">`</span></span>）\n\n    <span class="token operator">|</span>\n    <span class="token operator">|</span>\n    v\n\n调度更新（<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">ensureRootIsScheduled</span><span class="token template-punctuation string">`</span></span>）\n\n    <span class="token operator">|</span>\n    <span class="token operator">|</span>\n    v\n\nrender 阶段（<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">performSyncWorkOnRoot</span><span class="token template-punctuation string">`</span></span> 或 <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">performConcurrentWorkOnRoot</span><span class="token template-punctuation string">`</span></span>）\n\n    <span class="token operator">|</span>\n    <span class="token operator">|</span>\n    v\n\ncommit 阶段（<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">commitRoot</span><span class="token template-punctuation string">`</span></span>）</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h3 id="react-的其他入口函数"><a href="#react-%E7%9A%84%E5%85%B6%E4%BB%96%E5%85%A5%E5%8F%A3%E5%87%BD%E6%95%B0" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>React 的其他入口函数</h3>\n<p>当前 React 共有三种模式：</p>\n<ul>\n<li>legacy，这是当前 React 使用的方式。当前没有计划删除本模式，但是这个模式可能不支持一些新功能。</li>\n<li>blocking，开启部分 concurrent 模式特性的中间模式。目前正在实验中。作为迁移到 concurrent 模式的第一个步骤。</li>\n<li>concurrent，面向未来的开发模式。我们之前讲的任务中断/任务优先级都是针对 concurrent 模式。</li>\n</ul>\n<p>你可以从下表看出各种模式对特性的支持：</p>\n<table>\n<thead>\n<tr>\n<th align="center"></th>\n<th align="center">legacy 模式</th>\n<th align="center">blocking 模式</th>\n<th align="center">concurrent 模式</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align="center">String Refs</td>\n<td align="center">✅</td>\n<td align="center">🚫\n*\n*</td>\n<td align="center">🚫\n*\n*</td>\n</tr>\n<tr>\n<td align="center">Legacy Context</td>\n<td align="center">✅</td>\n<td align="center">🚫\n*\n*</td>\n<td align="center">🚫\n*\n*</td>\n</tr>\n<tr>\n<td align="center">findDOMNode</td>\n<td align="center">✅</td>\n<td align="center">🚫\n*\n*</td>\n<td align="center">🚫\n*\n*</td>\n</tr>\n<tr>\n<td align="center">Suspense</td>\n<td align="center">✅</td>\n<td align="center">✅</td>\n<td align="center">✅</td>\n</tr>\n<tr>\n<td align="center">SuspenseList</td>\n<td align="center">🚫</td>\n<td align="center">✅</td>\n<td align="center">✅</td>\n</tr>\n<tr>\n<td align="center">Suspense SSR + Hydration</td>\n<td align="center">🚫</td>\n<td align="center">✅</td>\n<td align="center">✅</td>\n</tr>\n<tr>\n<td align="center">Progressive Hydration</td>\n<td align="center">🚫</td>\n<td align="center">✅</td>\n<td align="center">✅</td>\n</tr>\n<tr>\n<td align="center">Selective Hydration</td>\n<td align="center">🚫</td>\n<td align="center">🚫</td>\n<td align="center">✅</td>\n</tr>\n<tr>\n<td align="center">Cooperative Multitasking</td>\n<td align="center">🚫</td>\n<td align="center">🚫</td>\n<td align="center">✅</td>\n</tr>\n<tr>\n<td align="center">Automatic batching of multiple setStates</td>\n<td align="center">🚫\n*</td>\n<td align="center">✅</td>\n<td align="center">✅</td>\n</tr>\n<tr>\n<td align="center">Priority-based Rendering</td>\n<td align="center">🚫</td>\n<td align="center">🚫</td>\n<td align="center">✅</td>\n</tr>\n<tr>\n<td align="center">Interruptible Prerendering</td>\n<td align="center">🚫</td>\n<td align="center">🚫</td>\n<td align="center">✅</td>\n</tr>\n<tr>\n<td align="center">useTransition</td>\n<td align="center">🚫</td>\n<td align="center">🚫</td>\n<td align="center">✅</td>\n</tr>\n<tr>\n<td align="center">useDeferredValue</td>\n<td align="center">🚫</td>\n<td align="center">🚫</td>\n<td align="center">✅</td>\n</tr>\n<tr>\n<td align="center">Suspense Reveal “Train”</td>\n<td align="center">🚫</td>\n<td align="center">🚫</td>\n<td align="center">✅</td>\n</tr>\n</tbody>\n</table>\n<p>*：legacy 模式在合成事件中有自动批处理的功能，但仅限于一个浏览器任务。非 React 事件想使用这个功能必须使用 unstable_batchedUpdates。在 blocking 模式和 concurrent 模式下，所有的 setState 在默认情况下都是批处理的。</p>\n<p>**：会在开发中发出警告。</p>\n<p>模式的变化影响整个应用的工作方式，所以无法只针对某个组件开启不同模式。</p>\n<p>基于此原因，可以通过不同的入口函数开启不同模式：</p>\n<ul>\n<li>legacy — <code class="language-text">ReactDOM.render(&lt;App /&gt;, rootNode)</code></li>\n<li>blocking — <code class="language-text">ReactDOM.createBlockingRoot(rootNode).render(&lt;App /&gt;)</code></li>\n<li>concurrent — <code class="language-text">ReactDOM.createRoot(rootNode).render(&lt;App /&gt;)</code></li>\n</ul>\n<blockquote>\n<p>你可以在<a href="https://zh-hans.reactjs.org/docs/concurrent-mode-adoption.html#why-so-many-modes" target="_blank" rel="nofollow noreferrer noopener">这里</a>看到 React 团队解释为什么会有这么多模式</p>\n</blockquote>\n<p>虽然不同模式的入口函数不同，但是他们仅对 fiber.mode 变量产生影响，对我们在流程概览中描述的流程并无影响。</p>\n<h2 id="thissetstate"><a href="#thissetstate" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>this.setState</h2>\n<p>当我们有了前面知识的铺垫，就很容易理解 this.setState 的工作流程。</p>\n<h3 id="流程概览-2"><a href="#%E6%B5%81%E7%A8%8B%E6%A6%82%E8%A7%88-2" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>流程概览</h3>\n<p>可以看到，this.setState 内会调用 this.updater.enqueueSetState 方法。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="22457715872331030000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`Component.prototype.setState = function(partialState, callback) {\n  if (!(typeof partialState === \'object\' || typeof partialState === \'function\' || partialState == null)) {\n    {\n      throw Error(\n        \'setState(...): takes an object of state variables to update or a function which returns an object of state variables.\'\n      );\n    }\n  }\n  this.updater.enqueueSetState(this, partialState, callback, \'setState\');\n};`, `22457715872331030000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token class-name">Component</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">setState</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">partialState<span class="token punctuation">,</span> callback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> partialState <span class="token operator">===</span> <span class="token string">\'object\'</span> <span class="token operator">||</span> <span class="token keyword">typeof</span> partialState <span class="token operator">===</span> <span class="token string">\'function\'</span> <span class="token operator">||</span> partialState <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token punctuation">{</span>\n      <span class="token keyword">throw</span> <span class="token function">Error</span><span class="token punctuation">(</span>\n        <span class="token string">\'setState(...): takes an object of state variables to update or a function which returns an object of state variables.\'</span>\n      <span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>updater<span class="token punctuation">.</span><span class="token function">enqueueSetState</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> partialState<span class="token punctuation">,</span> callback<span class="token punctuation">,</span> <span class="token string">\'setState\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<blockquote>\n<p>你可以在<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react/src/ReactBaseClasses.js#L57" target="_blank" rel="nofollow noreferrer noopener">这里</a>看到这段代码</p>\n</blockquote>\n<p>在 enqueueSetState 方法中就是我们熟悉的从创建 update 到调度 update 的流程了。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="18175128899308591000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`enqueueSetState(inst, payload, callback) {\n  // 通过组件实例获取对应 fiber\n  const fiber = getInstance(inst);\n\n  const eventTime = requestEventTime();\n  const suspenseConfig = requestCurrentSuspenseConfig();\n\n  // 获取优先级\n  const lane = requestUpdateLane(fiber, suspenseConfig);\n\n  // 创建 update\n  const update = createUpdate(eventTime, lane, suspenseConfig);\n\n  update.payload = payload;\n\n  // 赋值回调函数\n  if (callback !== undefined && callback !== null) {\n    update.callback = callback;\n  }\n\n  // 将 update 插入 updateQueue\n  enqueueUpdate(fiber, update);\n  // 调度 update\n  scheduleUpdateOnFiber(fiber, lane, eventTime);\n}`, `18175128899308591000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token function">enqueueSetState</span><span class="token punctuation">(</span><span class="token parameter">inst<span class="token punctuation">,</span> payload<span class="token punctuation">,</span> callback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 通过组件实例获取对应 fiber</span>\n  <span class="token keyword">const</span> fiber <span class="token operator">=</span> <span class="token function">getInstance</span><span class="token punctuation">(</span>inst<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token keyword">const</span> eventTime <span class="token operator">=</span> <span class="token function">requestEventTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">const</span> suspenseConfig <span class="token operator">=</span> <span class="token function">requestCurrentSuspenseConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token comment">// 获取优先级</span>\n  <span class="token keyword">const</span> lane <span class="token operator">=</span> <span class="token function">requestUpdateLane</span><span class="token punctuation">(</span>fiber<span class="token punctuation">,</span> suspenseConfig<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token comment">// 创建 update</span>\n  <span class="token keyword">const</span> update <span class="token operator">=</span> <span class="token function">createUpdate</span><span class="token punctuation">(</span>eventTime<span class="token punctuation">,</span> lane<span class="token punctuation">,</span> suspenseConfig<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  update<span class="token punctuation">.</span>payload <span class="token operator">=</span> payload<span class="token punctuation">;</span>\n\n  <span class="token comment">// 赋值回调函数</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>callback <span class="token operator">!==</span> <span class="token keyword">undefined</span> <span class="token operator">&amp;&amp;</span> callback <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    update<span class="token punctuation">.</span>callback <span class="token operator">=</span> callback<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token comment">// 将 update 插入 updateQueue</span>\n  <span class="token function">enqueueUpdate</span><span class="token punctuation">(</span>fiber<span class="token punctuation">,</span> update<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token comment">// 调度 update</span>\n  <span class="token function">scheduleUpdateOnFiber</span><span class="token punctuation">(</span>fiber<span class="token punctuation">,</span> lane<span class="token punctuation">,</span> eventTime<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<blockquote>\n<p>你可以在<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberClassComponent.old.js#L196" target="_blank" rel="nofollow noreferrer noopener">这里</a>看到 enqueueSetState 代码</p>\n</blockquote>\n<p>这里值得注意的是对于 ClassComponent，update.payload 为 this.setState 的第一个传参（即要改变的 state）。</p>\n<h3 id="thisforceupdate"><a href="#thisforceupdate" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>this.forceUpdate</h3>\n<p>在 this.updater 上，除了 enqueueSetState 外，还存在 enqueueForceUpdate，当我们调用 this.forceUpdate 时会调用他。</p>\n<p>可以看到，除了赋值 <code class="language-text">update.tag = ForceUpdate;</code> 以及没有 payload 外，其他逻辑与 this.setState 一致。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="78611121459721620000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`enqueueForceUpdate(inst, callback) {\n    const fiber = getInstance(inst);\n    const eventTime = requestEventTime();\n    const suspenseConfig = requestCurrentSuspenseConfig();\n    const lane = requestUpdateLane(fiber, suspenseConfig);\n\n    const update = createUpdate(eventTime, lane, suspenseConfig);\n\n    // 赋值 tag 为 ForceUpdate\n    update.tag = ForceUpdate;\n\n    if (callback !== undefined && callback !== null) {\n      update.callback = callback;\n    }\n\n    enqueueUpdate(fiber, update);\n    scheduleUpdateOnFiber(fiber, lane, eventTime);\n  },\n};`, `78611121459721620000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token function">enqueueForceUpdate</span><span class="token punctuation">(</span><span class="token parameter">inst<span class="token punctuation">,</span> callback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">const</span> fiber <span class="token operator">=</span> <span class="token function">getInstance</span><span class="token punctuation">(</span>inst<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">const</span> eventTime <span class="token operator">=</span> <span class="token function">requestEventTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">const</span> suspenseConfig <span class="token operator">=</span> <span class="token function">requestCurrentSuspenseConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">const</span> lane <span class="token operator">=</span> <span class="token function">requestUpdateLane</span><span class="token punctuation">(</span>fiber<span class="token punctuation">,</span> suspenseConfig<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    <span class="token keyword">const</span> update <span class="token operator">=</span> <span class="token function">createUpdate</span><span class="token punctuation">(</span>eventTime<span class="token punctuation">,</span> lane<span class="token punctuation">,</span> suspenseConfig<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    <span class="token comment">// 赋值 tag 为 ForceUpdate</span>\n    update<span class="token punctuation">.</span>tag <span class="token operator">=</span> ForceUpdate<span class="token punctuation">;</span>\n\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>callback <span class="token operator">!==</span> <span class="token keyword">undefined</span> <span class="token operator">&amp;&amp;</span> callback <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      update<span class="token punctuation">.</span>callback <span class="token operator">=</span> callback<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token function">enqueueUpdate</span><span class="token punctuation">(</span>fiber<span class="token punctuation">,</span> update<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token function">scheduleUpdateOnFiber</span><span class="token punctuation">(</span>fiber<span class="token punctuation">,</span> lane<span class="token punctuation">,</span> eventTime<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<blockquote>\n<p>你可以在<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberClassComponent.old.js#L260" target="_blank" rel="nofollow noreferrer noopener">这里</a>看到 enqueueForceUpdate 代码</p>\n</blockquote>\n<p>那么赋值 <code class="language-text">update.tag = ForceUpdate;</code> 有何作用呢？</p>\n<p>在判断 ClassComponent 是否需要更新时有两个条件需要满足：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="67671669046944880000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`const shouldUpdate =\n  checkHasForceUpdateAfterProcessing() ||\n  checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext);`, `67671669046944880000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">const</span> shouldUpdate <span class="token operator">=</span>\n  <span class="token function">checkHasForceUpdateAfterProcessing</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span>\n  <span class="token function">checkShouldComponentUpdate</span><span class="token punctuation">(</span>workInProgress<span class="token punctuation">,</span> ctor<span class="token punctuation">,</span> oldProps<span class="token punctuation">,</span> newProps<span class="token punctuation">,</span> oldState<span class="token punctuation">,</span> newState<span class="token punctuation">,</span> nextContext<span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span></span></pre></div>\n<blockquote>\n<p>你可以在<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberClassComponent.old.js#L1137" target="_blank" rel="nofollow noreferrer noopener">这里</a>看到这段代码</p>\n</blockquote>\n<ul>\n<li>checkHasForceUpdateAfterProcessing：内部会判断本次更新的 Update 是否为 ForceUpdate。即如果本次更新的 Update 中存在 tag 为 ForceUpdate，则返回 true。</li>\n<li>checkShouldComponentUpdate：内部会调用 shouldComponentUpdate 方法。以及当该 ClassComponent 为 PureComponent 时会浅比较 state 与 props。</li>\n</ul>\n<blockquote>\n<p>你可以在<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberClassComponent.old.js#L294" target="_blank" rel="nofollow noreferrer noopener">这里</a>看到 checkShouldComponentUpdate 代码</p>\n</blockquote>\n<p>所以，当某次更新含有 tag 为 ForceUpdate 的 Update，那么当前 ClassComponent 不会受其他性能优化手段（shouldComponentUpdate|PureComponent）影响，一定会更新。</p>\n<h3 id="总结-1"><a href="#%E6%80%BB%E7%BB%93-1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总结</h3>\n<p>至此，我们学习完了 <code class="language-text">HostRoot | ClassComponent</code> 所使用的 Update 的更新流程。</p>\n<p>在下一章我们会学习另一种数据结构的 Update —— 用于 Hooks 的 Update。</p>\n<h1 id="hooks"><a href="#hooks" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Hooks</h1>\n<h2 id="hooks-理念"><a href="#hooks-%E7%90%86%E5%BF%B5" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Hooks 理念</h2>\n<p>你可以从<a href="https://zh-hans.reactjs.org/docs/hooks-intro.html#motivation" target="_blank" rel="nofollow noreferrer noopener">这里</a>了解 Hooks 的设计动机。作为一名框架使用者，了解设计动机对于我们日常开发就足够了。</p>\n<p>但是，为了更好的理解 Hooks 的源码架构，我们需要转换身份，以框架开发者的角度来看待 Hooks 的设计理念。</p>\n<h3 id="从-logo-聊起"><a href="#%E4%BB%8E-logo-%E8%81%8A%E8%B5%B7" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>从 LOGO 聊起</h3>\n<p>React LOGO 的图案是代表原子（atom）的符号。世间万物由原子组成，原子的类型与属性决定了事物的外观与表现。</p>\n<p>同样，在 React 中，我们可以将 UI 拆分为很多独立的单元，每个单元被称为 Component。这些 Component 的属性与类型决定了 UI 的外观与表现。</p>\n<p>讽刺的是，原子在希腊语中的意思为不可分割的（indivisible），但随后科学家在原子中发现了更小的粒子 —— 电子（electron）。电子可以很好的解释原子是如何工作的。</p>\n<p>在 React 中，我们可以说 ClassComponent 是一类原子。</p>\n<p>但对于 Hooks 来说，与其说是一类原子，不如说他是更贴近事物运行规律的电子。</p>\n<p>我们知道，React 的架构遵循 schedule - render - commit 的运行流程，这个流程是 React 世界最底层的运行规律。</p>\n<p>ClassComponent 作为 React 世界的原子，他的生命周期（componentWillXXX/componentDidXXX）是为了介入 React 的运行流程而实现的更上层抽象，这么做是为了方便框架使用者更容易上手。</p>\n<p>相比于 ClassComponent 的更上层抽象，Hooks 则更贴近 React 内部运行的各种概念（state | context | life-cycle）。</p>\n<p>作为使用 React 技术栈的开发者，当我们初次学习 Hooks 时，不管是官方文档还是身边有经验的同事，总会拿 ClassComponent 的生命周期来类比 Hooks API 的执行时机。</p>\n<p>这固然是很好的上手方式，但是当我们熟练运用 Hooks 时，就会发现，这两者的概念有很多割裂感，并不是同一抽象层次可以互相替代的概念。</p>\n<p>比如：替代 componentWillReceiveProps 的 Hooks 是什么呢？</p>\n<p>可能有些同学会回答，是 useEffect：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="39592522209201865000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`useEffect(() => {\n  console.log(\'something updated\');\n}, [props.something]);`, `39592522209201865000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'something updated\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>props<span class="token punctuation">.</span>something<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span></span></pre></div>\n<p>但是 componentWillReceiveProps 是在 render 阶段执行，而 useEffect 是在 commit 阶段完成渲染后异步执行。</p>\n<blockquote>\n<p>这篇文章可以帮你更好理解 componentWillReceiveProps：<a href="https://juejin.im/post/5f05a3e25188252e5c576cdb" target="_blank" rel="nofollow noreferrer noopener">深入源码剖析 componentWillXXX 为什么 UNSAFE</a></p>\n</blockquote>\n<p>所以，从源码运行规律的角度看待 Hooks，可能是更好的角度。这也是为什么上文说 Hooks 是 React 世界的电子而不是原子的原因。</p>\n<blockquote>\n<p>以上见解参考自<a href="https://www.youtube.com/watch?v=dpw9EHDh2bM&#x26;feature=youtu.be" target="_blank" rel="nofollow noreferrer noopener">React Core Team Dan 在 React Conf2018 的演讲</a></p>\n</blockquote>\n<h3 id="总结-2"><a href="#%E6%80%BB%E7%BB%93-2" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总结</h3>\n<p>Concurrent Mode 是 React 未来的发展方向，而 Hooks 是能够最大限度发挥 Concurrent Mode 潜力的 Component 构建方式。</p>\n<p>正如 Dan 在 React Conf 2018 演讲结尾所说：你可以从 React 的 LOGO 中看到这些围绕着核心的电子飞行轨道，Hooks 可能一直就在其中。</p>\n<h2 id="极简-hooks-实现"><a href="#%E6%9E%81%E7%AE%80-hooks-%E5%AE%9E%E7%8E%B0" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>极简 Hooks 实现</h2>\n<p>为了更好理解 Hooks 原理，这一节我们遵循 React 的运行流程，实现一个不到 100 行代码的极简 useState Hook。建议对照着代码来看本节内容。</p>\n<h3 id="工作原理"><a href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>工作原理</h3>\n<p>对于 useState Hook，考虑如下例子：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="4151562821346877000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function App() {\n  const [num, updateNum] = useState(0);\n\n  return <p onClick={() => updateNum((num) => num + 1)}>{num}</p>;\n}`, `4151562821346877000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> <span class="token punctuation">[</span>num<span class="token punctuation">,</span> updateNum<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token keyword">return</span> <span class="token operator">&lt;</span>p onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">updateNum</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">num</span><span class="token punctuation">)</span> <span class="token operator">=></span> num <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">></span><span class="token punctuation">{</span>num<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">></span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>可以将工作分为两部分：</p>\n<ol>\n<li>通过一些途径产生更新，更新会造成组件 render。</li>\n<li>组件 render 时 useState 返回的 num 为更新后的结果。</li>\n</ol>\n<p>其中步骤 1 的更新可以分为 mount 和 update：</p>\n<ol>\n<li>调用 ReactDOM.render 会产生 mount 的更新，更新内容为 useState 的 initialValue（即 0）。</li>\n<li>点击 p 标签触发 updateNum 会产生一次 update 的更新，更新内容为 num => num + 1。</li>\n</ol>\n<p>接下来讲解这两个步骤如何实现。</p>\n<h3 id="更新是什么"><a href="#%E6%9B%B4%E6%96%B0%E6%98%AF%E4%BB%80%E4%B9%88" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>更新是什么</h3>\n<blockquote>\n<p>通过一些途径产生更新，更新会造成组件 render。</p>\n</blockquote>\n<p>首先我们要明确更新是什么。</p>\n<p>在我们的极简例子中，更新就是如下数据结构：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="72813344068472150000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`const update = {\n  // 更新执行的函数\n  action,\n  // 与同一个 Hook 的其他更新形成链表\n  next: null\n};`, `72813344068472150000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">const</span> update <span class="token operator">=</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 更新执行的函数</span>\n  action<span class="token punctuation">,</span>\n  <span class="token comment">// 与同一个 Hook 的其他更新形成链表</span>\n  next<span class="token punctuation">:</span> <span class="token keyword">null</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>对于 App 来说，点击 p 标签产生的 update 的 action 为 num => num + 1。</p>\n<p>如果我们改写下 App 的 onClick：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="55788184640088965000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// 之前\nreturn <p onClick={() => updateNum((num) => num + 1)}>{num}</p>;\n\n// 之后\nreturn (\n  <p\n    onClick={() => {\n      updateNum((num) => num + 1);\n      updateNum((num) => num + 1);\n      updateNum((num) => num + 1);\n    }}\n  >\n    {num}\n  </p>\n);`, `55788184640088965000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">// 之前</span>\n<span class="token keyword">return</span> <span class="token operator">&lt;</span>p onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">updateNum</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">num</span><span class="token punctuation">)</span> <span class="token operator">=></span> num <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">></span><span class="token punctuation">{</span>num<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">></span><span class="token punctuation">;</span>\n\n<span class="token comment">// 之后</span>\n<span class="token keyword">return</span> <span class="token punctuation">(</span>\n  <span class="token operator">&lt;</span>p\n    onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n      <span class="token function">updateNum</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">num</span><span class="token punctuation">)</span> <span class="token operator">=></span> num <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token function">updateNum</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">num</span><span class="token punctuation">)</span> <span class="token operator">=></span> num <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token function">updateNum</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">num</span><span class="token punctuation">)</span> <span class="token operator">=></span> num <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span><span class="token punctuation">}</span>\n  <span class="token operator">></span>\n    <span class="token punctuation">{</span>num<span class="token punctuation">}</span>\n  <span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">></span>\n<span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>那么点击 p 标签会产生三个 update。</p>\n<h3 id="update-数据结构"><a href="#update-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>update 数据结构</h3>\n<p>这些 update 是如何组合在一起呢？</p>\n<p>答案是：他们会形成环状单向链表。</p>\n<p>调用 updateNum 实际调用的是 <code class="language-text">dispatchAction.bind(null, hook.queue)</code>，我们先来了解下这个函数：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="97717198297515970000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function dispatchAction(queue, action) {\n  // 创建 update\n  const update = {\n    action,\n    next: null\n  };\n\n  // 环状单向链表操作\n  if (queue.pending === null) {\n    update.next = update;\n  } else {\n    update.next = queue.pending.next;\n    queue.pending.next = update;\n  }\n  queue.pending = update;\n\n  // 模拟 React 开始调度更新\n  schedule();\n}`, `97717198297515970000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span> <span class="token function">dispatchAction</span><span class="token punctuation">(</span><span class="token parameter">queue<span class="token punctuation">,</span> action</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 创建 update</span>\n  <span class="token keyword">const</span> update <span class="token operator">=</span> <span class="token punctuation">{</span>\n    action<span class="token punctuation">,</span>\n    next<span class="token punctuation">:</span> <span class="token keyword">null</span>\n  <span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n  <span class="token comment">// 环状单向链表操作</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>queue<span class="token punctuation">.</span>pending <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    update<span class="token punctuation">.</span>next <span class="token operator">=</span> update<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n    update<span class="token punctuation">.</span>next <span class="token operator">=</span> queue<span class="token punctuation">.</span>pending<span class="token punctuation">.</span>next<span class="token punctuation">;</span>\n    queue<span class="token punctuation">.</span>pending<span class="token punctuation">.</span>next <span class="token operator">=</span> update<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  queue<span class="token punctuation">.</span>pending <span class="token operator">=</span> update<span class="token punctuation">;</span>\n\n  <span class="token comment">// 模拟 React 开始调度更新</span>\n  <span class="token function">schedule</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>环状链表操作不太容易理解，这里我们详细讲解下。</p>\n<p>当产生第一个 update（我们叫他 u0），此时 <code class="language-text">queue.pending === null</code>。</p>\n<p><code class="language-text">update.next = update;</code> 即 <code class="language-text">u0.next = u0</code>，他会和自己首尾相连形成单向环状链表。</p>\n<p>然后 <code class="language-text">queue.pending = update;</code> 即 <code class="language-text">queue.pending = u0</code></p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="65026983603423070000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`queue.pending = u0 ---> u0\n                ^       |\n                |       |\n                ---------`, `65026983603423070000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js">queue<span class="token punctuation">.</span>pending <span class="token operator">=</span> u0 <span class="token operator">--</span><span class="token operator">-</span><span class="token operator">></span> u0\n                <span class="token operator">^</span>       <span class="token operator">|</span>\n                <span class="token operator">|</span>       <span class="token operator">|</span>\n                <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>当产生第二个 update（我们叫他 u1），<code class="language-text">update.next = queue.pending.next;</code>，此时 <code class="language-text">queue.pending.next === u0</code>，即 <code class="language-text">u1.next = u0</code>。</p>\n<p><code class="language-text">queue.pending.next = update;</code> 即 <code class="language-text">u0.next = u1</code>。</p>\n<p>然后 <code class="language-text">queue.pending = update;</code> 即 <code class="language-text">queue.pending = u1</code></p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="76918344048973820000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`queue.pending = u1 ---> u0\n                ^       |\n                |       |\n                ---------`, `76918344048973820000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js">queue<span class="token punctuation">.</span>pending <span class="token operator">=</span> u1 <span class="token operator">--</span><span class="token operator">-</span><span class="token operator">></span> u0\n                <span class="token operator">^</span>       <span class="token operator">|</span>\n                <span class="token operator">|</span>       <span class="token operator">|</span>\n                <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>你可以照着这个例子模拟插入多个 update 的情况，会发现 queue.pending 始终指向最后一个插入的 update。</p>\n<p>这样做的好处是，当我们要遍历 update 时，queue.pending.next 指向第一个插入的 update。</p>\n<h3 id="状态如何保存"><a href="#%E7%8A%B6%E6%80%81%E5%A6%82%E4%BD%95%E4%BF%9D%E5%AD%98" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>状态如何保存</h3>\n<p>现在我们知道，更新产生的 update 对象会保存在 queue 中。</p>\n<p>不同于 ClassComponent 的实例可以存储数据，对于 FunctionComponent，queue 存储在哪里呢？</p>\n<p>答案是：FunctionComponent 对应的 fiber 中。</p>\n<p>我们使用如下精简的 fiber 结构：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="97372512347178250000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// App 组件对应的 fiber 对象\nconst fiber = {\n  // 保存该 FunctionComponent 对应的 Hooks 链表\n  memoizedState: null,\n  // 指向 App 函数\n  stateNode: App\n};`, `97372512347178250000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">// App 组件对应的 fiber 对象</span>\n<span class="token keyword">const</span> fiber <span class="token operator">=</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 保存该 FunctionComponent 对应的 Hooks 链表</span>\n  memoizedState<span class="token punctuation">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>\n  <span class="token comment">// 指向 App 函数</span>\n  stateNode<span class="token punctuation">:</span> App\n<span class="token punctuation">}</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h3 id="hook-数据结构"><a href="#hook-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Hook 数据结构</h3>\n<p>接下来我们关注 fiber.memoizedState 中保存的 Hook 的数据结构。</p>\n<p>可以看到，Hook 与 update 类似，都通过链表连接。不过 Hook 是无环的单向链表。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="93052807654906870000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`hook = {\n  // 保存 update 的 queue，即上文介绍的 queue\n  queue: {\n    pending: null\n  },\n  // 保存 hook 对应的 state\n  memoizedState: initialState,\n  // 与下一个 Hook 连接形成单向无环链表\n  next: null\n};`, `93052807654906870000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js">hook <span class="token operator">=</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 保存 update 的 queue，即上文介绍的 queue</span>\n  queue<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n    pending<span class="token punctuation">:</span> <span class="token keyword">null</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token comment">// 保存 hook 对应的 state</span>\n  memoizedState<span class="token punctuation">:</span> initialState<span class="token punctuation">,</span>\n  <span class="token comment">// 与下一个 Hook 连接形成单向无环链表</span>\n  next<span class="token punctuation">:</span> <span class="token keyword">null</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<blockquote>\n<p>注意</p>\n<p>注意区分 update 与 hook 的所属关系：</p>\n<p>每个 useState 对应一个 hook 对象。</p>\n<p>调用 <code class="language-text">const [num, updateNum] = useState(0);</code> 时 updateNum（即上文介绍的 dispatchAction）产生的 update 保存在 useState 对应的 hook.queue 中。</p>\n</blockquote>\n<h3 id="模拟-react-调度更新流程"><a href="#%E6%A8%A1%E6%8B%9F-react-%E8%B0%83%E5%BA%A6%E6%9B%B4%E6%96%B0%E6%B5%81%E7%A8%8B" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>模拟 React 调度更新流程</h3>\n<p>在上文 dispatchAction 末尾我们通过 schedule 方法模拟 React 调度更新流程。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="76039812861605540000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function dispatchAction(queue, action) {\n  // ...创建 update\n\n  // ...环状单向链表操作\n\n  // 模拟 React 开始调度更新\n  schedule();\n}`, `76039812861605540000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span> <span class="token function">dispatchAction</span><span class="token punctuation">(</span><span class="token parameter">queue<span class="token punctuation">,</span> action</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// ...创建 update</span>\n\n  <span class="token comment">// ...环状单向链表操作</span>\n\n  <span class="token comment">// 模拟 React 开始调度更新</span>\n  <span class="token function">schedule</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>现在我们来实现他。</p>\n<p>我们用 isMount 变量指代是 mount 还是 update。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="53676478070806490000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// 首次 render 时是 mount\nisMount = true;\n\nfunction schedule() {\n  // 更新前将 workInProgressHook 重置为 fiber 保存的第一个 Hook\n  workInProgressHook = fiber.memoizedState;\n  // 触发组件 render\n  fiber.stateNode();\n  // 组件首次 render 为 mount，以后再触发的更新为 update\n  isMount = false;\n}`, `53676478070806490000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">// 首次 render 时是 mount</span>\nisMount <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n\n<span class="token keyword">function</span> <span class="token function">schedule</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 更新前将 workInProgressHook 重置为 fiber 保存的第一个 Hook</span>\n  workInProgressHook <span class="token operator">=</span> fiber<span class="token punctuation">.</span>memoizedState<span class="token punctuation">;</span>\n  <span class="token comment">// 触发组件 render</span>\n  fiber<span class="token punctuation">.</span><span class="token function">stateNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token comment">// 组件首次 render 为 mount，以后再触发的更新为 update</span>\n  isMount <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>通过 workInProgressHook 变量指向当前正在工作的 hook。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="75453817937124560000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`workInProgressHook = fiber.memoizedState;`, `75453817937124560000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js">workInProgressHook <span class="token operator">=</span> fiber<span class="token punctuation">.</span>memoizedState<span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>在组件 render 时，每当遇到下一个 useState，我们移动 workInProgressHook 的指针。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="46318808115160360000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`workInProgressHook = workInProgressHook.next;`, `46318808115160360000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js">workInProgressHook <span class="token operator">=</span> workInProgressHook<span class="token punctuation">.</span>next<span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>这样，只要每次组件 render 时 useState 的调用顺序及数量保持一致，那么始终可以通过 workInProgressHook 找到当前 useState 对应的 hook 对象。</p>\n<p>到此为止，我们已经完成第一步。</p>\n<blockquote>\n<p>通过一些途径产生更新，更新会造成组件 render。</p>\n</blockquote>\n<p>接下来实现第二步。</p>\n<blockquote>\n<p>组件 render 时 useState 返回的 num 为更新后的结果。</p>\n</blockquote>\n<h3 id="计算-state"><a href="#%E8%AE%A1%E7%AE%97-state" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>计算 state</h3>\n<p>组件 render 时会调用 useState，他的大体逻辑如下：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="92808483030094800000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function useState(initialState) {\n  // 当前 useState 使用的 hook 会被赋值该该变量\n  let hook;\n\n  if (isMount) {\n    // ...mount 时需要生成 hook 对象\n  } else {\n    // ...update 时从 workInProgressHook 中取出该 useState 对应的 hook\n  }\n\n  let baseState = hook.memoizedState;\n  if (hook.queue.pending) {\n    // ...根据 queue.pending 中保存的 update 更新 state\n  }\n  hook.memoizedState = baseState;\n\n  return [baseState, dispatchAction.bind(null, hook.queue)];\n}`, `92808483030094800000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token parameter">initialState</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 当前 useState 使用的 hook 会被赋值该该变量</span>\n  <span class="token keyword">let</span> hook<span class="token punctuation">;</span>\n\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>isMount<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// ...mount 时需要生成 hook 对象</span>\n  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n    <span class="token comment">// ...update 时从 workInProgressHook 中取出该 useState 对应的 hook</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token keyword">let</span> baseState <span class="token operator">=</span> hook<span class="token punctuation">.</span>memoizedState<span class="token punctuation">;</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>hook<span class="token punctuation">.</span>queue<span class="token punctuation">.</span>pending<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// ...根据 queue.pending 中保存的 update 更新 state</span>\n  <span class="token punctuation">}</span>\n  hook<span class="token punctuation">.</span>memoizedState <span class="token operator">=</span> baseState<span class="token punctuation">;</span>\n\n  <span class="token keyword">return</span> <span class="token punctuation">[</span>baseState<span class="token punctuation">,</span> <span class="token function">dispatchAction</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> hook<span class="token punctuation">.</span>queue<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>我们首先关注如何获取 hook 对象：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="45444154672472890000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`if (isMount) {\n  // mount 时为该 useState 生成 hook\n  hook = {\n    queue: {\n      pending: null\n    },\n    memoizedState: initialState,\n    next: null\n  };\n\n  // 将 hook 插入 fiber.memoizedState 链表末尾\n  if (!fiber.memoizedState) {\n    fiber.memoizedState = hook;\n  } else {\n    workInProgressHook.next = hook;\n  }\n  // 移动 workInProgressHook 指针\n  workInProgressHook = hook;\n} else {\n  // update 时找到对应 hook\n  hook = workInProgressHook;\n  // 移动 workInProgressHook 指针\n  workInProgressHook = workInProgressHook.next;\n}`, `45444154672472890000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">if</span> <span class="token punctuation">(</span>isMount<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// mount 时为该 useState 生成 hook</span>\n  hook <span class="token operator">=</span> <span class="token punctuation">{</span>\n    queue<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n      pending<span class="token punctuation">:</span> <span class="token keyword">null</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n    memoizedState<span class="token punctuation">:</span> initialState<span class="token punctuation">,</span>\n    next<span class="token punctuation">:</span> <span class="token keyword">null</span>\n  <span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n  <span class="token comment">// 将 hook 插入 fiber.memoizedState 链表末尾</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>fiber<span class="token punctuation">.</span>memoizedState<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    fiber<span class="token punctuation">.</span>memoizedState <span class="token operator">=</span> hook<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n    workInProgressHook<span class="token punctuation">.</span>next <span class="token operator">=</span> hook<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token comment">// 移动 workInProgressHook 指针</span>\n  workInProgressHook <span class="token operator">=</span> hook<span class="token punctuation">;</span>\n<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n  <span class="token comment">// update 时找到对应 hook</span>\n  hook <span class="token operator">=</span> workInProgressHook<span class="token punctuation">;</span>\n  <span class="token comment">// 移动 workInProgressHook 指针</span>\n  workInProgressHook <span class="token operator">=</span> workInProgressHook<span class="token punctuation">.</span>next<span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>当找到该 useState 对应的 hook 后，如果该 hook.queue.pending 不为空（即存在 update），则更新其 state。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="22693928311277834000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// update 执行前的初始 state\nlet baseState = hook.memoizedState;\n\nif (hook.queue.pending) {\n  // 获取 update 环状单向链表中第一个 update\n  let firstUpdate = hook.queue.pending.next;\n\n  do {\n    // 执行 update action\n    const action = firstUpdate.action;\n    baseState = action(baseState);\n    firstUpdate = firstUpdate.next;\n\n    // 最后一个 update 执行完后跳出循环\n  } while (firstUpdate !== hook.queue.pending.next);\n\n  // 清空 queue.pending\n  hook.queue.pending = null;\n}\n\n// 将 update action 执行完后的 state 作为 memoizedState\nhook.memoizedState = baseState;`, `22693928311277834000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">// update 执行前的初始 state</span>\n<span class="token keyword">let</span> baseState <span class="token operator">=</span> hook<span class="token punctuation">.</span>memoizedState<span class="token punctuation">;</span>\n\n<span class="token keyword">if</span> <span class="token punctuation">(</span>hook<span class="token punctuation">.</span>queue<span class="token punctuation">.</span>pending<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 获取 update 环状单向链表中第一个 update</span>\n  <span class="token keyword">let</span> firstUpdate <span class="token operator">=</span> hook<span class="token punctuation">.</span>queue<span class="token punctuation">.</span>pending<span class="token punctuation">.</span>next<span class="token punctuation">;</span>\n\n  <span class="token keyword">do</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 执行 update action</span>\n    <span class="token keyword">const</span> action <span class="token operator">=</span> firstUpdate<span class="token punctuation">.</span>action<span class="token punctuation">;</span>\n    baseState <span class="token operator">=</span> <span class="token function">action</span><span class="token punctuation">(</span>baseState<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    firstUpdate <span class="token operator">=</span> firstUpdate<span class="token punctuation">.</span>next<span class="token punctuation">;</span>\n\n    <span class="token comment">// 最后一个 update 执行完后跳出循环</span>\n  <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>firstUpdate <span class="token operator">!==</span> hook<span class="token punctuation">.</span>queue<span class="token punctuation">.</span>pending<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token comment">// 清空 queue.pending</span>\n  hook<span class="token punctuation">.</span>queue<span class="token punctuation">.</span>pending <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// 将 update action 执行完后的 state 作为 memoizedState</span>\nhook<span class="token punctuation">.</span>memoizedState <span class="token operator">=</span> baseState<span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>完整代码如下：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="37199993480038780000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function useState(initialState) {\n  let hook;\n\n  if (isMount) {\n    hook = {\n      queue: {\n        pending: null\n      },\n      memoizedState: initialState,\n      next: null\n    };\n    if (!fiber.memoizedState) {\n      fiber.memoizedState = hook;\n    } else {\n      workInProgressHook.next = hook;\n    }\n    workInProgressHook = hook;\n  } else {\n    hook = workInProgressHook;\n    workInProgressHook = workInProgressHook.next;\n  }\n\n  let baseState = hook.memoizedState;\n  if (hook.queue.pending) {\n    let firstUpdate = hook.queue.pending.next;\n\n    do {\n      const action = firstUpdate.action;\n      baseState = action(baseState);\n      firstUpdate = firstUpdate.next;\n    } while (firstUpdate !== hook.queue.pending);\n\n    hook.queue.pending = null;\n  }\n  hook.memoizedState = baseState;\n\n  return [baseState, dispatchAction.bind(null, hook.queue)];\n}`, `37199993480038780000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token parameter">initialState</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">let</span> hook<span class="token punctuation">;</span>\n\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>isMount<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    hook <span class="token operator">=</span> <span class="token punctuation">{</span>\n      queue<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n        pending<span class="token punctuation">:</span> <span class="token keyword">null</span>\n      <span class="token punctuation">}</span><span class="token punctuation">,</span>\n      memoizedState<span class="token punctuation">:</span> initialState<span class="token punctuation">,</span>\n      next<span class="token punctuation">:</span> <span class="token keyword">null</span>\n    <span class="token punctuation">}</span><span class="token punctuation">;</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>fiber<span class="token punctuation">.</span>memoizedState<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      fiber<span class="token punctuation">.</span>memoizedState <span class="token operator">=</span> hook<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n      workInProgressHook<span class="token punctuation">.</span>next <span class="token operator">=</span> hook<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n    workInProgressHook <span class="token operator">=</span> hook<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n    hook <span class="token operator">=</span> workInProgressHook<span class="token punctuation">;</span>\n    workInProgressHook <span class="token operator">=</span> workInProgressHook<span class="token punctuation">.</span>next<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token keyword">let</span> baseState <span class="token operator">=</span> hook<span class="token punctuation">.</span>memoizedState<span class="token punctuation">;</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>hook<span class="token punctuation">.</span>queue<span class="token punctuation">.</span>pending<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">let</span> firstUpdate <span class="token operator">=</span> hook<span class="token punctuation">.</span>queue<span class="token punctuation">.</span>pending<span class="token punctuation">.</span>next<span class="token punctuation">;</span>\n\n    <span class="token keyword">do</span> <span class="token punctuation">{</span>\n      <span class="token keyword">const</span> action <span class="token operator">=</span> firstUpdate<span class="token punctuation">.</span>action<span class="token punctuation">;</span>\n      baseState <span class="token operator">=</span> <span class="token function">action</span><span class="token punctuation">(</span>baseState<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      firstUpdate <span class="token operator">=</span> firstUpdate<span class="token punctuation">.</span>next<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>firstUpdate <span class="token operator">!==</span> hook<span class="token punctuation">.</span>queue<span class="token punctuation">.</span>pending<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    hook<span class="token punctuation">.</span>queue<span class="token punctuation">.</span>pending <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  hook<span class="token punctuation">.</span>memoizedState <span class="token operator">=</span> baseState<span class="token punctuation">;</span>\n\n  <span class="token keyword">return</span> <span class="token punctuation">[</span>baseState<span class="token punctuation">,</span> <span class="token function">dispatchAction</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> hook<span class="token punctuation">.</span>queue<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h3 id="对触发事件进行抽象"><a href="#%E5%AF%B9%E8%A7%A6%E5%8F%91%E4%BA%8B%E4%BB%B6%E8%BF%9B%E8%A1%8C%E6%8A%BD%E8%B1%A1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>对触发事件进行抽象</h3>\n<p>最后，让我们抽象一下 React 的事件触发方式</p>\n<p>通过调用 App 返回的 click 方法模拟组件 click 的行为。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="86664587914494660000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function App() {\n  const [num, updateNum] = useState(0);\n\n  console.log(\\`\\${isMount ? \'mount\' : \'update\'} num: \\`, num);\n\n  return {\n    click() {\n      updateNum((num) => num + 1);\n    }\n  };\n}`, `86664587914494660000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> <span class="token punctuation">[</span>num<span class="token punctuation">,</span> updateNum<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>isMount <span class="token operator">?</span> <span class="token string">\'mount\'</span> <span class="token punctuation">:</span> <span class="token string">\'update\'</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> num: </span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token keyword">return</span> <span class="token punctuation">{</span>\n    <span class="token function">click</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token function">updateNum</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">num</span><span class="token punctuation">)</span> <span class="token operator">=></span> num <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h3 id="在线-demo"><a href="#%E5%9C%A8%E7%BA%BF-demo" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>在线 Demo</h3>\n<p>至此，我们完成了一个不到 100 行代码的 Hooks。重要的是，他与 React 的运行逻辑相同。</p>\n<div>\n          <div\n            class="gatsby-resp-iframe-wrapper"\n            style="padding-bottom: 25%; position: relative; height: 0; overflow: hidden;margin-bottom: 2em"\n          >\n            <iframe src="/examples/react-technology-notes-realization/use-state-demo.html" style="\n            position: absolute;\n            top: 0;\n            left: 0;\n            width: 100%;\n            height: 100%;\n          "></iframe>\n          </div>\n          </div>\n<p><div class="gatsby-highlight">\n        <pre class="language-html"><code><span class="token doctype">&lt;!DOCTYPE html></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>utf-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>width=device-width<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>JS Bin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>btn1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>加1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>btn2<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>加3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>console<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">\n    <span class="token keyword">let</span> workInProgressHook<span class="token punctuation">;</span>\n    <span class="token comment">// 首次 render 时是 mount</span>\n    <span class="token keyword">let</span> isMount <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n\n    <span class="token comment">// App 组件对应的 fiber 对象</span>\n    <span class="token keyword">const</span> fiber <span class="token operator">=</span> <span class="token punctuation">{</span>\n      <span class="token comment">// 保存该 FunctionComponent 对应的 Hooks 链表</span>\n      memoizedState<span class="token punctuation">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>\n      <span class="token comment">// 指向 App 函数</span>\n      stateNode<span class="token punctuation">:</span> App\n    <span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n    <span class="token keyword">function</span> <span class="token function">schedule</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token comment">// 更新前将 workInProgressHook 重置为 fiber 保存的第一个 Hook</span>\n      workInProgressHook <span class="token operator">=</span> fiber<span class="token punctuation">.</span>memoizedState<span class="token punctuation">;</span>\n      <span class="token comment">// 触发组件 render</span>\n      <span class="token keyword">const</span> app <span class="token operator">=</span> fiber<span class="token punctuation">.</span><span class="token function">stateNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token comment">// 组件首次 render 为 mount，以后再触发的更新为 update</span>\n      isMount <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>\n      <span class="token keyword">return</span> app<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token keyword">function</span> <span class="token function">dispatchAction</span><span class="token punctuation">(</span><span class="token parameter">queue<span class="token punctuation">,</span> action</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token comment">// 创建 update</span>\n      <span class="token keyword">const</span> update <span class="token operator">=</span> <span class="token punctuation">{</span>\n        action<span class="token punctuation">,</span>\n        next<span class="token punctuation">:</span> <span class="token keyword">null</span>\n      <span class="token punctuation">}</span>\n      <span class="token comment">// 环状单向链表操作</span>\n      <span class="token keyword">if</span> <span class="token punctuation">(</span>queue<span class="token punctuation">.</span>pending <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        update<span class="token punctuation">.</span>next <span class="token operator">=</span> update<span class="token punctuation">;</span>\n      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n        update<span class="token punctuation">.</span>next <span class="token operator">=</span> queue<span class="token punctuation">.</span>pending<span class="token punctuation">.</span>next<span class="token punctuation">;</span>\n        queue<span class="token punctuation">.</span>pending<span class="token punctuation">.</span>next <span class="token operator">=</span> update<span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n      <span class="token comment">// 模拟 React 开始调度更新</span>\n      queue<span class="token punctuation">.</span>pending <span class="token operator">=</span> update<span class="token punctuation">;</span>\n\n      <span class="token function">schedule</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token keyword">function</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token parameter">initialState</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token comment">// 当前 useState 使用的 hook 会被赋值该变量</span>\n      <span class="token keyword">let</span> hook<span class="token punctuation">;</span>\n\n      <span class="token keyword">if</span> <span class="token punctuation">(</span>isMount<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token comment">// mount 时需要生成 hook 对象</span>\n        hook <span class="token operator">=</span> <span class="token punctuation">{</span>\n          <span class="token comment">// 保存 update 的 queue，即上文介绍的 queue</span>\n          queue<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n            pending<span class="token punctuation">:</span> <span class="token keyword">null</span>\n          <span class="token punctuation">}</span><span class="token punctuation">,</span>\n          <span class="token comment">// 保存 hook 对应的 state</span>\n          memoizedState<span class="token punctuation">:</span> initialState<span class="token punctuation">,</span>\n          <span class="token comment">// 与下一个 Hook 连接形成单向无环链表</span>\n          next<span class="token punctuation">:</span> <span class="token keyword">null</span>\n        <span class="token punctuation">}</span>\n        <span class="token comment">// 将 hook 插入 fiber.memoizedState 链表末尾</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>fiber<span class="token punctuation">.</span>memoizedState<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n          fiber<span class="token punctuation">.</span>memoizedState <span class="token operator">=</span> hook<span class="token punctuation">;</span>\n        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n          workInProgressHook<span class="token punctuation">.</span>next <span class="token operator">=</span> hook<span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n        <span class="token comment">// 移动 workInProgressHook 指针</span>\n        workInProgressHook <span class="token operator">=</span> hook<span class="token punctuation">;</span>\n      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n        <span class="token comment">// update 时从 workInProgressHook 中取出该 useState 对应的 hook</span>\n        hook <span class="token operator">=</span> workInProgressHook<span class="token punctuation">;</span>\n        <span class="token comment">// 移动 workInProgressHook 指针</span>\n        workInProgressHook <span class="token operator">=</span> workInProgressHook<span class="token punctuation">.</span>next<span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n\n      <span class="token keyword">let</span> baseState <span class="token operator">=</span> hook<span class="token punctuation">.</span>memoizedState<span class="token punctuation">;</span>\n      <span class="token keyword">if</span> <span class="token punctuation">(</span>hook<span class="token punctuation">.</span>queue<span class="token punctuation">.</span>pending<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token comment">// 根据 queue.pending 中保存的 update 更新 state</span>\n        <span class="token comment">// 获取 update 环状单向链表中第一个 update</span>\n        <span class="token keyword">let</span> firstUpdate <span class="token operator">=</span> hook<span class="token punctuation">.</span>queue<span class="token punctuation">.</span>pending<span class="token punctuation">.</span>next<span class="token punctuation">;</span>\n        <span class="token keyword">do</span> <span class="token punctuation">{</span>\n          <span class="token comment">// 执行 update action</span>\n          <span class="token keyword">const</span> action <span class="token operator">=</span> firstUpdate<span class="token punctuation">.</span>action<span class="token punctuation">;</span>\n          baseState <span class="token operator">=</span> <span class="token function">action</span><span class="token punctuation">(</span>baseState<span class="token punctuation">)</span><span class="token punctuation">;</span>\n          firstUpdate <span class="token operator">=</span> firstUpdate<span class="token punctuation">.</span>next<span class="token punctuation">;</span>\n\n          <span class="token comment">// 最后一个 update 执行完后跳出循环</span>\n        <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>firstUpdate <span class="token operator">!==</span> hook<span class="token punctuation">.</span>queue<span class="token punctuation">.</span>pending<span class="token punctuation">)</span>\n\n        <span class="token comment">// 清空 queue.pending</span>\n        hook<span class="token punctuation">.</span>queue<span class="token punctuation">.</span>pending <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n      <span class="token comment">// 将 update action 执行完后的 state 作为 memoizedState</span>\n      hook<span class="token punctuation">.</span>memoizedState <span class="token operator">=</span> baseState<span class="token punctuation">;</span>\n\n      <span class="token keyword">return</span> <span class="token punctuation">[</span>baseState<span class="token punctuation">,</span> <span class="token function">dispatchAction</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> hook<span class="token punctuation">.</span>queue<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">const</span> <span class="token punctuation">[</span>num<span class="token punctuation">,</span> updateNum<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token keyword">const</span> consoleDOM <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">\'#console\'</span><span class="token punctuation">)</span>\n      <span class="token keyword">const</span> textDOM <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createRange</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">createContextualFragment</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&lt;div></span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>isMount <span class="token operator">?</span> <span class="token string">\'mount\'</span> <span class="token punctuation">:</span> <span class="token string">\'update\'</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> num: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>num<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">&lt;/div></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      consoleDOM<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>textDOM<span class="token punctuation">)</span>\n\n      <span class="token keyword">return</span> <span class="token punctuation">{</span>\n        <span class="token function">clickOne</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n          <span class="token function">updateNum</span><span class="token punctuation">(</span><span class="token parameter">num</span> <span class="token operator">=></span> num <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span><span class="token punctuation">,</span>\n        <span class="token function">clickThree</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n          <span class="token function">updateNum</span><span class="token punctuation">(</span><span class="token parameter">num</span> <span class="token operator">=></span> num <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n      <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n\n    window<span class="token punctuation">.</span>app <span class="token operator">=</span> <span class="token function">schedule</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">\'#btn1\'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">\'click\'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n      window<span class="token punctuation">.</span>app<span class="token punctuation">.</span><span class="token function">clickOne</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span>\n\n    document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">\'#btn2\'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">\'click\'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n      window<span class="token punctuation">.</span>app<span class="token punctuation">.</span><span class="token function">clickThree</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span>\n  </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code></pre>\n        </div></p>\n<h3 id="与-react-的区别"><a href="#%E4%B8%8E-react-%E7%9A%84%E5%8C%BA%E5%88%AB" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>与 React 的区别</h3>\n<p>我们用尽可能少的代码模拟了 Hooks 的运行，但是相比 React Hooks，他还有很多不足。以下是他与 React Hooks 的区别：</p>\n<ol>\n<li>React Hooks 没有使用 isMount 变量，而是在不同时机使用不同的 dispatcher。换言之，mount 时的 useState 与 update 时的 useState 不是同一个函数。</li>\n<li>React Hooks 有中途跳过更新的优化手段。</li>\n<li>React Hooks 有 batchedUpdates，当在 click 中触发三次 updateNum，精简 React 会触发三次更新，而 React 只会触发一次。</li>\n<li>React Hooks 的 update 有优先级概念，可以跳过不高优先的 update。</li>\n</ol>\n<p>更多的细节，我们会在本章后续小节讲解。</p>\n<h2 id="hooks-数据结构"><a href="#hooks-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Hooks 数据结构</h2>\n<p>在上一节我们实现了一个极简的 useState，了解了 Hooks 的运行原理。</p>\n<p>本节我们讲解 Hooks 的数据结构，为后面介绍具体的 hook 打下基础。</p>\n<h3 id="dispatcher"><a href="#dispatcher" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>dispatcher</h3>\n<p>在上一节的极简 useState 实现中，使用 isMount 变量区分 mount 与 update。</p>\n<p>在真实的 Hooks 中，组件 mount 时的 hook 与 update 时的 hook 来源于不同的对象，这类对象在源码中被称为 dispatcher。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="16194064829074172000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// mount 时的 Dispatcher\nconst HooksDispatcherOnMount: Dispatcher = {\n  useCallback: mountCallback,\n  useContext: readContext,\n  useEffect: mountEffect,\n  useImperativeHandle: mountImperativeHandle,\n  useLayoutEffect: mountLayoutEffect,\n  useMemo: mountMemo,\n  useReducer: mountReducer,\n  useRef: mountRef,\n  useState: mountState\n  // ...省略\n};\n\n// update 时的 Dispatcher\nconst HooksDispatcherOnUpdate: Dispatcher = {\n  useCallback: updateCallback,\n  useContext: readContext,\n  useEffect: updateEffect,\n  useImperativeHandle: updateImperativeHandle,\n  useLayoutEffect: updateLayoutEffect,\n  useMemo: updateMemo,\n  useReducer: updateReducer,\n  useRef: updateRef,\n  useState: updateState\n  // ...省略\n};`, `16194064829074172000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">// mount 时的 Dispatcher</span>\n<span class="token keyword">const</span> HooksDispatcherOnMount<span class="token punctuation">:</span> Dispatcher <span class="token operator">=</span> <span class="token punctuation">{</span>\n  useCallback<span class="token punctuation">:</span> mountCallback<span class="token punctuation">,</span>\n  useContext<span class="token punctuation">:</span> readContext<span class="token punctuation">,</span>\n  useEffect<span class="token punctuation">:</span> mountEffect<span class="token punctuation">,</span>\n  useImperativeHandle<span class="token punctuation">:</span> mountImperativeHandle<span class="token punctuation">,</span>\n  useLayoutEffect<span class="token punctuation">:</span> mountLayoutEffect<span class="token punctuation">,</span>\n  useMemo<span class="token punctuation">:</span> mountMemo<span class="token punctuation">,</span>\n  useReducer<span class="token punctuation">:</span> mountReducer<span class="token punctuation">,</span>\n  useRef<span class="token punctuation">:</span> mountRef<span class="token punctuation">,</span>\n  useState<span class="token punctuation">:</span> mountState\n  <span class="token comment">// ...省略</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n<span class="token comment">// update 时的 Dispatcher</span>\n<span class="token keyword">const</span> HooksDispatcherOnUpdate<span class="token punctuation">:</span> Dispatcher <span class="token operator">=</span> <span class="token punctuation">{</span>\n  useCallback<span class="token punctuation">:</span> updateCallback<span class="token punctuation">,</span>\n  useContext<span class="token punctuation">:</span> readContext<span class="token punctuation">,</span>\n  useEffect<span class="token punctuation">:</span> updateEffect<span class="token punctuation">,</span>\n  useImperativeHandle<span class="token punctuation">:</span> updateImperativeHandle<span class="token punctuation">,</span>\n  useLayoutEffect<span class="token punctuation">:</span> updateLayoutEffect<span class="token punctuation">,</span>\n  useMemo<span class="token punctuation">:</span> updateMemo<span class="token punctuation">,</span>\n  useReducer<span class="token punctuation">:</span> updateReducer<span class="token punctuation">,</span>\n  useRef<span class="token punctuation">:</span> updateRef<span class="token punctuation">,</span>\n  useState<span class="token punctuation">:</span> updateState\n  <span class="token comment">// ...省略</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>可见，mount 时调用的 hook 和 update 时调用的 hook 其实是两个不同的函数。</p>\n<p>在 FunctionComponent render 前，会根据 FunctionComponent 对应 fiber 的以下条件区分 mount 与 update。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="8564406187207218000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`current === null || current.memoizedState === null;`, `8564406187207218000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js">current <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">||</span> current<span class="token punctuation">.</span>memoizedState <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>并将不同情况对应的 dispatcher 赋值给全局变量 ReactCurrentDispatcher 的 current 属性。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="5024053361365666000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`ReactCurrentDispatcher.current =\n  current === null || current.memoizedState === null ? HooksDispatcherOnMount : HooksDispatcherOnUpdate;`, `5024053361365666000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js">ReactCurrentDispatcher<span class="token punctuation">.</span>current <span class="token operator">=</span>\n  current <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">||</span> current<span class="token punctuation">.</span>memoizedState <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">?</span> HooksDispatcherOnMount <span class="token punctuation">:</span> HooksDispatcherOnUpdate<span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span></span></pre></div>\n<blockquote>\n<p>你可以在<a href="https://github.com/acdlite/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberHooks.new.js#L409" target="_blank" rel="nofollow noreferrer noopener">这里</a>看到这行代码</p>\n</blockquote>\n<p>在 FunctionComponent render 时，会从 ReactCurrentDispatcher.current（即当前 dispatcher）中寻找需要的 hook。</p>\n<p>换言之，不同的调用栈上下文为 ReactCurrentDispatcher.current 赋值不同的 dispatcher，则 FunctionComponent render 时调用的 hook 也是不同的函数。</p>\n<blockquote>\n<p>除了这两个 dispatcher，你可以在<a href="https://github.com/acdlite/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberHooks.new.js#L1775" target="_blank" rel="nofollow noreferrer noopener">这里</a>看到其他 dispatcher 定义</p>\n</blockquote>\n<h3 id="一个-dispatcher-使用场景"><a href="#%E4%B8%80%E4%B8%AA-dispatcher-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>一个 dispatcher 使用场景</h3>\n<p>当错误的书写了嵌套形式的 hook，如：</p>\n<p>此时 ReactCurrentDispatcher.current 已经指向 ContextOnlyDispatcher，所以调用 useState 实际会调用 throwInvalidHookError，直接抛出异常。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="55740160083886070000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`export const ContextOnlyDispatcher: Dispatcher = {\n  useCallback: throwInvalidHookError,\n  useContext: throwInvalidHookError,\n  useEffect: throwInvalidHookError,\n  useImperativeHandle: throwInvalidHookError,\n  useLayoutEffect: throwInvalidHookError,\n  // ...省略`, `55740160083886070000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">export</span> <span class="token keyword">const</span> ContextOnlyDispatcher<span class="token punctuation">:</span> Dispatcher <span class="token operator">=</span> <span class="token punctuation">{</span>\n  useCallback<span class="token punctuation">:</span> throwInvalidHookError<span class="token punctuation">,</span>\n  useContext<span class="token punctuation">:</span> throwInvalidHookError<span class="token punctuation">,</span>\n  useEffect<span class="token punctuation">:</span> throwInvalidHookError<span class="token punctuation">,</span>\n  useImperativeHandle<span class="token punctuation">:</span> throwInvalidHookError<span class="token punctuation">,</span>\n  useLayoutEffect<span class="token punctuation">:</span> throwInvalidHookError<span class="token punctuation">,</span>\n  <span class="token comment">// ...省略</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>你可以在<a href="https://github.com/acdlite/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberHooks.new.js#L458" target="_blank" rel="nofollow noreferrer noopener">这里</a>看到这段逻辑</p>\n<h3 id="hook-的数据结构"><a href="#hook-%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Hook 的数据结构</h3>\n<p>接下来我们学习 hook 的数据结构。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="1061040147749725600"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`const hook: Hook = {\n  memoizedState: null,\n\n  baseState: null,\n  baseQueue: null,\n  queue: null,\n\n  next: null\n};`, `1061040147749725600`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">const</span> hook<span class="token punctuation">:</span> Hook <span class="token operator">=</span> <span class="token punctuation">{</span>\n  memoizedState<span class="token punctuation">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>\n\n  baseState<span class="token punctuation">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>\n  baseQueue<span class="token punctuation">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>\n  queue<span class="token punctuation">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>\n\n  next<span class="token punctuation">:</span> <span class="token keyword">null</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<blockquote>\n<p>你可以在<a href="https://github.com/acdlite/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberHooks.new.js#L546" target="_blank" rel="nofollow noreferrer noopener">这里</a>看到创建 hook 的逻辑</p>\n</blockquote>\n<p>其中除 memoizedState 以外字段的意义与上一章介绍的 updateQueue 类似。</p>\n<h3 id="memoizedstate"><a href="#memoizedstate" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>memoizedState</h3>\n<p>hook 与 FunctionComponent fiber 都存在 memoizedState 属性，不要混淆他们的概念。</p>\n<p>fiber.memoizedState：FunctionComponent 对应 fiber 保存的 Hooks 链表。</p>\n<p>hook.memoizedState：Hooks 链表中保存的单一 hook 对应的数据。</p>\n<p>不同类型 hook 的 memoizedState 保存不同类型数据，具体如下：</p>\n<ul>\n<li>useState：对于 <code class="language-text">const [state, updateState] = useState(initialState)</code>，memoizedState 保存 state 的值</li>\n<li>useReducer：对于 <code class="language-text">const [state, dispatch] = useReducer(reducer, {});</code>，memoizedState 保存 state 的值</li>\n<li>useEffect：memoizedState 保存包含 useEffect 回调函数、依赖项等的链表数据结构 effect，你可以在<a href="https://github.com/acdlite/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberHooks.new.js#L1181" target="_blank" rel="nofollow noreferrer noopener">这里</a>看到 effect 的创建过程。effect 链表同时会保存在 fiber.updateQueue 中</li>\n<li>useRef：对于 useRef(1)，memoizedState 保存 <code class="language-text">{current: 1}</code></li>\n<li>useMemo：对于 <code class="language-text">useMemo(callback, [depA])</code>，memoizedState 保存[ <code class="language-text">[callback(), depA]</code></li>\n<li>useCallback：对于 <code class="language-text">useCallback(callback, [depA])</code>，memoizedState 保存 <code class="language-text">[callback, depA]</code>。与 useMemo 的区别是，useCallback 保存的是 callback 函数本身，而 useMemo 保存的是 callback 函数的执行结果</li>\n</ul>\n<p>有些 hook 是没有 memoizedState 的，比如：</p>\n<ul>\n<li>useContext</li>\n</ul>\n<h2 id="usestate-与-usereducer"><a href="#usestate-%E4%B8%8E-usereducer" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>useState 与 useReducer</h2>\n<p>Redux 的作者 Dan 加入 React 核心团队后的一大贡献就是“将 Redux 的理念带入 React”。</p>\n<p>这里面最显而易见的影响莫过于 useState 与 useReducer 这两个 Hook。本质来说，useState 只是预置了 reducer 的 useReducer。</p>\n<p>本节我们来学习 useState 与 useReducer 的实现。</p>\n<h3 id="流程概览-3"><a href="#%E6%B5%81%E7%A8%8B%E6%A6%82%E8%A7%88-3" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>流程概览</h3>\n<p>我们将这两个 Hook 的工作流程分为声明阶段和调用阶段，对于：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="3907041833868629500"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function App() {\n  const [state, dispatch] = useReducer(reducer, { a: 1 });\n\n  const [num, updateNum] = useState(0);\n\n  return (\n    <div>\n      <button onClick={() => dispatch({ type: \'a\' })}>{state.a}</button>\n      <button onClick={() => updateNum((num) => num + 1)}>{num}</button>\n    </div>\n  );\n}`, `3907041833868629500`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> <span class="token punctuation">[</span>state<span class="token punctuation">,</span> dispatch<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useReducer</span><span class="token punctuation">(</span>reducer<span class="token punctuation">,</span> <span class="token punctuation">{</span> a<span class="token punctuation">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token keyword">const</span> <span class="token punctuation">[</span>num<span class="token punctuation">,</span> updateNum<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token keyword">return</span> <span class="token punctuation">(</span>\n    <span class="token operator">&lt;</span>div<span class="token operator">></span>\n      <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token punctuation">{</span> type<span class="token punctuation">:</span> <span class="token string">\'a\'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">></span><span class="token punctuation">{</span>state<span class="token punctuation">.</span>a<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span>\n      <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">updateNum</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">num</span><span class="token punctuation">)</span> <span class="token operator">=></span> num <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">></span><span class="token punctuation">{</span>num<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span>\n    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>\n  <span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>声明阶段即 App 调用时，会依次执行 useReducer 与 useState 方法。</p>\n<p>调用阶段即点击按钮后，dispatch 或 updateNum 被调用时。</p>\n<h3 id="声明阶段"><a href="#%E5%A3%B0%E6%98%8E%E9%98%B6%E6%AE%B5" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>声明阶段</h3>\n<p>当 FunctionComponent 进入 render 阶段的 beginWork 时，会调用 <a href="https://github.com/acdlite/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberBeginWork.new.js#L1419" target="_blank" rel="nofollow noreferrer noopener">renderWithHooks</a> 方法。</p>\n<p>该方法内部会执行 FunctionComponent 对应函数（即 fiber.type）。</p>\n<p>你可以在 <a href="https://github.com/acdlite/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberHooks.new.js#L415" target="_blank" rel="nofollow noreferrer noopener">这里</a> 看到这段逻辑</p>\n<p>对于这两个 Hook，他们的源码如下：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="39619977858761340000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function useState(initialState) {\n  var dispatcher = resolveDispatcher();\n  return dispatcher.useState(initialState);\n}\nfunction useReducer(reducer, initialArg, init) {\n  var dispatcher = resolveDispatcher();\n  return dispatcher.useReducer(reducer, initialArg, init);\n}`, `39619977858761340000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token parameter">initialState</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">var</span> dispatcher <span class="token operator">=</span> <span class="token function">resolveDispatcher</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">return</span> dispatcher<span class="token punctuation">.</span><span class="token function">useState</span><span class="token punctuation">(</span>initialState<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">function</span> <span class="token function">useReducer</span><span class="token punctuation">(</span><span class="token parameter">reducer<span class="token punctuation">,</span> initialArg<span class="token punctuation">,</span> init</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">var</span> dispatcher <span class="token operator">=</span> <span class="token function">resolveDispatcher</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">return</span> dispatcher<span class="token punctuation">.</span><span class="token function">useReducer</span><span class="token punctuation">(</span>reducer<span class="token punctuation">,</span> initialArg<span class="token punctuation">,</span> init<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>正如上一节 <a href="https://react.iamkasong.com/hooks/structure.html#dispatcher" target="_blank" rel="nofollow noreferrer noopener">dispatcher</a> 所说，在不同场景下，同一个 Hook 会调用不同处理函数。</p>\n<p>我们分别讲解 mount 与 update 两个场景。</p>\n<h4 id="mount-时"><a href="#mount-%E6%97%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>mount 时</h4>\n<p>mount 时，useReducer 会调用 <a href="https://github.com/acdlite/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberHooks.new.js#L638" target="_blank" rel="nofollow noreferrer noopener">mountReducer</a>，useState 会调用 <a href="https://github.com/acdlite/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberHooks.new.js#L1143" target="_blank" rel="nofollow noreferrer noopener">mountState</a>。</p>\n<p>我们来简单对比这这两个方法：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="62458208032464445000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function mountState<S>(initialState: (() => S) | S): [S, Dispatch<BasicStateAction<S>>] {\n  // 创建并返回当前的 hook\n  const hook = mountWorkInProgressHook();\n\n  // ...赋值初始 state\n\n  // 创建 queue\n  const queue = (hook.queue = {\n    pending: null,\n    dispatch: null,\n    lastRenderedReducer: basicStateReducer,\n    lastRenderedState: (initialState: any)\n  });\n\n  // ...创建 dispatch\n  return [hook.memoizedState, dispatch];\n}\n\nfunction mountReducer<S, I, A>(reducer: (S, A) => S, initialArg: I, init?: (I) => S): [S, Dispatch<A>] {\n  // 创建并返回当前的 hook\n  const hook = mountWorkInProgressHook();\n\n  // ...赋值初始 state\n\n  // 创建 queue\n  const queue = (hook.queue = {\n    pending: null,\n    dispatch: null,\n    lastRenderedReducer: reducer,\n    lastRenderedState: (initialState: any)\n  });\n\n  // ...创建 dispatch\n  return [hook.memoizedState, dispatch];\n}`, `62458208032464445000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span> mountState<span class="token operator">&lt;</span><span class="token constant">S</span><span class="token operator">></span><span class="token punctuation">(</span>initialState<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token constant">S</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token constant">S</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token constant">S</span><span class="token punctuation">,</span> Dispatch<span class="token operator">&lt;</span>BasicStateAction<span class="token operator">&lt;</span><span class="token constant">S</span><span class="token operator">>></span><span class="token punctuation">]</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 创建并返回当前的 hook</span>\n  <span class="token keyword">const</span> hook <span class="token operator">=</span> <span class="token function">mountWorkInProgressHook</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token comment">// ...赋值初始 state</span>\n\n  <span class="token comment">// 创建 queue</span>\n  <span class="token keyword">const</span> queue <span class="token operator">=</span> <span class="token punctuation">(</span>hook<span class="token punctuation">.</span>queue <span class="token operator">=</span> <span class="token punctuation">{</span>\n    pending<span class="token punctuation">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>\n    dispatch<span class="token punctuation">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>\n    lastRenderedReducer<span class="token punctuation">:</span> basicStateReducer<span class="token punctuation">,</span>\n    lastRenderedState<span class="token punctuation">:</span> <span class="token punctuation">(</span>initialState<span class="token punctuation">:</span> any<span class="token punctuation">)</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token comment">// ...创建 dispatch</span>\n  <span class="token keyword">return</span> <span class="token punctuation">[</span>hook<span class="token punctuation">.</span>memoizedState<span class="token punctuation">,</span> dispatch<span class="token punctuation">]</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">function</span> mountReducer<span class="token operator">&lt;</span><span class="token constant">S</span><span class="token punctuation">,</span> <span class="token constant">I</span><span class="token punctuation">,</span> <span class="token constant">A</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token function-variable function">reducer</span><span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token constant">S</span><span class="token punctuation">,</span> <span class="token constant">A</span></span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token constant">S</span><span class="token punctuation">,</span> initialArg<span class="token punctuation">:</span> <span class="token constant">I</span><span class="token punctuation">,</span> init<span class="token operator">?</span><span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token constant">I</span></span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token constant">S</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token constant">S</span><span class="token punctuation">,</span> Dispatch<span class="token operator">&lt;</span><span class="token constant">A</span><span class="token operator">></span><span class="token punctuation">]</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 创建并返回当前的 hook</span>\n  <span class="token keyword">const</span> hook <span class="token operator">=</span> <span class="token function">mountWorkInProgressHook</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token comment">// ...赋值初始 state</span>\n\n  <span class="token comment">// 创建 queue</span>\n  <span class="token keyword">const</span> queue <span class="token operator">=</span> <span class="token punctuation">(</span>hook<span class="token punctuation">.</span>queue <span class="token operator">=</span> <span class="token punctuation">{</span>\n    pending<span class="token punctuation">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>\n    dispatch<span class="token punctuation">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>\n    lastRenderedReducer<span class="token punctuation">:</span> reducer<span class="token punctuation">,</span>\n    lastRenderedState<span class="token punctuation">:</span> <span class="token punctuation">(</span>initialState<span class="token punctuation">:</span> any<span class="token punctuation">)</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token comment">// ...创建 dispatch</span>\n  <span class="token keyword">return</span> <span class="token punctuation">[</span>hook<span class="token punctuation">.</span>memoizedState<span class="token punctuation">,</span> dispatch<span class="token punctuation">]</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>其中 mountWorkInProgressHook 方法会创建并返回对应 hook，对应极简 Hooks 实现中 useState 方法的 isMount 逻辑部分。</p>\n<p>可以看到，mount 时这两个 Hook 的唯一区别为 queue 参数的 lastRenderedReducer 字段。</p>\n<p>queue 的数据结构如下：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="17271713179095527000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`const queue = (hook.queue = {\n  // 与极简实现中的同名字段意义相同，保存 update 对象\n  pending: null,\n  // 保存 dispatchAction.bind() 的值\n  dispatch: null,\n  // 上一次 render 时使用的 reducer\n  lastRenderedReducer: reducer,\n  // 上一次 render 时的 state\n  lastRenderedState: (initialState: any)\n});`, `17271713179095527000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">const</span> queue <span class="token operator">=</span> <span class="token punctuation">(</span>hook<span class="token punctuation">.</span>queue <span class="token operator">=</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 与极简实现中的同名字段意义相同，保存 update 对象</span>\n  pending<span class="token punctuation">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>\n  <span class="token comment">// 保存 dispatchAction.bind() 的值</span>\n  dispatch<span class="token punctuation">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>\n  <span class="token comment">// 上一次 render 时使用的 reducer</span>\n  lastRenderedReducer<span class="token punctuation">:</span> reducer<span class="token punctuation">,</span>\n  <span class="token comment">// 上一次 render 时的 state</span>\n  lastRenderedState<span class="token punctuation">:</span> <span class="token punctuation">(</span>initialState<span class="token punctuation">:</span> any<span class="token punctuation">)</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>其中，useReducer 的 lastRenderedReducer 为传入的 reducer 参数。useState 的 lastRenderedReducer 为 basicStateReducer。</p>\n<p>basicStateReducer 方法如下：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="53311753281812080000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function basicStateReducer<S>(state: S, action: BasicStateAction<S>): S {\n  return typeof action === \'function\' ? action(state) : action;\n}`, `53311753281812080000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span> basicStateReducer<span class="token operator">&lt;</span><span class="token constant">S</span><span class="token operator">></span><span class="token punctuation">(</span>state<span class="token punctuation">:</span> <span class="token constant">S</span><span class="token punctuation">,</span> action<span class="token punctuation">:</span> BasicStateAction<span class="token operator">&lt;</span><span class="token constant">S</span><span class="token operator">></span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token constant">S</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token keyword">typeof</span> action <span class="token operator">===</span> <span class="token string">\'function\'</span> <span class="token operator">?</span> <span class="token function">action</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span> <span class="token punctuation">:</span> action<span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span></span></pre></div>\n<p>可见，useState 即 reducer 参数为 basicStateReducer 的 useReducer。</p>\n<p>mount 时的整体运行逻辑与极简实现的 isMount 逻辑类似，你可以对照着看。</p>\n<h4 id="update-时"><a href="#update-%E6%97%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>update 时</h4>\n<p>如果说 mount 时这两者还有区别，那 update 时，useReducer 与 useState 调用的则是同一个函数 <a href="https://github.com/acdlite/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberHooks.new.js#L665" target="_blank" rel="nofollow noreferrer noopener">updateReducer</a>。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="56122908599443180000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function updateReducer<S, I, A>(reducer: (S, A) => S, initialArg: I, init?: (I) => S): [S, Dispatch<A>] {\n  // 获取当前 hook\n  const hook = updateWorkInProgressHook();\n  const queue = hook.queue;\n\n  queue.lastRenderedReducer = reducer;\n\n  // ...同 update 与 updateQueue 类似的更新逻辑\n\n  const dispatch: Dispatch<A> = (queue.dispatch: any);\n  return [hook.memoizedState, dispatch];\n}`, `56122908599443180000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span> updateReducer<span class="token operator">&lt;</span><span class="token constant">S</span><span class="token punctuation">,</span> <span class="token constant">I</span><span class="token punctuation">,</span> <span class="token constant">A</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token function-variable function">reducer</span><span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token constant">S</span><span class="token punctuation">,</span> <span class="token constant">A</span></span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token constant">S</span><span class="token punctuation">,</span> initialArg<span class="token punctuation">:</span> <span class="token constant">I</span><span class="token punctuation">,</span> init<span class="token operator">?</span><span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token constant">I</span></span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token constant">S</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token constant">S</span><span class="token punctuation">,</span> Dispatch<span class="token operator">&lt;</span><span class="token constant">A</span><span class="token operator">></span><span class="token punctuation">]</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 获取当前 hook</span>\n  <span class="token keyword">const</span> hook <span class="token operator">=</span> <span class="token function">updateWorkInProgressHook</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">const</span> queue <span class="token operator">=</span> hook<span class="token punctuation">.</span>queue<span class="token punctuation">;</span>\n\n  queue<span class="token punctuation">.</span>lastRenderedReducer <span class="token operator">=</span> reducer<span class="token punctuation">;</span>\n\n  <span class="token comment">// ...同 update 与 updateQueue 类似的更新逻辑</span>\n\n  <span class="token keyword">const</span> dispatch<span class="token punctuation">:</span> Dispatch<span class="token operator">&lt;</span><span class="token constant">A</span><span class="token operator">></span> <span class="token operator">=</span> <span class="token punctuation">(</span>queue<span class="token punctuation">.</span>dispatch<span class="token punctuation">:</span> any<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">return</span> <span class="token punctuation">[</span>hook<span class="token punctuation">.</span>memoizedState<span class="token punctuation">,</span> dispatch<span class="token punctuation">]</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>整个流程可以概括为一句话：</p>\n<blockquote>\n<p>找到对应的 hook，根据 update 计算该 hook 的新 state 并返回。</p>\n</blockquote>\n<p>mount 时获取当前 hook 使用的是 mountWorkInProgressHook，而 update 时使用的是 updateWorkInProgressHook，这里的原因是：</p>\n<ul>\n<li>mount 时可以确定是调用 ReactDOM.render 或相关初始化 API 产生的更新，只会执行一次。</li>\n<li>update 可能是在事件回调或副作用中触发的更新或者是 render 阶段触发的更新，为了避免组件无限循环更新，后者需要区别对待。</li>\n</ul>',
id:"/github/workspace/blog/React技术解密笔记——实现篇/index.md absPath of file >>> MarkdownRemark",timeToRead:50,frontmatter:{date:"2021-02-01 10:53:07",path:"/react-technology-notes-realization/",tags:"前端, React, 高级前端",title:"React技术解密笔记——实现篇",draft:null}},{excerpt:"render 阶段 流程概览 本章我们会讲解 Fiber 节点是如何被创建并构建 Fiber 树的。 render 阶段开始于 performSyncWorkOnRoot 或 performConcurrentWorkOnRoot 方法的调用。这取决于本次更新是同步更新还是异步更新。 我们现在还不需要学习这两个方法，只需要知道在这两个方法中会调用如下两个方法： 可以看到，他们唯一的区别是是否调用 shouldYield。如果当前浏览器帧没有剩余时间，shouldYield…",html:'<h1 id="render-阶段"><a href="#render-%E9%98%B6%E6%AE%B5" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>render 阶段</h1>\n<h2 id="流程概览"><a href="#%E6%B5%81%E7%A8%8B%E6%A6%82%E8%A7%88" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>流程概览</h2>\n<p>本章我们会讲解 Fiber 节点是如何被创建并构建 Fiber 树的。</p>\n<p>render 阶段开始于 performSyncWorkOnRoot 或 performConcurrentWorkOnRoot 方法的调用。这取决于本次更新是同步更新还是异步更新。</p>\n<p>我们现在还不需要学习这两个方法，只需要知道在这两个方法中会调用如下两个方法：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="52738839424053060000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// performSyncWorkOnRoot会调用该方法\nfunction workLoopSync() {\n  while (workInProgress !== null) {\n    performUnitOfWork(workInProgress);\n  }\n}\n\n// performConcurrentWorkOnRoot会调用该方法\nfunction workLoopConcurrent() {\n  while (workInProgress !== null && !shouldYield()) {\n    performUnitOfWork(workInProgress);\n  }\n}`, `52738839424053060000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">// performSyncWorkOnRoot会调用该方法</span>\n<span class="token keyword">function</span> <span class="token function">workLoopSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">while</span> <span class="token punctuation">(</span>workInProgress <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token function">performUnitOfWork</span><span class="token punctuation">(</span>workInProgress<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// performConcurrentWorkOnRoot会调用该方法</span>\n<span class="token keyword">function</span> <span class="token function">workLoopConcurrent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">while</span> <span class="token punctuation">(</span>workInProgress <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">shouldYield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token function">performUnitOfWork</span><span class="token punctuation">(</span>workInProgress<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>可以看到，他们唯一的区别是是否调用 shouldYield。如果当前浏览器帧没有剩余时间，shouldYield 会中止循环，直到浏览器有空闲时间后再继续遍历。</p>\n<p>workInProgress 代表当前已创建的 workInProgress fiber。</p>\n<p>performUnitOfWork 方法会创建下一个 Fiber 节点并赋值给 workInProgress，并将 workInProgress 与已创建的 Fiber 节点连接起来构成 Fiber 树。</p>\n<blockquote>\n<p>你可以从<a href="https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L1599" target="_blank" rel="nofollow noreferrer noopener">这里</a>看到 workLoopConcurrent 的源码</p>\n</blockquote>\n<p>我们知道 Fiber Reconciler 是从 Stack Reconciler 重构而来，通过遍历的方式实现可中断的递归，所以 performUnitOfWork 的工作可以分为两部分：“递”和“归”。</p>\n<h3 id="递阶段"><a href="#%E9%80%92%E9%98%B6%E6%AE%B5" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>“递”阶段</h3>\n<p>首先从 rootFiber 开始向下深度优先遍历。为遍历到的每个 Fiber 节点调用 <a href="https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberBeginWork.new.js#L3058" target="_blank" rel="nofollow noreferrer noopener">beginWork 方法</a>。</p>\n<p>该方法会根据传入的 Fiber 节点创建子 Fiber 节点，并将这两个 Fiber 节点连接起来。</p>\n<p>当遍历到叶子节点（即没有子组件的组件）时就会进入“归”阶段。</p>\n<h3 id="归阶段"><a href="#%E5%BD%92%E9%98%B6%E6%AE%B5" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>“归”阶段</h3>\n<p>在“归”阶段会调用 <a href="https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberCompleteWork.new.js#L652" target="_blank" rel="nofollow noreferrer noopener">completeWork</a> 处理 Fiber 节点。</p>\n<p>当某个 Fiber 节点执行完 completeWork，如果其存在兄弟 Fiber 节点（即 fiber.sibling !== null），会进入其兄弟 Fiber 的“递”阶段。</p>\n<p>如果不存在兄弟 Fiber，会进入父级 Fiber 的“归”阶段。</p>\n<p>“递”和“归”阶段会交错执行直到“归”到 rootFiber。至此，render 阶段的工作就结束了。</p>\n<h3 id="例子"><a href="#%E4%BE%8B%E5%AD%90" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>例子</h3>\n<p>以上一节的例子举例：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="80852733353915270000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function App() {\n  return (\n    <div>\n      i am\n      <span>KaSong</span>\n    </div>\n  );\n}\n\nReactDOM.render(<App />, document.getElementById(\'root\'));`, `80852733353915270000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token punctuation">(</span>\n    <span class="token operator">&lt;</span>div<span class="token operator">></span>\n      i am\n      <span class="token operator">&lt;</span>span<span class="token operator">></span>KaSong<span class="token operator">&lt;</span><span class="token operator">/</span>span<span class="token operator">></span>\n    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>\n  <span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\nReactDOM<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>App <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">,</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">\'root\'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>对应的 Fiber 树结构：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-01-21-17-58-17-f6bcacfdef6508ce0ffa17d297746c02-d2875.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 82.6946847960445%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAIAAABSJhvpAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABu0lEQVQ4y41TC28TMQze//9TCCGBELAWNAqT1q3Pu+MeubwuT9uHr2WwCmhrRbHl5Ivtz87NeJCMZAIMEYaELpH2OQKOl+SGDkq75BIKZV69frPe7lwepYvsJzoLPioOE2F6YrlvN7Vim9flyEdVy6IST4CoPXAKvSlLsbbBXAYTkbSi6ksTcjsA753pGlWF5K+K7BMGGKUN35cb7eIQaYgTYXQN2AawkZT1H+d3jTQM3gofMh7zAgQgoL/Y+wVOObroEpAK1Nnkk/fRGx+HgHpQq+p+XT/EHP5d8659fCq/JoDeBB+hEqvH8ptxkrvAPfcpI/4/Mg+JZZ5srHRSPhsPMeNvOmqdTMSAI3NpPN+lkyFRLsVM2tgPn253+4KBrUkJ2I+FDNzC2ecvb9+9N3bgRg4hH7l8rhmQx9P41ErLnDNhteq2zbISBTttHHdN/7AXh4xGpNO0T2U65IIbWTIXm/q+FEXggJF60/3ot0LXZ8AvniHsdFspIT3aiHLQtayMUxfAB24pA/o8NkItlpvVrmKDx4HOpv1HmHP+pEVRzGbzu8XidjaX0+jRVWCWkCEAJRp5TcaLf/4TtbXfi5tRl/oAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 01 21 17 58 17"\n        title=""\n        src="/static/2021-01-21-17-58-17-f6bcacfdef6508ce0ffa17d297746c02-fee1c.png"\n        srcset="/static/2021-01-21-17-58-17-f6bcacfdef6508ce0ffa17d297746c02-a67b7.png 200w,\n/static/2021-01-21-17-58-17-f6bcacfdef6508ce0ffa17d297746c02-0b187.png 400w,\n/static/2021-01-21-17-58-17-f6bcacfdef6508ce0ffa17d297746c02-fee1c.png 800w,\n/static/2021-01-21-17-58-17-f6bcacfdef6508ce0ffa17d297746c02-b1a91.png 1200w,\n/static/2021-01-21-17-58-17-f6bcacfdef6508ce0ffa17d297746c02-95179.png 1600w,\n/static/2021-01-21-17-58-17-f6bcacfdef6508ce0ffa17d297746c02-d2875.png 1618w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>render 阶段会依次执行：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="85211003728000680000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`1. rootFiber beginWork\n2. App Fiber beginWork\n3. div Fiber beginWork\n4. &quot;i am&quot; Fiber beginWork\n5. &quot;i am&quot; Fiber completeWork\n6. span Fiber beginWork\n7. span Fiber completeWork\n8. div Fiber completeWork\n9. App Fiber completeWork\n10. rootFiber completeWork`, `85211003728000680000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">1. rootFiber beginWork\n2. App Fiber beginWork\n3. div Fiber beginWork\n4. &quot;i am&quot; Fiber beginWork\n5. &quot;i am&quot; Fiber completeWork\n6. span Fiber beginWork\n7. span Fiber completeWork\n8. div Fiber completeWork\n9. App Fiber completeWork\n10. rootFiber completeWork</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<blockquote>\n<p>注意</p>\n<p>之所以没有 “KaSong” Fiber 的 beginWork/completeWork，是因为作为一种性能优化手段，针对只有单一文本子节点的 Fiber，React 会特殊处理。</p>\n</blockquote>\n<h2 id="beginwork"><a href="#beginwork" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>beginWork</h2>\n<p>上一节我们了解到 render 阶段的工作可以分为“递”阶段和“归”阶段。其中“递”阶段会执行 beginWork，“归”阶段会执行 completeWork。这一节我们看看“递”阶段的 beginWork 方法究竟做了什么。</p>\n<h3 id="方法概览"><a href="#%E6%96%B9%E6%B3%95%E6%A6%82%E8%A7%88" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>方法概览</h3>\n<p>可以从<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberBeginWork.new.js#L3075" target="_blank" rel="nofollow noreferrer noopener">源码这里</a>看到 beginWork 的定义。整个方法大概有 500 行代码。</p>\n<p>从上一节我们已经知道，beginWork 的工作是传入当前 Fiber 节点，创建子 Fiber 节点，我们从传参来看看具体是如何做的。</p>\n<h4 id="从传参看方法执行"><a href="#%E4%BB%8E%E4%BC%A0%E5%8F%82%E7%9C%8B%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>从传参看方法执行</h4>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="62334836803684060000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function beginWork(current: Fiber | null, workInProgress: Fiber, renderLanes: Lanes): Fiber | null {\n  // ...省略函数体\n}`, `62334836803684060000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span> <span class="token function">beginWork</span><span class="token punctuation">(</span><span class="token parameter">current<span class="token punctuation">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span> workInProgress<span class="token punctuation">:</span> Fiber<span class="token punctuation">,</span> renderLanes<span class="token punctuation">:</span> Lanes</span><span class="token punctuation">)</span><span class="token punctuation">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token punctuation">{</span>\n  <span class="token comment">// ...省略函数体</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span></span></pre></div>\n<p>其中传参：</p>\n<ul>\n<li>current：当前组件对应的 Fiber 节点在上一次更新时的 Fiber 节点，即 workInProgress.alternate</li>\n<li>workInProgress：当前组件对应的 Fiber 节点</li>\n<li>renderLanes：优先级相关，在讲解 Scheduler 时再讲解</li>\n</ul>\n<p>从双缓存机制一节我们知道，除 rootFiber 以外， 组件 mount 时，由于是首次渲染，是不存在当前组件对应的 Fiber 节点在上一次更新时的 Fiber 节点，即 mount 时 current === null。</p>\n<p>组件 update 时，由于之前已经 mount 过，所以 current !== null。</p>\n<p>所以我们可以通过 <code class="language-text">current === null</code> 来区分组件是处于 mount 还是 update。</p>\n<p>基于此原因，beginWork 的工作可以分为两部分：</p>\n<ul>\n<li>update 时：如果 current 存在，在满足一定条件时可以复用 current 节点，这样就能克隆 current.child 作为 workInProgress.child，而不需要新建 workInProgress.child。</li>\n<li>mount 时：除 fiberRootNode 以外，current === null。会根据 fiber.tag 不同，创建不同类型的子 Fiber 节点</li>\n</ul>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="29988485367269480000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function beginWork(current: Fiber | null, workInProgress: Fiber, renderLanes: Lanes): Fiber | null {\n  // update 时：如果 current 存在可能存在优化路径\n  // 可以复用 current（即上一次更新的 Fiber 节点）\n  if (current !== null) {\n    // ...省略\n\n    // 复用 current\n    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n  } else {\n    didReceiveUpdate = false;\n  }\n\n  // mount 时：根据 tag 不同，创建不同的子 Fiber 节点\n  switch (workInProgress.tag) {\n    case IndeterminateComponent:\n    // ...省略\n    case LazyComponent:\n    // ...省略\n    case FunctionComponent:\n    // ...省略\n    case ClassComponent:\n    // ...省略\n    case HostRoot:\n    // ...省略\n    case HostComponent:\n    // ...省略\n    case HostText:\n    // ...省略\n    // ...省略其他类型\n  }\n}`, `29988485367269480000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span> <span class="token function">beginWork</span><span class="token punctuation">(</span><span class="token parameter">current<span class="token punctuation">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span> workInProgress<span class="token punctuation">:</span> Fiber<span class="token punctuation">,</span> renderLanes<span class="token punctuation">:</span> Lanes</span><span class="token punctuation">)</span><span class="token punctuation">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token punctuation">{</span>\n  <span class="token comment">// update 时：如果 current 存在可能存在优化路径</span>\n  <span class="token comment">// 可以复用 current（即上一次更新的 Fiber 节点）</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// ...省略</span>\n\n    <span class="token comment">// 复用 current</span>\n    <span class="token keyword">return</span> <span class="token function">bailoutOnAlreadyFinishedWork</span><span class="token punctuation">(</span>current<span class="token punctuation">,</span> workInProgress<span class="token punctuation">,</span> renderLanes<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n    didReceiveUpdate <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token comment">// mount 时：根据 tag 不同，创建不同的子 Fiber 节点</span>\n  <span class="token keyword">switch</span> <span class="token punctuation">(</span>workInProgress<span class="token punctuation">.</span>tag<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">case</span> IndeterminateComponent<span class="token punctuation">:</span>\n    <span class="token comment">// ...省略</span>\n    <span class="token keyword">case</span> LazyComponent<span class="token punctuation">:</span>\n    <span class="token comment">// ...省略</span>\n    <span class="token keyword">case</span> FunctionComponent<span class="token punctuation">:</span>\n    <span class="token comment">// ...省略</span>\n    <span class="token keyword">case</span> ClassComponent<span class="token punctuation">:</span>\n    <span class="token comment">// ...省略</span>\n    <span class="token keyword">case</span> HostRoot<span class="token punctuation">:</span>\n    <span class="token comment">// ...省略</span>\n    <span class="token keyword">case</span> HostComponent<span class="token punctuation">:</span>\n    <span class="token comment">// ...省略</span>\n    <span class="token keyword">case</span> HostText<span class="token punctuation">:</span>\n    <span class="token comment">// ...省略</span>\n    <span class="token comment">// ...省略其他类型</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h3 id="update-时"><a href="#update-%E6%97%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>update 时</h3>\n<p>我们可以看到，满足如下情况时 didReceiveUpdate === false（即可以直接复用前一次更新的子 Fiber，不需要新建子 Fiber）</p>\n<ol>\n<li><code class="language-text">oldProps === newProps &amp;&amp; workInProgress.type === current.type</code>，即 props 与 fiber.type 不变</li>\n<li><code class="language-text">!includesSomeLane(renderLanes, updateLanes)</code>，即当前 Fiber 节点优先级不够，会在讲解 Scheduler 时介绍</li>\n</ol>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="13813560132074777000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`if (current !== null) {\n  const oldProps = current.memoizedProps;\n  const newProps = workInProgress.pendingProps;\n\n  if (oldProps !== newProps || hasLegacyContextChanged() || (__DEV__ ? workInProgress.type !== current.type : false)) {\n    didReceiveUpdate = true;\n  } else if (!includesSomeLane(renderLanes, updateLanes)) {\n    didReceiveUpdate = false;\n    switch (\n      workInProgress.tag\n      // 省略处理\n    ) {\n    }\n    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n  } else {\n    didReceiveUpdate = false;\n  }\n} else {\n  didReceiveUpdate = false;\n}`, `13813560132074777000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> oldProps <span class="token operator">=</span> current<span class="token punctuation">.</span>memoizedProps<span class="token punctuation">;</span>\n  <span class="token keyword">const</span> newProps <span class="token operator">=</span> workInProgress<span class="token punctuation">.</span>pendingProps<span class="token punctuation">;</span>\n\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>oldProps <span class="token operator">!==</span> newProps <span class="token operator">||</span> <span class="token function">hasLegacyContextChanged</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>__DEV__ <span class="token operator">?</span> workInProgress<span class="token punctuation">.</span>type <span class="token operator">!==</span> current<span class="token punctuation">.</span>type <span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    didReceiveUpdate <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">includesSomeLane</span><span class="token punctuation">(</span>renderLanes<span class="token punctuation">,</span> updateLanes<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    didReceiveUpdate <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>\n    <span class="token keyword">switch</span> <span class="token punctuation">(</span>\n      workInProgress<span class="token punctuation">.</span>tag\n      <span class="token comment">// 省略处理</span>\n    <span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token punctuation">}</span>\n    <span class="token keyword">return</span> <span class="token function">bailoutOnAlreadyFinishedWork</span><span class="token punctuation">(</span>current<span class="token punctuation">,</span> workInProgress<span class="token punctuation">,</span> renderLanes<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n    didReceiveUpdate <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n  didReceiveUpdate <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h3 id="mount-时"><a href="#mount-%E6%97%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>mount 时</h3>\n<p>当不满足优化路径时，我们就进入第二部分，新建子 Fiber。</p>\n<p>我们可以看到，根据 fiber.tag 不同，进入不同类型 Fiber 的创建逻辑。</p>\n<p>可以从<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactWorkTags.js" target="_blank" rel="nofollow noreferrer noopener">这里</a>看到 tag 对应的组件类型</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="73494515105641150000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// mount 时：根据 tag 不同，创建不同的 Fiber 节点\nswitch (workInProgress.tag) {\n  case IndeterminateComponent:\n  // ...省略\n  case LazyComponent:\n  // ...省略\n  case FunctionComponent:\n  // ...省略\n  case ClassComponent:\n  // ...省略\n  case HostRoot:\n  // ...省略\n  case HostComponent:\n  // ...省略\n  case HostText:\n  // ...省略\n  // ...省略其他类型\n}`, `73494515105641150000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">// mount 时：根据 tag 不同，创建不同的 Fiber 节点</span>\n<span class="token keyword">switch</span> <span class="token punctuation">(</span>workInProgress<span class="token punctuation">.</span>tag<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">case</span> IndeterminateComponent<span class="token punctuation">:</span>\n  <span class="token comment">// ...省略</span>\n  <span class="token keyword">case</span> LazyComponent<span class="token punctuation">:</span>\n  <span class="token comment">// ...省略</span>\n  <span class="token keyword">case</span> FunctionComponent<span class="token punctuation">:</span>\n  <span class="token comment">// ...省略</span>\n  <span class="token keyword">case</span> ClassComponent<span class="token punctuation">:</span>\n  <span class="token comment">// ...省略</span>\n  <span class="token keyword">case</span> HostRoot<span class="token punctuation">:</span>\n  <span class="token comment">// ...省略</span>\n  <span class="token keyword">case</span> HostComponent<span class="token punctuation">:</span>\n  <span class="token comment">// ...省略</span>\n  <span class="token keyword">case</span> HostText<span class="token punctuation">:</span>\n  <span class="token comment">// ...省略</span>\n  <span class="token comment">// ...省略其他类型</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>对于我们常见的组件类型，如（FunctionComponent/ClassComponent/HostComponent），最终会进入 reconcileChildren 方法。</p>\n<h3 id="reconcilechildren"><a href="#reconcilechildren" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>reconcileChildren</h3>\n<p>从该函数名就能看出这是 Reconciler 模块的核心部分。那么他究竟做了什么呢？</p>\n<ul>\n<li>对于 mount 的组件，他会创建新的子 Fiber 节点</li>\n<li>对于 update 的组件，他会将当前组件与该组件在上次更新时对应的 Fiber 节点比较（也就是俗称的 Diff 算法），将比较的结果生成新 Fiber 节点</li>\n</ul>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="13779895608120451000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`export function reconcileChildren(current: Fiber | null, workInProgress: Fiber, nextChildren: any, renderLanes: Lanes) {\n  if (current === null) {\n    // 对于mount的组件\n    workInProgress.child = mountChildFibers(workInProgress, null, nextChildren, renderLanes);\n  } else {\n    // 对于update的组件\n    workInProgress.child = reconcileChildFibers(workInProgress, current.child, nextChildren, renderLanes);\n  }\n}`, `13779895608120451000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">reconcileChildren</span><span class="token punctuation">(</span><span class="token parameter">current<span class="token punctuation">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span> workInProgress<span class="token punctuation">:</span> Fiber<span class="token punctuation">,</span> nextChildren<span class="token punctuation">:</span> any<span class="token punctuation">,</span> renderLanes<span class="token punctuation">:</span> Lanes</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 对于mount的组件</span>\n    workInProgress<span class="token punctuation">.</span>child <span class="token operator">=</span> <span class="token function">mountChildFibers</span><span class="token punctuation">(</span>workInProgress<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> nextChildren<span class="token punctuation">,</span> renderLanes<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 对于update的组件</span>\n    workInProgress<span class="token punctuation">.</span>child <span class="token operator">=</span> <span class="token function">reconcileChildFibers</span><span class="token punctuation">(</span>workInProgress<span class="token punctuation">,</span> current<span class="token punctuation">.</span>child<span class="token punctuation">,</span> nextChildren<span class="token punctuation">,</span> renderLanes<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>从代码可以看出，和 beginWork 一样，他也是通过 <code class="language-text">current === null</code> 区分 mount 与 update。</p>\n<p>不论走哪个逻辑，最终他会生成新的子 Fiber 节点并赋值给 workInProgress.child，作为本次 beginWork 返回值，并作为下次 performUnitOfWork 执行时 workInProgress 的传参。</p>\n<blockquote>\n<p>注意</p>\n<p>值得一提的是，mountChildFibers 与 reconcileChildFibers 这两个方法的逻辑基本一致。唯一的区别是：reconcileChildFibers 会为生成的 Fiber 节点带上 effectTag 属性，而 mountChildFibers 不会。</p>\n</blockquote>\n<h3 id="effecttag"><a href="#effecttag" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>effectTag</h3>\n<p>我们知道，render 阶段的工作是在内存中进行，当工作结束后会通知 Renderer 需要执行的 DOM 操作。要执行 DOM 操作的具体类型就保存在 fiber.effectTag 中。</p>\n<blockquote>\n<p>你可以从<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactSideEffectTags.js" target="_blank" rel="nofollow noreferrer noopener">这里</a>看到 effectTag 对应的 DOM 操作</p>\n</blockquote>\n<p>比如：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="43910849325818390000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// DOM 需要插入到页面中\nexport const Placement = /*                */ 0b00000000000010;\n// DOM 需要更新\nexport const Update = /*                   */ 0b00000000000100;\n// DOM 需要插入到页面中并更新\nexport const PlacementAndUpdate = /*       */ 0b00000000000110;\n// DOM 需要删除\nexport const Deletion = /*                 */ 0b00000000001000;`, `43910849325818390000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">// DOM 需要插入到页面中</span>\n<span class="token keyword">export</span> <span class="token keyword">const</span> Placement <span class="token operator">=</span> <span class="token comment">/*                */</span> <span class="token number">0b00000000000010</span><span class="token punctuation">;</span>\n<span class="token comment">// DOM 需要更新</span>\n<span class="token keyword">export</span> <span class="token keyword">const</span> Update <span class="token operator">=</span> <span class="token comment">/*                   */</span> <span class="token number">0b00000000000100</span><span class="token punctuation">;</span>\n<span class="token comment">// DOM 需要插入到页面中并更新</span>\n<span class="token keyword">export</span> <span class="token keyword">const</span> PlacementAndUpdate <span class="token operator">=</span> <span class="token comment">/*       */</span> <span class="token number">0b00000000000110</span><span class="token punctuation">;</span>\n<span class="token comment">// DOM 需要删除</span>\n<span class="token keyword">export</span> <span class="token keyword">const</span> Deletion <span class="token operator">=</span> <span class="token comment">/*                 */</span> <span class="token number">0b00000000001000</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<blockquote>\n<p>通过二进制表示 effectTag，可以方便的使用位操作为 fiber.effectTag 赋值多个 effect。</p>\n</blockquote>\n<p>那么，如果要通知 Renderer 将 Fiber 节点对应的 DOM 节点插入页面中，需要满足两个条件：</p>\n<ol>\n<li>fiber.stateNode 存在，即 Fiber 节点中保存了对应的 DOM 节点</li>\n<li>(fiber.effectTag &#x26; Placement) !== 0，即 Fiber 节点存在 Placement effectTag</li>\n</ol>\n<p>我们知道，mount 时，<code class="language-text">fiber.stateNode === null</code>，且在 reconcileChildren 中调用的 mountChildFibers 不会为 Fiber 节点赋值 effectTag。那么首屏渲染如何完成呢？</p>\n<p>针对第一个问题，fiber.stateNode 会在 completeWork 中创建，我们会在下一节介绍。</p>\n<p>第二个问题的答案十分巧妙：假设 mountChildFibers 也会赋值 effectTag，那么可以预见 mount 时整棵 Fiber 树所有节点都会有 Placement effectTag。那么 commit 阶段在执行 DOM 操作时每个节点都会执行一次插入操作，这样大量的 DOM 操作是极低效的。</p>\n<p>为了解决这个问题，在 mount 时只有 rootFiber 会赋值 Placement effectTag，在 commit 阶段只会执行一次插入操作。</p>\n<h3 id="参考资料"><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>参考资料</h3>\n<p>beginWork 流程图</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-01-22-10-42-18-caba41064a5ec2b50d3061e096f0b360-72d75.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 56.25%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAA9UlEQVQoz5WRyU4EMQxE+///jRMS4gRCYhA9vWVPvMTBnQsDzNBQByuJVKpX8dC6pE+X4e7x6eHlBCx6nn3KxIvP98+nULD90HB5oVon44mlIAaA0cYA+L4aG1O7puHbPWTIWCcfM+5RIsJV2g19MQPXcbVn45GrAk/Wzy5kFqP8QIfYMrnoe73a2uSW2a0kDYmu5n+akXA3awpgKGkL2pcUwcSk1t+wuWeebSzEe/OCr9Mybs4leJuNL3DQmWtF1rHz8f5PUPsGb//XhdlmXBS5Ng/kgF2h0XhXcEu4BN3AUbJ205wqolOLICmJ9HeWv+z5X/oAvwGIYLJSJZkAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 01 22 10 42 18"\n        title=""\n        src="/static/2021-01-22-10-42-18-caba41064a5ec2b50d3061e096f0b360-fee1c.png"\n        srcset="/static/2021-01-22-10-42-18-caba41064a5ec2b50d3061e096f0b360-a67b7.png 200w,\n/static/2021-01-22-10-42-18-caba41064a5ec2b50d3061e096f0b360-0b187.png 400w,\n/static/2021-01-22-10-42-18-caba41064a5ec2b50d3061e096f0b360-fee1c.png 800w,\n/static/2021-01-22-10-42-18-caba41064a5ec2b50d3061e096f0b360-b1a91.png 1200w,\n/static/2021-01-22-10-42-18-caba41064a5ec2b50d3061e096f0b360-95179.png 1600w,\n/static/2021-01-22-10-42-18-caba41064a5ec2b50d3061e096f0b360-72d75.png 1920w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<h2 id="completework"><a href="#completework" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>completeWork</h2>\n<p>在流程概览一节我们了解组件在 render 阶段会经历 beginWork 与 completeWork。</p>\n<p>上一节我们讲解了组件执行 beginWork 后会创建子 Fiber 节点，节点上可能存在 effectTag。</p>\n<p>这一节让我们看看 completeWork 会做什么工作。</p>\n<p>你可以从<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberCompleteWork.new.js#L673" target="_blank" rel="nofollow noreferrer noopener">这里</a>看到 completeWork 方法定义。</p>\n<h3 id="流程概览-1"><a href="#%E6%B5%81%E7%A8%8B%E6%A6%82%E8%A7%88-1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>流程概览</h3>\n<p>类似 beginWork，completeWork 也是针对不同 fiber.tag 调用不同的处理逻辑。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="89001454642326900000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function completeWork(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  renderLanes: Lanes,\n): Fiber | null {\n  const newProps = workInProgress.pendingProps;\n\n  switch (workInProgress.tag) {\n    case IndeterminateComponent:\n    case LazyComponent:\n    case SimpleMemoComponent:\n    case FunctionComponent:\n    case ForwardRef:\n    case Fragment:\n    case Mode:\n    case Profiler:\n    case ContextConsumer:\n    case MemoComponent:\n      return null;\n    case ClassComponent: {\n      // ...省略\n      return null;\n    }\n    case HostRoot: {\n      // ...省略\n      updateHostContainer(workInProgress);\n      return null;\n    }\n    case HostComponent: {\n      // ...省略\n      return null;\n    }\n  // ...省略`, `89001454642326900000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span> <span class="token function">completeWork</span><span class="token punctuation">(</span>\n  <span class="token parameter">current<span class="token punctuation">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>\n  workInProgress<span class="token punctuation">:</span> Fiber<span class="token punctuation">,</span>\n  renderLanes<span class="token punctuation">:</span> Lanes<span class="token punctuation">,</span></span>\n<span class="token punctuation">)</span><span class="token punctuation">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> newProps <span class="token operator">=</span> workInProgress<span class="token punctuation">.</span>pendingProps<span class="token punctuation">;</span>\n\n  <span class="token keyword">switch</span> <span class="token punctuation">(</span>workInProgress<span class="token punctuation">.</span>tag<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">case</span> IndeterminateComponent<span class="token punctuation">:</span>\n    <span class="token keyword">case</span> LazyComponent<span class="token punctuation">:</span>\n    <span class="token keyword">case</span> SimpleMemoComponent<span class="token punctuation">:</span>\n    <span class="token keyword">case</span> FunctionComponent<span class="token punctuation">:</span>\n    <span class="token keyword">case</span> ForwardRef<span class="token punctuation">:</span>\n    <span class="token keyword">case</span> Fragment<span class="token punctuation">:</span>\n    <span class="token keyword">case</span> Mode<span class="token punctuation">:</span>\n    <span class="token keyword">case</span> Profiler<span class="token punctuation">:</span>\n    <span class="token keyword">case</span> ContextConsumer<span class="token punctuation">:</span>\n    <span class="token keyword">case</span> MemoComponent<span class="token punctuation">:</span>\n      <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n    <span class="token keyword">case</span> ClassComponent<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n      <span class="token comment">// ...省略</span>\n      <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n    <span class="token keyword">case</span> HostRoot<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n      <span class="token comment">// ...省略</span>\n      <span class="token function">updateHostContainer</span><span class="token punctuation">(</span>workInProgress<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n    <span class="token keyword">case</span> HostComponent<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n      <span class="token comment">// ...省略</span>\n      <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n  <span class="token comment">// ...省略</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>我们重点关注页面渲染所必须的 HostComponent（即原生 DOM 组件对应的 Fiber 节点），其他类型 Fiber 的处理留在具体功能实现时讲解。</p>\n<h3 id="处理-hostcomponent"><a href="#%E5%A4%84%E7%90%86-hostcomponent" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>处理 HostComponent</h3>\n<p>和 beginWork 一样，我们根据 <code class="language-text">current === null</code> 判断是 mount 还是 update。</p>\n<p>同时针对 HostComponent，判断 update 时我们还需要考虑 <code class="language-text">workInProgress.stateNode != null</code>（即该 Fiber 节点是否存在对应的 DOM 节点）</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="94465511888591980000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`case HostComponent: {\n  popHostContext(workInProgress);\n  const rootContainerInstance = getRootHostContainer();\n  const type = workInProgress.type;\n\n  if (current !== null && workInProgress.stateNode != null) {\n    // update的情况\n    // ...省略\n  } else {\n    // mount的情况\n    // ...省略\n  }\n  return null;\n}`, `94465511888591980000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">case</span> HostComponent<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n  <span class="token function">popHostContext</span><span class="token punctuation">(</span>workInProgress<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">const</span> rootContainerInstance <span class="token operator">=</span> <span class="token function">getRootHostContainer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">const</span> type <span class="token operator">=</span> workInProgress<span class="token punctuation">.</span>type<span class="token punctuation">;</span>\n\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> workInProgress<span class="token punctuation">.</span>stateNode <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// update的情况</span>\n    <span class="token comment">// ...省略</span>\n  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n    <span class="token comment">// mount的情况</span>\n    <span class="token comment">// ...省略</span>\n  <span class="token punctuation">}</span>\n  <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h3 id="update-时-1"><a href="#update-%E6%97%B6-1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>update 时</h3>\n<p>当 update 时，Fiber 节点已经存在对应 DOM 节点，所以不需要生成 DOM 节点。需要做的主要是处理 props，比如：</p>\n<ul>\n<li>onClick、onChange 等回调函数的注册</li>\n<li>处理 style prop</li>\n<li>处理 DANGEROUSLY<em>SET</em>INNER_HTML prop</li>\n<li>处理 children prop</li>\n</ul>\n<p>我们去掉一些当前不需要关注的功能（比如 ref），可以看到最主要的逻辑是调用 updateHostComponent 方法。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="90009251575280700000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`if (current !== null && workInProgress.stateNode != null) {\n  // update的情况\n  updateHostComponent(current, workInProgress, type, newProps, rootContainerInstance);\n}`, `90009251575280700000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> workInProgress<span class="token punctuation">.</span>stateNode <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// update的情况</span>\n  <span class="token function">updateHostComponent</span><span class="token punctuation">(</span>current<span class="token punctuation">,</span> workInProgress<span class="token punctuation">,</span> type<span class="token punctuation">,</span> newProps<span class="token punctuation">,</span> rootContainerInstance<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>你可以从<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberCompleteWork.new.js#L225" target="_blank" rel="nofollow noreferrer noopener">这里</a>看到 updateHostComponent 方法定义。</p>\n<p>在 updateHostComponent 内部，被处理完的 props 会被赋值给 workInProgress.updateQueue，并最终会在 commit 阶段被渲染在页面上。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="66462334845372290000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`workInProgress.updateQueue = (updatePayload: any);`, `66462334845372290000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js">workInProgress<span class="token punctuation">.</span>updateQueue <span class="token operator">=</span> <span class="token punctuation">(</span>updatePayload<span class="token punctuation">:</span> any<span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>其中 updatePayload 为数组形式，他的奇数索引的值为变化的 prop key，偶数索引的值为变化的 prop value。</p>\n<blockquote>\n<p>具体渲染过程见 mutation 阶段一节</p>\n</blockquote>\n<h3 id="mount-时-1"><a href="#mount-%E6%97%B6-1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>mount 时</h3>\n<p>同样，我们省略了不相关的逻辑。可以看到，mount 时的主要逻辑包括三个：</p>\n<ul>\n<li>为 Fiber 节点生成对应的 DOM 节点</li>\n<li>将子孙 DOM 节点插入刚生成的 DOM 节点中</li>\n<li>与 update 逻辑中的 updateHostComponent 类似的处理 props 的过程</li>\n</ul>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="68999349632884520000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// mount 的情况\n\n// ...省略服务端渲染相关逻辑\n\nconst currentHostContext = getHostContext();\n// 为 fiber 创建对应 DOM 节点\nconst instance = createInstance(type, newProps, rootContainerInstance, currentHostContext, workInProgress);\n// 将子孙 DOM 节点插入刚生成的 DOM 节点中\nappendAllChildren(instance, workInProgress, false, false);\n// DOM 节点赋值给 fiber.stateNode\nworkInProgress.stateNode = instance;\n\n// 与 update 逻辑中的 updateHostComponent 类似的处理 props 的过程\nif (finalizeInitialChildren(instance, type, newProps, rootContainerInstance, currentHostContext)) {\n  markUpdate(workInProgress);\n}`, `68999349632884520000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">// mount 的情况</span>\n\n<span class="token comment">// ...省略服务端渲染相关逻辑</span>\n\n<span class="token keyword">const</span> currentHostContext <span class="token operator">=</span> <span class="token function">getHostContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token comment">// 为 fiber 创建对应 DOM 节点</span>\n<span class="token keyword">const</span> instance <span class="token operator">=</span> <span class="token function">createInstance</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span> newProps<span class="token punctuation">,</span> rootContainerInstance<span class="token punctuation">,</span> currentHostContext<span class="token punctuation">,</span> workInProgress<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token comment">// 将子孙 DOM 节点插入刚生成的 DOM 节点中</span>\n<span class="token function">appendAllChildren</span><span class="token punctuation">(</span>instance<span class="token punctuation">,</span> workInProgress<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token comment">// DOM 节点赋值给 fiber.stateNode</span>\nworkInProgress<span class="token punctuation">.</span>stateNode <span class="token operator">=</span> instance<span class="token punctuation">;</span>\n\n<span class="token comment">// 与 update 逻辑中的 updateHostComponent 类似的处理 props 的过程</span>\n<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">finalizeInitialChildren</span><span class="token punctuation">(</span>instance<span class="token punctuation">,</span> type<span class="token punctuation">,</span> newProps<span class="token punctuation">,</span> rootContainerInstance<span class="token punctuation">,</span> currentHostContext<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token function">markUpdate</span><span class="token punctuation">(</span>workInProgress<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>还记得上一节我们讲到：mount 时只会在 rootFiber 存在 Placement effectTag。那么 commit 阶段是如何通过一次插入 DOM 操作（对应一个 Placement effectTag）将整棵 DOM 树插入页面的呢？</p>\n<p>原因就在于 completeWork 中的 appendAllChildren 方法。</p>\n<p>由于 completeWork 属于“归”阶段调用的函数，每次调用 appendAllChildren 时都会将已生成的子孙 DOM 节点插入当前生成的 DOM 节点下。那么当“归”到 rootFiber 时，我们已经有一个构建好的离屏 DOM 树。</p>\n<h3 id="effectlist"><a href="#effectlist" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>effectList</h3>\n<p>至此 render 阶段的绝大部分工作就完成了。</p>\n<p>还有一个问题：作为 DOM 操作的依据，commit 阶段需要找到所有有 effectTag 的 Fiber 节点并依次执行 effectTag 对应操作。难道需要在 commit 阶段再遍历一次 Fiber 树寻找 <code class="language-text">effectTag !== null</code> 的 Fiber 节点么？</p>\n<p>这显然是很低效的。</p>\n<p>为了解决这个问题，在 completeWork 的上层函数 completeUnitOfWork 中，每个执行完 completeWork 且存在 effectTag 的 Fiber 节点会被保存在一条被称为 effectList 的单向链表中。</p>\n<p>effectList 中第一个 Fiber 节点保存在 fiber.firstEffect，最后一个元素保存在 fiber.lastEffect。</p>\n<p>类似 appendAllChildren，在“归”阶段，所有有 effectTag 的 Fiber 节点都会被追加在 effectList 中，最终形成一条以 rootFiber.firstEffect 为起点的单向链表。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="45061565449255570000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`                       nextEffect         nextEffect\nrootFiber.firstEffect -----------> fiber -----------> fiber`, `45061565449255570000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">                       nextEffect         nextEffect\nrootFiber.firstEffect -----------&gt; fiber -----------&gt; fiber</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span></span></pre></div>\n<p>这样，在 commit 阶段只需要遍历 effectList 就能执行所有 effect 了。</p>\n<p>你可以在<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L1744" target="_blank" rel="nofollow noreferrer noopener">这里</a>看到这段代码逻辑。</p>\n<p>借用 React 团队成员 Dan Abramov 的话：effectList 相较于 Fiber 树，就像圣诞树上挂的那一串彩灯。</p>\n<h3 id="流程结尾"><a href="#%E6%B5%81%E7%A8%8B%E7%BB%93%E5%B0%BE" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>流程结尾</h3>\n<p>至此，render 阶段全部工作完成。在 performSyncWorkOnRoot 函数中 fiberRootNode 被传递给 commitRoot 方法，开启 commit 阶段工作流程。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="60574676364668715000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`commitRoot(root);`, `60574676364668715000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token function">commitRoot</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>代码见<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L1107" target="_blank" rel="nofollow noreferrer noopener">这里</a>。</p>\n<h3 id="参考资料-1"><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99-1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>参考资料</h3>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-01-22-11-00-58-2752d0ac0e3c528568d26090d2fe1e7e-c9723.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 88.08030112923463%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAIAAADUsmlHAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACHElEQVQ4y3VS2XLbMAzU/39RX/rQzrTukTSTVE6V+Eot2dZlHRTFm2AgynbdRsXs2JCEJQDuBuAcAiMj/WKXJRWx4/M58P39ahtukkV6lP4TnBGMf8a5TdV9jZY/46yRlilNpKJSU6V3nfgUPn28C+dJodwU2Xo4/6vBHVq6Ldu4InHVEqnxpYEB4P5C8M/zZQtlgarhQAugrUW8LQsmmRjLQ/EtWgltSyqWeb0uamnG4U41E2QMKrqmr0paE6HHIgOAwIQbmzGV9qrxJwXXV4u5NNBLyZTcN7hwJy3Ob3GFUYId4R8eovc3D+GuYODJLeMVZVyp4Wy/HCZM21YqvDxpAfNeWeOgM5AyvaeyVb4znvdjsX43u83bzvnO1yITZcNd/nn+PHtcPAwqmusxg1GnTpmkoeiQ38dBnoLy6ztHtWome22xLCMsJQzzgWzscIdUmuhQPCYZIkzSuO4u5mHa1D0vOyaMKbi+XcV36zjvBbKCWfj0PVqjq7ykzks7JOP4AlxSd/PNdr6J0TMMTo46jX2/fEGUlA8ca/HCUFvcXBhQZ5eDtx0GTnvz/PLl17JivjMaaMDZQJcYpjDALWwrsinqdV4nLW0UVIwfKZd+2QCuHHOBtyTgFMgnQrVcNRzFNxr+zDLtsEtnYUZ7DTO/bTBBxrpS6HVWLvZ5lKSrQ37oOIcJ5gQZtWml2Vft/tikDUlKNDmX/yG/ApDIFEsabW9gAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 01 22 11 00 58"\n        title=""\n        src="/static/2021-01-22-11-00-58-2752d0ac0e3c528568d26090d2fe1e7e-fee1c.png"\n        srcset="/static/2021-01-22-11-00-58-2752d0ac0e3c528568d26090d2fe1e7e-a67b7.png 200w,\n/static/2021-01-22-11-00-58-2752d0ac0e3c528568d26090d2fe1e7e-0b187.png 400w,\n/static/2021-01-22-11-00-58-2752d0ac0e3c528568d26090d2fe1e7e-fee1c.png 800w,\n/static/2021-01-22-11-00-58-2752d0ac0e3c528568d26090d2fe1e7e-b1a91.png 1200w,\n/static/2021-01-22-11-00-58-2752d0ac0e3c528568d26090d2fe1e7e-c9723.png 1594w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<h1 id="commit-阶段"><a href="#commit-%E9%98%B6%E6%AE%B5" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>commit 阶段</h1>\n<h2 id="流程概览-2"><a href="#%E6%B5%81%E7%A8%8B%E6%A6%82%E8%A7%88-2" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>流程概览</h2>\n<p>commitRoot 方法是 commit 阶段工作的起点，fiberRootNode 会作为传参。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="75488580877680530000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`commitRoot(root);`, `75488580877680530000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token function">commitRoot</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>在 rootFiber.firstEffect 上保存了一条需要执行副作用的 Fiber 节点的单向链表 effectList，这些 Fiber 节点的 updateQueue 中保存了变化的 props。</p>\n<p>这些副作用对应的 DOM 操作在 commit 阶段执行。</p>\n<p>除此之外，一些生命周期钩子（比如 componentDidXXX）、hook（比如 useEffect）需要在 commit 阶段执行。</p>\n<p>commit 阶段的主要工作（即 Renderer 的工作流程）分为三部分：</p>\n<ul>\n<li>before mutation 阶段（执行 DOM 操作前）</li>\n<li>mutation 阶段（执行 DOM 操作）</li>\n<li>layout 阶段（执行 DOM 操作后）</li>\n</ul>\n<p>你可以从<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L2001" target="_blank" rel="nofollow noreferrer noopener">这里</a>看到 commit 阶段的完整代码</p>\n<p>在 before mutation 阶段之前和 layout 阶段之后还有一些额外工作，涉及到比如 useEffect 的触发、优先级相关的重置、ref 的绑定/解绑。</p>\n<p>这些对我们当前属于超纲内容，为了内容完整性，在这节简单介绍。</p>\n<h3 id="before-mutation-之前"><a href="#before-mutation-%E4%B9%8B%E5%89%8D" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>before mutation 之前</h3>\n<p>commitRootImpl 方法中直到第一句 <code class="language-text">if (firstEffect !== null)</code> 之前属于 before mutation 之前。</p>\n<p>我们大体看下他做的工作，现在你还不需要理解他们：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="44847156707908575000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`do {\n  // 触发 useEffect 回调与其他同步任务。由于这些任务可能触发新的渲染，所以这里要一直遍历执行直到没有任务\n  flushPassiveEffects();\n} while (rootWithPendingPassiveEffects !== null);\n\n// root 指 fiberRootNode\n// root.finishedWork 指当前应用的 rootFiber\nconst finishedWork = root.finishedWork;\n\n// 凡是变量名带 lane 的都是优先级相关\nconst lanes = root.finishedLanes;\nif (finishedWork === null) {\n  return null;\n}\nroot.finishedWork = null;\nroot.finishedLanes = NoLanes;\n\n// 重置 Scheduler 绑定的回调函数\nroot.callbackNode = null;\nroot.callbackId = NoLanes;\n\nlet remainingLanes = mergeLanes(finishedWork.lanes, finishedWork.childLanes);\n// 重置优先级相关变量\nmarkRootFinished(root, remainingLanes);\n\n// 清除已完成的 discrete updates，例如：用户鼠标点击触发的更新。\nif (rootsWithPendingDiscreteUpdates !== null) {\n  if (!hasDiscreteLanes(remainingLanes) && rootsWithPendingDiscreteUpdates.has(root)) {\n    rootsWithPendingDiscreteUpdates.delete(root);\n  }\n}\n\n// 重置全局变量\nif (root === workInProgressRoot) {\n  workInProgressRoot = null;\n  workInProgress = null;\n  workInProgressRootRenderLanes = NoLanes;\n} else {\n}\n\n// 将 effectList 赋值给 firstEffect\n// 由于每个 fiber 的 effectList 只包含他的子孙节点\n// 所以根节点如果有 effectTag 则不会被包含进来\n// 所以这里将有 effectTag 的根节点插入到 effectList 尾部\n// 这样才能保证有 effect 的 fiber 都在 effectList 中\nlet firstEffect;\nif (finishedWork.effectTag > PerformedWork) {\n  if (finishedWork.lastEffect !== null) {\n    finishedWork.lastEffect.nextEffect = finishedWork;\n    firstEffect = finishedWork.firstEffect;\n  } else {\n    firstEffect = finishedWork;\n  }\n} else {\n  // 根节点没有 effectTag\n  firstEffect = finishedWork.firstEffect;\n}`, `44847156707908575000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">do</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 触发 useEffect 回调与其他同步任务。由于这些任务可能触发新的渲染，所以这里要一直遍历执行直到没有任务</span>\n  <span class="token function">flushPassiveEffects</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>rootWithPendingPassiveEffects <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token comment">// root 指 fiberRootNode</span>\n<span class="token comment">// root.finishedWork 指当前应用的 rootFiber</span>\n<span class="token keyword">const</span> finishedWork <span class="token operator">=</span> root<span class="token punctuation">.</span>finishedWork<span class="token punctuation">;</span>\n\n<span class="token comment">// 凡是变量名带 lane 的都是优先级相关</span>\n<span class="token keyword">const</span> lanes <span class="token operator">=</span> root<span class="token punctuation">.</span>finishedLanes<span class="token punctuation">;</span>\n<span class="token keyword">if</span> <span class="token punctuation">(</span>finishedWork <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\nroot<span class="token punctuation">.</span>finishedWork <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\nroot<span class="token punctuation">.</span>finishedLanes <span class="token operator">=</span> NoLanes<span class="token punctuation">;</span>\n\n<span class="token comment">// 重置 Scheduler 绑定的回调函数</span>\nroot<span class="token punctuation">.</span>callbackNode <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\nroot<span class="token punctuation">.</span>callbackId <span class="token operator">=</span> NoLanes<span class="token punctuation">;</span>\n\n<span class="token keyword">let</span> remainingLanes <span class="token operator">=</span> <span class="token function">mergeLanes</span><span class="token punctuation">(</span>finishedWork<span class="token punctuation">.</span>lanes<span class="token punctuation">,</span> finishedWork<span class="token punctuation">.</span>childLanes<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token comment">// 重置优先级相关变量</span>\n<span class="token function">markRootFinished</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> remainingLanes<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token comment">// 清除已完成的 discrete updates，例如：用户鼠标点击触发的更新。</span>\n<span class="token keyword">if</span> <span class="token punctuation">(</span>rootsWithPendingDiscreteUpdates <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">hasDiscreteLanes</span><span class="token punctuation">(</span>remainingLanes<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> rootsWithPendingDiscreteUpdates<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    rootsWithPendingDiscreteUpdates<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// 重置全局变量</span>\n<span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">===</span> workInProgressRoot<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  workInProgressRoot <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n  workInProgress <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n  workInProgressRootRenderLanes <span class="token operator">=</span> NoLanes<span class="token punctuation">;</span>\n<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// 将 effectList 赋值给 firstEffect</span>\n<span class="token comment">// 由于每个 fiber 的 effectList 只包含他的子孙节点</span>\n<span class="token comment">// 所以根节点如果有 effectTag 则不会被包含进来</span>\n<span class="token comment">// 所以这里将有 effectTag 的根节点插入到 effectList 尾部</span>\n<span class="token comment">// 这样才能保证有 effect 的 fiber 都在 effectList 中</span>\n<span class="token keyword">let</span> firstEffect<span class="token punctuation">;</span>\n<span class="token keyword">if</span> <span class="token punctuation">(</span>finishedWork<span class="token punctuation">.</span>effectTag <span class="token operator">></span> PerformedWork<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>finishedWork<span class="token punctuation">.</span>lastEffect <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    finishedWork<span class="token punctuation">.</span>lastEffect<span class="token punctuation">.</span>nextEffect <span class="token operator">=</span> finishedWork<span class="token punctuation">;</span>\n    firstEffect <span class="token operator">=</span> finishedWork<span class="token punctuation">.</span>firstEffect<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n    firstEffect <span class="token operator">=</span> finishedWork<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 根节点没有 effectTag</span>\n  firstEffect <span class="token operator">=</span> finishedWork<span class="token punctuation">.</span>firstEffect<span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>可以看到，before mutation 之前主要做一些变量赋值，状态重置的工作。</p>\n<p>这一长串代码我们只需要关注最后赋值的 firstEffect，在 commit 的三个子阶段都会用到他。</p>\n<h3 id="layout-之后"><a href="#layout-%E4%B9%8B%E5%90%8E" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>layout 之后</h3>\n<p>接下来让我们简单看下 layout 阶段执行完后的代码，现在你还不需要理解他们：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="12914436205253655000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`const rootDidHavePassiveEffects = rootDoesHavePassiveEffects;\n\n// useEffect 相关\nif (rootDoesHavePassiveEffects) {\n  rootDoesHavePassiveEffects = false;\n  rootWithPendingPassiveEffects = root;\n  pendingPassiveEffectsLanes = lanes;\n  pendingPassiveEffectsRenderPriority = renderPriorityLevel;\n} else {\n}\n\n// 性能优化相关\nif (remainingLanes !== NoLanes) {\n  if (enableSchedulerTracing) {\n    // ...\n  }\n} else {\n  // ...\n}\n\n// 性能优化相关\nif (enableSchedulerTracing) {\n  if (!rootDidHavePassiveEffects) {\n    // ...\n  }\n}\n\n// ...检测无限循环的同步任务\nif (remainingLanes === SyncLane) {\n  // ...\n}\n\n// 在离开 commitRoot 函数前调用，触发一次新的调度，确保任何附加的任务被调度\nensureRootIsScheduled(root, now());\n\n// ...处理未捕获错误及老版本遗留的边界问题\n\n// 执行同步任务，这样同步任务不需要等到下次事件循环再执行\n// 比如在 componentDidMount 中执行 setState 创建的更新会在这里被同步执行\n// 或 useLayoutEffect\nflushSyncCallbackQueue();\n\nreturn null;`, `12914436205253655000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">const</span> rootDidHavePassiveEffects <span class="token operator">=</span> rootDoesHavePassiveEffects<span class="token punctuation">;</span>\n\n<span class="token comment">// useEffect 相关</span>\n<span class="token keyword">if</span> <span class="token punctuation">(</span>rootDoesHavePassiveEffects<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  rootDoesHavePassiveEffects <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>\n  rootWithPendingPassiveEffects <span class="token operator">=</span> root<span class="token punctuation">;</span>\n  pendingPassiveEffectsLanes <span class="token operator">=</span> lanes<span class="token punctuation">;</span>\n  pendingPassiveEffectsRenderPriority <span class="token operator">=</span> renderPriorityLevel<span class="token punctuation">;</span>\n<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// 性能优化相关</span>\n<span class="token keyword">if</span> <span class="token punctuation">(</span>remainingLanes <span class="token operator">!==</span> NoLanes<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>enableSchedulerTracing<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// ...</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n  <span class="token comment">// ...</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// 性能优化相关</span>\n<span class="token keyword">if</span> <span class="token punctuation">(</span>enableSchedulerTracing<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>rootDidHavePassiveEffects<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// ...</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// ...检测无限循环的同步任务</span>\n<span class="token keyword">if</span> <span class="token punctuation">(</span>remainingLanes <span class="token operator">===</span> SyncLane<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// ...</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// 在离开 commitRoot 函数前调用，触发一次新的调度，确保任何附加的任务被调度</span>\n<span class="token function">ensureRootIsScheduled</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token comment">// ...处理未捕获错误及老版本遗留的边界问题</span>\n\n<span class="token comment">// 执行同步任务，这样同步任务不需要等到下次事件循环再执行</span>\n<span class="token comment">// 比如在 componentDidMount 中执行 setState 创建的更新会在这里被同步执行</span>\n<span class="token comment">// 或 useLayoutEffect</span>\n<span class="token function">flushSyncCallbackQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<blockquote>\n<p>你可以在<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L2195" target="_blank" rel="nofollow noreferrer noopener">这里</a>看到这段代码</p>\n</blockquote>\n<p>主要包括三点内容：</p>\n<ol>\n<li>\n<p>useEffect 相关的处理。</p>\n<p>我们会在讲解 layout 阶段时讲解。</p>\n</li>\n<li>\n<p>性能追踪相关。</p>\n<p>源码里有很多和 interaction 相关的变量。他们都和追踪 React 渲染时间、性能相关，在 <a href="https://zh-hans.reactjs.org/docs/profiler.html" target="_blank" rel="nofollow noreferrer noopener">Profiler API</a> 和 <a href="https://github.com/facebook/react-devtools/pull/1069" target="_blank" rel="nofollow noreferrer noopener">DevTools</a> 中使用。</p>\n<p>你可以在这里看到 <a href="https://gist.github.com/bvaughn/8de925562903afd2e7a12554adcdda16#overview" target="_blank" rel="nofollow noreferrer noopener">interaction</a> 的定义</p>\n</li>\n<li>\n<p>在 commit 阶段会触发一些生命周期钩子（如 componentDidXXX）和 hook（如 useLayoutEffect、useEffect）。</p>\n<p>在这些回调方法中可能触发新的更新，新的更新会开启新的 render-commit 流程。</p>\n</li>\n</ol>\n<h2 id="before-mutation-阶段"><a href="#before-mutation-%E9%98%B6%E6%AE%B5" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>before mutation 阶段</h2>\n<p>在本节正式开始前，让我们复习下这一章到目前为止所学的。</p>\n<p>Renderer 工作的阶段被称为 commit 阶段，commit 阶段可以分为三个子阶段：</p>\n<ul>\n<li>before mutation 阶段（执行 DOM 操作前）</li>\n<li>mutation 阶段（执行 DOM 操作）</li>\n<li>layout 阶段（执行 DOM 操作后）</li>\n</ul>\n<p>本节我们看看 before mutation 阶段（执行 DOM 操作前）都做了什么。</p>\n<h3 id="概览"><a href="#%E6%A6%82%E8%A7%88" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>概览</h3>\n<p>before mutation 阶段的代码很短，整个过程就是遍历 effectList 并调用 commitBeforeMutationEffects 函数处理。</p>\n<p>这部分源码在<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L2104-L2127" target="_blank" rel="nofollow noreferrer noopener">这里</a>。为了增加可读性，示例代码中删除了不相关的逻辑</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="87506080201027760000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// 保存之前的优先级，以同步优先级执行，执行完毕后恢复之前优先级\nconst previousLanePriority = getCurrentUpdateLanePriority();\nsetCurrentUpdateLanePriority(SyncLanePriority);\n\n// 将当前上下文标记为 CommitContext，作为 commit 阶段的标志\nconst prevExecutionContext = executionContext;\nexecutionContext |= CommitContext;\n\n// 处理 focus 状态\nfocusedInstanceHandle = prepareForCommit(root.containerInfo);\nshouldFireAfterActiveInstanceBlur = false;\n\n// beforeMutation 阶段的主函数\ncommitBeforeMutationEffects(finishedWork);\n\nfocusedInstanceHandle = null;`, `87506080201027760000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">// 保存之前的优先级，以同步优先级执行，执行完毕后恢复之前优先级</span>\n<span class="token keyword">const</span> previousLanePriority <span class="token operator">=</span> <span class="token function">getCurrentUpdateLanePriority</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token function">setCurrentUpdateLanePriority</span><span class="token punctuation">(</span>SyncLanePriority<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token comment">// 将当前上下文标记为 CommitContext，作为 commit 阶段的标志</span>\n<span class="token keyword">const</span> prevExecutionContext <span class="token operator">=</span> executionContext<span class="token punctuation">;</span>\nexecutionContext <span class="token operator">|=</span> CommitContext<span class="token punctuation">;</span>\n\n<span class="token comment">// 处理 focus 状态</span>\nfocusedInstanceHandle <span class="token operator">=</span> <span class="token function">prepareForCommit</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>containerInfo<span class="token punctuation">)</span><span class="token punctuation">;</span>\nshouldFireAfterActiveInstanceBlur <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>\n\n<span class="token comment">// beforeMutation 阶段的主函数</span>\n<span class="token function">commitBeforeMutationEffects</span><span class="token punctuation">(</span>finishedWork<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\nfocusedInstanceHandle <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>我们重点关注 beforeMutation 阶段的主函数 commitBeforeMutationEffects 做了什么。</p>\n<h3 id="commitbeforemutationeffects"><a href="#commitbeforemutationeffects" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>commitBeforeMutationEffects</h3>\n<p>大体代码逻辑：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="77254116334119880000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function commitBeforeMutationEffects() {\n  while (nextEffect !== null) {\n    const current = nextEffect.alternate;\n\n    if (!shouldFireAfterActiveInstanceBlur && focusedInstanceHandle !== null) {\n      // ...focus blur 相关\n    }\n\n    const effectTag = nextEffect.effectTag;\n\n    // 调用 getSnapshotBeforeUpdate\n    if ((effectTag & Snapshot) !== NoEffect) {\n      commitBeforeMutationEffectOnFiber(current, nextEffect);\n    }\n\n    // 调度 useEffect\n    if ((effectTag & Passive) !== NoEffect) {\n      if (!rootDoesHavePassiveEffects) {\n        rootDoesHavePassiveEffects = true;\n        scheduleCallback(NormalSchedulerPriority, () => {\n          flushPassiveEffects();\n          return null;\n        });\n      }\n    }\n    nextEffect = nextEffect.nextEffect;\n  }\n}`, `77254116334119880000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span> <span class="token function">commitBeforeMutationEffects</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">while</span> <span class="token punctuation">(</span>nextEffect <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">const</span> current <span class="token operator">=</span> nextEffect<span class="token punctuation">.</span>alternate<span class="token punctuation">;</span>\n\n    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>shouldFireAfterActiveInstanceBlur <span class="token operator">&amp;&amp;</span> focusedInstanceHandle <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token comment">// ...focus blur 相关</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token keyword">const</span> effectTag <span class="token operator">=</span> nextEffect<span class="token punctuation">.</span>effectTag<span class="token punctuation">;</span>\n\n    <span class="token comment">// 调用 getSnapshotBeforeUpdate</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>effectTag <span class="token operator">&amp;</span> Snapshot<span class="token punctuation">)</span> <span class="token operator">!==</span> NoEffect<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token function">commitBeforeMutationEffectOnFiber</span><span class="token punctuation">(</span>current<span class="token punctuation">,</span> nextEffect<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token comment">// 调度 useEffect</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>effectTag <span class="token operator">&amp;</span> Passive<span class="token punctuation">)</span> <span class="token operator">!==</span> NoEffect<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>rootDoesHavePassiveEffects<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        rootDoesHavePassiveEffects <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n        <span class="token function">scheduleCallback</span><span class="token punctuation">(</span>NormalSchedulerPriority<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n          <span class="token function">flushPassiveEffects</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n          <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n    nextEffect <span class="token operator">=</span> nextEffect<span class="token punctuation">.</span>nextEffect<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>整体可以分为三部分：</p>\n<ol>\n<li>处理 DOM 节点渲染/删除后的 autoFocus、blur 逻辑。</li>\n<li>调用 getSnapshotBeforeUpdate 生命周期钩子。</li>\n<li>调度 useEffect。</li>\n</ol>\n<p>我们讲解下 2、3 两点。</p>\n<h3 id="调用-getsnapshotbeforeupdate"><a href="#%E8%B0%83%E7%94%A8-getsnapshotbeforeupdate" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>调用 getSnapshotBeforeUpdate</h3>\n<p>commitBeforeMutationEffectOnFiber 是 commitBeforeMutationLifeCycles 的别名。</p>\n<p>在该方法内会调用 getSnapshotBeforeUpdate。</p>\n<p>你可以在<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberCommitWork.old.js#L222" target="_blank" rel="nofollow noreferrer noopener">这里</a>看到这段逻辑</p>\n<p>从 Reactv16 开始，componentWillXXX 钩子前增加了 UNSAFE_ 前缀。</p>\n<p>究其原因，是因为 Stack Reconciler 重构为 Fiber Reconciler 后，render 阶段的任务可能中断/重新开始，对应的组件在 render 阶段的生命周期钩子（即 componentWillXXX）可能触发多次。</p>\n<p>这种行为和 Reactv15 不一致，所以标记为 UNSAFE_。</p>\n<p>更详细的解释参照<a href="https://juejin.im/post/6847902224287285255#comment" target="_blank" rel="nofollow noreferrer noopener">这里</a></p>\n<p>为此，React 提供了替代的生命周期钩子 getSnapshotBeforeUpdate。</p>\n<p>我们可以看见，getSnapshotBeforeUpdate 是在 commit 阶段内的 before mutation 阶段调用的，由于 commit 阶段是同步的，所以不会遇到多次调用的问题。</p>\n<h3 id="调度-useeffect"><a href="#%E8%B0%83%E5%BA%A6-useeffect" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>调度 useEffect</h3>\n<p>在这几行代码内，scheduleCallback 方法由 Scheduler 模块提供，用于以某个优先级异步调度一个回调函数。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="20189664485699140000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// 调度 useEffect\nif ((effectTag & Passive) !== NoEffect) {\n  if (!rootDoesHavePassiveEffects) {\n    rootDoesHavePassiveEffects = true;\n    scheduleCallback(NormalSchedulerPriority, () => {\n      // 触发 useEffect\n      flushPassiveEffects();\n      return null;\n    });\n  }\n}`, `20189664485699140000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">// 调度 useEffect</span>\n<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>effectTag <span class="token operator">&amp;</span> Passive<span class="token punctuation">)</span> <span class="token operator">!==</span> NoEffect<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>rootDoesHavePassiveEffects<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    rootDoesHavePassiveEffects <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n    <span class="token function">scheduleCallback</span><span class="token punctuation">(</span>NormalSchedulerPriority<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n      <span class="token comment">// 触发 useEffect</span>\n      <span class="token function">flushPassiveEffects</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>在此处，被异步调度的回调函数就是触发 useEffect 的方法 flushPassiveEffects。</p>\n<p>我们接下来讨论 useEffect 如何被异步调度，以及为什么要异步（而不是同步）调度。</p>\n<h4 id="如何异步调度"><a href="#%E5%A6%82%E4%BD%95%E5%BC%82%E6%AD%A5%E8%B0%83%E5%BA%A6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>如何异步调度</h4>\n<p>在 flushPassiveEffects 方法内部会从全局变量 rootWithPendingPassiveEffects 获取 effectList。</p>\n<p>关于 flushPassiveEffects 的具体讲解参照 useEffect 与 useLayoutEffect 一节</p>\n<p>在 completeWork 一节我们讲到，effectList 中保存了需要执行副作用的 Fiber 节点。其中副作用包括</p>\n<ul>\n<li>插入 DOM 节点（Placement）</li>\n<li>更新 DOM 节点（Update）</li>\n<li>删除 DOM 节点（Deletion）</li>\n</ul>\n<p>除此外，当一个 FunctionComponent 含有 useEffect 或 useLayoutEffect，他对应的 Fiber 节点也会被赋值 effectTag。</p>\n<p>你可以从<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactHookEffectTags.js" target="_blank" rel="nofollow noreferrer noopener">这里</a>看到 hook 相关的 effectTag</p>\n<p>在 flushPassiveEffects 方法内部会遍历 rootWithPendingPassiveEffects（即 effectList）执行 effect 回调函数。</p>\n<p>如果在此时直接执行 <code class="language-text">rootWithPendingPassiveEffects === null</code>。</p>\n<p>那么 rootWithPendingPassiveEffects 会在何时赋值呢？</p>\n<p>在上一节 layout 之后的代码片段中会根据 <code class="language-text">rootDoesHavePassiveEffects === true</code> 决定是否赋值 rootWithPendingPassiveEffects。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="27116445416300120000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`const rootDidHavePassiveEffects = rootDoesHavePassiveEffects;\nif (rootDoesHavePassiveEffects) {\n  rootDoesHavePassiveEffects = false;\n  rootWithPendingPassiveEffects = root;\n  pendingPassiveEffectsLanes = lanes;\n  pendingPassiveEffectsRenderPriority = renderPriorityLevel;\n}`, `27116445416300120000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">const</span> rootDidHavePassiveEffects <span class="token operator">=</span> rootDoesHavePassiveEffects<span class="token punctuation">;</span>\n<span class="token keyword">if</span> <span class="token punctuation">(</span>rootDoesHavePassiveEffects<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  rootDoesHavePassiveEffects <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>\n  rootWithPendingPassiveEffects <span class="token operator">=</span> root<span class="token punctuation">;</span>\n  pendingPassiveEffectsLanes <span class="token operator">=</span> lanes<span class="token punctuation">;</span>\n  pendingPassiveEffectsRenderPriority <span class="token operator">=</span> renderPriorityLevel<span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>所以整个 useEffect 异步调用分为三步：</p>\n<ol>\n<li>before mutation 阶段在 scheduleCallback 中调度 flushPassiveEffects</li>\n<li>layout 阶段之后将 effectList 赋值给 rootWithPendingPassiveEffects</li>\n<li>scheduleCallback 触发 flushPassiveEffects，flushPassiveEffects 内部遍历 rootWithPendingPassiveEffects</li>\n</ol>\n<h4 id="为什么需要异步调用"><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>为什么需要异步调用</h4>\n<p>摘录自 React 文档 effect 的执行时机：</p>\n<p>与 componentDidMount、componentDidUpdate 不同的是，在浏览器完成布局与绘制之后，传给 useEffect 的函数会延迟调用。这使得它适用于许多常见的副作用场景，比如设置订阅和事件处理等情况，因此不应在函数中执行阻塞浏览器更新屏幕的操作。</p>\n<p>可见，useEffect 异步执行的原因主要是防止同步执行时阻塞浏览器渲染。</p>\n<h3 id="总结"><a href="#%E6%80%BB%E7%BB%93" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总结</h3>\n<p>经过本节学习，我们知道了在 before mutation 阶段，会遍历 effectList，依次执行：</p>\n<ol>\n<li>处理 DOM 节点渲染/删除后的 autoFocus、blur 逻辑</li>\n<li>调用 getSnapshotBeforeUpdate 生命周期钩子</li>\n<li>调度 useEffect</li>\n</ol>\n<h2 id="mutation-阶段"><a href="#mutation-%E9%98%B6%E6%AE%B5" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>mutation 阶段</h2>\n<p>终于到了执行 DOM 操作的 mutation 阶段</p>\n<h3 id="概览-1"><a href="#%E6%A6%82%E8%A7%88-1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>概览</h3>\n<p>类似 before mutation 阶段，mutation 阶段也是遍历 effectList，执行函数。这里执行的是 commitMutationEffects。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="46156527248860860000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`nextEffect = firstEffect;\ndo {\n  try {\n    commitMutationEffects(root, renderPriorityLevel);\n  } catch (error) {\n    invariant(nextEffect !== null, \'Should be working on an effect.\');\n    captureCommitPhaseError(nextEffect, error);\n    nextEffect = nextEffect.nextEffect;\n  }\n} while (nextEffect !== null);`, `46156527248860860000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js">nextEffect <span class="token operator">=</span> firstEffect<span class="token punctuation">;</span>\n<span class="token keyword">do</span> <span class="token punctuation">{</span>\n  <span class="token keyword">try</span> <span class="token punctuation">{</span>\n    <span class="token function">commitMutationEffects</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> renderPriorityLevel<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token function">invariant</span><span class="token punctuation">(</span>nextEffect <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token string">\'Should be working on an effect.\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token function">captureCommitPhaseError</span><span class="token punctuation">(</span>nextEffect<span class="token punctuation">,</span> error<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    nextEffect <span class="token operator">=</span> nextEffect<span class="token punctuation">.</span>nextEffect<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>nextEffect <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h3 id="commitmutationeffects"><a href="#commitmutationeffects" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>commitMutationEffects</h3>\n<p>代码如下：</p>\n<blockquote>\n<p>你可以在<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberWorkLoop.old.js#L2091" target="_blank" rel="nofollow noreferrer noopener">这里</a>看到 commitMutationEffects 源码</p>\n</blockquote>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="83879737961598340000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function commitMutationEffects(root: FiberRoot, renderPriorityLevel) {\n  // 遍历 effectList\n  while (nextEffect !== null) {\n    const effectTag = nextEffect.effectTag;\n\n    // 根据 ContentReset effectTag 重置文字节点\n    if (effectTag & ContentReset) {\n      commitResetTextContent(nextEffect);\n    }\n\n    // 更新 ref\n    if (effectTag & Ref) {\n      const current = nextEffect.alternate;\n      if (current !== null) {\n        commitDetachRef(current);\n      }\n    }\n\n    // 根据 effectTag 分别处理\n    const primaryEffectTag = effectTag & (Placement | Update | Deletion | Hydrating);\n    switch (primaryEffectTag) {\n      // 插入DOM\n      case Placement: {\n        commitPlacement(nextEffect);\n        nextEffect.effectTag &= ~Placement;\n        break;\n      }\n      // 插入 DOM 并更新 DOM\n      case PlacementAndUpdate: {\n        // 插入\n        commitPlacement(nextEffect);\n        nextEffect.effectTag &= ~Placement;\n        // 更新\n        const current = nextEffect.alternate;\n        commitWork(current, nextEffect);\n        break;\n      }\n      // SSR\n      case Hydrating: {\n        nextEffect.effectTag &= ~Hydrating;\n        break;\n      }\n      // SSR\n      case HydratingAndUpdate: {\n        nextEffect.effectTag &= ~Hydrating;\n\n        const current = nextEffect.alternate;\n        commitWork(current, nextEffect);\n        break;\n      }\n      // 更新 DOM\n      case Update: {\n        const current = nextEffect.alternate;\n        commitWork(current, nextEffect);\n        break;\n      }\n      // 删除 DOM\n      case Deletion: {\n        commitDeletion(root, nextEffect, renderPriorityLevel);\n        break;\n      }\n    }\n\n    nextEffect = nextEffect.nextEffect;\n  }\n}`, `83879737961598340000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span> <span class="token function">commitMutationEffects</span><span class="token punctuation">(</span><span class="token parameter">root<span class="token punctuation">:</span> FiberRoot<span class="token punctuation">,</span> renderPriorityLevel</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 遍历 effectList</span>\n  <span class="token keyword">while</span> <span class="token punctuation">(</span>nextEffect <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">const</span> effectTag <span class="token operator">=</span> nextEffect<span class="token punctuation">.</span>effectTag<span class="token punctuation">;</span>\n\n    <span class="token comment">// 根据 ContentReset effectTag 重置文字节点</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>effectTag <span class="token operator">&amp;</span> ContentReset<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token function">commitResetTextContent</span><span class="token punctuation">(</span>nextEffect<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token comment">// 更新 ref</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>effectTag <span class="token operator">&amp;</span> Ref<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">const</span> current <span class="token operator">=</span> nextEffect<span class="token punctuation">.</span>alternate<span class="token punctuation">;</span>\n      <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token function">commitDetachRef</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token comment">// 根据 effectTag 分别处理</span>\n    <span class="token keyword">const</span> primaryEffectTag <span class="token operator">=</span> effectTag <span class="token operator">&amp;</span> <span class="token punctuation">(</span>Placement <span class="token operator">|</span> Update <span class="token operator">|</span> Deletion <span class="token operator">|</span> Hydrating<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">switch</span> <span class="token punctuation">(</span>primaryEffectTag<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token comment">// 插入DOM</span>\n      <span class="token keyword">case</span> Placement<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n        <span class="token function">commitPlacement</span><span class="token punctuation">(</span>nextEffect<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        nextEffect<span class="token punctuation">.</span>effectTag <span class="token operator">&amp;=</span> <span class="token operator">~</span>Placement<span class="token punctuation">;</span>\n        <span class="token keyword">break</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n      <span class="token comment">// 插入 DOM 并更新 DOM</span>\n      <span class="token keyword">case</span> PlacementAndUpdate<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n        <span class="token comment">// 插入</span>\n        <span class="token function">commitPlacement</span><span class="token punctuation">(</span>nextEffect<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        nextEffect<span class="token punctuation">.</span>effectTag <span class="token operator">&amp;=</span> <span class="token operator">~</span>Placement<span class="token punctuation">;</span>\n        <span class="token comment">// 更新</span>\n        <span class="token keyword">const</span> current <span class="token operator">=</span> nextEffect<span class="token punctuation">.</span>alternate<span class="token punctuation">;</span>\n        <span class="token function">commitWork</span><span class="token punctuation">(</span>current<span class="token punctuation">,</span> nextEffect<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">break</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n      <span class="token comment">// SSR</span>\n      <span class="token keyword">case</span> Hydrating<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n        nextEffect<span class="token punctuation">.</span>effectTag <span class="token operator">&amp;=</span> <span class="token operator">~</span>Hydrating<span class="token punctuation">;</span>\n        <span class="token keyword">break</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n      <span class="token comment">// SSR</span>\n      <span class="token keyword">case</span> HydratingAndUpdate<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n        nextEffect<span class="token punctuation">.</span>effectTag <span class="token operator">&amp;=</span> <span class="token operator">~</span>Hydrating<span class="token punctuation">;</span>\n\n        <span class="token keyword">const</span> current <span class="token operator">=</span> nextEffect<span class="token punctuation">.</span>alternate<span class="token punctuation">;</span>\n        <span class="token function">commitWork</span><span class="token punctuation">(</span>current<span class="token punctuation">,</span> nextEffect<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">break</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n      <span class="token comment">// 更新 DOM</span>\n      <span class="token keyword">case</span> Update<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n        <span class="token keyword">const</span> current <span class="token operator">=</span> nextEffect<span class="token punctuation">.</span>alternate<span class="token punctuation">;</span>\n        <span class="token function">commitWork</span><span class="token punctuation">(</span>current<span class="token punctuation">,</span> nextEffect<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">break</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n      <span class="token comment">// 删除 DOM</span>\n      <span class="token keyword">case</span> Deletion<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n        <span class="token function">commitDeletion</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> nextEffect<span class="token punctuation">,</span> renderPriorityLevel<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">break</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n\n    nextEffect <span class="token operator">=</span> nextEffect<span class="token punctuation">.</span>nextEffect<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>commitMutationEffects 会遍历 effectList，对每个 Fiber 节点执行如下三个操作：</p>\n<ol>\n<li>根据 ContentReset effectTag 重置文字节点</li>\n<li>更新 ref</li>\n<li>根据 effectTag 分别处理，其中 effectTag 包括 (Placement | Update | Deletion | Hydrating)</li>\n</ol>\n<p>我们关注步骤三中的 Placement | Update | Deletion。Hydrating 作为服务端渲染相关，我们先不关注。</p>\n<h3 id="placement-effect"><a href="#placement-effect" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Placement effect</h3>\n<p>当 Fiber 节点含有 Placement effectTag，意味着该 Fiber 节点对应的 DOM 节点需要插入到页面中。</p>\n<p>调用的方法为 commitPlacement。</p>\n<blockquote>\n<p>你可以在<a href="https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberCommitWork.new.js#L1156" target="_blank" rel="nofollow noreferrer noopener">这里</a>看到 commitPlacement 源码</p>\n</blockquote>\n<p>该方法所做的工作分为三步：</p>\n<ol>\n<li>\n<p>获取父级 DOM 节点。其中 finishedWork 为传入的 Fiber 节点。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="10920700350477320000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`const parentFiber = getHostParentFiber(finishedWork);\n// 父级 DOM 节点\nconst parentStateNode = parentFiber.stateNode;`, `10920700350477320000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">const</span> parentFiber <span class="token operator">=</span> <span class="token function">getHostParentFiber</span><span class="token punctuation">(</span>finishedWork<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token comment">// 父级 DOM 节点</span>\n<span class="token keyword">const</span> parentStateNode <span class="token operator">=</span> parentFiber<span class="token punctuation">.</span>stateNode<span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span></span></pre></div>\n</li>\n<li>\n<p>获取 Fiber 节点的 DOM 兄弟节点</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="51524529067446200000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`const before = getHostSibling(finishedWork);`, `51524529067446200000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">const</span> before <span class="token operator">=</span> <span class="token function">getHostSibling</span><span class="token punctuation">(</span>finishedWork<span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n</li>\n<li>\n<p>根据 DOM 兄弟节点是否存在决定调用 parentNode.insertBefore 或 parentNode.appendChild 执行 DOM 插入操作。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="42764723971290300000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// parentStateNode 是否是 rootFiber\nif (isContainer) {\n insertOrAppendPlacementNodeIntoContainer(finishedWork, before, parent);\n} else {\n insertOrAppendPlacementNode(finishedWork, before, parent);\n}`, `42764723971290300000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">// parentStateNode 是否是 rootFiber</span>\n<span class="token keyword">if</span> <span class="token punctuation">(</span>isContainer<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n <span class="token function">insertOrAppendPlacementNodeIntoContainer</span><span class="token punctuation">(</span>finishedWork<span class="token punctuation">,</span> before<span class="token punctuation">,</span> parent<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n <span class="token function">insertOrAppendPlacementNode</span><span class="token punctuation">(</span>finishedWork<span class="token punctuation">,</span> before<span class="token punctuation">,</span> parent<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n</li>\n</ol>\n<p>值得注意的是，getHostSibling（获取兄弟 DOM 节点）的执行很耗时，当在同一个父 Fiber 节点下依次执行多个插入操作，getHostSibling 算法的复杂度为指数级。</p>\n<p>这是由于 Fiber 节点不只包括 HostComponent，所以 Fiber 树和渲染的 DOM 树节点并不是一一对应的。要从 Fiber 节点找到 DOM 节点很可能跨层级遍历。</p>\n<p>考虑如下例子：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="44863445915040416000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function Item() {\n  return <li><li>;\n}\n\nfunction App() {\n  return (\n    <div>\n      <Item/>\n    </div>\n  )\n}\n\nReactDOM.render(<App/>, document.getElementById(\'root\'));`, `44863445915040416000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                jsx 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="jsx"><pre style="counter-reset: linenumber NaN" class="language-jsx line-numbers"><code class="language-jsx"><span class="token keyword">function</span> <span class="token function">Item</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span><span class="token plain-text">;\n}\n\nfunction App() </span><span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token punctuation">(</span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span><span class="token plain-text">\n      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Item</span></span><span class="token punctuation">/></span></span><span class="token plain-text">\n    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n  <span class="token punctuation">)</span>\n<span class="token punctuation">}</span><span class="token plain-text">\n\nReactDOM.render(</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">App</span></span><span class="token punctuation">/></span></span><span class="token plain-text">, document.getElementById(\'root\'));</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>对应的 Fiber 树和 DOM 树 结构为：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="30534003264957300000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// Fiber树\n          child      child      child       child\nrootFiber -----> App -----> div -----> Item -----> li\n\n// DOM树\n#root ---> div ---> li`, `30534003264957300000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">// Fiber树\n          child      child      child       child\nrootFiber -----&gt; App -----&gt; div -----&gt; Item -----&gt; li\n\n// DOM树\n#root ---&gt; div ---&gt; li</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>当在 div 的子节点 Item 前插入一个新节点 p，即 App 变为：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="60437080267822870000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function App() {\n  return (\n    <div>\n      <p></p>\n      <Item />\n    </div>\n  );\n}`, `60437080267822870000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                jsx 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="jsx"><pre style="counter-reset: linenumber NaN" class="language-jsx line-numbers"><code class="language-jsx"><span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token punctuation">(</span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span><span class="token plain-text">\n      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token plain-text">\n      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Item</span></span> <span class="token punctuation">/></span></span><span class="token plain-text">\n    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n  <span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>对应的 Fiber 树和 DOM 树结构为：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="91391397796219200000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// Fiber树\n          child      child      child\nrootFiber -----> App -----> div -----> p\n                                       | sibling       child\n                                       | -------> Item -----> li\n// DOM树\n#root ---> div ---> p\n             |\n               ---> li`, `91391397796219200000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">// Fiber树\n          child      child      child\nrootFiber -----&gt; App -----&gt; div -----&gt; p\n                                       | sibling       child\n                                       | -------&gt; Item -----&gt; li\n// DOM树\n#root ---&gt; div ---&gt; p\n             |\n               ---&gt; li</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>此时 DOM 节点 p 的兄弟节点为 li，而 Fiber 节点 p 对应的兄弟 DOM 节点为：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="56401511914653610000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`fiberP.sibling.child`, `56401511914653610000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">fiberP.sibling.child</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>即 fiber p 的兄弟 fiber Item 的子 fiber li</p>\n<h3 id="update-effect"><a href="#update-effect" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Update effect</h3>\n<p>当 Fiber 节点含有 Update effectTag，意味着该 Fiber 节点需要更新。调用的方法为 commitWork，他会根据 Fiber.tag 分别处理。</p>\n<blockquote>\n<p>你可以在<a href="https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberCommitWork.new.js#L1441" target="_blank" rel="nofollow noreferrer noopener">这里</a>看到 commitWork 源码</p>\n</blockquote>\n<p>这里我们主要关注 FunctionComponent 和 HostComponent。</p>\n<h4 id="functioncomponent-mutation"><a href="#functioncomponent-mutation" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>FunctionComponent mutation</h4>\n<p>当 fiber.tag 为 FunctionComponent，会调用 commitHookEffectListUnmount。该方法会遍历 effectList，执行所有 useLayoutEffect hook 的销毁函数。</p>\n<blockquote>\n<p>你可以在<a href="https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberCommitWork.new.js#L314" target="_blank" rel="nofollow noreferrer noopener">这里</a>看到 commitHookEffectListUnmount 源码</p>\n</blockquote>\n<p>所谓“销毁函数”，见如下例子：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="86469379332007700000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`useLayoutEffect(() => {\n  // ...一些副作用逻辑\n\n  return () => {\n    // ...这就是销毁函数\n  };\n});`, `86469379332007700000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token function">useLayoutEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  <span class="token comment">// ...一些副作用逻辑</span>\n\n  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n    <span class="token comment">// ...这就是销毁函数</span>\n  <span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>你不需要很了解 useLayoutEffect，我们会在下一节详细介绍。你只需要知道在 mutation 阶段会执行 useLayoutEffect 的销毁函数。</p>\n<h4 id="hostcomponent-mutation"><a href="#hostcomponent-mutation" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>HostComponent mutation</h4>\n<p>当 fiber.tag 为 HostComponent，会调用 commitUpdate。</p>\n<p>你可以在<a href="https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-dom/src/client/ReactDOMHostConfig.js#L423" target="_blank" rel="nofollow noreferrer noopener">这里</a>看到 commitUpdate 源码</p>\n<p>最终会在 updateDOMProperties 中将 render 阶段 completeWork 中为 Fiber 节点赋值的 updateQueue 对应的内容渲染在页面上。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="11763953410558136000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`for (let i = 0; i < updatePayload.length; i += 2) {\n  const propKey = updatePayload[i];\n  const propValue = updatePayload[i + 1];\n\n  // 处理 style\n  if (propKey === STYLE) {\n    setValueForStyles(domElement, propValue);\n    // 处理 DANGEROUSLY_SET_INNER_HTML\n  } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {\n    setInnerHTML(domElement, propValue);\n    // 处理 children\n  } else if (propKey === CHILDREN) {\n    setTextContent(domElement, propValue);\n  } else {\n    // 处理剩余 props\n    setValueForProperty(domElement, propKey, propValue, isCustomComponentTag);\n  }\n}`, `11763953410558136000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> updatePayload<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">+=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> propKey <span class="token operator">=</span> updatePayload<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>\n  <span class="token keyword">const</span> propValue <span class="token operator">=</span> updatePayload<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n\n  <span class="token comment">// 处理 style</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>propKey <span class="token operator">===</span> <span class="token constant">STYLE</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token function">setValueForStyles</span><span class="token punctuation">(</span>domElement<span class="token punctuation">,</span> propValue<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token comment">// 处理 DANGEROUSLY_SET_INNER_HTML</span>\n  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>propKey <span class="token operator">===</span> <span class="token constant">DANGEROUSLY_SET_INNER_HTML</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token function">setInnerHTML</span><span class="token punctuation">(</span>domElement<span class="token punctuation">,</span> propValue<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token comment">// 处理 children</span>\n  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>propKey <span class="token operator">===</span> <span class="token constant">CHILDREN</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token function">setTextContent</span><span class="token punctuation">(</span>domElement<span class="token punctuation">,</span> propValue<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 处理剩余 props</span>\n    <span class="token function">setValueForProperty</span><span class="token punctuation">(</span>domElement<span class="token punctuation">,</span> propKey<span class="token punctuation">,</span> propValue<span class="token punctuation">,</span> isCustomComponentTag<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h3 id="deletion-effect"><a href="#deletion-effect" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Deletion effect</h3>\n<p>当 Fiber 节点含有 Deletion effectTag，意味着该 Fiber 节点对应的 DOM 节点需要从页面中删除。调用的方法为 commitDeletion。</p>\n<blockquote>\n<p>你可以在<a href="https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberCommitWork.new.js#L1421" target="_blank" rel="nofollow noreferrer noopener">这里</a>看到 commitDeletion 源码</p>\n</blockquote>\n<p>该方法会执行如下操作：</p>\n<ol>\n<li>递归调用 Fiber 节点及其子孙 Fiber 节点中 fiber.tag 为 ClassComponent 的 componentWillUnmount 生命周期钩子，从页面移除 Fiber 节点对应 DOM 节点</li>\n<li>解绑 ref</li>\n<li>调度 useEffect 的销毁函数</li>\n</ol>\n<h3 id="总结-1"><a href="#%E6%80%BB%E7%BB%93-1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总结</h3>\n<p>从这节我们学到，mutation 阶段会遍历 effectList，依次执行 commitMutationEffects。该方法的主要工作为“根据 effectTag 调用不同的处理函数处理 Fiber。</p>\n<h2 id="layout-阶段"><a href="#layout-%E9%98%B6%E6%AE%B5" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>layout 阶段</h2>\n<p>该阶段之所以称为 layout，因为该阶段的代码都是在 DOM 渲染完成（mutation 阶段完成）后执行的。</p>\n<p>该阶段触发的生命周期钩子和 hook 可以直接访问到已经改变后的 DOM，即该阶段是可以参与 DOM layout 的阶段。</p>\n<h3 id="概览-2"><a href="#%E6%A6%82%E8%A7%88-2" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>概览</h3>\n<p>与前两个阶段类似，layout 阶段也是遍历 effectList，执行函数。</p>\n<p>具体执行的函数是 commitLayoutEffects。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="18455696660423946000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`root.current = finishedWork;\n\nnextEffect = firstEffect;\ndo {\n  try {\n    commitLayoutEffects(root, lanes);\n  } catch (error) {\n    invariant(nextEffect !== null, \'Should be working on an effect.\');\n    captureCommitPhaseError(nextEffect, error);\n    nextEffect = nextEffect.nextEffect;\n  }\n} while (nextEffect !== null);\n\nnextEffect = null;`, `18455696660423946000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js">root<span class="token punctuation">.</span>current <span class="token operator">=</span> finishedWork<span class="token punctuation">;</span>\n\nnextEffect <span class="token operator">=</span> firstEffect<span class="token punctuation">;</span>\n<span class="token keyword">do</span> <span class="token punctuation">{</span>\n  <span class="token keyword">try</span> <span class="token punctuation">{</span>\n    <span class="token function">commitLayoutEffects</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> lanes<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token function">invariant</span><span class="token punctuation">(</span>nextEffect <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token string">\'Should be working on an effect.\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token function">captureCommitPhaseError</span><span class="token punctuation">(</span>nextEffect<span class="token punctuation">,</span> error<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    nextEffect <span class="token operator">=</span> nextEffect<span class="token punctuation">.</span>nextEffect<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>nextEffect <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\nnextEffect <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h3 id="commitlayouteffects"><a href="#commitlayouteffects" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>commitLayoutEffects</h3>\n<p>代码如下：</p>\n<blockquote>\n<p>你可以在<a href="https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L2302" target="_blank" rel="nofollow noreferrer noopener">这里</a>看到 commitLayoutEffects 源码</p>\n</blockquote>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="83499596616436330000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function commitLayoutEffects(root: FiberRoot, committedLanes: Lanes) {\n  while (nextEffect !== null) {\n    const effectTag = nextEffect.effectTag;\n\n    // 调用生命周期钩子和 hook\n    if (effectTag & (Update | Callback)) {\n      const current = nextEffect.alternate;\n      commitLayoutEffectOnFiber(root, current, nextEffect, committedLanes);\n    }\n\n    // 赋值 ref\n    if (effectTag & Ref) {\n      commitAttachRef(nextEffect);\n    }\n\n    nextEffect = nextEffect.nextEffect;\n  }\n}`, `83499596616436330000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span> <span class="token function">commitLayoutEffects</span><span class="token punctuation">(</span><span class="token parameter">root<span class="token punctuation">:</span> FiberRoot<span class="token punctuation">,</span> committedLanes<span class="token punctuation">:</span> Lanes</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">while</span> <span class="token punctuation">(</span>nextEffect <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">const</span> effectTag <span class="token operator">=</span> nextEffect<span class="token punctuation">.</span>effectTag<span class="token punctuation">;</span>\n\n    <span class="token comment">// 调用生命周期钩子和 hook</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>effectTag <span class="token operator">&amp;</span> <span class="token punctuation">(</span>Update <span class="token operator">|</span> Callback<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">const</span> current <span class="token operator">=</span> nextEffect<span class="token punctuation">.</span>alternate<span class="token punctuation">;</span>\n      <span class="token function">commitLayoutEffectOnFiber</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> current<span class="token punctuation">,</span> nextEffect<span class="token punctuation">,</span> committedLanes<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token comment">// 赋值 ref</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>effectTag <span class="token operator">&amp;</span> Ref<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token function">commitAttachRef</span><span class="token punctuation">(</span>nextEffect<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    nextEffect <span class="token operator">=</span> nextEffect<span class="token punctuation">.</span>nextEffect<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>commitLayoutEffects 一共做了两件事：</p>\n<ol>\n<li>commitLayoutEffectOnFiber（调用生命周期钩子和 hook 相关操作）</li>\n<li>commitAttachRef（赋值 ref）</li>\n</ol>\n<h3 id="commitlayouteffectonfiber"><a href="#commitlayouteffectonfiber" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>commitLayoutEffectOnFiber</h3>\n<p>commitLayoutEffectOnFiber 方法会根据 fiber.tag 对不同类型的节点分别处理。</p>\n<blockquote>\n<p>你可以在<a href="https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberCommitWork.new.js#L459" target="_blank" rel="nofollow noreferrer noopener">这里</a>看到 commitLayoutEffectOnFiber 源码（commitLayoutEffectOnFiber 为别名，方法原名为 commitLifeCycles）</p>\n</blockquote>\n<ul>\n<li>\n<p>对于 ClassComponent，他会通过 <code class="language-text">current === null</code> 区分是 mount 还是 update，调用 componentDidMount 或 componentDidUpdate。</p>\n<p>触发状态更新的 this.setState 如果赋值了第二个参数回调函数，也会在此时调用。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="62113083508780510000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`this.setState({ xxx: 1 }, () => {\nconsole.log(\'i am update~\');\n});`, `62113083508780510000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span> xxx<span class="token punctuation">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'i am update~\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span></span></pre></div>\n</li>\n<li>\n<p>对于 FunctionComponent 及相关类型，他会调用 useLayoutEffect hook 的回调函数，调度 useEffect 的销毁与回调函数</p>\n<p>相关类型指特殊处理后的 FunctionComponent，比如 ForwardRef、React.memo 包裹的 FunctionComponent</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="7489609306501843000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`switch (finishedWork.tag) {\n// 以下都是 FunctionComponent 及相关类型\ncase FunctionComponent:\ncase ForwardRef:\ncase SimpleMemoComponent:\ncase Block: {\n  // 执行 useLayoutEffect 的回调函数\n  commitHookEffectListMount(HookLayout | HookHasEffect, finishedWork);\n  // 调度 useEffect 的销毁函数与回调函数\n  schedulePassiveEffects(finishedWork);\n  return;\n}`, `7489609306501843000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">switch</span> <span class="token punctuation">(</span>finishedWork<span class="token punctuation">.</span>tag<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n<span class="token comment">// 以下都是 FunctionComponent 及相关类型</span>\n<span class="token keyword">case</span> FunctionComponent<span class="token punctuation">:</span>\n<span class="token keyword">case</span> ForwardRef<span class="token punctuation">:</span>\n<span class="token keyword">case</span> SimpleMemoComponent<span class="token punctuation">:</span>\n<span class="token keyword">case</span> Block<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 执行 useLayoutEffect 的回调函数</span>\n  <span class="token function">commitHookEffectListMount</span><span class="token punctuation">(</span>HookLayout <span class="token operator">|</span> HookHasEffect<span class="token punctuation">,</span> finishedWork<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token comment">// 调度 useEffect 的销毁函数与回调函数</span>\n  <span class="token function">schedulePassiveEffects</span><span class="token punctuation">(</span>finishedWork<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">return</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<blockquote>\n<p>你可以从<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberCommitWork.old.js#L465-L491" target="_blank" rel="nofollow noreferrer noopener">这里</a>看到这段代码</p>\n</blockquote>\n</li>\n</ul>\n<p>在上一节介绍过，mutation 阶段会执行 useLayoutEffect hook 的销毁函数。</p>\n<p>结合这里我们可以发现，useLayoutEffect hook 从上一次更新的销毁函数调用到本次更新的回调函数调用是同步执行的。</p>\n<p>而 useEffect 则需要先调度，在 Layout 阶段完成后再异步执行。</p>\n<p>这就是 useLayoutEffect 与 useEffect 的区别。</p>\n<ul>\n<li>\n<p>对于 HostRoot，即 rootFiber，如果赋值了第三个参数回调函数，也会在此时调用。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="85371911188324070000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`ReactDOM.render(<App />, document.querySelector(\'#root\'), function() {\nconsole.log(\'i am mount~\');\n});`, `85371911188324070000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js">ReactDOM<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>App <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">,</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">\'#root\'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'i am mount~\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span></span></pre></div>\n</li>\n</ul>\n<h3 id="commitattachref"><a href="#commitattachref" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>commitAttachRef</h3>\n<p>commitLayoutEffects 会做的第二件事是 commitAttachRef。</p>\n<blockquote>\n<p>你可以在<a href="https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberCommitWork.new.js#L823" target="_blank" rel="nofollow noreferrer noopener">这里</a>看到 commitAttachRef 源码</p>\n</blockquote>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="15969268749294875000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function commitAttachRef(finishedWork: Fiber) {\n  const ref = finishedWork.ref;\n  if (ref !== null) {\n    const instance = finishedWork.stateNode;\n\n    // 获取 DOM 实例\n    let instanceToUse;\n    switch (finishedWork.tag) {\n      case HostComponent:\n        instanceToUse = getPublicInstance(instance);\n        break;\n      default:\n        instanceToUse = instance;\n    }\n\n    if (typeof ref === \'function\') {\n      // 如果 ref 是函数形式，调用回调函数\n      ref(instanceToUse);\n    } else {\n      // 如果 ref 是 ref 实例形式，赋值 ref.current\n      ref.current = instanceToUse;\n    }\n  }\n}`, `15969268749294875000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span> <span class="token function">commitAttachRef</span><span class="token punctuation">(</span><span class="token parameter">finishedWork<span class="token punctuation">:</span> Fiber</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> ref <span class="token operator">=</span> finishedWork<span class="token punctuation">.</span>ref<span class="token punctuation">;</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>ref <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">const</span> instance <span class="token operator">=</span> finishedWork<span class="token punctuation">.</span>stateNode<span class="token punctuation">;</span>\n\n    <span class="token comment">// 获取 DOM 实例</span>\n    <span class="token keyword">let</span> instanceToUse<span class="token punctuation">;</span>\n    <span class="token keyword">switch</span> <span class="token punctuation">(</span>finishedWork<span class="token punctuation">.</span>tag<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">case</span> HostComponent<span class="token punctuation">:</span>\n        instanceToUse <span class="token operator">=</span> <span class="token function">getPublicInstance</span><span class="token punctuation">(</span>instance<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">break</span><span class="token punctuation">;</span>\n      <span class="token keyword">default</span><span class="token punctuation">:</span>\n        instanceToUse <span class="token operator">=</span> instance<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> ref <span class="token operator">===</span> <span class="token string">\'function\'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token comment">// 如果 ref 是函数形式，调用回调函数</span>\n      <span class="token function">ref</span><span class="token punctuation">(</span>instanceToUse<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n      <span class="token comment">// 如果 ref 是 ref 实例形式，赋值 ref.current</span>\n      ref<span class="token punctuation">.</span>current <span class="token operator">=</span> instanceToUse<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>代码逻辑很简单：获取 DOM 实例，更新 ref。</p>\n<h3 id="current-fiber-树切换"><a href="#current-fiber-%E6%A0%91%E5%88%87%E6%8D%A2" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>current Fiber 树切换</h3>\n<p>至此，整个 layout 阶段就结束了。</p>\n<p>在结束本节的学习前，我们关注下这行代码：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="16675690754418948000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`root.current = finishedWork;`, `16675690754418948000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js">root<span class="token punctuation">.</span>current <span class="token operator">=</span> finishedWork<span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<blockquote>\n<p>你可以在<a href="https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L2022" target="_blank" rel="nofollow noreferrer noopener">这里</a>看到这行代码</p>\n</blockquote>\n<p>在双缓存机制一节我们介绍过，workInProgress Fiber 树在 commit 阶段完成渲染后会变为 current Fiber 树。这行代码的作用就是切换 fiberRootNode 指向的 current Fiber 树。</p>\n<p>那么这行代码为什么在这里呢？（在 mutation 阶段结束后，layout 阶段开始前。）</p>\n<p>我们知道 componentWillUnmount 会在 mutation 阶段执行。此时 current Fiber 树还指向前一次更新的 Fiber 树，在生命周期钩子内获取的 DOM 还是更新前的。</p>\n<p>componentDidMount 和 componentDidUpdate 会在 layout 阶段执行。此时 current Fiber 树已经指向更新后的 Fiber 树，在生命周期钩子内获取的 DOM 就是更新后的。</p>\n<h3 id="总结-2"><a href="#%E6%80%BB%E7%BB%93-2" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总结</h3>\n<p>从这节我们学到，layout 阶段会遍历 effectList，依次执行 commitLayoutEffects。该方法的主要工作为“根据 effectTag 调用不同的处理函数处理 Fiber 并更新 ref。</p>',
id:"/github/workspace/blog/React技术解密笔记——架构篇/index.md absPath of file >>> MarkdownRemark",timeToRead:27,frontmatter:{date:"2021-01-21 17:34:36",path:"/react-technology-notes-framework/",tags:"前端, React, 高级前端",title:"React技术解密笔记——架构篇",draft:null}}],length:20,tag:"高级前端",pagesSum:4,page:2}}}});