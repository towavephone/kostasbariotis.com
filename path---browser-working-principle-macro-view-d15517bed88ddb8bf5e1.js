webpackJsonp([0xbc30a3da7eca],{1058:function(n,a){n.exports={data:{file:{childImageSharp:{sizes:{base64:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAeCAYAAAAsEj5rAAAACXBIWXMAAAsSAAALEgHS3X78AAAHlUlEQVRIx11WaWxU1xWewbQlrdofkSIhGiBpMPZ4Vs/2lpm3zupZPOOZ8Sz2YGzANkaAKaYQUrMkLYgiIlxCQjCYQAwYEoMQNJAIFBxaQgUhoCopYceBJo1pKFVDCbOc0/fesOZKV+fM1Tvf/c56R0VYOZW8lvAxtSybvbExAu1+mndGuaDQ2F4rNHVFhCZJZlMeZ1Qrf9Mt+H+qur/ihFORAFA64J0pVTcXVcDmcKFfruIzZ7rY1H89fAZivjbM1MzFxkAnZqWd9M7KJcTmv7zCN44sY+tflm12C79WLxLCqidWN9cwWpYvsfXL13vasZudgm4mgX4hW6h1teRjnrZCwjOzWO/twIR/FjZ7WnEZ35JvcUSeU4gwSXV7W1sJzEH6R8nSRArlXjr6r7S1DqNUvMAzCXCzSfDxDRAUmyDkaoawtEPi1LxHyGLMkby5gEqUy7atjnq1roosAXqE6Yq7DBXa7RLS6HRG8y4hhbwzDiJbj4IkXUwS5e1h07IOorMePUL6ruiKGmRblg2PesJlq9nxrJMMfydIbhIWP9jMPrBLkrIHgXfG0CdmgKMjwFARFKVvHEQo5xUyKDDRN2T7aE17mV5rfZQYm1lM0EQYWUe0aNTxoKl0Qnk5jVqNA/VaFu3SBS7SB7Ju0ougr2KKWg2DBi17mbCaxyghMzgeMTTp2W7CGkTKHshZqn0Q5Osg6opBhAmAzcADY/NheyQJBi2D8mXVehYMOgEsJg9aTIxSN2YTO+ohQ62G6rGZa5AmAjmj0YvzG5vhVP8f4fTO12FtVxfMjTfC6zPbwOsIQNybhK6GlmLCm5DA6cu2aoeSaaOeVheLxRKgpoJcZ5UAly94MeeiQ+jnQtBCcTBTZ8Ght9fDfy58DDdOHIRj2zdA/4uzYWBpZ6Fr6jR8/lfWP8n2usqA2mQgH7msr3Ks0WgEfGvN6lz/q6tgXqgZjgpZOGSLwsldA4CFG4j3rmP/osU47xkdrm5pLfjdETm+p64cf0fJME34HiVFV+VYajF50UGGc/Nnz4XDfW/ArQ09+M++XsCblwD+fQEL356HswuWwdedS+Dg2p5ilZQwa7VrpCHZ9nOl7Ojg44B0hxxg0hbMjx2rh2iwDk4feReKI58hfn8V8c5lwNyXiF+dRbz4Z1jY1g4TJ1rQbnHfc/ORihJDr5q0kw8AyVqDjpeSEpJLAyaMN6HRwMDuTa/B1fcPwcfbBuHc8SPw+cnDsGvzeim7HOg0DpAYoouPBWUMJxUo65y18X4MtbYJOo3zjgQoxwWen1iNDdPmwPu9+2BvfCXsXbQRehf9Hly0B8aN04OuioGqCipvt/hQ5GLzS4Dh0Tdv3+/nvm0qVVUlfUouboOWK8jxmaznMBXIwpbfroWN63th384tcHTfDpj0gg21lQxoK+m8TQGMb5UxAt6OUYSVkUuGK5MPKiuIHicZwWqDmNNqpE6pIFBjpGDxsqXwuxUroWtBN5w4NgSbNvcDIRW61CUFu9UrtV/si7Fjf/ajUmICSvxKgJMtdQxVK2XOU9RpGNBL3VBeQWIqPR3SjR3QOW8xrFmxCnrWbYJMaobEkr1HE/4zIpv4nrK7NIrbpF+tspoYZdpMLte+wNPRu6S1Bs1GqV/1DOqMPFjIMFbq3dg6cyFkGmagqZqHaoOAHF2XZ6ngWg+XBM4RVoLHOWrLVG4uWpo4FvsvfHz6NktFkbT6QafnQGsUoFLHYm1dFj44cgwYPgQVkymkbP6RWl+LNIRjL/uFhltuNjEoYySCXaNUojOsMPSw4aqwa+o9ga5DggiC1RFDmyMG1bYQVlTSIIhRMJq9RaPZJ4VF+DQZ6MCAmOkLurJ/DYiNt/R67VMKs4hrqjL+o+6mjrj0hjBEOG+1h8FOxcFO1oHVFgazPYQGqdfNthBYpUqwEME78nsT4tP7o96WwWSwA1nKb35iyCZ8M85EXE3oYBO3ab4RKWcSKCaFJJMCQprSpPQcUFwKzWQUKo1+lC9x0r7Fcc+0OVOj8zEkNrY8BAuLDV11ruZvDXrhuJ3NIu+bAYK/FXjfdOA8zegUp6DdmQKNMQD+8HTseW1LYeijE/jB4Q+/Wry8a5L01B6MeaetUcDSjfVjjOVM7da+bTMPvHfkbmrKb5DksjkLncmZqXTe6siAnWmAmkhbYUPvQP7cufO5L69fxyvD/8Ctb+/aI2PU8AmvRGqZAoiIityzb8/T165d3X3t2vD/Pjr+KW7b+R6u2/AOrli9CQfePYQXLg3jpSvDeOLkWTxw6Oh3uwYPrJTMlNHlFcLPeNk6/UOXZ7cuGP1A397fP/7v584vvzJ8o+dvn33+Zm/v9q9X/2EDbN+19+ybm3ds33/ww5f63uovf/D9woVL1A90P5dQqYaGhpQfg4N71BJbteoHqyk7Z+e8zlfuSupPHj+/eO2bso5ZcxQ9Fsiqgny6ZOv3+VTfjIwo+iefnFYN7BxQf3FxuEwGH1c+fgxBuIZnTFuIIh9U2qt3844fb9y0Vf0gXPKm7bzKzYZ+wGTKFFWNz1/6v8OLUiuaFKMJz00yEvaa/RQZnK086s6MutpEqRLx+kcT+rH1f+YikeeNfqnwAAAAAElFTkSuQmCC",aspectRatio:.6666666666666666,src:"/static/avatar-a4ccbab8e7381acb89452773ce94d5a0-25c91.png",srcSet:"/static/avatar-a4ccbab8e7381acb89452773ce94d5a0-8a97b.png 200w,\n/static/avatar-a4ccbab8e7381acb89452773ce94d5a0-0fdf3.png 400w,\n/static/avatar-a4ccbab8e7381acb89452773ce94d5a0-25c91.png 600w",srcWebp:"/static/avatar-a4ccbab8e7381acb89452773ce94d5a0-216f6.webp",srcSetWebp:"/static/avatar-a4ccbab8e7381acb89452773ce94d5a0-5d70e.webp 200w,\n/static/avatar-a4ccbab8e7381acb89452773ce94d5a0-d1677.webp 400w,\n/static/avatar-a4ccbab8e7381acb89452773ce94d5a0-216f6.webp 600w",sizes:"(max-width: 600px) 100vw, 600px"}}},site:{siteMetadata:{title:"女王控的博客",description:'前端工程师，黑猫女王控，欢迎勾搭，技术相关<a href="https://github.com/towavephone" target="_blank">@towavephone</a>，QQ闲聊<a href="tencent://AddContact/?fromId=45&fromSubId=1&subcmd=all&uin=634407147&website=www.oicqzone.com">@towave</a>，bili关注<a href="https://space.bilibili.com/11507708#/" target="_blank">@towave</a>',siteUrl:"https://blog.towavephone.com"}},mainPost:{html:'<h1 id="chrome-架构"><a href="#chrome-%E6%9E%B6%E6%9E%84" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Chrome 架构</h1>\n<p>在开始之前，我们一起看下，Chrome 打开一个页面需要启动多少进程？你可以点击 Chrome 浏览器右上角的“选项”菜单，选择“更多工具”子菜单，点击“任务管理器”，这将打开 Chrome 的任务管理器的窗口，如下图</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-01-16-58-08-24d148ec13da8eb39ea10a69aab6b6c8-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 59.982486865148864%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAB+UlEQVQoz4WQ3U4TURDH9yWMLWBtz36c/Tx7drsfLSDdLgVEAjTRmJCAd6WlGLoSL1Bky8KiItrt9hHUGwlemfgCvpiz5QYulOSXyZw58/9nZpg/v36nb1qHg17v9X4Q7O8FweG7ow8fz88/XUAShsdhPzoK+wcHb3vBq71eABHatrc7Py4vmcHFZ4weUksXsChiGWNJlBRF0VSVqBqxbReiYVoaoaIkm+UssZ3KxOSDMOwzSZIalVrNm9eIrhsmNcsQiU5FWdGpubrWtN1KdWbWrc4oKll8vDzn1Z8+ey7JShyfMelwmLPWao0n9bpPdIPoJmhUQkuI5wVxruYtLCxxHHbcKmL5YolVNd2fbzhOJYpOmGQ46u22m+tNy66AvVm2y5Zj2S6MJ2DJq/u+38BYhm4Qg52m0UZj0bKcKDplBkk6PW14nqeoOieIsLMwBnKWE2AKkIEGVoInx2NRVl23KsvqyWnMpOno3v08fLAsn8UbcJyAEFcqsdcJN65kbayQy03EZ+8zMZwODMH1Fhz+VwWmm5wqxPFYnM9P8QJGmWUGGsPeAN0G9CAZXzsdFYuIUlPT9DshhAKGUUaIzcYefEkKhaJpWtcf/wHEs4+8peWVldV1VaP944i5uvq5sbHZ6XRbrfadtNs7nZ1ud/fl5taLr9++/wVH6rYYMlmo1gAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 01 16 58 08"\n        title=""\n        src="/static/2021-07-01-16-58-08-24d148ec13da8eb39ea10a69aab6b6c8-fee1c.png"\n        srcset="/static/2021-07-01-16-58-08-24d148ec13da8eb39ea10a69aab6b6c8-a67b7.png 200w,\n/static/2021-07-01-16-58-08-24d148ec13da8eb39ea10a69aab6b6c8-0b187.png 400w,\n/static/2021-07-01-16-58-08-24d148ec13da8eb39ea10a69aab6b6c8-fee1c.png 800w,\n/static/2021-07-01-16-58-08-24d148ec13da8eb39ea10a69aab6b6c8-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>和 Windows 任务管理器一样，Chrome 任务管理器也是用来展示运行中 Chrome 使用的进程信息的。从图中可以看到，Chrome 启动了 4 个进程，你也许会好奇，只是打开了 1 个页面，为什么要启动这么多进程呢？</p>\n<p>在解答这个问题之前，我们需要了解一下进程的概念，不过由于好多人容易把进程和线程的概念混淆，从而影响后续其他概念的理解，所以这里我就将这两个概念以及它们之间的关系一并为你讲解下。</p>\n<h2 id="进程和线程"><a href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>进程和线程</h2>\n<p>不过，在介绍进程和线程之前，我需要先讲解下什么是并行处理，因为如果你理解了并行处理的概念，那么再理解进程和线程之间的关系就会变得轻松许多。</p>\n<h3 id="什么是并行处理"><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>什么是并行处理</h3>\n<p>计算机中的并行处理就是同一时刻处理多个任务，比如我们要计算下面这三个表达式的值，并显示出结果</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="80115869826279930000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`A = 1+2\nB = 20/5\nC = 7*8`, `80115869826279930000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">A = 1+2\nB = 20/5\nC = 7*8</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span></span></pre></div>\n<p>在编写代码的时候，我们可以把这个过程拆分为四个任务：</p>\n<ul>\n<li>任务 1 是计算 A=1+2；</li>\n<li>任务 2 是计算 B=20/5；</li>\n<li>任务 3 是计算 C=7*8；</li>\n<li>任务 4 是显示最后计算的结果</li>\n</ul>\n<p>正常情况下程序可以使用单线程来处理，也就是分四步按照顺序分别执行这四个任务。</p>\n<p>如果采用多线程，会怎么样呢？我们只需分“两步走”：第一步，使用三个线程同时执行前三个任务；第二步，再执行第四个显示任务。</p>\n<p>通过对比分析，你会发现用单线程执行需要四步，而使用多线程只需要两步。因此，使用并行处理能大大提升性能</p>\n<h3 id="线程-vs-进程"><a href="#%E7%BA%BF%E7%A8%8B-vs-%E8%BF%9B%E7%A8%8B" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>线程 VS 进程</h3>\n<p>多线程可以并行处理任务，但是线程是不能单独存在的，它是由进程来启动和管理的。那什么又是进程呢？</p>\n<p>一个进程就是一个程序的运行实例。详细解释就是，启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫进程。</p>\n<p>为了让你更好地理解上述计算过程，我画了下面这张对比图</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-01-17-00-46-687c7cb62d625aa36a786fa5988d5ff2-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 50.350262697022764%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABxElEQVQozyVSy4rUQBSNS3d+gxvXCuJWEPwKEcGNf6H+y9AiKPhixI2CIqgLRZmVzPRgku7pVKXer1RVkvKk+5JUHW7Vuffce6sqpSil/tW1kLJt2/V6zTmHc9zbNE1N03RdRwhZn58DD8Mwz/PhqNJKsZ4KxiQliuw4IT0h3nsHM4ZR6izMbJqG9f3i01owAGuMqZSU2IP3LWU14cZYqzUOcC8iixJzDCnnBQwOCVMIo1UpeNyqrHM5Ru7C7eP2yrP6xakocxJKp5S8Mfc+d/e/kFLy41/80TdWcvxJ3M3j3ZszMXmQrdNSCj9ce0erI7I6VbgqtPEh8J4+/S2f/IFnvPPh4uqri+TdCTEPv6tPtUxOV5CIGqSPN95uL622q7+iJC+1gb+nNKc0paGU+cHX/u5HtijytkxjGlCor/ADCBeuv26qo+b5mTrIzjkLAUERX5nnnXJbHZaaUwoxQReaUjnvI8g23HpPLr/kII+ac6VAllLGvWE2kAADOe8tHMjIjG4jxEmnfmwktaFMk9ZLwxjDdHrkx9gZ58DzNCEWZo5xLLKxIQPeiaKk3zRWK4x1iWgt/ODjzSAPVuCDH1FwBPAfWE0ipIeX/78AAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 01 17 00 46"\n        title=""\n        src="/static/2021-07-01-17-00-46-687c7cb62d625aa36a786fa5988d5ff2-fee1c.png"\n        srcset="/static/2021-07-01-17-00-46-687c7cb62d625aa36a786fa5988d5ff2-a67b7.png 200w,\n/static/2021-07-01-17-00-46-687c7cb62d625aa36a786fa5988d5ff2-0b187.png 400w,\n/static/2021-07-01-17-00-46-687c7cb62d625aa36a786fa5988d5ff2-fee1c.png 800w,\n/static/2021-07-01-17-00-46-687c7cb62d625aa36a786fa5988d5ff2-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从图中可以看到，线程是依附于进程的，而进程中使用多线程并行处理能提升运算效率。</p>\n<p>总结来说，进程和线程之间的关系有以下 4 个特点</p>\n<ol>\n<li>\n<p>进程中的任意一线程执行出错，都会导致整个进程的崩溃。</p>\n<p>我们可以模拟以下场景：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="30158571809324552000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`A = 1+2\nB = 20/0\nC = 7*8`, `30158571809324552000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">A = 1+2\nB = 20/0\nC = 7*8</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span></span></pre></div>\n<p>我把上述三个表达式稍作修改，在计算 B 的值的时候，我把表达式的分母改成 0，当线程执行到 B = 20/0 时，由于分母为 0，线程会执行出错，这样就会导致整个进程的崩溃，当然另外两个线程执行的结果也没有了</p>\n</li>\n<li>\n<p>线程之间共享进程中的数据。</p>\n<p>如下图所示，线程之间可以对进程的公共数据进行读写操作。</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-01-18-39-03-ef151acdbd0c54e8f3aa8a46d03f6465-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 69.0893169877408%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAIAAACgpqunAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACHUlEQVQoz41TS6rUQBTNDkRwDc6cOHULDgUnLkFwI4IbcCCCqCMfDwRx4ESegg4c+aDblv4nnU+lfql/VeLJSyv9Zp5Uqkjdczn3l2y4jr7vsVPG5vM59qqqFovfy+UyL/LRep2cpb6XQgjGBGdGdUYppy2nlJSVoPRQ5FVRVIcDb6lVWncdFu4F5zHGDC++ASV48sE6e6AHF1wlKmVUnucgQKQRjdQScQXnOs4h5pzLUkpKSoQ7pCTbijHSCuKcJbzpFJe0SjH1MVFB4Kw6Jtsa0Ts7YlSWUjqjvGKDJkMM2miDZc0Q/GC5N6NVaeW974PFTTCd6sSkHK11Qx+CYVISG6LHk2JIwYUgBfFdPfjORY+YtfOcVUGTYISFM5SVsUO0L2fs1hm5c54zrVFXprpHn3a33+WvZhQ5owqtdvfeb2+82Z0tBQjwGnNuGVO0+bBsH37hj7/WwhjYuNL3P+5vvt0//9nA2UYPrSffyIPP5CKXICCxDIayLNFP3aGYyMEoq0Lyu7a8e77OXjdPf+yHwQunQ/DeGiQUrIkpHQuGAzVDs1FzY0yI4UpZvrgsn12K7/sxbIxDgJe1Ez/9c0bd2hPAMA4TKonGGpGsnuYJTEIICBA4OuOAZl3XMKxWq6IozBW01qvNZvZrATa6Ot1s1uvlasWFQIPQuWya5wmTQvqL6Sad4DjT0bZ1SSnLTv+H/wGYNpjtfts0zR8aWRcchjLahQAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 01 18 39 03"\n        title=""\n        src="/static/2021-07-01-18-39-03-ef151acdbd0c54e8f3aa8a46d03f6465-fee1c.png"\n        srcset="/static/2021-07-01-18-39-03-ef151acdbd0c54e8f3aa8a46d03f6465-a67b7.png 200w,\n/static/2021-07-01-18-39-03-ef151acdbd0c54e8f3aa8a46d03f6465-0b187.png 400w,\n/static/2021-07-01-18-39-03-ef151acdbd0c54e8f3aa8a46d03f6465-fee1c.png 800w,\n/static/2021-07-01-18-39-03-ef151acdbd0c54e8f3aa8a46d03f6465-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从上图可以看出，线程 1、线程 2、线程 3 分别把执行的结果写入 A、B、C 中，然后线程 2 继续从 A、B、C 中读取数据，用来显示执行结果。</p>\n</li>\n<li>\n<p>当一个进程关闭之后，操作系统会回收进程所占用的内存。</p>\n<p>当一个进程退出时，操作系统会回收该进程所申请的所有资源；即使其中任意线程因为操作不当导致内存泄漏，当进程退出时，这些内存也会被正确回收。</p>\n<p>比如之前的 IE 浏览器，支持很多插件，而这些插件很容易导致内存泄漏，这意味着只要浏览器开着，内存占用就有可能会越来越多，但是当关闭浏览器进程时，这些内存就都会被系统回收掉</p>\n</li>\n<li>\n<p>进程之间的内容相互隔离。</p>\n<p>进程隔离是为保护操作系统中进程互不干扰的技术，每一个进程只能访问自己占有的数据，也就避免出现进程 A 写入数据到进程 B 的情况。正是因为进程之间的数据是严格隔离的，所以一个进程如果崩溃了，或者挂起了，是不会影响到其他进程的。如果进程之间需要进行数据的通信，这时候就需要使用用于进程间通信（IPC）的机制了。</p>\n</li>\n</ol>\n<h2 id="单进程浏览器时代"><a href="#%E5%8D%95%E8%BF%9B%E7%A8%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E6%97%B6%E4%BB%A3" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>单进程浏览器时代</h2>\n<p>在了解了进程和线程之后，我们再来一起看下单进程浏览器的架构。顾名思义，单进程浏览器是指浏览器的所有功能模块都是运行在同一个进程里，这些模块包含了网络、插件、JavaScript 运行环境、渲染引擎和页面等。其实早在 2007 年之前，市面上浏览器都是单进程的。单进程浏览器的架构如下图所示</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-02-10-33-23-b0f62bc9971ee98ba6e5c476f2936afd-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 41.06830122591944%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAIAAAB2/0i6AAAACXBIWXMAAA7DAAAOwwHHb6hkAAABe0lEQVQY03WQO2ocQRCGJxY4MCjyBZzpBgYfwBdwrsgXcKo76ABGWgmBwcIvzAYyxpESG4G8Qjvsg5Xm1dsz3dOP6q6ex86o11orkn+KCrr5+H4q6P+l6zq/8zyP45gQkiQJADy8P5rA/yGiBmPQ1XXDOV/cRrRglFKltUE0xjZN81/YA8hp39raoZISaNKvKuewrV2nCiiZsXbT7n7+Zg2vViu09nAi3/7iV4X18v3Q7I8B0X2LYG8EVwz7pjIWRVmWN4syjkshvMPza7MBeDEsguPyaA7gqq1Tvv1JSIOvz2VwLA4myhfhUuVRlF9cFKM/LMsY5966hv1hXv3kT7/q9wursHo+FDtnugB881s/+aIHM+i7mgnJ05SHYz6b8izzJdq23ZhfDpfBgJ7MtXHV9gfy7CP15t1zFgyW765Zo3hyG5HphIQhGY1IOF6m6Qa2xvyY04PLZF5Ih3g2zb7PiLX2MmGfr9ObvKz99SxqIUBrUEpL6REP3gEh5689LMhejQAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 02 10 33 23"\n        title=""\n        src="/static/2021-07-02-10-33-23-b0f62bc9971ee98ba6e5c476f2936afd-fee1c.png"\n        srcset="/static/2021-07-02-10-33-23-b0f62bc9971ee98ba6e5c476f2936afd-a67b7.png 200w,\n/static/2021-07-02-10-33-23-b0f62bc9971ee98ba6e5c476f2936afd-0b187.png 400w,\n/static/2021-07-02-10-33-23-b0f62bc9971ee98ba6e5c476f2936afd-fee1c.png 800w,\n/static/2021-07-02-10-33-23-b0f62bc9971ee98ba6e5c476f2936afd-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>如此多的功能模块运行在一个进程里，是导致单进程浏览器不稳定、不流畅和不安全的一个主要因素。下面我就来一一分析下出现这些问题的原因</p>\n<h3 id="不稳定"><a href="#%E4%B8%8D%E7%A8%B3%E5%AE%9A" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>不稳定</h3>\n<p>早期浏览器需要借助于插件来实现诸如 Web 视频、Web 游戏等各种强大的功能，但是插件是最容易出问题的模块，并且还运行在浏览器进程之中，所以一个插件的意外崩溃会引起整个浏览器的崩溃。</p>\n<p>除了插件之外，渲染引擎模块也是不稳定的，通常一些复杂的 JavaScript 代码就有可能引起渲染引擎模块的崩溃。和插件一样，渲染引擎的崩溃也会导致整个浏览器的崩溃</p>\n<h3 id="不流畅"><a href="#%E4%B8%8D%E6%B5%81%E7%95%85" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>不流畅</h3>\n<p>从上面的“单进程浏览器架构示意图”可以看出，所有页面的渲染模块、JavaScript 执行环境以及插件都是运行在同一个线程中的，这就意味着同一时刻只能有一个模块可以执行。</p>\n<p>比如，下面这个无限循环的脚本：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="58550226762517774000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function freeze() {\n  while (1) {\n    console.log(\'freeze\');\n  }\n}\nfreeze();`, `58550226762517774000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span> <span class="token function">freeze</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'freeze\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n<span class="token function">freeze</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>如果让这个脚本运行在一个单进程浏览器的页面里，你感觉会发生什么？</p>\n<p>因为这个脚本是无限循环的，所以当其执行时，它会独占整个线程，这样导致其他运行在该线程中的模块就没有机会被执行。因为浏览器中所有的页面都运行在该线程中，所以这些页面都没有机会去执行任务，这样就会导致整个浏览器失去响应，变卡顿。这块内容要继续往深的地方讲就到页面的事件循环系统了，具体相关内容会在后面的模块中为你深入讲解。</p>\n<p>除了上述脚本或者插件会让单进程浏览器变卡顿外，页面的内存泄漏也是单进程变慢的一个重要原因。通常浏览器的内核都是非常复杂的，运行一个复杂点的页面再关闭页面，会存在内存不能完全回收的情况，这样导致的问题是使用时间越长，内存占用越高，浏览器会变得越慢。</p>\n<h3 id="不安全"><a href="#%E4%B8%8D%E5%AE%89%E5%85%A8" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>不安全</h3>\n<p>这里依然可以从插件和页面脚本两个方面来解释该原因。</p>\n<p>插件可以使用 C/C++ 等代码编写，通过插件可以获取到操作系统的任意资源，当你在页面运行一个插件时也就意味着这个插件能完全操作你的电脑。如果是个恶意插件，那么它就可以释放病毒、窃取你的账号密码，引发安全性问题。</p>\n<p>至于页面脚本，它可以通过浏览器的漏洞来获取系统权限，这些脚本获取系统权限之后也可以对你的电脑做一些恶意的事情，同样也会引发安全问题。</p>\n<p>以上这些就是当时浏览器的特点，不稳定，不流畅，而且不安全。这是一段不堪回首的过去，也许你没有经历过，不过你可以想象一下这样的场景：当你正在用浏览器打开多个页面时，突然某个页面崩溃了或者失去响应，随之而来的是整个浏览器的崩溃或者无响应，然后你发现你给老板写的邮件页面也随之消失了，这时你的心情会不会和页面一样崩溃呢</p>\n<h2 id="多进程浏览器时代"><a href="#%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E6%97%B6%E4%BB%A3" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>多进程浏览器时代</h2>\n<p>好在现代浏览器已经解决了这些问题，是如何解决的呢？这就得聊聊我们这个“多进程浏览器时代”了</p>\n<h3 id="早期多进程架构"><a href="#%E6%97%A9%E6%9C%9F%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%9E%B6%E6%9E%84" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>早期多进程架构</h3>\n<p>你可以先看看下面这张图，这是 2008 年 Chrome 发布时的进程架构。</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-02-10-41-39-bd2a4bd820e0f87d8d65b603e1e31eca-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 63.48511383537654%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAIAAAAmMtkJAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABtklEQVQoz3VR30sbQRD27y99CKXQl7bgS+tjRCkVX5RWKKhgsMWYYvFuL/dz7y6X/b2zu+ncRWOl8WNYdmfmm292Zmf1Agi303J5W7GbimXCoif8l7OznRr83l03+v7n/fHk1Xn2lbDeFbaSwyM2bu/27haji/TD6c3ri/yILNEFAfl9ieEMLyuvwmHEds/vP59NP16Sk2TZK2xpOwQnpWFMdh1w7gH6ws55zmRTpzGRNV05yLkZ35bjGd2f0fG0/Ba3A9k7ZKZZRgjp2hbJznswWneLLE2TOCqLAgQ/i+joy9W78Y+3R5M3B5efJvN128FpxbtOMKaFCN4/9I1VjLFKoaHAHJV/zg+vooNf8/3r5DRqerL3XkqplJJCKK3xsuw6SmnTNG3bcs7VAAyA1T74Z38GACEEnnYA1qoojeKYJEmR5845CxYGYGkUeVjOhozK8A9EU7Oq4mWpsKhzG78xOAntfb8nfG4jo7rg4vdMJnHPs08RY62Ssl+HgwWuBuB52wCaM1VTkRBZFHixRttHaGOk4AE9Wud5Xtf108CUXE9Go2EeGj7WkTUwDXvBjj04Wvf4C6TU5K4TgcwjAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 02 10 41 39"\n        title=""\n        src="/static/2021-07-02-10-41-39-bd2a4bd820e0f87d8d65b603e1e31eca-fee1c.png"\n        srcset="/static/2021-07-02-10-41-39-bd2a4bd820e0f87d8d65b603e1e31eca-a67b7.png 200w,\n/static/2021-07-02-10-41-39-bd2a4bd820e0f87d8d65b603e1e31eca-0b187.png 400w,\n/static/2021-07-02-10-41-39-bd2a4bd820e0f87d8d65b603e1e31eca-fee1c.png 800w,\n/static/2021-07-02-10-41-39-bd2a4bd820e0f87d8d65b603e1e31eca-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从图中可以看出，Chrome 的页面是运行在单独的渲染进程中的，同时页面里的插件也是运行在单独的插件进程之中，而进程之间是通过 IPC 机制进行通信（如图中虚线部分）。</p>\n<p><strong>我们先看看如何解决不稳定的问题</strong>。由于进程是相互隔离的，所以当一个页面或者插件崩溃时，影响到的仅仅是当前的页面进程或者插件进程，并不会影响到浏览器和其他页面，这就完美地解决了页面或者插件的崩溃会导致整个浏览器崩溃，也就是不稳定的问题。</p>\n<p><strong>接下来再来看看不流畅的问题是如何解决的</strong>。同样，JavaScript 也是运行在渲染进程中的，所以即使 JavaScript 阻塞了渲染进程，影响到的也只是当前的渲染页面，而并不会影响浏览器和其他页面，因为其他页面的脚本是运行在它们自己的渲染进程中的。所以当我们再在 Chrome 中运行上面那个死循环的脚本时，没有响应的仅仅是当前的页面。</p>\n<p>对于内存泄漏的解决方法那就更简单了，因为当关闭一个页面时，整个渲染进程也会被关闭，之后该进程所占用的内存都会被系统回收，这样就轻松解决了浏览器页面的内存泄漏问题。</p>\n<p><strong>最后我们再来看看上面的两个安全问题是怎么解决的</strong>。采用多进程架构的额外好处是可以使用安全沙箱，你可以把沙箱看成是操作系统给进程上了一把锁，沙箱里面的程序可以运行，但是不能在你的硬盘上写入任何数据，也不能在敏感位置读取任何数据，例如你的文档和桌面。Chrome 把插件进程和渲染进程锁在沙箱里面，这样即使在渲染进程或者插件进程里面执行了恶意程序，恶意程序也无法突破沙箱去获取系统权限。</p>\n<p>好了，分析完早期的 Chrome 浏览器后，相信你已经了解了浏览器采用多进程架构的必要性</p>\n<h3 id="目前多进程架构"><a href="#%E7%9B%AE%E5%89%8D%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%9E%B6%E6%9E%84" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>目前多进程架构</h3>\n<p>不过 Chrome 的发展是滚滚向前的，相较之前，目前的架构又有了很多新的变化。我们先看看最新的 Chrome 进程架构，你可以参考下图</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-02-10-50-30-0c08515b5c453a3e0b919294d48b6226-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 43.25744308231174%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAIAAAC9o5sfAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABR0lEQVQoz5WRPUvDQBjHM4iDY8HNQXBxEro6FT+Fn8GPpNJRBFOQWnDQQXB1F7WYGpr00iYlbXK5e+65F5/GVii69M/xcHD/3/N2ntVai0qVZZXnyLkzxq1kldJCyKKAsrSI7o88C6DL+SgMB/2PjDH3Y7J2EaScTiZhEIzjyAH8AzuNGiQCGAVYcYPK2FrOaaVAVFoKulCDdUa7Brces+NOv+W/NbvxE5MOZcGXKnjlEM5eimYnOLl5PeqOesOKGLPK4O1cJd5FsNUOvcvh9YDToONsGsdxFEX5bE5w6yH3zr+22wOvzdrvBTH6Fz7sTfZux/vddLfD7ofcaZgX5bK0EASfPmcNnx3cpQ0/8T9nazAHRaeUqhSgjaHdq1qISJFml4j0uvAA7UC52kC2emGbaPFhWmdpypKEOtsMNojEg5SMMSnlN1pY8HNoYpOOAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 02 10 50 30"\n        title=""\n        src="/static/2021-07-02-10-50-30-0c08515b5c453a3e0b919294d48b6226-fee1c.png"\n        srcset="/static/2021-07-02-10-50-30-0c08515b5c453a3e0b919294d48b6226-a67b7.png 200w,\n/static/2021-07-02-10-50-30-0c08515b5c453a3e0b919294d48b6226-0b187.png 400w,\n/static/2021-07-02-10-50-30-0c08515b5c453a3e0b919294d48b6226-fee1c.png 800w,\n/static/2021-07-02-10-50-30-0c08515b5c453a3e0b919294d48b6226-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从图中可以看出，最新的 Chrome 浏览器包括：1 个浏览器（Browser）主进程、1 个 GPU 进程、1 个网络（NetWork）进程、多个渲染进程和多个插件进程</p>\n<p>下面我们来逐个分析下这几个进程的功能。</p>\n<ul>\n<li><strong>浏览器进程</strong>。主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。</li>\n<li><strong>渲染进程</strong>。核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。</li>\n<li><strong>GPU 进程</strong>。其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。</li>\n<li><strong>网络进程</strong>。主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。</li>\n<li><strong>插件进程</strong>。主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响</li>\n</ul>\n<p>讲到这里，现在你应该就可以回答文章开头提到的问题了：仅仅打开了 1 个页面，为什么有 4 个进程？因为打开 1 个页面至少需要 1 个网络进程、1 个浏览器进程、1 个 GPU 进程以及 1 个渲染进程，共 4 个；如果打开的页面有运行插件的话，还需要再加上 1 个插件进程。</p>\n<p>不过凡事都有两面性，虽然多进程模型提升了浏览器的稳定性、流畅性和安全性，但同样不可避免地带来了一些问题</p>\n<ul>\n<li><strong>更高的资源占用</strong>。因为每个进程都会包含公共基础结构的副本（如 JavaScript 运行环境），这就意味着浏览器会消耗更多的内存资源。</li>\n<li><strong>更复杂的体系架构</strong>。浏览器各模块之间耦合性高、扩展性差等问题，会导致现在的架构已经很难适应新的需求了</li>\n</ul>\n<p>对于上面这两个问题，Chrome 团队一直在寻求一种弹性方案，既可以解决资源占用高的问题，也可以解决复杂的体系架构的问题</p>\n<h3 id="未来面向服务的架构"><a href="#%E6%9C%AA%E6%9D%A5%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%9E%B6%E6%9E%84" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>未来面向服务的架构</h3>\n<p>为了解决这些问题，在 2016 年，Chrome 官方团队使用“面向服务的架构”（Services Oriented Architecture，简称 SOA）的思想设计了新的 Chrome 架构。也就是说 Chrome 整体架构会朝向现代操作系统所采用的“面向服务的架构” 方向发展，原来的各种模块会被重构成独立的服务（Service），每个服务（Service）都可以在独立的进程中运行，访问服务（Service）必须使用定义好的接口，通过 IPC 来通信，从而构建一个更内聚、松耦合、易于维护和扩展的系统，更好实现 Chrome 简单、稳定、高速、安全的目标。如果你对面向服务的架构感兴趣，你可以去网上搜索下资料，这里就不过多介绍了。</p>\n<p>Chrome 最终要把 UI、数据库、文件、设备、网络等模块重构为基础服务，类似操作系统底层服务，下面是 Chrome“面向服务的架构”的进程模型图</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-02-10-57-46-ffb91623e2df93bde2a7eec2ad8cdc48-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 50.96322241681261%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABSUlEQVQoz4VS7Y7lIAjt+z/lJJM72Zm22mu1FRDYg939PYY0ipwPoYu7mw5l6q3RdRmzz2XCyLRS+LrcYhFRPc9Wa+/9qVnMfYj0Wv+8vrbvb75vVVeAx3jnvK8rKFRB72etP+u6bns5q9oEkxpCzOfReR5ZNb3Lmo+Pz8+fPeEWyWD04B3uXW2YLRKOfBDdrSEcumHahKgcRy0FmydjQ2B71gywD/NFNMBXKXnbEDrfbLhjTttG9/2fDhnCQ8r7jXZIKPsCnxo6Hc87jwx6VI4BK5RSyjmLjADj3aDbdwQ2I1ABDkd0tZLTeRwmMj0qOn+kyOjMACvM/b4RMAX0P2VRxwCCNWUORyi1Vtu27TmFMjL4dAyFhQSJQY8yPPNsnc9Ozr2D7uk/AiKPDq54GJgu4tJuUCz+28LAXQRtj38jBiOw+fV6wftfQWJIpkhtoi4AAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 02 10 57 46"\n        title=""\n        src="/static/2021-07-02-10-57-46-ffb91623e2df93bde2a7eec2ad8cdc48-fee1c.png"\n        srcset="/static/2021-07-02-10-57-46-ffb91623e2df93bde2a7eec2ad8cdc48-a67b7.png 200w,\n/static/2021-07-02-10-57-46-ffb91623e2df93bde2a7eec2ad8cdc48-0b187.png 400w,\n/static/2021-07-02-10-57-46-ffb91623e2df93bde2a7eec2ad8cdc48-fee1c.png 800w,\n/static/2021-07-02-10-57-46-ffb91623e2df93bde2a7eec2ad8cdc48-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>目前 Chrome 正处在老的架构向服务化架构过渡阶段，这将是一个漫长的迭代过程。</p>\n<p>Chrome 正在逐步构建 Chrome 基础服务（Chrome Foundation Service），如果你认为 Chrome 是“便携式操作系统”，那么 Chrome 基础服务便可以被视为该操作系统的“基础”系统服务层。</p>\n<p>同时 Chrome 还提供灵活的弹性架构，在强大性能设备上会以多进程的方式运行基础服务，但是如果在资源受限的设备上（如下图），Chrome 会将很多服务整合到一个进程中，从而节省内存占用。</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-02-10-58-14-8d908e5e3d0fe15a69ea90f28746affc-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 55.166374781085814%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABrUlEQVQoz5VSy2pUQRCdnSt3omC+xg8Q/AQ3uvUBLgTxK8S9EBjURQJxF7IQxAQlcVSMiNe5M95Mz9x75z76/arutjIRZNSFHpqiD9Sp011Vg7SOaK0X0jDqpYwAwTtQygqxot55r1cAAEwerEsjCF4v5pPxt7auk/dRq2VZTsbjuiyDtZSxLMuKorDWhhAGvzlbKQRjGDA6tJCSUcoZU1JYrYX8CaVUjHFNjMW0MSmGlCBG7wG6ZlkVk6qY8q7xEGLwKUIK8Bdn5N6aUWN2pvzVQmHStBXbWbOVNe8rgbIvnd47ER+X2p2JjdJ907CuZV1HuUjO3HzLzj3Jr+y1KfntE3PpObk4nDz8wLH4vcP+/GZ+/eUiOgsopos5OTos3x1Vn4/nsxlY/TQXd/erR586fDxa3T5Y3tovHx/3KH5RyPsjOswFWHMqVpy3hPRk1vc95TxZdeeg2tj8em2XJLCvCd949v3yML+6O0f6YEQvbNU33lAwGv7stnMuwGlXsDd4996l6PHzZzQ6k7z2Shjs6685x5j+Abg2OPx+BdyTQfofoBiPkpIQgtP6ASH5Zb1BcUF5AAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 02 10 58 14"\n        title=""\n        src="/static/2021-07-02-10-58-14-8d908e5e3d0fe15a69ea90f28746affc-fee1c.png"\n        srcset="/static/2021-07-02-10-58-14-8d908e5e3d0fe15a69ea90f28746affc-a67b7.png 200w,\n/static/2021-07-02-10-58-14-8d908e5e3d0fe15a69ea90f28746affc-0b187.png 400w,\n/static/2021-07-02-10-58-14-8d908e5e3d0fe15a69ea90f28746affc-fee1c.png 800w,\n/static/2021-07-02-10-58-14-8d908e5e3d0fe15a69ea90f28746affc-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<h2 id="总结"><a href="#%E6%80%BB%E7%BB%93" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总结</h2>\n<p>本文主要是从 Chrome 进程架构的视角，分析了浏览器的进化史。</p>\n<p>最初的浏览器都是单进程的，它们不稳定、不流畅且不安全，之后出现了 Chrome，创造性地引入了多进程架构，并解决了这些遗留问题。随后 Chrome 试图应用到更多业务场景，如移动设备、VR、视频等，为了支持这些场景，Chrome 的架构体系变得越来越复杂，这种架构的复杂性倒逼 Chrome 开发团队必须进行架构的重构，最终 Chrome 团队选择了面向服务架构（SOA）形式，这也是 Chrome 团队现阶段的一个主要任务。</p>\n<p>鉴于目前架构的复杂性，要完整过渡到面向服务架构，估计还需要好几年时间才能完成。不过 Chrome 开发是一个渐进的过程，新的特性会一点点加入进来，这也意味着我们随时能看到 Chrome 新的变化。</p>\n<p>总体说来，Chrome 是以一个非常快速的速度在进化，越来越多的业务和应用都逐渐转至浏览器来开发，身为开发人员，我们不能坐视不管，而应该紧跟其步伐，收获这波技术红利</p>\n<h1 id="tcp-协议"><a href="#tcp-%E5%8D%8F%E8%AE%AE" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>TCP 协议</h1>\n<p>在衡量 Web 页面性能的时候有一个重要的指标叫“FP（First Paint）”，是指从页面加载到首次开始绘制的时长。这个指标直接影响了用户的跳出率，更快的页面响应意味着更多的 PV、更高的参与度，以及更高的转化率。那什么影响 FP 指标呢？其中一个重要的因素是网络加载速度</p>\n<p>要想优化 Web 页面的加载速度，你需要对网络有充分的了解。而理解网络的关键是要对网络协议有深刻的认识，不管你是使用 HTTP，还是使用 WebSocket，它们都是基于 TCP/IP 的，如果你对这些原理有足够了解，也就清楚如何去优化 Web 性能，或者能更轻松地定位 Web 问题了。此外，TCP/IP 的设计思想还有助于拓宽你的知识边界，从而在整体上提升你对项目的理解和解决问题的能力。</p>\n<p>好，接下来我们回到正题，开始今天的内容。在网络中，一个文件通常会被拆分为很多数据包来进行传输，而数据包在传输过程中又有很大概率丢失或者出错。那么如何保证页面文件能被完整地送达浏览器呢？</p>\n<p>这篇文章将站在数据包的视角，给出问题答案</p>\n<h2 id="一个数据包的旅程"><a href="#%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%8C%85%E7%9A%84%E6%97%85%E7%A8%8B" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>一个数据包的“旅程”</h2>\n<p>下面我将分别从“数据包如何送达主机”“主机如何将数据包转交给应用”和“数据是如何被完整地送达应用程序”这三个角度来为你讲述数据的传输过程</p>\n<p>互联网，实际上是一套理念和协议组成的体系架构。其中，协议是一套众所周知的规则和标准，如果各方都同意使用，那么它们之间的通信将变得毫无障碍</p>\n<p>互联网中的数据是通过数据包来传输的。如果发送的数据很大，那么该数据就会被拆分为很多小数据包来传输。比如你现在听的音频数据，是拆分成一个个小的数据包来传输的，并不是一个大的文件一次传输过来的</p>\n<h4 id="ip：把数据包送达目的主机"><a href="#ip%EF%BC%9A%E6%8A%8A%E6%95%B0%E6%8D%AE%E5%8C%85%E9%80%81%E8%BE%BE%E7%9B%AE%E7%9A%84%E4%B8%BB%E6%9C%BA" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>IP：把数据包送达目的主机</h4>\n<p>数据包要在互联网上进行传输，就要符合网际协议（Internet Protocol，简称 IP）标准。互联网上不同的在线设备都有唯一的地址，地址只是一个数字，这和大部分家庭收件地址类似，你只需要知道一个家庭的具体地址，就可以往这个地址发送包裹，这样物流系统就能把物品送到目的地</p>\n<p>计算机的地址就称为 IP 地址，访问任何网站实际上只是你的计算机向另外一台计算机请求信息。</p>\n<p>如果要想把一个数据包从主机 A 发送给主机 B，那么在传输之前，数据包上会被附加上主机 B 的 IP 地址信息，这样在传输过程中才能正确寻址。额外地，数据包上还会附加上主机 A 本身的 IP 地址，有了这些信息主机 B 才可以回复信息给主机 A。这些附加的信息会被装进一个叫 IP 头的数据结构里。IP 头是 IP 数据包开头的信息，包含 IP 版本、源 IP 地址、目标 IP 地址、生存时间等信息</p>\n<p>为了方便理解，我先把网络简单分为三层结构，如下图</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-02-11-17-17-5bcd4ef7a02968d2eb48bfe0f2c63841-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 61.55866900175131%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABpUlEQVQoz3VSW46cMBCci0TKiZNr5CsX2CtEWq20v5sZlhkGgx/4/YbUYJKsFKUFlmlc3VXVPm2/o9badZ1zbvtPTNM0jiM267q2zKnB8I1VSplzrnt8LNpOa62NMe1ky5ywCyEANs9UaR1TAh4ZrOseMUYykr7vGWellJQSMt77A4wUYNe+5zOtOYMWMsjf73el1LZuTLKZz8GHdTsIo8QBTmhXsmWkCB4ZjZzlUhp/dM4pB1Ap4SGhPTudBxi/rbVKq0UJZ11wNnvnrAG4NQHDRUtBiWHMMOoE14IDcnTGORutMALmEBtfRVQBVFIDo3PMyS8cfvKJdkQYqVMMf2kba9/ee8enL8/k07fLDxq26H+eL3AY8rB215vi9OvL9Pn77eketprK2sApwSI9EUiLzmvGoNh5PwwD6ME8WCAXCS7U+Nd3YnzcZwHNtUI9usOqHFzxriqJUfzRHPB7EW4cMKXCab28xeF6jApvqw0bVdDQCj77pCquFAb+mGXKw3Kz3iRUCj4610qfPl5Al52O2iaLjQn6fD0zzXzxyMiw/HthfwG7fbSqWvTU3AAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 02 11 17 17"\n        title=""\n        src="/static/2021-07-02-11-17-17-5bcd4ef7a02968d2eb48bfe0f2c63841-fee1c.png"\n        srcset="/static/2021-07-02-11-17-17-5bcd4ef7a02968d2eb48bfe0f2c63841-a67b7.png 200w,\n/static/2021-07-02-11-17-17-5bcd4ef7a02968d2eb48bfe0f2c63841-0b187.png 400w,\n/static/2021-07-02-11-17-17-5bcd4ef7a02968d2eb48bfe0f2c63841-fee1c.png 800w,\n/static/2021-07-02-11-17-17-5bcd4ef7a02968d2eb48bfe0f2c63841-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<blockquote>\n<p>下面我们一起来看下一个数据包从主机 A 到主机 B 的旅程：</p>\n</blockquote>\n<ul>\n<li>上层将含有“极客时间”的数据包交给网络层；</li>\n<li>网络层再将 IP 头附加到数据包上，组成新的 IP 数据包，并交给底层；</li>\n<li>底层通过物理网络将数据包传输给主机 B；</li>\n<li>数据包被传输到主机 B 的网络层，在这里主机 B 拆开数据包的 IP 头信息，并将拆开来的数据部分交给上层；</li>\n<li>最终，含有“极客时间”信息的数据包就到达了主机 B 的上层了</li>\n</ul>\n<h3 id="udp：把数据包送达应用程序"><a href="#udp%EF%BC%9A%E6%8A%8A%E6%95%B0%E6%8D%AE%E5%8C%85%E9%80%81%E8%BE%BE%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>UDP：把数据包送达应用程序</h3>\n<p>IP 是非常底层的协议，只负责把数据包传送到对方电脑，但是对方电脑并不知道把数据包交给哪个程序，是交给浏览器还是交给王者荣耀？因此，需要基于 IP 之上开发能和应用打交道的协议，最常见的是“用户数据包协议（User Datagram Protocol）”，简称 UDP。</p>\n<p>UDP 中一个最重要的信息是端口号，端口号其实就是一个数字，每个想访问网络的程序都需要绑定一个端口号。通过端口号 UDP 就能把指定的数据包发送给指定的程序了，所以 IP 通过 IP 地址信息把数据包发送给指定的电脑，而 UDP 通过端口号把数据包分发给正确的程序。和 IP 头一样，端口号会被装进 UDP 头里面，UDP 头再和原始数据包合并组成新的 UDP 数据包。UDP 头中除了目的端口，还有源端口号等信息</p>\n<p>为了支持 UDP 协议，我把前面的三层结构扩充为四层结构，在网络层和上层之间增加了传输层，如下图所示：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-02-11-18-52-dfda3b6ba81a1ee42cefbb375d72fe34-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 71.2784588441331%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAIAAACgpqunAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACCUlEQVQoz3VTu4oVQRCdzxIxEv0OA39C8AcMTA3MBUMRQTERDERBXUwMluvuOvd6Z3Ze/Zjp6ffD0z3uooFF04+pqlN1qmqqlFKMETshpOu69H9p25ZSem0PqUIIpohSSkrpriQWwcUW8d5rrWHmi2wGFY6u7+q6BupmDR2sl2VhjOFybI6Hw0EIscUMRfAde4W3UMJYU+J563xx91vk4AMVBAZF5WzRXadWxRClkYApTPIKIas3Vjlbp11w6Q9PxDQAcAW9wtmznnPKVvX8jD/5Tk+ZTdHPi+CcA4XNXIl5R9XT0/nZjg2zSCXNnDawCaPTOHRMPPw83HvXfOwN4nfDALbQHvuWjd2nZrn//vLBFzJOs6vP1TQhk+ycKfnMFQFzYs4qbba0wVJooS2KDCLQei2EZEzNPKZYwQKcSwFC2lbK+1YwQK9qVVpFOHubVwwuZM5p4zwtxFi9alfPBuuCm5avpXgJLZFWoXdE+Vr4g3D7BWkA9Ioz6A3Nrw97cvtVfefN8cbL/eNvI+na3Y8zTM6xaflw+eikv/ni/O7b9tbr5msvU3A+lCGBf54z56kJVHuiPSq/9WabKjR41nZczaRcPzL280IxCmJ5PLemB++VXvFATrjDB1OVmx8SXYkyMsPBWkk3cydlrvbfo79audpVOmWCoTNtusYGMDSrFT43IsV/f5Xf49Ahhtcri7AAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 02 11 18 52"\n        title=""\n        src="/static/2021-07-02-11-18-52-dfda3b6ba81a1ee42cefbb375d72fe34-fee1c.png"\n        srcset="/static/2021-07-02-11-18-52-dfda3b6ba81a1ee42cefbb375d72fe34-a67b7.png 200w,\n/static/2021-07-02-11-18-52-dfda3b6ba81a1ee42cefbb375d72fe34-0b187.png 400w,\n/static/2021-07-02-11-18-52-dfda3b6ba81a1ee42cefbb375d72fe34-fee1c.png 800w,\n/static/2021-07-02-11-18-52-dfda3b6ba81a1ee42cefbb375d72fe34-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>下面我们一起来看下一个数据包从主机 A 旅行到主机 B 的路线：</p>\n<ul>\n<li>上层将含有“极客时间”的数据包交给传输层；</li>\n<li>传输层会在数据包前面附加上 UDP 头，组成新的 UDP 数据包，再将新的 UDP 数据包交给网络层；</li>\n<li>网络层再将 IP 头附加到数据包上，组成新的 IP 数据包，并交给底层；</li>\n<li>数据包被传输到主机 B 的网络层，在这里主机 B 拆开 IP 头信息，并将拆开来的数据部分交给传输层；</li>\n<li>在传输层，数据包中的 UDP 头会被拆开，并根据 UDP 中所提供的端口号，把数据部分交给上层的应用程序；</li>\n<li>最终，含有“极客时间”信息的数据包就旅行到了主机 B 上层应用程序这里</li>\n</ul>\n<p>在使用 UDP 发送数据时，有各种因素会导致数据包出错，虽然 UDP 可以校验数据是否正确，但是对于错误的数据包，UDP 并不提供重发机制，只是丢弃当前的包，而且 UDP 在发送之后也无法知道是否能达到目的地。</p>\n<p>虽说 UDP 不能保证数据可靠性，但是传输速度却非常快，所以 UDP 会应用在一些关注速度、但不那么严格要求数据完整性的领域，如在线视频、互动游戏等</p>\n<h3 id="tcp：把数据完整地送达应用程序"><a href="#tcp%EF%BC%9A%E6%8A%8A%E6%95%B0%E6%8D%AE%E5%AE%8C%E6%95%B4%E5%9C%B0%E9%80%81%E8%BE%BE%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>TCP：把数据完整地送达应用程序</h3>\n<p>对于浏览器请求，或者邮件这类要求数据传输可靠性（reliability）的应用，如果使用 UDP 来传输会存在两个问题：</p>\n<ul>\n<li>数据包在传输过程中容易丢失；</li>\n<li>大文件会被拆分成很多小的数据包来传输，这些小的数据包会经过不同的路由，并在不同的时间到达接收端，而 UDP 协议并不知道如何组装这些数据包，从而把这些数据包还原成完整的文件</li>\n</ul>\n<p>基于这两个问题，我们引入 TCP 了。TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。相对于 UDP，TCP 有下面两个特点:</p>\n<ul>\n<li>对于数据包丢失的情况，TCP 提供重传机制；</li>\n<li>TCP 引入了数据包排序机制，用来保证把乱序的数据包组合成一个完整的文件。</li>\n</ul>\n<p>和 UDP 头一样，TCP 头除了包含了目标端口和本机端口号外，还提供了用于排序的序列号，以便接收端通过序号来重排数据包。</p>\n<p>下面看看 TCP 下的单个数据包的传输流程</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-02-13-44-25-a22307eda038250780c4d21ce4a0c211-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 69.87740805604203%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAIAAACgpqunAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACCUlEQVQoz2VSzW7UMBDeN+SKegTBo3DnDZBYIbW8AYcCooITKgcudFsK3U2y2cSxE8fj+Df9HHcrJMaWNfL8fTPfrOZ5jjHiFUIURRGPMh/lUa+q6nA4QAkh5M8VNFLU972Ucpomv4i1Fq/WGgr+h37IOsQtYoxB4CqGyAUvyxLxuQ4ETkjEGPPOF3WxK3cIfrRCQeoUDG3Uo7HGWasnQ5PBi+AMNfgwTuNkJ+c8GauNdemkiywJttQSP1DgjOxzDECVKyAL4TgbszU6GuVEhEqpMgDwge/rSnDx6kf35EP57rcCrqZtMT9kOTStZM33enz6qX55Ud81IpZ3E+cY2gpdkSallCY6L9SbjbxkJnqriIZhSMG8kZJvhX67Gd7fyk6SF5x4twwspp4TbO/n6FEzeIfOH3gKMcH2dukiITfgAi7ep56XgUnn3dKVzx4x+twzWCFDxpklb3bw0R+pSuy3eyG6RtLZTX963a+v+OdCajWCvESY6MZBXNbj+hc/vRnWV+LP6ObgQBZgR8Y6wdrrpn9+0Tz7cjg5r17/5FLw7S7R2zKGDs82/ORj9eJrC+u3vyxoBaITVcCW9zDx9LCSMPlMFbIHtJRgL6J6t70l1obcc15J7EOvpUGmtD0RgPf7fVxCueKcBGZk0nokM/zTbs//iPEGs8XVTg96AEnkKF1LPvj5P7kHeU4gpw/e15EAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 02 13 44 25"\n        title=""\n        src="/static/2021-07-02-13-44-25-a22307eda038250780c4d21ce4a0c211-fee1c.png"\n        srcset="/static/2021-07-02-13-44-25-a22307eda038250780c4d21ce4a0c211-a67b7.png 200w,\n/static/2021-07-02-13-44-25-a22307eda038250780c4d21ce4a0c211-0b187.png 400w,\n/static/2021-07-02-13-44-25-a22307eda038250780c4d21ce4a0c211-fee1c.png 800w,\n/static/2021-07-02-13-44-25-a22307eda038250780c4d21ce4a0c211-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>通过上图你应该可以了解一个数据包是如何通过 TCP 来传输的。TCP 单个数据包的传输流程和 UDP 流程差不多，不同的地方在于，通过 TCP 头的信息保证了一块大的数据传输的完整性。</p>\n<p>下面我们再看下完整的 TCP 连接过程，通过这个过程你可以明白 TCP 是如何保证重传机制和数据包的排序功能的。</p>\n<p>从下图可以看出，一个完整的 TCP 连接的生命周期包括了“建立连接”“传输数据”和“断开连接”三个阶段。</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-02-13-45-05-9debda7a276103e3391207cbaa5dbbae-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 35.72679509632224%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAIAAACHqfpvAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABG0lEQVQY05VPvU7DMBj0UAmJt2Bmgjdh4jl4AxZYeAKYKiREl6zMbCAhJIYsBVEaQRzsOI4/O47jOo1xA0lnTvJnfT+nu0Pe+67r1j38P4HCU0rFcZxlmZYSytIITkR18ZKfPdPzWJ4+ptEr65wFxgBAgTBKbslt22qtXaiCl5x7U70pt3OdoKvF5Iaiy+XRfRHOSkqEEBqEM2ZLDrZ9/7WNUQC+0cvG70YFmiaTGUVTfPygvF9bY0CqJsgOATfkWtdJknxjbGtNsswq+IDm8I7u384Pove92eLkqfAaQjqMMfn6tNb+6m3IoeGcV1VljMFpav5cBSerlYKQtjfXtc5JKYftoDwiJCeEjGtrVzTP66EN82CQMTYm/QFrzIGFa7OL5AAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 02 13 45 05"\n        title=""\n        src="/static/2021-07-02-13-45-05-9debda7a276103e3391207cbaa5dbbae-fee1c.png"\n        srcset="/static/2021-07-02-13-45-05-9debda7a276103e3391207cbaa5dbbae-a67b7.png 200w,\n/static/2021-07-02-13-45-05-9debda7a276103e3391207cbaa5dbbae-0b187.png 400w,\n/static/2021-07-02-13-45-05-9debda7a276103e3391207cbaa5dbbae-fee1c.png 800w,\n/static/2021-07-02-13-45-05-9debda7a276103e3391207cbaa5dbbae-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<ul>\n<li>首先，<strong>建立连接阶段</strong>。这个阶段是通过“三次握手”来建立客户端和服务器之间的连接。TCP 提供面向连接的通信传输。面向连接是指在数据通信开始之前先做好两端之间的准备工作。所谓三次握手，是指在建立一个 TCP 连接时，客户端和服务器总共要发送三个数据包以确认连接的建立。</li>\n<li>其次，<strong>传输数据阶段</strong>。在该阶段，接收端需要对每个数据包进行确认操作，也就是接收端在接收到数据包之后，需要发送确认数据包给发送端。所以当发送端发送了一个数据包之后，在规定时间内没有接收到接收端反馈的确认消息，则判断为数据包丢失，并触发发送端的重发机制。同样，一个大的文件在传输过程中会被拆分成很多小的数据包，这些数据包到达接收端后，接收端会按照 TCP 头中的序号为其排序，从而保证组成完整的数据。</li>\n<li>最后，<strong>断开连接阶段</strong>。数据传输完毕之后，就要终止连接了，涉及到最后一个阶段“四次挥手”来保证双方都能断开连接</li>\n</ul>\n<p>到这里你应该就明白了，TCP 为了保证数据传输的可靠性，牺牲了数据包的传输速度，因为“三次握手”和“数据包校验机制”等把传输过程中的数据包的数量提高了一倍。</p>\n<h2 id="总结-1"><a href="#%E6%80%BB%E7%BB%93-1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总结</h2>\n<ul>\n<li>互联网中的数据是通过数据包来传输的，数据包在传输过程中容易丢失或出错。</li>\n<li>IP 负责把数据包送达目的主机。</li>\n<li>UDP 负责把数据包送达具体应用。</li>\n<li>而 TCP 保证了数据完整地传输，它的连接可分为三个阶段：建立连接、传输数据和断开连接。</li>\n<li>其实了解 TCP 协议，是为了全方位了解 HTTP，包括其实际功能和局限性，之后才会更加深刻地理解为什么要推出 HTTP/2，以及为什么要推出 QUIC 协议，也就是未来的 HTTP/3。这是一个由浅入深、循序渐进的过程，我希望你能稳扎稳打，学好这每一步、每一个协议，后面“水到自然渠成”</li>\n</ul>\n<h1 id="http-请求流程"><a href="#http-%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>HTTP 请求流程</h1>\n<p>一个 TCP 连接过程包括了建立连接、传输数据和断开连接三个阶段。</p>\n<p>而 HTTP 协议，正是建立在 TCP 连接基础之上的。HTTP 是一种允许浏览器向服务器获取资源的协议，是 Web 的基础，通常由浏览器发起请求，用来获取不同类型的文件，例如 HTML 文件、CSS 文件、JavaScript 文件、图片、视频等。此外，HTTP 也是浏览器使用最广的协议，所以要想学好浏览器，就要先深入了解 HTTP。</p>\n<p>不知道你是否有过下面这些疑问：</p>\n<ol>\n<li>为什么通常在第一次访问一个站点时，打开速度很慢，当再次访问这个站点时，速度就很快了？</li>\n<li>当登录过一个网站之后，下次再访问该站点，就已经处于登录状态了，这是怎么做到的呢？</li>\n</ol>\n<p>这一切的秘密都隐藏在 HTTP 的请求过程中。所以，在今天这篇文章中，我将通过分析一个 HTTP 请求过程中每一步的状态来带你了解完整的 HTTP 请求过程，希望你看完这篇文章后，能够对 HTTP 协议有个全新的认识</p>\n<h2 id="浏览器端发起-http-请求流程"><a href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%AB%AF%E5%8F%91%E8%B5%B7-http-%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>浏览器端发起 HTTP 请求流程</h2>\n<p>如果你在浏览器地址栏里键入地址：<a href="http://baidu.com%EF%BC%8C%E9%82%A3%E4%B9%88%E6%8E%A5%E4%B8%8B%E6%9D%A5%EF%BC%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BC%9A%E5%AE%8C%E6%88%90%E5%93%AA%E4%BA%9B%E5%8A%A8%E4%BD%9C%E5%91%A2%EF%BC%9F%E4%B8%8B%E9%9D%A2%E6%88%91%E4%BB%AC%E5%B0%B1%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E8%AF%A6%E7%BB%86%E2%80%9C%E8%BF%BD%E8%B8%AA%E2%80%9D%E4%B8%8B" target="_blank" rel="nofollow noreferrer noopener">http://baidu.com，那么接下来，浏览器会完成哪些动作呢？下面我们就一步一步详细“追踪”下</a></p>\n<h3 id="构建请求"><a href="#%E6%9E%84%E5%BB%BA%E8%AF%B7%E6%B1%82" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>构建请求</h3>\n<p>首先，浏览器构建请求行信息（如下所示），构建好后，浏览器准备发起网络请求</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="11123849053951717000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`GET /index.html HTTP1.1`, `11123849053951717000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">GET /index.html HTTP1.1</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<h3 id="查找缓存"><a href="#%E6%9F%A5%E6%89%BE%E7%BC%93%E5%AD%98" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>查找缓存</h3>\n<p>在真正发起网络请求之前，浏览器会先在浏览器缓存中查询是否有要请求的文件。其中，浏览器缓存是一种在本地保存资源副本，以供下次请求时直接使用的技术。</p>\n<p>当浏览器发现请求的资源已经在浏览器缓存中存有副本，它会拦截请求，返回该资源的副本，并直接结束请求，而不会再去源服务器重新下载。这样做的好处有：</p>\n<ul>\n<li>缓解服务器端压力，提升性能（获取资源的耗时更短了）；</li>\n<li>对于网站来说，缓存是实现快速资源加载的重要组成部分。</li>\n<li>当然，如果缓存查找失败，就会进入网络请求过程了。</li>\n</ul>\n<h3 id="准备-ip-地址和端口"><a href="#%E5%87%86%E5%A4%87-ip-%E5%9C%B0%E5%9D%80%E5%92%8C%E7%AB%AF%E5%8F%A3" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>准备 IP 地址和端口</h3>\n<p>不过，先不急，在了解网络请求之前，我们需要先看看 HTTP 和 TCP 的关系。因为浏览器使用 HTTP 协议作为应用层协议，用来封装请求的文本信息；并使用 TCP/IP 作传输层协议将它发到网络上，所以在 HTTP 工作开始之前，浏览器需要通过 TCP 与服务器建立连接。也就是说 HTTP 的内容是通过 TCP 的传输数据阶段来实现的，你可以结合下图更好地理解这二者的关系。</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-02-14-30-42-7b68c79b1d7fb59a33041ec119870e5c-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 49.91243432574431%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAB1ElEQVQoz21RTWsUMRieo2BBf4Y3/S16kAXrai1bRbx60IPF/yCClXpUcbEFKxQUQQ+22y0sflRY211mdqczmXzMV2YySSYzcWa2az345OFN8uZ9kjc8hm6g5iyrUVMXhcIYEoKb8/Iv52U1DH2CYsai0EpVk86ywrLIdBpU27KsM6qo47yylhuFUqY1efQtau+Ed/vBEXyb02cpXQ/RU85e0Oi5Yz8haC0K1zldmwTde31y/Ws4pvlMnP86PLqwTY1XyZmNaB8+kOSy4IvUb2ndzsUidFvQveqBVupf+Z3cP7tBjJfJLslP2mZCXvqUGF26sBUNvMcxuMbiFWAvaX0nF7chuAWcJQ8sp6Q9TlbPb/lGN9nzG3EupePBix9C4028sOn37VUtl1nYYXFHiRWRdjznZqXHqMOjGz/hw3Ob0Hgd7mJRizPGTMv6bOJ3h3h7hEyzFxx/CbxeQr9n7ICxA0p/ANBznB2M9sbT/kcTvx/7IZ/9ufJE5YHnoqmJbSuXCnoBITTLVG1R40maCgCCOBYJzXzX9o8nNI5OreJCsIwzzouydkNKyViKEATARcir1lLWfXLO/SDExE8Z+9fnU5TNc1UcjUaDwWA4HFZ36f/hD7gCD4uvreRIAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 02 14 30 42"\n        title=""\n        src="/static/2021-07-02-14-30-42-7b68c79b1d7fb59a33041ec119870e5c-fee1c.png"\n        srcset="/static/2021-07-02-14-30-42-7b68c79b1d7fb59a33041ec119870e5c-a67b7.png 200w,\n/static/2021-07-02-14-30-42-7b68c79b1d7fb59a33041ec119870e5c-0b187.png 400w,\n/static/2021-07-02-14-30-42-7b68c79b1d7fb59a33041ec119870e5c-fee1c.png 800w,\n/static/2021-07-02-14-30-42-7b68c79b1d7fb59a33041ec119870e5c-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>那接下来你可以思考这么“一连串”问题：</p>\n<ul>\n<li>HTTP 网络请求的第一步是做什么呢？结合上图看，是和服务器建立 TCP 连接。</li>\n<li>那建立连接的信息都有了吗？上一篇文章中，我们讲到建立 TCP 连接的第一步就是需要准备 IP 地址和端口号。</li>\n<li>那怎么获取 IP 地址和端口号呢？这得看看我们现在有什么，我们有一个 URL 地址，那么是否可以利用 URL 地址来获取 IP 和端口信息呢？</li>\n</ul>\n<p>在上一篇文章中，我们介绍过数据包都是通过 IP 地址传输给接收方的。由于 IP 地址是数字标识，比如极客时间网站的 IP 是 39.106.233.176, 难以记忆，但使用极客时间的域名（time.geekbang.org）就好记多了，所以基于这个需求又出现了一个服务，负责把域名和 IP 地址做一一映射关系。这套域名映射为 IP 的系统就叫做“域名系统”，简称 DNS（Domain Name System）。</p>\n<p>所以，这样一路推导下来，你会发现在第一步浏览器会请求 DNS 返回域名对应的 IP。当然浏览器还提供了 DNS 数据缓存服务，如果某个域名已经解析过了，那么浏览器会缓存解析的结果，以供下次查询时直接使用，这样也会减少一次网络请求。</p>\n<blockquote>\n<ul>\n<li>递归：客户端只发一次请求，要求对方给出最终结果。</li>\n<li>迭代：客户端发出一次请求，对方如果没有授权回答，它就会返回一个能解答这个查询的其它名称服务器列表，客户端会再向返回的列表中发出请求，直到找到最终负责所查域名的名称服务器，从它得到最终结果。</li>\n<li>授权回答：向 dns 服务器查询一个域名，刚好这个域名是本服务器负责，返回的结果就是授权回答。</li>\n</ul>\n</blockquote>\n<ul>\n<li>客户端——本地 dns 服务端：这部分属于递归查询。</li>\n<li>本地 dns 服务端——外网：这部分属于迭代查询。</li>\n<li>递归查询时，返回的结果只有两种：查询成功或查询失败。</li>\n<li>迭代查询，又称作重指引,返回的是最佳的查询点或者主机地址。</li>\n<li>在本地有两种缓存，浏览器缓存和操作系统(OS)缓存，优先访问浏览器缓存。</li>\n</ul>\n<p>拿到 IP 之后，接下来就需要获取端口号了。通常情况下，如果 URL 没有特别指明端口号，那么 HTTP 协议默认是 80 端口。</p>\n<h3 id="等待-tcp-队列"><a href="#%E7%AD%89%E5%BE%85-tcp-%E9%98%9F%E5%88%97" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>等待 TCP 队列</h3>\n<p>现在已经把端口和 IP 地址都准备好了，那么下一步是不是可以建立 TCP 连接了呢？</p>\n<p>答案依然是“不行”。Chrome 有个机制，同一个域名同时最多只能建立 6 个 TCP 连接，如果在同一个域名下同时有 10 个请求发生，那么其中 4 个请求会进入排队等待状态，直至进行中的请求完成。</p>\n<p>当然，如果当前请求数量少于 6，会直接进入下一步，建立 TCP 连接。</p>\n<h3 id="建立-tcp-连接"><a href="#%E5%BB%BA%E7%AB%8B-tcp-%E8%BF%9E%E6%8E%A5" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>建立 TCP 连接</h3>\n<p>排队等待结束之后，终于可以快乐地和服务器握手了，在 HTTP 工作开始之前，浏览器通过 TCP 与服务器建立连接。而 TCP 的工作方式，我在上一篇文章中已经做过详细介绍了，如果有必要，你可以自行回顾下，这里我就不再重复讲述了。</p>\n<h3 id="发送-http-请求"><a href="#%E5%8F%91%E9%80%81-http-%E8%AF%B7%E6%B1%82" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>发送 HTTP 请求</h3>\n<p>一旦建立了 TCP 连接，浏览器就可以和服务器进行通信了。而 HTTP 中的数据正是在这个通信过程中传输的。</p>\n<p>你可以结合下图来理解，浏览器是如何发送请求信息给服务器的。</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-02-14-32-10-3c3808ca8b8b038e69000ae8d201f4f5-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 57.4430823117338%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAB+0lEQVQoz02Q3Y7SQBTH+xw+hfFdjDd6qVe+g8l64QNoNNxsoonRxAv1zgtjAgFWWGAp/aC0pbCUyi79pO18lHZmPFSWOHMyOfPxO///HElwmMdRp4cd48ekPqyz06P/hgTHa1SeO+SthYch/e6S1yZu3ZL3DmrMScPG31xccV6XO1W7g0FNjotn/eRRO/7i7V+q+cN20nDo0xF63Imf9NMXGqJClGDnjgPkXy2JMh7shR3k8uxadjZjyx3b69H8z9D2JqtAW8euv9uliGSZKOib0ebB5+nXZQ5kxbhUcpYx4frJQNZ7Y71zOemOFGPpXd+E7jbZ+HGU5ASRAiFYf7j52dC/8Iuy/ojEOQdLfpReKNPezOlqprz04BYLAW73oFAbhgB5WvtGFUfVwbgkOIfrIEq7stpRzZ7h9HRLma/CDOe0yBEhtAAEekYRanvZOy0cR7Ti7KgM8C3AE6Olmk3FbE2MrmIMtJlsmMrMNJ3FNohu/LDIslc979658sHKjn8WtW2AW2Otqdk/r/SWZv+60rqquQihSwJzQRgEj3MSVoe2Y8ZzcHJSDsPdUNaGuvVb1keG059ML2Xdcla2vdhFMQX3aYaTRA3w2WD70YyhVsWYJOqWYEx3cRrFWRhBHJIoiJM4BarApCSwYrEvOl56/9P0eXMNcMnYXwugWNovkYlQAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 02 14 32 10"\n        title=""\n        src="/static/2021-07-02-14-32-10-3c3808ca8b8b038e69000ae8d201f4f5-fee1c.png"\n        srcset="/static/2021-07-02-14-32-10-3c3808ca8b8b038e69000ae8d201f4f5-a67b7.png 200w,\n/static/2021-07-02-14-32-10-3c3808ca8b8b038e69000ae8d201f4f5-0b187.png 400w,\n/static/2021-07-02-14-32-10-3c3808ca8b8b038e69000ae8d201f4f5-fee1c.png 800w,\n/static/2021-07-02-14-32-10-3c3808ca8b8b038e69000ae8d201f4f5-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>首先浏览器会向服务器发送请求行，它包括了请求方法、请求 URI（Uniform Resource Identifier）和 HTTP 版本协议。</p>\n<p>发送请求行，就是告诉服务器浏览器需要什么资源，最常用的请求方法是 Get。比如，直接在浏览器地址栏键入极客时间的域名（time.geekbang.org），这就是告诉服务器要 Get 它的首页资源。</p>\n<p>另外一个常用的请求方法是 POST，它用于发送一些数据给服务器，比如登录一个网站，就需要通过 POST 方法把用户信息发送给服务器。如果使用 POST 方法，那么浏览器还要准备数据给服务器，这里准备的数据是通过请求体来发送。</p>\n<p>在浏览器发送请求行命令之后，还要以请求头形式发送其他一些信息，把浏览器的一些基础信息告诉服务器。比如包含了浏览器所使用的操作系统、浏览器内核等信息，以及当前请求的域名信息、浏览器端的 Cookie 信息，等等</p>\n<h2 id="服务器端处理-http-请求流程"><a href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%A4%84%E7%90%86-http-%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>服务器端处理 HTTP 请求流程</h2>\n<p>历经千辛万苦，HTTP 的请求信息终于被送达了服务器。接下来，服务器会根据浏览器的请求信息来准备相应的内容</p>\n<h3 id="返回请求"><a href="#%E8%BF%94%E5%9B%9E%E8%AF%B7%E6%B1%82" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>返回请求</h3>\n<p>一旦服务器处理结束，便可以返回数据给浏览器了。你可以通过工具软件 curl 来查看返回请求数据，具体使用方法是在命令行中输入以下命令：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="29020121558944023000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`curl -i https://time.geekbang.org/`, `29020121558944023000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">curl -i https://time.geekbang.org/</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>注意这里加上了 -i 是为了返回响应行、响应头和响应体的数据，返回的结果如下图所示，你可以结合这些数据来理解服务器是如何响应浏览器的。</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-02-14-33-16-988b7460f818f1f1b7cc6d1a675b62dd-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 57.00525394045533%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABzUlEQVQoz3VSu44UMRDcnyEl5z+I+AIISBDiE0gJSC5CSAQkhEQXcgTcaoVuD7S3e8e8djzv8XieHtvjtumZEwcS0CpZpZarq7vtFRijASQA1yC0lhoUgDbG2H+HWXAbK+Rvnf7hGXu8rp9t2ItN9WTNDrW0f1z6TxG7UmBOE/Hyir/a0te75mRbnOxqr8U0WLTHFgDpHBaADvKjy9Y5n9PGrDiYerKZMHsvuvpxPFwHxDuWZdVRyikdq2pqW4RsGtN3FxF78P778y8Z+k5gVjjeMEGj4MYnF9fO3ic7x987bpykQz8MA781x72Mozh28qxUXytVK8wYnNnC0l4Wxzeu5/mB43ohIV3fY6taa6UUnoBWUpz7+b0320enHvrhXn+L8zR1gyAMiev7YRSjc0iiOEm8IEiyrKobVjdxM56nw2U5NtP8IndiKAkhrpsEAXGcJPDrLK2zjKVJHh7bIhdt2zPWyUlbK8EO07KwO3EeRREhjFI5jlpKJUYkCiHEzIWQfRfT9sOh+By3el7/Ip5/BD5DnsdFMeGfWQCYm+vOpbWxCrmSm2N5/923p58IqibzS4yXu4rRvJg4/xuKc8n50PdUaDrZStl2afsnTdJpKRbSYLIAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 02 14 33 16"\n        title=""\n        src="/static/2021-07-02-14-33-16-988b7460f818f1f1b7cc6d1a675b62dd-fee1c.png"\n        srcset="/static/2021-07-02-14-33-16-988b7460f818f1f1b7cc6d1a675b62dd-a67b7.png 200w,\n/static/2021-07-02-14-33-16-988b7460f818f1f1b7cc6d1a675b62dd-0b187.png 400w,\n/static/2021-07-02-14-33-16-988b7460f818f1f1b7cc6d1a675b62dd-fee1c.png 800w,\n/static/2021-07-02-14-33-16-988b7460f818f1f1b7cc6d1a675b62dd-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>首先服务器会返回响应行，包括协议版本和状态码。</p>\n<p>但并不是所有的请求都可以被服务器处理的，那么一些无法处理或者处理出错的信息，怎么办呢？服务器会通过请求行的状态码来告诉浏览器它的处理结果，比如：</p>\n<ul>\n<li>最常用的状态码是 200，表示处理成功；</li>\n<li>如果没有找到页面，则会返回 404</li>\n</ul>\n<p>状态码类型很多，这里我就不过多介绍了，网上有很多资料，你可以自行查询和学习。</p>\n<p>随后，正如浏览器会随同请求发送请求头一样，服务器也会随同响应向浏览器发送响应头。响应头包含了服务器自身的一些信息，比如服务器生成返回数据的时间、返回的数据类型（JSON、HTML、流媒体等类型），以及服务器要在客户端保存的 Cookie 等信息。</p>\n<p>发送完响应头后，服务器就可以继续发送响应体的数据，通常，响应体就包含了 HTML 的实际内容。</p>\n<p>以上这些就是服务器响应浏览器的具体过程</p>\n<h3 id="断开连接"><a href="#%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>断开连接</h3>\n<p>通常情况下，一旦服务器向客户端返回了请求数据，它就要关闭 TCP 连接。不过如果浏览器或者服务器在其头信息中加入了：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="17929697123268217000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`Connection:Keep-Alive`, `17929697123268217000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">Connection:Keep-Alive</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>那么 TCP 连接在发送后将仍然保持打开状态，这样浏览器就可以继续通过同一个 TCP 连接发送请求。保持 TCP 连接可以省去下次请求时需要建立连接的时间，提升资源加载速度。比如，一个 Web 页面中内嵌的图片就都来自同一个 Web 站点，如果初始化了一个持久连接，你就可以复用该连接，以请求其他资源，而不需要重新再建立新的 TCP 连接。</p>\n<h3 id="重定向"><a href="#%E9%87%8D%E5%AE%9A%E5%90%91" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>重定向</h3>\n<p>到这里似乎请求流程快结束了，不过还有一种情况你需要了解下，比如当你在浏览器中打开 geekbang.org 后，你会发现最终打开的页面地址是 <a href="https://www.geekbang.org%E3%80%82" target="_blank" rel="nofollow noreferrer noopener">https://www.geekbang.org。</a></p>\n<p>这两个 URL 之所以不一样，是因为涉及到了一个重定向操作。跟前面一样，你依然可以使用 curl 来查看下请求 geekbang.org 会返回什么内容？</p>\n<p>在控制台输入如下命令：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="74457831793958040000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`curl -I geekbang.org`, `74457831793958040000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">curl -I geekbang.org</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>注意这里输入的参数是 -I，和 -i 不一样，-I 表示只需要获取响应头和响应行数据，而不需要获取响应体的数据，最终返回的数据如下图所示：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-02-14-34-31-69e505f1be7d2fd4b613ea7a458e0885-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 49.38704028021015%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABu0lEQVQoz32RPW/UMBjHs/AN+EKMDExs7cTOzFqkSggJBGIoEqq6wAhLRbcuqKI6hKjuUO7ydnbeLlzsXHOX+HKJX842SSr1hYHHkvXX4+dnP//Hhr4dql3/i/ZU3aowrpXs09/R5rW5fGfmB+P80F69/Z0d2OQ9qD/5m0NQOSW/rrwDiz51ZOUPjv1Hn8ePT+Duiffwy2TnW7b7Y/3sonz6szhD9F+41VLprVJroTDTIRHDEP8KsJnkF9FiANMBSAc+Hvp/knQh9I01Q9+1KbXOKuYFiRcmIJ47MLJhbPszG0S2B2dBuCFEMiY5v4Ll6bx5YZZvLPJqtDhyi7JhEEyjOArDEPbhui5CaZZlGONlnndv1HXbsKGUenK+MvbP7708M/ZO73/040oAMB3btut5luNMIUwx7t3d9Cgp7eBSqK8J3R8Ve6PV8+Hyg1XElyQNwtiykA8RmM4ByGexLApFiFqXirPuoiu4H5KCtTaJdiudUpVXDQJgAUELp56LA3/uOshxZtYkmYxRHLdGlhh1ntu5N1tFuCq4LLmstkpIxZqaM8rqTSeaut0F56xpOKWCNrRab1n3Z38BvcEfk8FQqrIAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 02 14 34 31"\n        title=""\n        src="/static/2021-07-02-14-34-31-69e505f1be7d2fd4b613ea7a458e0885-fee1c.png"\n        srcset="/static/2021-07-02-14-34-31-69e505f1be7d2fd4b613ea7a458e0885-a67b7.png 200w,\n/static/2021-07-02-14-34-31-69e505f1be7d2fd4b613ea7a458e0885-0b187.png 400w,\n/static/2021-07-02-14-34-31-69e505f1be7d2fd4b613ea7a458e0885-fee1c.png 800w,\n/static/2021-07-02-14-34-31-69e505f1be7d2fd4b613ea7a458e0885-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从图中你可以看到，响应行返回的状态码是 301，状态 301 就是告诉浏览器，我需要重定向到另外一个网址，而需要重定向的网址正是包含在响应头的 Location 字段中，接下来，浏览器获取 Location 字段中的地址，并使用该地址重新导航，这就是一个完整重定向的执行流程。这也就解释了为什么输入的是 geekbang.org，最终打开的却是 <a href="https://www.geekbang.org" target="_blank" rel="nofollow noreferrer noopener">https://www.geekbang.org</a> 了。</p>\n<p>不过也不要认为这种跳转是必然的。如果你打开 <a href="https://12306.cn" target="_blank" rel="nofollow noreferrer noopener">https://12306.cn</a>，你会发现这个站点是打不开的。这是因为12306的服务器并没有处理跳转，所以必须要手动输入完整的 <a href="https://www.12306.com" target="_blank" rel="nofollow noreferrer noopener">https://www.12306.com</a> 才能打开页面。</p>\n<h2 id="问题解答"><a href="#%E9%97%AE%E9%A2%98%E8%A7%A3%E7%AD%94" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>问题解答</h2>\n<p>说了这么多，相信你现在已经了解了 HTTP 的请求流程，那现在我们再回过头来看看文章开头提出的问题。</p>\n<h3 id="为什么很多站点第二次打开速度会很快？"><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BE%88%E5%A4%9A%E7%AB%99%E7%82%B9%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%89%93%E5%BC%80%E9%80%9F%E5%BA%A6%E4%BC%9A%E5%BE%88%E5%BF%AB%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>为什么很多站点第二次打开速度会很快？</h3>\n<p>如果第二次页面打开很快，主要原因是第一次加载页面过程中，缓存了一些耗时的数据。</p>\n<p>那么，哪些数据会被缓存呢？从上面介绍的核心请求路径可以发现，DNS 缓存和页面资源缓存这两块数据是会被浏览器缓存的。其中，DNS 缓存比较简单，它主要就是在浏览器本地把对应的 IP 和域名关联起来，这里就不做过多分析了。</p>\n<p>我们重点看下浏览器资源缓存，下面是缓存处理的过程：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-02-14-37-15-61f31fbab75310c0f7be777f4b9becac-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 114.79859894921192%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAXCAIAAACEf/j0AAAACXBIWXMAAA7DAAAOwwHHb6hkAAADgUlEQVQ4y2VUy47sNBC9Env+gX9hwS+wYMcn8DEsEAskdAUbJCSQ0JWu0GhmmBnNq5/ppDvPThznYTuOEzvpxAnV3cP09KWkWEmljl0551TejePYtm1RFGVZjm+i6zqlVN/3r5lhGCBTHaJpGsi8gyvL85vbu9lsprU+FsGaJMl8PqeUvmZ2u51lWZeXl9fX19Pp9AV8fH2s+OTw8X8BZ0KnR8gePKftbzbz/ADFOIzjEKEsJ4QyHPi1a6s0kVEoUVS5jkowZayu6xP4u4vos++NLU5wmkVJGmHMRdUPA+c8RrFpWqa1NgxjGwR1VSGEzsC/2vzbv0PL9RJabHGGCWOi5lW1RbEfxW6I1v7WQzjnQkiVppmU8gQ+xu3D08Xt/T+Pk9vHiRdGtuejNH+aLx8M6+p5djdbOltk+0FGqDpQ/QKGDoEBRIuIlmIYhR7LTtd6pGWdCplvIx4iXgje9qrXZVVLpc7ATT+0wygB2XQVKxShLeelqMpmJ3KiKGtUAwWgx6fg412nB1BZD2Mvm16ITggwA1RDcgdGglXvxYSkegtOlA5F63qe7biOH5i2E6VZRhksvGmdCHtJjgtBZQMbAdVn4K/+DL78w684g0/GhOZFUatm36FqAi6fn5+t5YJmaUQ4d9wySeALTuBvPkZffwjKgslOy52GtVYt7J+W1YrUM3e7xnnIKiNmJMnLLDtjG9gCYlbrDai69gJ3G4HOrBQp417dX5D+97j/CzVL3olxFNC2fNP20dWG7Xy8urmfLacrK0DYD6O84Fy2Ico3rAnakXZDdyRMnrE9AJPQZFhUhdxJwqooqnFclqKta3p3Qzw/ZGUE/uAl2OyFMJiqXg9I9kS2dhAarj9bOzPLtrcRDAdKUiabueMtvfDB3Fw9TizXD2DfV3ti0Xz+o/nDqugqjlmJaZFCt7UEwanamSibPT2YKwM22jBJGg3DcwKnVfvFL95PJtM1P5hkT0A/jJ0esZCLtFzHqU1Lm4hLK/RyjpLkNBhw1XuFuuXKNDbOZLlamOs4IzjN40IYRfsBqZ8X+P2Tc+MlZhClhHb//ZtObE8N4+r+cbq2J8bKR9jxfKpaSorw6mZzeesuLNKPYB19oOoE3k+VHgvZsqYHHqFC6bEb9sI0hFTzab0yKmMJCu3A+Xo4A8NDd8CrfqwPDgPbwJy81h3HQx+OfRv/AjZeCGwYRGz2AAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 02 14 37 15"\n        title=""\n        src="/static/2021-07-02-14-37-15-61f31fbab75310c0f7be777f4b9becac-fee1c.png"\n        srcset="/static/2021-07-02-14-37-15-61f31fbab75310c0f7be777f4b9becac-a67b7.png 200w,\n/static/2021-07-02-14-37-15-61f31fbab75310c0f7be777f4b9becac-0b187.png 400w,\n/static/2021-07-02-14-37-15-61f31fbab75310c0f7be777f4b9becac-fee1c.png 800w,\n/static/2021-07-02-14-37-15-61f31fbab75310c0f7be777f4b9becac-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>首先，我们看下服务器是通过什么方式让浏览器缓存数据的？</p>\n<p>从上图的第一次请求可以看出，当服务器返回 HTTP 响应头给浏览器时，浏览器是通过响应头中的 Cache-Control 字段来设置是否缓存该资源。通常，我们还需要为这个资源设置一个缓存过期时长，而这个时长是通过 Cache-Control 中的 Max-age 参数来设置的，比如上图设置的缓存过期时间是 2000 秒。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="59683274926228250000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`Cache-Control:Max-age=2000`, `59683274926228250000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">Cache-Control:Max-age=2000</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>这也就意味着，在该缓存资源还未过期的情况下, 如果再次请求该资源，会直接返回缓存中的资源给浏览器。</p>\n<p>但如果缓存过期了，浏览器则会继续发起网络请求，并且在 HTTP 请求头中带上：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="84084319836746500000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`If-None-Match:&quot;4f80f-13c-3a1xb12a&quot;`, `84084319836746500000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">If-None-Match:&quot;4f80f-13c-3a1xb12a&quot;</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>服务器收到请求头后，会根据 If-None-Match 的值来判断请求的资源是否有更新。</p>\n<ul>\n<li>如果没有更新，就返回 304 状态码，相当于服务器告诉浏览器：“这个缓存可以继续使用，这次就不重复发送数据给你了。”</li>\n<li>如果资源有更新，服务器就直接返回最新资源给浏览器。</li>\n</ul>\n<p>简要来说，很多网站第二次访问能够秒开，是因为这些网站把很多资源都缓存在了本地，浏览器缓存直接使用本地副本来回应请求，而不会产生真实的网络请求，从而节省了时间。同时，DNS 数据也被浏览器缓存了，这又省去了 DNS 查询环节</p>\n<h3 id="登录状态是如何保持的？"><a href="#%E7%99%BB%E5%BD%95%E7%8A%B6%E6%80%81%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E6%8C%81%E7%9A%84%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>登录状态是如何保持的？</h3>\n<ul>\n<li>\n<p>通过上面的介绍，你已经了解了缓存是如何工作的。下面我们再一起看下登录状态是如何保持的。</p>\n</li>\n<li>\n<p>用户打开登录页面，在登录框里填入用户名和密码，点击确定按钮。点击按钮会触发页面脚本生成用户登录信息，然后调用 POST 方法提交用户登录信息给服务器。</p>\n</li>\n<li>\n<p>服务器接收到浏览器提交的信息之后，查询后台，验证用户登录信息是否正确，如果正确的话，会生成一段表示用户身份的字符串，并把该字符串写到响应头的 Set-Cookie 字段里，如下所示，然后把响应头发送给浏览器</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="68351414039080250000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`Set-Cookie: UID=3431uad;`, `68351414039080250000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">Set-Cookie: UID=3431uad;</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n</li>\n<li>\n<p>浏览器在接收到服务器的响应头后，开始解析响应头，如果遇到响应头里含有 Set-Cookie 字段的情况，浏览器就会把这个字段信息保存到本地。比如把 UID=3431uad 保持到本地。</p>\n</li>\n<li>\n<p>当用户再次访问时，浏览器会发起 HTTP 请求，但在发起请求之前，浏览器会读取之前保存的 Cookie 数据，并把数据写进请求头里的 Cookie 字段里（如下所示），然后浏览器再将请求头发送给服务器。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="16093561926860001000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`Cookie: UID=3431uad;`, `16093561926860001000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">Cookie: UID=3431uad;</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n</li>\n<li>\n<p>服务器在收到 HTTP 请求头数据之后，就会查找请求头里面的“Cookie”字段信息，当查找到包含 UID=3431uad 的信息时，服务器查询后台，并判断该用户是已登录状态，然后生成含有该用户信息的页面数据，并把生成的数据发送给浏览器。</p>\n</li>\n<li>\n<p>浏览器在接收到该含有当前用户的页面数据后，就可以正确展示用户登录的状态信息了</p>\n</li>\n</ul>\n<p>好了，通过这个流程你可以知道浏览器页面状态是通过使用 Cookie 来实现的。Cookie 流程可以参考下图：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-02-14-40-22-4af82d22add944617ac7cc3ca154385a-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 81.61120840630473%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAIAAACZeshMAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAB/ElEQVQoz31T23LbIBD1/39Lf6F96eS1k6ljJ5Yjy5axQNwkhISRhKCL1KRO23jnDLMLHDi7C6sw2+SDewP4f9kU/qwuWGx1yxwBkwc47ycfDUbwYWaYvHV+/HjuCsKZEKwLwxRcvCRuMcbsdknXmTDPjCEuSTOeuCmVle0QyaZ3Dxv27RF/33LMqxyXBeMYQBnCpCAl4bygHJVsnx2eTvLLA/r6SH6kMpIH54UecG2pHs8lbexwnVW0dtjuElbVcGc3TtYHRDlTGsIx5hL8kjNYzC8EzOXpgg/ociZlmqPsfMlQkRyOJ0xOBSFcSN1Nc5pLUX8XDOoBs4iUhxyBwpxQwJlQ8BHon2XDibVugeUm79+rPfNjiApyxkSotqwUbOTakKqJfqVk06ICK90uMsMtOcwx5WJwsYsA3ffpBTdXO73Vv1aN0vo/5CVmQnS2p5WidYOYXCevWVFiWRNZmX5sdNPcIZeME8q3u/36JXlK0pcs3yTp9vXw83l3wSRHl6Zt32X+Q6aUyao2V6ENVV2pOtoY8GVrVGf2aabb9nPZc87QSUgUum1c6FyADvfzqoqqPydzwe0wwiO9Om9G3/auGybwrYt9lbW6ezNjtu+XT6Kvdr15FrWCJz3M5Kqu9Z2Ccc6Px6MQoqQMigediyNjAMY5IcRae/urfgES7pe98fK3TwAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 02 14 40 22"\n        title=""\n        src="/static/2021-07-02-14-40-22-4af82d22add944617ac7cc3ca154385a-fee1c.png"\n        srcset="/static/2021-07-02-14-40-22-4af82d22add944617ac7cc3ca154385a-a67b7.png 200w,\n/static/2021-07-02-14-40-22-4af82d22add944617ac7cc3ca154385a-0b187.png 400w,\n/static/2021-07-02-14-40-22-4af82d22add944617ac7cc3ca154385a-fee1c.png 800w,\n/static/2021-07-02-14-40-22-4af82d22add944617ac7cc3ca154385a-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>简单地说，如果服务器端发送的响应头内有 Set-Cookie 的字段，那么浏览器就会将该字段的内容保持到本地。当下次客户端再往该服务器发送请求时，客户端会自动在请求头中加入 Cookie 值后再发送出去。服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到该用户的状态信息。</p>\n<h2 id="总结-2"><a href="#%E6%80%BB%E7%BB%93-2" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总结</h2>\n<p>本篇文章的内容比较多、比较碎，但是非常重要，所以我先来总结下今天的主要内容。</p>\n<p>为了便于你理解，我画了下面这张详细的“HTTP 请求示意图”，用来展现浏览器中的 HTTP 请求所经历的各个阶段。</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-02-14-40-45-86a71443bb66a1e30057d7f6a1be6e9f-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 37.04028021015762%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAIAAACHqfpvAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABeklEQVQY04WQPUvDUBSGg4s/w8HRXf+Co+Ci2IoVnMXBwUWUFvwDujm4FVsQFRQtrV9owaFSLf1umqS1TW4Tb5MmN01uknuMuLl4lvfwvufhcA4H/xWxbUEQRFFyXfon4n6FAchICeccx+H5tkks3w8cxw0BYtmahr/wcDx2KaWhQz3f833GGPfD/dCse3BNX3neg+mUOHVpXvFJGO2M9IRtJqhzMEBxJO+rg33f3F14qi29EIAghL2AjS0W6FuXLFd+Z8HE2YhLwal4BMaijtdMYxVgHSmRgRJRURS8yEyuOncfhAs5wI+V8ua81pK2b+/O9rY+45Npi0t6Sf4Q3GUDx2wzBsHGQI4q/egQx8BemcmUZ3Ph/T5n691aLXverjeeS8XiQ7bxcFIQj98+y0JB69xgNa9peUnIYPyKlJeOlMNaPv1Rv6j0WOBzI5PwvNRttiqNarstoq6io56pypZhSaJMCDUMUio1wz+FTbPZsQgdKn1DRYzBN4lJZz58Un6rAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 02 14 40 45"\n        title=""\n        src="/static/2021-07-02-14-40-45-86a71443bb66a1e30057d7f6a1be6e9f-fee1c.png"\n        srcset="/static/2021-07-02-14-40-45-86a71443bb66a1e30057d7f6a1be6e9f-a67b7.png 200w,\n/static/2021-07-02-14-40-45-86a71443bb66a1e30057d7f6a1be6e9f-0b187.png 400w,\n/static/2021-07-02-14-40-45-86a71443bb66a1e30057d7f6a1be6e9f-fee1c.png 800w,\n/static/2021-07-02-14-40-45-86a71443bb66a1e30057d7f6a1be6e9f-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从图中可以看到，浏览器中的 HTTP 请求从发起到结束一共经历了如下八个阶段：构建请求、查找缓存、准备 IP 和端口、等待 TCP 队列、建立 TCP 连接、发起 HTTP 请求、服务器处理请求、服务器返回请求和断开连接。</p>\n<p>然后我还通过 HTTP 请求路径解答了两个经常会碰到的问题，一个涉及到了 Cache 流程，另外一个涉及到如何使用 Cookie 来进行状态管理。</p>\n<p>通过今天系统的讲解，想必你已经了解了一个 HTTP 完整的工作流程，相信这些知识点之于你以后的学习或工作会很有帮助。</p>\n<h1 id="渲染流程（上）"><a href="#%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>渲染流程（上）</h1>\n<p>在上一篇文章中我们介绍了导航相关的流程，那导航被提交后又会怎么样呢？就进入了渲染阶段。这个阶段很重要，了解其相关流程能让你“看透”页面是如何工作的，有了这些知识，你可以解决一系列相关的问题，比如能熟练使用开发者工具，因为能够理解开发者工具里面大部分项目的含义，能优化页面卡顿问题，使用 JavaScript 优化动画流程，通过优化样式表来防止强制同步布局，等等。</p>\n<p>既然它的功能这么强大，那么今天，我们就来好好聊聊渲染流程。</p>\n<p>通常，我们编写好 HTML、CSS、JavaScript 等文件，经过浏览器就会显示出漂亮的页面（如下图所示），但是你知道它们是如何转化成页面的吗？这背后的原理，估计很多人都答不上来。</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-02-16-05-52-f9ed713c2bf23d27e50dcf589b7ed991-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 39.492119089316986%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAIAAAB2/0i6AAAACXBIWXMAAA7DAAAOwwHHb6hkAAABCklEQVQY022R626DIABGff9X2SNs2b/d0qyb84IWq7ZORZw60yLgQAe167bWE0IC5PtyAGO8YNCMh3FESqnXFxg/gd8tRlmNcYFw07RxGEXxFpflWf+/8F8oZWsI0UeVZoUHPNuyVdNJSggppJrFMdzLIWyFUHpCQ7ouyzMAg1fTDdbb+4fnKEykRuwJTTZu7N9U9acq0uGayUXR73rJKCWEYGVZVh7wbcv1YXR9++g4K845paoUr8ACLK9yhFWZDu/6QeXJl5zc2rZdvph13QQBTLM0DGPTtKYj5bUnHel415H5OzPG757eHACT901ZpnmOEULjHMb0dmf/QIi6gTIVnPGDMB3mvuob8QvKF8uYFxQAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 02 16 05 52"\n        title=""\n        src="/static/2021-07-02-16-05-52-f9ed713c2bf23d27e50dcf589b7ed991-fee1c.png"\n        srcset="/static/2021-07-02-16-05-52-f9ed713c2bf23d27e50dcf589b7ed991-a67b7.png 200w,\n/static/2021-07-02-16-05-52-f9ed713c2bf23d27e50dcf589b7ed991-0b187.png 400w,\n/static/2021-07-02-16-05-52-f9ed713c2bf23d27e50dcf589b7ed991-fee1c.png 800w,\n/static/2021-07-02-16-05-52-f9ed713c2bf23d27e50dcf589b7ed991-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从图中可以看出，左边输入的是 HTML、CSS、JavaScript 数据，这些数据经过中间渲染模块的处理，最终输出为屏幕上的像素。</p>\n<p>这中间的渲染模块就是我们今天要讨论的主题。为了能更好地理解下文，你可以先结合下图快速抓住 HTML、CSS 和 JavaScript 的含义：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-02-16-05-58-6a940bf92dcacab8dcc2cc452b23d026-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 61.646234676007005%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABTklEQVQoz51S207DMAzd/38RbzzxEwyGRtssbSDNpbk4iVPcbmPTYBLiKKkax8c+trOZV9Q6/wMb2vsJH5r82GX6l0JEMRT5aXs+KkUWxLnvyzB8CDFIKRnLzuGFHErVUEVASp9TclpP46ilNMZ4751zfa+c84Lixuh9SaleyDcoiJlWpjgphECEUoAMpeAvstsJn3iRcYlHWylFSehLtKOTMbNzwA6MFBUx+ClfyCPUnUGXT2StSfKi+ZvMegsZ37tWj6Ph3Np4V/YNEEA3+woRlErWgHM5/iDfGxbGUBibg0et6mSr9zVfyaZqD+fu10q3flqRV6e6jKM47yHnAECdRJoVwKVhz7qc8iByzpumaduWopAFALquI8PLdtt0XdYadq9o7Z9qXnKvD9C7CUJYznj1SOjquuB6xpGDEGPbAGOJs/C2S/yQhv7o+AWZubvkbXXPigAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 02 16 05 58"\n        title=""\n        src="/static/2021-07-02-16-05-58-6a940bf92dcacab8dcc2cc452b23d026-fee1c.png"\n        srcset="/static/2021-07-02-16-05-58-6a940bf92dcacab8dcc2cc452b23d026-a67b7.png 200w,\n/static/2021-07-02-16-05-58-6a940bf92dcacab8dcc2cc452b23d026-0b187.png 400w,\n/static/2021-07-02-16-05-58-6a940bf92dcacab8dcc2cc452b23d026-fee1c.png 800w,\n/static/2021-07-02-16-05-58-6a940bf92dcacab8dcc2cc452b23d026-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从上图可以看出，HTML 的内容是由标记和文本组成。标记也称为标签，每个标签都有它自己的语意，浏览器会根据标签的语意来正确展示 HTML 内容。比如上面的 <code class="language-text">&lt;p&gt;</code> 标签是告诉浏览器在这里的内容需要创建一个新段落，中间的文本就是段落中需要显示的内容</p>\n<p>如果需要改变 HTML 的字体颜色、大小等信息，就需要用到 CSS。CSS 又称为层叠样式表，是由选择器和属性组成，比如图中的 p 选择器，它会把 HTML 里面 <code class="language-text">&lt;p&gt;</code> 标签的内容选择出来，然后再把选择器的属性值应用到 <code class="language-text">&lt;p&gt;</code> 标签内容上。选择器里面有个 color 属性，它的值是 red，这是告诉渲染引擎把 <code class="language-text">&lt;p&gt;</code> 标签的内容显示为红色</p>\n<p>至于 JavaScript（简称为 JS），使用它可以使网页的内容“动”起来，比如上图中，可以通过 JavaScript 来修改 CSS 样式值，从而达到修改文本颜色的目的。</p>\n<p>搞清楚 HTML、CSS 和 JavaScript 的含义后，那么接下来我们就正式开始分析渲染模块了。</p>\n<p>由于渲染机制过于复杂，所以渲染模块在执行过程中会被划分为很多子阶段，输入的 HTML 经过这些子阶段，最后输出像素。我们把这样的一个处理流程叫做渲染流水线，其大致流程如下图所示：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-02-16-06-13-89b78e89bcac2f6bb9219e8b4c79262f-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 21.36602451838879%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAIAAAABPYjBAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAAxklEQVQI111PzQqCQBj0dYJepEeQnqM36REiiA5BBEnUIegUQQehCFL7MTV12z/NXXfVXKgOzmWY75sZGK1qoFRQVBQEY5Hn/6OUsuHV1KuqRKEEYyyECGISIwwRdv0gfMFaAkQwQgCAujGrTYzX3d8wk+X2yYUsLD9qjeze+tIeW/29py/v+tzprtzOzK7eFBMSPIG5m5zMFeO/cCpKNxGZLCGhg0O4ucbDY7T3oGEDw4oXzmt6jlmaEEppknoPJ/BvnKs5H8Iz3DFqFoEBAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 02 16 06 13"\n        title=""\n        src="/static/2021-07-02-16-06-13-89b78e89bcac2f6bb9219e8b4c79262f-fee1c.png"\n        srcset="/static/2021-07-02-16-06-13-89b78e89bcac2f6bb9219e8b4c79262f-a67b7.png 200w,\n/static/2021-07-02-16-06-13-89b78e89bcac2f6bb9219e8b4c79262f-0b187.png 400w,\n/static/2021-07-02-16-06-13-89b78e89bcac2f6bb9219e8b4c79262f-fee1c.png 800w,\n/static/2021-07-02-16-06-13-89b78e89bcac2f6bb9219e8b4c79262f-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>按照渲染的时间顺序，流水线可分为如下几个子阶段：<strong>构建 DOM 树、样式计算、布局阶段、分层、绘制、分块、光栅化和合成</strong>。内容比较多，我会用两篇文章来为你详细讲解这各个子阶段。接下来，在介绍每个阶段的过程中，你应该重点关注以下三点内容</p>\n<ul>\n<li>开始每个子阶段都有其输入的内容；</li>\n<li>然后每个子阶段有其处理过程；</li>\n<li>最终每个子阶段会生成输出内容。</li>\n</ul>\n<p>理解了这三部分内容，能让你更加清晰地理解每个子阶段。</p>\n<h2 id="构建-dom-树"><a href="#%E6%9E%84%E5%BB%BA-dom-%E6%A0%91" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>构建 DOM 树</h2>\n<p>为什么要构建 DOM 树呢？这是因为浏览器无法直接理解和使用 HTML，所以需要将 HTML 转换为浏览器能够理解的结构——DOM 树。</p>\n<p>这里我们还需要简单介绍下什么是树结构，为了更直观地理解，你可以参考下面我画的几个树结构：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-02-16-08-36-42700865796c08a6398a35d5c4b39f2b-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 75.21891418563924%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAIAAABr+ngCAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABPElEQVQoz42Sy06DQBSGef8XcuXKhXHhwsRrUjXUtqQtBSxzYc5tHJgKlVDbEzKZ+XO+nMtP4n9DunOl2JH409GwRzkkJ8cwE6alUdZ5meCjNKtwqyE+kyhZ8oWBQGcKgUg3rnQ8wjT6KuQINUAvBfkeXlUqLXS4zJWErjXwW24HuEtaaV7u25ohoXKtlIQCsxLS0s4r+1UTxzyFuYGNob5sjLqBuu3ooLXwQktmZK1wbX1c1sZK4Xz4ejieWytLE3aDQjQszKJ8fLdvWqScb4ZeO0yOuueqcPd38Z5Ekdgr8oLgbm/EGulEmVo4GyP13o+sOuXNrpFM82j4E/DYYS4N5BrikOfgv8Y+7yBO/bCFI+P9RW3rBpnJOYfEl1buIzCv+2D+9N/+L9wxxeMTZcupdVwA4/UVfr5Pwj/+r3VzCmDATQAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 02 16 08 36"\n        title=""\n        src="/static/2021-07-02-16-08-36-42700865796c08a6398a35d5c4b39f2b-fee1c.png"\n        srcset="/static/2021-07-02-16-08-36-42700865796c08a6398a35d5c4b39f2b-a67b7.png 200w,\n/static/2021-07-02-16-08-36-42700865796c08a6398a35d5c4b39f2b-0b187.png 400w,\n/static/2021-07-02-16-08-36-42700865796c08a6398a35d5c4b39f2b-fee1c.png 800w,\n/static/2021-07-02-16-08-36-42700865796c08a6398a35d5c4b39f2b-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从图中可以看出，树这种结构非常像我们现实生活中的“树”，其中每个点我们称为节点，相连的节点称为父子节点。树结构在浏览器中的应用还是比较多的，比如下面我们要介绍的渲染流程，就在频繁地使用树结构。</p>\n<p>接下来咱们还是言归正传，来看看 DOM 树的构建过程，你可以参考下图</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-02-16-08-49-4cefa68e354f6a9eef45bfa391736ac8-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 48.59894921190894%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABSklEQVQoz32R2U7DMBBF+/9PfABfgcQrm3gAFZVCF7WCkC5pms3x7niJE2wCVYIEI9my594zM5ZH7d/RNH5f5/x8fJgeyFem6RtGbglptK47rS93R8Dk2fUyo+qUGcAY8ygrEcFMCl1rbzJcw7A1dJlV420+O+L7IFV182s0D1NWZZApJZXSSptKqlpxnUxbuHrcFE870Fh5MTuUlLmythnCUqpjweIUQsxEpRDCprbO1ipyuS5fYnwb5M72vM8nEegP72HXKgGuvfbM8MEhlFdB8f62el0spjGaR/kipSfVw0xoKlQP84q1vlAQZzeTGUHwY7e/m4fhEYRJefKM/vkptxAE0ebDGGNtjYqUEcQpHrzZBeecUtp1c+HcZVkKIborIQQh9KM2D3uyBby19TfMGHOOPlwURQe7JITQ1dJadwMHUZLkQGv1CfvcQGddNcHkAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 02 16 08 49"\n        title=""\n        src="/static/2021-07-02-16-08-49-4cefa68e354f6a9eef45bfa391736ac8-fee1c.png"\n        srcset="/static/2021-07-02-16-08-49-4cefa68e354f6a9eef45bfa391736ac8-a67b7.png 200w,\n/static/2021-07-02-16-08-49-4cefa68e354f6a9eef45bfa391736ac8-0b187.png 400w,\n/static/2021-07-02-16-08-49-4cefa68e354f6a9eef45bfa391736ac8-fee1c.png 800w,\n/static/2021-07-02-16-08-49-4cefa68e354f6a9eef45bfa391736ac8-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从图中可以看出，构建 DOM 树的输入内容是一个非常简单的 HTML 文件，然后经由 HTML 解析器解析，最终输出树状结构的 DOM。</p>\n<p>为了更加直观地理解 DOM 树，你可以打开 Chrome 的“开发者工具”，选择“Console”标签来打开控制台，然后在控制台里面输入“document”后回车，这样你就能看到一个完整的 DOM 树结构，如下图所示：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-02-16-09-05-2067a2b87ed56790b581b29b437b690e-78894.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 85.24904214559388%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAIAAABSJhvpAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACCUlEQVQ4y41T/W+bMBDl//9rJu3XdVKlbd2qtouaRUlHS/iyjbENGAzGH8CckDZZl247PVnm4N17uju89ZO6Xsq7lbpdqS93qhFdmqYQIkJIEARZliUAL9ePCcRxHLtXlFKXdyfG2LtayHcfxMVVd3ndvf8oi6pNkggAgBBijNV1XVa8KCuckyRJiqLgnGut1T686fdQSqNsJxJFkSsvhGiewxV6OefwMEc/4dpHm7ItHZkLtXrMkzh0fKfc/DW8m6fPXx8uP20uaJ07suwVyvIwCJx2EsfOf1VVTu4sjrbH/VlLuwoZgCBKASvLpu0cRHcenolDef/dynYmG14Sfx0sbtLNfZslikCV70GekR8znvI38vbbqNSsb3Cq6grGib9YV4RMg52MnuweRh/uxn08ahC87ramaLTGuaipaIrWmL7vdd1Z0VtlrNF91xvRaqFGCUNvGsdpGI5kAkdXfpoYYGADelFJKSHtEOvaru/buhaKMsG4lmD7hzKBkzXGWrRFDWt2jXTVD9186e3uUaP4DHlWdhyc4oe1H7nFogXHXCs9D2UcZnL0JtmNYuuHECG3jI4x2GFv4d/Kxl0EF5xybbSSapb6T9u7sTkpHGP3M8AQtqWY/R4wDm/YptmszGAF/Gw4Wb7Xytmp8j6l0qfdnuSI/Nh0aTKUxBa5LbBlJ6CZLWnvL38BTV/IFJc6LtoAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 02 16 09 05"\n        title=""\n        src="/static/2021-07-02-16-09-05-2067a2b87ed56790b581b29b437b690e-fee1c.png"\n        srcset="/static/2021-07-02-16-09-05-2067a2b87ed56790b581b29b437b690e-a67b7.png 200w,\n/static/2021-07-02-16-09-05-2067a2b87ed56790b581b29b437b690e-0b187.png 400w,\n/static/2021-07-02-16-09-05-2067a2b87ed56790b581b29b437b690e-fee1c.png 800w,\n/static/2021-07-02-16-09-05-2067a2b87ed56790b581b29b437b690e-78894.png 1044w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>图中的 document 就是 DOM 结构，你可以看到，DOM 和 HTML 内容几乎是一样的，但是和 HTML 不同的是，DOM 是保存在内存中树状结构，可以通过 JavaScript 来查询或修改其内容。</p>\n<p>那下面就来看看如何通过 JavaScript 来修改 DOM 的内容，在控制台中输入：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="98461324440191200000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`document.getElementsByTagName(\'p\')[0].innerText = \'black\';`, `98461324440191200000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js">document<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span><span class="token string">\'p\'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>innerText <span class="token operator">=</span> <span class="token string">\'black\'</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>这行代码的作用是把第一个 <code class="language-text">&lt;p&gt;</code> 标签的内容修改为 black，具体执行结果你可以参考下图：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-02-16-09-41-51e72617b9c746f8ec1a1d3f6cf66ed3-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 62.34676007005253%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABh0lEQVQoz4WSWW+cMBSF8/9/VdTHPkVtGjGTAQMeNi94Axu8EQ+kmkylKp8u5nKl43Nk/LR9EvaKqYs73vsYQwgu7i//F+duk0PzlB4/z/kvdH4huu28NQPChJBhGDAdq2vfD2gY+nGHc57my7LcxWFdKVxI7R2jzrCm7QEASa+U4kLedtp7s6O1ttbexSlGLcGZZdIQu5iypbCuEMJCiKRR0w2plEwolYbmwTkEIGFGL5Omq56Lqi/zSwNrRsgkRCrF+ST40UjOF63v4huw3ShLIVY1dn+y7vU3Op/7LOtOpybLeJHjokJ5LmCt3k+mbbY98KfYgdxjHDcf14lTCgFIpxJicGoybWl7aEdmGXNSOEr8pB6dD6KL3ri4dVcsmUq/ziK8VsDC2pbANlc3DOnTEXJ3jsviEfJC+BFb3KUcChTw5yu7lF6p7f/sYq3X4iJ/PJvsbe3aYKdgFAbXNgdmFIfJv/UQO12jdIYhHGNnA+u4Notb/TfOXzdLVzGtms/zOG3f8QHUorEigoV4zAAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 02 16 09 41"\n        title=""\n        src="/static/2021-07-02-16-09-41-51e72617b9c746f8ec1a1d3f6cf66ed3-fee1c.png"\n        srcset="/static/2021-07-02-16-09-41-51e72617b9c746f8ec1a1d3f6cf66ed3-a67b7.png 200w,\n/static/2021-07-02-16-09-41-51e72617b9c746f8ec1a1d3f6cf66ed3-0b187.png 400w,\n/static/2021-07-02-16-09-41-51e72617b9c746f8ec1a1d3f6cf66ed3-fee1c.png 800w,\n/static/2021-07-02-16-09-41-51e72617b9c746f8ec1a1d3f6cf66ed3-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从图中可以看出，在执行了一段修改第一个 <code class="language-text">&lt;p&gt;</code> 标签的 JavaScript 代码后，DOM 的第一个 p 节点的内容成功被修改，同时页面中的内容也被修改了</p>\n<p>好了，现在我们已经生成 DOM 树了，但是 DOM 节点的样式我们依然不知道，要让 DOM 节点拥有正确的样式，这就需要样式计算了</p>\n<h2 id="样式计算"><a href="#%E6%A0%B7%E5%BC%8F%E8%AE%A1%E7%AE%97" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>样式计算</h2>\n<p>样式计算的目的是为了计算出 DOM 节点中每个元素的具体样式，这个阶段大体可分为三步来完成</p>\n<h3 id="把-css-转换为浏览器能够理解的结构"><a href="#%E6%8A%8A-css-%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%B5%8F%E8%A7%88%E5%99%A8%E8%83%BD%E5%A4%9F%E7%90%86%E8%A7%A3%E7%9A%84%E7%BB%93%E6%9E%84" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>把 CSS 转换为浏览器能够理解的结构</h3>\n<p>那 CSS 样式的来源主要有哪些呢？你可以先参考下图：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-02-16-12-02-e0fe4b6f2cb6fe5338ba6e72a381bf91-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 51.225919439579684%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAB4klEQVQoz32S3U/aUBjGvdkytuESqBRMbEHari0CK/ZD0TikRUCIWfz3gIRFjTCzjBv9FxTXIslIIHxeDLeMjoSPXiwG7A4dy2JM9kve8948z3nenPcs6Lre66nXsnJzU1JKJQVUaV6fZeXyqthTfwLN/V+m0yk4dYMFUJlMhnhNRWJxSZKiUliUpIgYju3tBTkfCps/5bNT7XuxWKxUKoqilMvlZrP557qZOZVKkSQZTyRFUQzv7oZCoe2trYgU4dj1V4sv87lToOn3+6PRaDAYDIfD8Xj8IBnHcZKiUNcqwIUgdhh2u93Cum8ZMn/MvdfvRo1Go9PpgMxWqwX8/5JnY+OYP8B6GYamKSfqXEEQmqLZwBvIYj7Ln+j3v2q1GrC1DUD+g2QMw2ivn/CsEW7MiSJ2uwPHCa/P//yF+TSXB5rJZKI/YmZOp9MYQQa3d3iO43lBEDY2eHYnyLHMms2yeJY71vW7drvz7fb2q0G329U0bW7OZrM2+zLD8u8ODw+SyeT+/kEiKjAUH/B4CKTw4Wii/ZBluV6vfzGoVquqqs7N4LVNJtMK6nK6VmGHA7JardCSBVqywY4nT58dHZ/8b+xCofBWlOKJBFgV2LFkAFosGg1ubl5cnAMN+BuPzb8BngdqTouR4pMAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 02 16 12 02"\n        title=""\n        src="/static/2021-07-02-16-12-02-e0fe4b6f2cb6fe5338ba6e72a381bf91-fee1c.png"\n        srcset="/static/2021-07-02-16-12-02-e0fe4b6f2cb6fe5338ba6e72a381bf91-a67b7.png 200w,\n/static/2021-07-02-16-12-02-e0fe4b6f2cb6fe5338ba6e72a381bf91-0b187.png 400w,\n/static/2021-07-02-16-12-02-e0fe4b6f2cb6fe5338ba6e72a381bf91-fee1c.png 800w,\n/static/2021-07-02-16-12-02-e0fe4b6f2cb6fe5338ba6e72a381bf91-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从图中可以看出，CSS 样式来源主要有三种：</p>\n<ul>\n<li>通过 link 引用的外部 CSS 文件</li>\n<li><code class="language-text">&lt;style&gt;</code> 标记内的 CSS</li>\n<li>元素的 style 属性内嵌的 CSS</li>\n</ul>\n<p>和 HTML 文件一样，浏览器也是无法直接理解这些纯文本的 CSS 样式，所以当渲染引擎接收到 CSS 文本时，会执行一个转换操作，将 CSS 文本转换为浏览器可以理解的结构——styleSheets。</p>\n<p>为了加深理解，你可以在 Chrome 控制台中查看其结构，只需要在控制台中输入 document.styleSheets，然后就看到如下图所示的结构</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-02-16-12-40-791585362c47e31660a48d55a09dac3a-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 51.48861646234676%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABfElEQVQoz4VS27KjIBD0//8vu+ckGowgF+UiNwUSdMekzta+bdeUtgzN9Aw21lqEHiNlQgjnvHN227Z1Xe2y5JTWGIHAZ9o2IDGELSUgwftScpO2RKkQ87wYgzEex9F7zzmfGeV44ILraRKE0Ecv6agJ9iM2nEnGVu+aWqvksm/7YSDGLADworV2zlFKlVI+BDjr40tLGSCcVVrHGJvjOIxY+CCUtjln8Ayrp8+UP3g+nymlUgoQyKZ8EugCUqdYEU2vXHHlrQfZXivs3lI5/odTbCfH+2lmcwwRGgbnIA4hGKOhFPg3xvwl5yyt/ew5xcvsZiYkHyENS/sb9R37cez/kPP1IbWeleteJVMjGtH9DlOBg6GlWsor51fJr5ROktLz3TS0ClF+cFaONk58YowRQhBCjPNAsLldl661/R2e+vvL4kF2Lft14T3CbfvoOvgxGhialoZggt8AMVy1xsPctgohPTzm7jbdvlV/n35fFLijdGjb6+XCGfsD3vwz8Zv1rq8AAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 02 16 12 40"\n        title=""\n        src="/static/2021-07-02-16-12-40-791585362c47e31660a48d55a09dac3a-fee1c.png"\n        srcset="/static/2021-07-02-16-12-40-791585362c47e31660a48d55a09dac3a-a67b7.png 200w,\n/static/2021-07-02-16-12-40-791585362c47e31660a48d55a09dac3a-0b187.png 400w,\n/static/2021-07-02-16-12-40-791585362c47e31660a48d55a09dac3a-fee1c.png 800w,\n/static/2021-07-02-16-12-40-791585362c47e31660a48d55a09dac3a-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从图中可以看出，这个样式表包含了很多种样式，已经把那三种来源的样式都包含进去了。当然样式表的具体结构不是我们今天讨论的重点，你只需要知道渲染引擎会把获取到的 CSS 文本全部转换为 styleSheets 结构中的数据，并且该结构同时具备了查询和修改功能，这会为后面的样式操作提供基础</p>\n<h3 id="转换样式表中的属性值，使其标准化"><a href="#%E8%BD%AC%E6%8D%A2%E6%A0%B7%E5%BC%8F%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%B1%9E%E6%80%A7%E5%80%BC%EF%BC%8C%E4%BD%BF%E5%85%B6%E6%A0%87%E5%87%86%E5%8C%96" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>转换样式表中的属性值，使其标准化</h3>\n<p>现在我们已经把现有的 CSS 文本转化为浏览器可以理解的结构了，那么接下来就要对其进行属性值的标准化操作。</p>\n<p>要理解什么是属性值标准化，你可以看下面这样一段 CSS 文本</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="1200411703464743200"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`body {\n  font-size: 2em;\n}\np {\n  color: blue;\n}\nspan {\n  display: none;\n}\ndiv {\n  font-weight: bold;\n}\ndiv p {\n  color: green;\n}\ndiv {\n  color: red;\n}`, `1200411703464743200`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                css 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="css"><pre style="counter-reset: linenumber NaN" class="language-css line-numbers"><code class="language-css"><span class="token selector">body</span> <span class="token punctuation">{</span>\n  <span class="token property">font-size</span><span class="token punctuation">:</span> 2em<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token selector">p</span> <span class="token punctuation">{</span>\n  <span class="token property">color</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token selector">span</span> <span class="token punctuation">{</span>\n  <span class="token property">display</span><span class="token punctuation">:</span> none<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token selector">div</span> <span class="token punctuation">{</span>\n  <span class="token property">font-weight</span><span class="token punctuation">:</span> bold<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token selector">div p</span> <span class="token punctuation">{</span>\n  <span class="token property">color</span><span class="token punctuation">:</span> green<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token selector">div</span> <span class="token punctuation">{</span>\n  <span class="token property">color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>可以看到上面的 CSS 文本中有很多属性值，如 2em、blue、bold，这些类型数值不容易被渲染引擎理解，所以需要将所有值转换为渲染引擎容易理解的、标准化的计算值，这个过程就是属性值标准化。</p>\n<p>那标准化后的属性值是什么样子的？</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-02-16-13-34-8841a135870c814b592e642ff3947b8f-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 30.297723292469353%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAIAAABM9SnKAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABDUlEQVQY0zWP63LCIBBGff/Xsp3WqZ3RqdVqTQgYbgmQREmwDZdu1DKHH/DtYZdZuq0xpSE8cGE6xonoU7rG5G4MNyD1cYrAmsHux0BbWzb21PSkscR0tDnb0bsQiW4zoTKhc6EwrQqhoZK1FqKHzJzfQMIYIjkXTBmZS/VB+K6U7/uc05IVSCBUZZnTGuqx6sT1X0bWrwve1pIUOTodhcR5Zb6UPajL2zceukar+szKX1zEc5euPTIWw/fuMh/8iuoNrZdELktxqLtP2cLbekwrauB+TdU2o7uCb0/1npuNbKufe+cYnY+oDwvtn3UAXtR4vPhhDM4HPMSF8U/Kz3WcmzDX/lV7mBQUkP8AhUBPsP+pwwMAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 02 16 13 34"\n        title=""\n        src="/static/2021-07-02-16-13-34-8841a135870c814b592e642ff3947b8f-fee1c.png"\n        srcset="/static/2021-07-02-16-13-34-8841a135870c814b592e642ff3947b8f-a67b7.png 200w,\n/static/2021-07-02-16-13-34-8841a135870c814b592e642ff3947b8f-0b187.png 400w,\n/static/2021-07-02-16-13-34-8841a135870c814b592e642ff3947b8f-fee1c.png 800w,\n/static/2021-07-02-16-13-34-8841a135870c814b592e642ff3947b8f-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从图中可以看到，2em 被解析成了 32px，red 被解析成了 rgb(255,0,0)，bold 被解析成了 700……</p>\n<h3 id="计算出-dom-树中每个节点的具体样式"><a href="#%E8%AE%A1%E7%AE%97%E5%87%BA-dom-%E6%A0%91%E4%B8%AD%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E5%85%B7%E4%BD%93%E6%A0%B7%E5%BC%8F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>计算出 DOM 树中每个节点的具体样式</h3>\n<p>现在样式的属性已被标准化了，接下来就需要计算 DOM 树中每个节点的样式属性了，如何计算呢？</p>\n<p>这就涉及到 CSS 的继承规则和层叠规则了。</p>\n<p>首先是 CSS 继承。CSS 继承就是每个 DOM 节点都包含有父节点的样式。这么说可能有点抽象，我们可以结合具体例子，看下面这样一张样式表是如何应用到 DOM 节点上的。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="51887303672199290000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`body {\n  font-size: 20px;\n}\np {\n  color: blue;\n}\nspan {\n  display: none;\n}\ndiv {\n  font-weight: bold;\n  color: red;\n}\ndiv p {\n  color: green;\n}`, `51887303672199290000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                css 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="css"><pre style="counter-reset: linenumber NaN" class="language-css line-numbers"><code class="language-css"><span class="token selector">body</span> <span class="token punctuation">{</span>\n  <span class="token property">font-size</span><span class="token punctuation">:</span> 20px<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token selector">p</span> <span class="token punctuation">{</span>\n  <span class="token property">color</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token selector">span</span> <span class="token punctuation">{</span>\n  <span class="token property">display</span><span class="token punctuation">:</span> none<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token selector">div</span> <span class="token punctuation">{</span>\n  <span class="token property">font-weight</span><span class="token punctuation">:</span> bold<span class="token punctuation">;</span>\n  <span class="token property">color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token selector">div p</span> <span class="token punctuation">{</span>\n  <span class="token property">color</span><span class="token punctuation">:</span> green<span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>这张样式表最终应用到 DOM 节点的效果如下图所示：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-02-16-14-28-f41716c265ae029adde20d8757c7c165-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 76.70753064798599%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAIAAABr+ngCAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACAklEQVQoz4VTy26bQBT1qh/Qb8oiatUP6Lar/EP/oNt+QxZN1XblqE1XUdVVF7YUimOMMVAIZng/DDMwY3LGkzgPWeqRQMMM53LuuYfRcADbut+m3dCLrXzYAQshxH6tMMLVdV1ZltUOWZ5XZXF8ao7e/zk3koFFf2cz01wCrutqmpbnuap4R07TFLuGYVgru0zjKg5+LcnZVRRkeE+wtsnzAhxZOss45/vvS3LbtlEcxxEpQ+v3kvzUlrK2vLqx5l5aaRJ6nn8DBEGwWq3CMOz7/o6swOXr7O14ffTZlysu2zw6td590bzF1US7nkwmpmmqEuj0gbxX0tGma6t749iWFYPgQ+kNNdkUWdM0gnMohfhH5N29ZuLCTMb6TcXELGZvvv6zSEbFcPLDe/XN/25TKebB7Huy2prH9OVH88UH/dKjTtq8PnNWeUd7fnIRHX+yz5f1YfK+RJKlUbnppAECjUsvOLzhAw2F4PAJ3WLgz8lVJYfdpG5bFxgJo1T0Uqdt2wvMGWO0ncVi4XmecuuRbCHWO8DKvCgIiTZ1PYhOkREBFRIkghDynAxggNPpdKbrlmXBz3ZTDXwjZ8ZYuwMWkE0pVVY/IaMeDnAcRZHjuGQdpMRDHpIkAfPQL/DUMDVqCNN1HULmcwMqkIq6rv9PVkBjYPq+jzwh0ggGUn2QfAuXeEuqlewHzAAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 02 16 14 28"\n        title=""\n        src="/static/2021-07-02-16-14-28-f41716c265ae029adde20d8757c7c165-fee1c.png"\n        srcset="/static/2021-07-02-16-14-28-f41716c265ae029adde20d8757c7c165-a67b7.png 200w,\n/static/2021-07-02-16-14-28-f41716c265ae029adde20d8757c7c165-0b187.png 400w,\n/static/2021-07-02-16-14-28-f41716c265ae029adde20d8757c7c165-fee1c.png 800w,\n/static/2021-07-02-16-14-28-f41716c265ae029adde20d8757c7c165-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从图中可以看出，所有子节点都继承了父节点样式。比如 body 节点的 font-size 属性是 20，那 body 节点下面的所有节点的 font-size 都等于 20。</p>\n<p>为了加深你对 CSS 继承的理解，你可以打开 Chrome 的“开发者工具”，选择第一个“element”标签，再选择“style”子标签，你会看到如下界面</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-02-16-14-40-9531707a82e91ea0e7e015bea3cbc620-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 91.3309982486865%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAIAAADUsmlHAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACdElEQVQ4y22TyW4UMRCG82ScEA+DIl6AEzdOXLiEC+IN8gI5wAEpAimblKAMUZZJT7e73e19adtlNzXZSGam5Ivd/dtVX/21NT1EuVtTCKN3xhhpjU5eB6uNVngSw5himF7G1sreMTrMK07pFOSnQ75fiSnK0ak06uTElOOquEAA02Y3ZEOCYbQatDQTpP0WFgamklOCBDkFi3+uiUsu0Zbkp6CiU92C0ZZpZTOEFIIf7yMGpwqMa2mjOsgcFGTwtJJXM9B1sQRTBbz0fiVXop4ybBKPArxAWrS57eYX3XzG2mvd3SpGOWds6EnTWGs2AisPu+zl0CjBgrdT8Z9P9GEjJ4idNGLojOJY/0baSz3myduFUYprgdsjNtnR/qr4xyM3eYHfSlqrOY8KPCvRWNlZQbX2TCDYNEHIjjsj5QjWOXx5A21sEhhSPLOi1bSRN3NW11oIh4xV53ntjTbGajmEUflgE75fylra0YrqSpydidPT6nzGtck5RYyUlq0ODnNB3FBWgS0PcrRtfd2RVnPhQlbVcb37drG7bdtzZYOWzNcn7OJH//c7muqpVQCmyaYxvOY98Up5JRCrufx5sfN69uVNpH+0QySu+frqYHvr+N2W/r3z7OWy7H70ipK5aDs9cOc9lIIOSzgSGSxKnXUn38jeh27vfSQHj/bMCSzNloLrSXWFU6G4HFGWIgIbZQeQpNII7J52yOWZt1HsWfYsOdbcXlLS8kE49HSIXvaGEY2ojceaY9Ax4bXmP+3lVNkuux4dOpAb2aO47buG9cRx4iW1cjASG0lT9JAzPDp8dZ6XxePQPq07FsD7sLgp2KqX8Q+E9QRmNn6f9QAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 02 16 14 40"\n        title=""\n        src="/static/2021-07-02-16-14-40-9531707a82e91ea0e7e015bea3cbc620-fee1c.png"\n        srcset="/static/2021-07-02-16-14-40-9531707a82e91ea0e7e015bea3cbc620-a67b7.png 200w,\n/static/2021-07-02-16-14-40-9531707a82e91ea0e7e015bea3cbc620-0b187.png 400w,\n/static/2021-07-02-16-14-40-9531707a82e91ea0e7e015bea3cbc620-fee1c.png 800w,\n/static/2021-07-02-16-14-40-9531707a82e91ea0e7e015bea3cbc620-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>这个界面展示的信息很丰富，大致可描述为如下</p>\n<ul>\n<li>首先，可以选择要查看的元素的样式（位于图中的区域 2 中），在图中的第 1 个区域中点击对应的元素元素，就可以了下面的区域查看该元素的样式了。比如这里我们选择的元素是 <code class="language-text">&lt;p&gt;</code> 标签，位于 html.body.div.这个路径下面</li>\n<li>其次，可以从样式来源（位于图中的区域 3 中）中查看样式的具体来源信息，看看是来源于样式文件，还是来源于 UserAgent 样式表。这里需要特别提下 UserAgent 样式，它是浏览器提供的一组默认样式，如果你不提供任何样式，默认使用的就是 UserAgent 样式。</li>\n<li>最后，可以通过区域 2 和区域 3 来查看样式继承的具体过程。</li>\n</ul>\n<p>以上就是 CSS 继承的一些特性，样式计算过程中，会根据 DOM 节点的继承关系来合理计算节点样式。</p>\n<p>样式计算过程中的第二个规则是样式层叠（即 CSS 选择器优先级）。层叠是 CSS 的一个基本特征，它是一个定义了如何合并来自多个源的属性值的算法。它在 CSS 处于核心地位，CSS 的全称“层叠样式表”正是强调了这一点。关于层叠的具体规则这里就不做过多介绍了，网上资料也非常多，你可以自行搜索学习</p>\n<p>总之，样式计算阶段的目的是为了计算出 DOM 节点中每个元素的具体样式，在计算过程中需要遵守 CSS 的继承和层叠两个规则。这个阶段最终输出的内容是每个 DOM 节点的样式，并被保存在 ComputedStyle 的结构内。</p>\n<p>如果你想了解每个 DOM 元素最终的计算样式，可以打开 Chrome 的“开发者工具”，选择第一个“element”标签，然后再选择“Computed”子标签，如下图所示：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-02-16-15-44-cc5179ac54d5735966256e9c98c20ca1-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 75.04378283712785%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAIAAABr+ngCAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACO0lEQVQoz32STW/UMBCG999zBSQqDlS0QqgCcefQAxdaUWjZ0lZVN2yy2cROHMeJncSJvxO8y6oFoTJ6LY1sPzP2a89QjsqSgBwHYVJThvKMUooQwhiv12sAUghBFIVpmkIA4jjGRREEC79ECJl1tCPrcnRuHMdBOm1HZ+00TX3flz4qGsYAE0ZZ63Pa8Iq1qKxRgX2P2TSNKK6SZYbyMiMDYVL03Grla/kSmzFNzhp0d1pcf2qCE748HcLPqkF+fjbwIVvkRtvp73DO7VCfawHODi6Onyy/PIU/XoCzZxzebmBrXVM1eZInaUorxqvez+zgadfbKVlcH73/uPf8aP/t8Zubsz2JFhvYj7qoMgCHod92GR86/wlfvZvPX518PTw5Pwi/vxS/YcI1hAwUNCcdpgK3ggpXCzcoew9bLavLD2z+Gp/v15eH5Nt+n29h6SacszQtclQzKnpthRm9pLd93J3Cm6d5rZpyYKXuatNVo1EbWA2yDJFR+sGrLdNn6ya60yRXJVQY6grpqlAVYnDVZWkL4i4JZ0YZLfT9q9zDbRyQq8s2TbSUWw1GSc7b+dUFRqhpO5bGs+nf2MIcrGi0pFE4UGb8sY2x1goh1wkwxvgdhpJH4R6uWLRsIfTiBdLa40YKASAUQhg3ygo/CvsrVbc3LFiwnwFbLiTv3Gj7nkdRrLUyo1P1f2CwwsGyhoj6r5yhhrZcGtr2qwR2veyUbQv0KOy9lQho4h3G2ssnW4kikyVSBCuc/wL43Euj4RSMGwAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 02 16 15 44"\n        title=""\n        src="/static/2021-07-02-16-15-44-cc5179ac54d5735966256e9c98c20ca1-fee1c.png"\n        srcset="/static/2021-07-02-16-15-44-cc5179ac54d5735966256e9c98c20ca1-a67b7.png 200w,\n/static/2021-07-02-16-15-44-cc5179ac54d5735966256e9c98c20ca1-0b187.png 400w,\n/static/2021-07-02-16-15-44-cc5179ac54d5735966256e9c98c20ca1-fee1c.png 800w,\n/static/2021-07-02-16-15-44-cc5179ac54d5735966256e9c98c20ca1-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>上图红色方框中显示了 html.body.div.p 标签的 ComputedStyle 的值。你想要查看哪个元素，点击左边对应的标签就可以了</p>\n<h2 id="布局阶段"><a href="#%E5%B8%83%E5%B1%80%E9%98%B6%E6%AE%B5" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>布局阶段</h2>\n<p>现在，我们有 DOM 树和 DOM 树中元素的样式，但这还不足以显示页面，因为我们还不知道 DOM 元素的几何位置信息。那么接下来就需要计算出 DOM 树中可见元素的几何位置，我们把这个计算过程叫做布局。</p>\n<p>Chrome 在布局阶段需要完成两个任务：创建布局树和布局计算</p>\n<h3 id="创建布局树"><a href="#%E5%88%9B%E5%BB%BA%E5%B8%83%E5%B1%80%E6%A0%91" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>创建布局树</h3>\n<p>你可能注意到了 DOM 树还含有很多不可见的元素，比如 head 标签，还有使用了 display:none 属性的元素。所以在显示之前，我们还要额外地构建一棵只包含可见元素布局树。</p>\n<p>我们结合下图来看看布局树的构造过程：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-02-16-16-13-ad77522d9035a03d3d0ba10af3f479dd-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 86.1646234676007%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAIAAABSJhvpAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACf0lEQVQ4y22SyW7bMBCG86h9hvYBivbSQ9AHCHrJobmkKboEaGEgjYM4abMndeotsS1Z1E5qJSlLomh1LLlJanggCEMOv+Hwn1krK5vNykSWqSz/LedW+3JWcjHLCymLAjallA+htdqx4+x5Q1s/thbbdYrqD9SLPfNSJZIS28W2bed5voAfjr5sot1BAE6aCzjhYhz4XkSTxjDkaa4G/HCIY2yblgVRzjncP4f7JN04s4wo3bxxr+wEKnVclxAP4DiIWooPZ+4JP7hzFaQrE2SaJqV0AbdtttXGQspPHedQ8cMkh3fWz9Fj8frQOrXSrTbR4vzZLtJpUQuxKPv9bfhtQHa6RIuyTIiNU13kWUXPHNfb7xiEJhnnQRSbyPB8P0mSWrM5HE6Ltxfx9f2k8WVn63zSJtl2x4+mYiaFNlGJiVgcSUYxxhrS4PN9/xH2w/jdx++9+xGn0YcfJ6fd8U33jifTeXlS+kGgKIo2HgMMy7qRj2pzxq7PT1zXAd9CKrYN28HhYE/GOuwwSkFeEBlMCPGklRVcZyKE9Hq9qofz9Kjxiqo/wcGuOxqNhsPhYDBI03QFDPUAFoYhNDBJeFKUXvNNqh5NRUlpHAQBhODah4KXhyTLMpCRcZ4yCvlav2+7Bn76wqWx/Q+G3G5lNAhLMd28tL72/Xo8JWOOrhumaRhGHMfLcFEURmW6YRQ0cpjY7scXKGiN/TLnMsvDKMLzsSOMsRU3i8ogC/yvrq/uFO1zP1g/1ockKaVwbRtmFmSHwVwBQ+sh5jgOwbh50Bx32r/+DI80phh2FnkeIRC1LWtF2XWrEIwPQp5jgzRTxs5a+3k6VScqQtqScrX9Bak3uY1GwpNFAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 02 16 16 13"\n        title=""\n        src="/static/2021-07-02-16-16-13-ad77522d9035a03d3d0ba10af3f479dd-fee1c.png"\n        srcset="/static/2021-07-02-16-16-13-ad77522d9035a03d3d0ba10af3f479dd-a67b7.png 200w,\n/static/2021-07-02-16-16-13-ad77522d9035a03d3d0ba10af3f479dd-0b187.png 400w,\n/static/2021-07-02-16-16-13-ad77522d9035a03d3d0ba10af3f479dd-fee1c.png 800w,\n/static/2021-07-02-16-16-13-ad77522d9035a03d3d0ba10af3f479dd-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从上图可以看出，DOM 树中所有不可见的节点都没有包含到布局树中。</p>\n<p>为了构建布局树，浏览器大体上完成了下面这些工作</p>\n<p>遍历 DOM 树中的所有可见节点，并把这些节点加到布局中；而不可见的节点会被布局树忽略掉，如 head 标签下面的全部内容，再比如 body.p.span 这个元素，因为它的属性包含 dispaly:none，所以这个元素也没有被包进布局树</p>\n<h3 id="布局计算"><a href="#%E5%B8%83%E5%B1%80%E8%AE%A1%E7%AE%97" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>布局计算</h3>\n<p>现在我们有了一棵完整的布局树。那么接下来，就要计算布局树节点的坐标位置了。布局的计算过程非常复杂，我们这里先跳过不讲，等到后面章节中我再做详细的介绍。</p>\n<p>在执行布局操作的时候，会把布局运算的结果重新写回布局树中，所以布局树既是输入内容也是输出内容，这是布局阶段一个不合理的地方，因为在布局阶段并没有清晰地将输入内容和输出内容区分开来。针对这个问题，Chrome 团队正在重构布局代码，下一代布局系统叫 LayoutNG，试图更清晰地分离输入和输出，从而让新设计的布局算法更加简单。</p>\n<h2 id="总结-3"><a href="#%E6%80%BB%E7%BB%93-3" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总结</h2>\n<p>好了，今天正文就到这里，我画了下面这张比较完整的渲染流水线，你可以结合这张图来回顾下今天的内容。</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-02-16-16-48-d4a99bbcee5f2b5ebe9f227ed61e45f5-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 26.70753064798599%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAIAAADKYVtkAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABAElEQVQY002OvU7DMBRG8xCMvAc8BzMTKzsPws4GAwxlCRJSkYq6UIEoFBEiUkITJ24g2I7r2HF+HJtQiuhZ7tX33SNdy6yhtRZL/pO/pZRSCK6UWr+3fkdT113dlAWGIIWRUWVbFaoqu0ppU1QKL2QIYkqz5od2JWttZKs/cCar6i7Clz66AfjkCV75X8PX0H7PoHc7d66JN+AYyFpRSmIwlVIuZWNwLsaPk0awvf5s8yzcsafWobN1Huz3vY3j+M0+QL3d5GhbuD0q1Mx3X+5P0/Rz9TZieQCTjOXPCRkG6CFCFz4eRcSZ40FIcexSMCH+iKGIi4KxBSEZ57wTvwFi8Q6DqtcibQAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 02 16 16 48"\n        title=""\n        src="/static/2021-07-02-16-16-48-d4a99bbcee5f2b5ebe9f227ed61e45f5-fee1c.png"\n        srcset="/static/2021-07-02-16-16-48-d4a99bbcee5f2b5ebe9f227ed61e45f5-a67b7.png 200w,\n/static/2021-07-02-16-16-48-d4a99bbcee5f2b5ebe9f227ed61e45f5-0b187.png 400w,\n/static/2021-07-02-16-16-48-d4a99bbcee5f2b5ebe9f227ed61e45f5-fee1c.png 800w,\n/static/2021-07-02-16-16-48-d4a99bbcee5f2b5ebe9f227ed61e45f5-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从图中可以看出，本节内容我们介绍了渲染流程的前三个阶段：DOM 生成、样式计算和布局。要点可大致总结为如下：</p>\n<ul>\n<li>浏览器不能直接理解 HTML 数据，所以第一步需要将其转换为浏览器能够理解的 DOM 树结构；</li>\n<li>生成 DOM 树后，还需要根据 CSS 样式表，来计算出 DOM 树所有节点的样式；</li>\n<li>最后计算 DOM 元素的布局信息，使其都保存在布局树中。</li>\n</ul>\n<h1 id="渲染流程（下）"><a href="#%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B%EF%BC%88%E4%B8%8B%EF%BC%89" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>渲染流程（下）</h1>\n<p>在上篇文章中，我们介绍了渲染流水线中的 DOM 生成、样式计算和布局三个阶段，那今天我们接着讲解渲染流水线后面的阶段。</p>\n<p>这里还是先简单回顾下上节前三个阶段的主要内容：在 HTML 页面内容被提交给渲染引擎之后，渲染引擎首先将 HTML 解析为浏览器可以理解的 DOM；然后根据 CSS 样式表，计算出 DOM 树所有节点的样式；接着又计算每个元素的几何坐标位置，并将这些信息保存在布局树中</p>\n<h2 id="分层"><a href="#%E5%88%86%E5%B1%82" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>分层</h2>\n<p>现在我们有了布局树，而且每个元素的具体位置信息都计算出来了，那么接下来是不是就要开始着手绘制页面了？</p>\n<p>答案依然是否定的。</p>\n<p>因为页面中有很多复杂的效果，如一些复杂的 3D 变换、页面滚动，或者使用 z-indexing 做 z 轴排序等，为了更加方便地实现这些效果，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树（LayerTree）。如果你熟悉 PS，相信你会很容易理解图层的概念，正是这些图层叠加在一起构成了最终的页面图像。</p>\n<p>要想直观地理解什么是图层，你可以打开 Chrome 的“开发者工具-更多工具”，选择“Layers”标签，就可以看到可视化页面的分层情况，如下图所示</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-02-16-19-07-5b6eab53e4d0fc218cd4e6927b2a7603-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 94.13309982486864%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAATCAIAAAAf7rriAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACh0lEQVQ4y5VTS29SQRS+/4ekJKKFQl03/g9j3PRBbdK4F4toS5NW+w8aN8aNMeERWnWlxkYhBBo3dSFvuK953LkP8LszQKmJC7/czJ0zc7453zlzRpv8D1zX9X1/bmqeRPBv+BLwwQiy4zjXZF3XDV23F0Ak5qZhYF8fjUYYTdPknOOgKXkcBOOFONjo9/udTgd85TEeqy8ETMQHfybbYZ7gvqQphUIIaAMZP9MwOGPYBVOJRwDsQn9I5sRio7Zj64qDU+FXrdYuLr79brXevHv//Ue122lf/rxst9qWacIHnspNw8G9brvf7Q6HQywxxnBkpVLJ5p5D/KePH16fnlbKhULx7dcvn39dXQ0GfVU2QGOcG4bZ6yHT/mAwQHkgGNt72WdPnu692M/n9vNH+YOT45dHh4cHuezxqxPbsqiEBj/8er0emBhBRvBQea12/8HD9Y301vbOzu7j7Z3ddPrR5mZ6fWOr0WiotDX4YaZuGxVzPS9UJQSMSeBNZIUXofyRdkhW1UcNw+UABMkJ/LH8KCW43vk9zSfTq1JLsnsEsQxGLNSfWga1LWkSShmjTNYSM4awGJHpNLIKHsZHAxDLocRhtkMt4XDBKLdNbhuuEhpmFsy7VZtrUOI5vIklOHUYEZy4DnM5FczGiis42slzhSID12T1CrBHEYoSZpv4oJwzorKQGdme68wKN9b+enFICRWR/ThBZfALe38SzrGCuS/fWSAbVlu8A4z1er1ULJ6fn5VKxUKxWC6X0G2l0IAFs3wmgQnMG7IxNpvNe2trd1dXl+/cXlpaisViyWTylgRMjKlUCiuJRCIajd6QrfiZTCYSicAjHo8vx+MrEuCszID1pMQfp7zrJyfY/70AAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 02 16 19 07"\n        title=""\n        src="/static/2021-07-02-16-19-07-5b6eab53e4d0fc218cd4e6927b2a7603-fee1c.png"\n        srcset="/static/2021-07-02-16-19-07-5b6eab53e4d0fc218cd4e6927b2a7603-a67b7.png 200w,\n/static/2021-07-02-16-19-07-5b6eab53e4d0fc218cd4e6927b2a7603-0b187.png 400w,\n/static/2021-07-02-16-19-07-5b6eab53e4d0fc218cd4e6927b2a7603-fee1c.png 800w,\n/static/2021-07-02-16-19-07-5b6eab53e4d0fc218cd4e6927b2a7603-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从上图可以看出，渲染引擎给页面分了很多图层，这些图层按照一定顺序叠加在一起，就形成了最终的页面，你可以参考下图</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-02-16-19-23-31433d4b6eb787869027519d7532ea44-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 76.00700525394046%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAIAAABr+ngCAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACWklEQVQoz3VSS2sTURQeUFwp4kLdqIWK0ELEShfBUDUqakUXIkqLzzRpYoot2Gp9hWma2lIQNS78GXZVXElBUElT24UKQsBMpplJM5mZxDxn7jRN6pe5bUyVfgzDufc8vu+ec5gM952L8ZIkaZpWLBar1erq5jAMQ9f1QqFQLpfjcYGRk0vJZDKVSimyIsuyqqppE2oD0utQTCA4k8lEIhGmpK2htBFgWDYBA4r+8UKCIIjM/9qo8nw+H4vFotFoLperXzYGKKpKkzc4qI8QAm3QDObG5HqALCu15ArRysXsCilVKhXoXDEBG38ajfbAhkEDcKwxKyqDg6GXSDFPtNpLKHAJ5vVu6PjqMI8aComiyJAaDN0o68QgDUCJzQZGpfE8zxBjWc/KeuInSYuUEOUhTxREHzviY/3PWD/rD4wGxn0jAXb0+f2hR++mplAC7WTAkMv+lhKClEygwzhiEvCFw+EtO/bs2t/aZLFZbBesZ68Os5OTr96eutTdfasHARgE3myk0xl+Mc7zi1gS+lT45ua+NrcesXdePn3x2u2+hwNPx+MJCfcfPn7pGxiCwXEcQ3XSP/YO+1BPbmpusR0/Y7V33vQMPh57+evHt9X80vT0e3f/4N9k6CyYoJtEk+fnF3bvO9Rx/kqX58G9JxPDY68/zczEFz5PvAg67vbXZCMZTYJaLCq6h2JYYOiAb3Y2zGzbfqCl7aCl/aj1RPsx+2HrybaOc1t37u26fmPtzWAGIXaQkoOZzikUCjmdTpfL5exxut1ur9fb63J53L2OO45g8A2mDbI/ApfzmGn3K60AAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 02 16 19 23"\n        title=""\n        src="/static/2021-07-02-16-19-23-31433d4b6eb787869027519d7532ea44-fee1c.png"\n        srcset="/static/2021-07-02-16-19-23-31433d4b6eb787869027519d7532ea44-a67b7.png 200w,\n/static/2021-07-02-16-19-23-31433d4b6eb787869027519d7532ea44-0b187.png 400w,\n/static/2021-07-02-16-19-23-31433d4b6eb787869027519d7532ea44-fee1c.png 800w,\n/static/2021-07-02-16-19-23-31433d4b6eb787869027519d7532ea44-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>现在你知道了浏览器的页面实际上被分成了很多图层，这些图层叠加后合成了最终的页面。下面我们再来看看这些图层和布局树节点之间的关系，如文中图所示：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-02-16-19-40-789dd716354757d4cc55c2ea69397fd2-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 59.01926444833625%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABpUlEQVQoz4WSzU7bQBDHIy59AV6Je699AU4cEOIJeukTVOKCBIqQEIeqlSpVEBHxIQ4o5JCqBUIj8oEw8dqOvbteez/Gu0zi1JEQiL9kezU7v935z7jm/gsAoijKssy9IWvtZDLBHFyUkVq1R8KwddXu3v2DAl6FlVKdTqfdbud5/hKWSQAicZJZLV+F8yx7Go8TShljc7isgEvYv4e9O7nbVd1YO1cYKCphncYYxrnkXMQx0hhcwLnSX67452Z/7SQ5echcoaXSlaSULE3HhAQPo8TzeJrOYXz+BOrTIVttBJsXVGnqrLGgjdFoEi/EOil2aTQkvm8AUiEKgIXnv7H7+IutfAtWfvJbwp5i9kglzxUgakAIweNJGgaI4UTQsE8I1jKHuzc3hz8OLA++D8yHrWj562hpW+xcC+dMJrWZqfxwzon3GA8HURhiJ6Zwv98/PTtPWeJlrv472O949Ws2pGY225c9x8vB6IXnadLsrQu7eextHI3WG15ubBV/S7Xy1ylPwvFctlok5r3BwPf9cusduEoyWjcbR4zS+14PvbwLPwMDc6Y+uC/7VAAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 02 16 19 40"\n        title=""\n        src="/static/2021-07-02-16-19-40-789dd716354757d4cc55c2ea69397fd2-fee1c.png"\n        srcset="/static/2021-07-02-16-19-40-789dd716354757d4cc55c2ea69397fd2-a67b7.png 200w,\n/static/2021-07-02-16-19-40-789dd716354757d4cc55c2ea69397fd2-0b187.png 400w,\n/static/2021-07-02-16-19-40-789dd716354757d4cc55c2ea69397fd2-fee1c.png 800w,\n/static/2021-07-02-16-19-40-789dd716354757d4cc55c2ea69397fd2-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>通常情况下，并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层。如上图中的 span 标签没有专属图层，那么它们就从属于它们的父节点图层。但不管怎样，最终每一个节点都会直接或者间接地从属于一个层。</p>\n<p>那么需要满足什么条件，渲染引擎才会为特定的节点创建新的层呢？通常满足下面两点中任意一点的元素就可以被提升为单独的一个图层。</p>\n<p>第一点，拥有层叠上下文属性的元素会被提升为单独的一层。</p>\n<p>页面是个二维平面，但是层叠上下文能够让 HTML 元素具有三维概念，这些 HTML 元素按照自身属性的优先级分布在垂直于这个二维平面的 z 轴上。你可以结合下图来直观感受下：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-02-16-19-52-1b184bd368aca2f479b6127e610206b6-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 52.62697022767075%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABZ0lEQVQoz5WSy0sCQRzH/ZOiW53qGEQY6aFLBEFZB+15CUMrIqgklIwORV6KuhTdDPEBgYb22J3Xaj4WDavd9WCXdjc3tzEsgtTqw/f0m/kwM3zHoGmaqr6+VVS9ItejvWiqQoctqFaruq4bREniEIiw6aW4sHItrl4JC3HJn+LTKYIxaQjHcYqi1OQnUcoixh0tdG0+2lyZCW9+aIP37yXyCKK7JEEI/4D6sizXZOFD9sTuT6bCcvd6rsddNHqzvV5mcJs9DuJsCkP0i7x1WTiavXhod/g6XJaRwNzY+bzpdNrDOmMCgM1PFkUJAvYGc/xagG9b3O309E0mTNaYaTzav8OPhkssxKSZLEkSC0ASIw6TpP3AN3xoXEZmJ2u23w7sFyyhEmgtAwDoBHIknSFnbM4aEmfCAo0tKDgiRYCaX5vKEMJaA59r3PeQxnV9vVlkGAYhBP8M3VyXad3lcvn5n9B/SeV3TSkhZIoRX2gAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 02 16 19 52"\n        title=""\n        src="/static/2021-07-02-16-19-52-1b184bd368aca2f479b6127e610206b6-fee1c.png"\n        srcset="/static/2021-07-02-16-19-52-1b184bd368aca2f479b6127e610206b6-a67b7.png 200w,\n/static/2021-07-02-16-19-52-1b184bd368aca2f479b6127e610206b6-0b187.png 400w,\n/static/2021-07-02-16-19-52-1b184bd368aca2f479b6127e610206b6-fee1c.png 800w,\n/static/2021-07-02-16-19-52-1b184bd368aca2f479b6127e610206b6-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从图中可以看出，明确定位属性的元素、定义透明属性的元素、使用 CSS 滤镜的元素等，都拥有层叠上下文属性。</p>\n<p>第二点，需要剪裁（clip）的地方也会被创建为图层。</p>\n<p>不过首先你需要了解什么是剪裁，结合下面的 HTML 代码：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="63483987954569400000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`<style>\n  div {\n    width: 200;\n    height: 200;\n    overflow: auto;\n    background: gray;\n  }\n</style>\n<body>\n  <div>\n    <p>\n      所以元素有了层叠上下文的属性或者需要被剪裁，那么就会被提升成为单独一层，你可以参看下图：\n    </p>\n    <p>\n      从上图我们可以看到，document层上有A和B层，而B层之上又有两个图层。这些图层组织在一起也是一颗树状结构。\n    </p>\n    <p>\n      图层树是基于布局树来创建的，为了找出哪些元素需要在哪些层中，渲染引擎会遍历布局树来创建层树（Update LayerTree）。\n    </p>\n  </div>\n</body>`, `63483987954569400000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                html 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">\n  <span class="token selector">div</span> <span class="token punctuation">{</span>\n    <span class="token property">width</span><span class="token punctuation">:</span> 200<span class="token punctuation">;</span>\n    <span class="token property">height</span><span class="token punctuation">:</span> 200<span class="token punctuation">;</span>\n    <span class="token property">overflow</span><span class="token punctuation">:</span> auto<span class="token punctuation">;</span>\n    <span class="token property">background</span><span class="token punctuation">:</span> gray<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>\n      所以元素有了层叠上下文的属性或者需要被剪裁，那么就会被提升成为单独一层，你可以参看下图：\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>\n      从上图我们可以看到，document层上有A和B层，而B层之上又有两个图层。这些图层组织在一起也是一颗树状结构。\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>\n      图层树是基于布局树来创建的，为了找出哪些元素需要在哪些层中，渲染引擎会遍历布局树来创建层树（Update LayerTree）。\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>在这里我们把 div 的大小限定为 200*200 像素，而 div 里面的文字内容比较多，文字所显示的区域肯定会超出 200*200 的面积，这时候就产生了剪裁，渲染引擎会把裁剪文字内容的一部分用于显示在 div 区域，下图是运行时的执行结果</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-02-16-20-36-8dcd5a1dc365e9c77df5fd51b4ebf21e-e52c1.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 664px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 70.18072289156628%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAIAAACgpqunAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABkUlEQVQoz6WSO48BURiG/TiFahESNq4xZhF3ywxD3BKlRE8kGsS1EgmS3UKB2h+Q+BvMPjmq3ZjdYt9i8s2Z83zvd945ptPpNBqNlsvlfD6fTqfj8Xg2m00mE+rVakXNp8vlouv6/X7Xv8vU6XQsFovb7bbZbC9CVqvV4XDY7fZUKvUqtN/v2Xq73X7CvV7P5/PJsuz3+5PJZCwWSyQSkiQFAoF8Ph+JRBRFOR6Pz+Fut+tyucLhsMfjwZ/C6/XmcrlSqVSpVDRNUxX1cDg8h4fDIVZsBcC5WCxmMplqtdpqtRqNRrPZhDeEF4tFoVCA4UkLCgzfhWq1GjCLhvBgMAiFQhySsXm+CTE/r5y2Xq//AZMWM8fjcdKCZ2xZSBKihSFM2viwNZ1OP+INBoMw9ML8EYch3O/3SRuAnGEehpgzBbGzqKrqb2NzDTg2PL+a3dFoFICTw9Mrm80awu1222w2Y4K/0+nkVpXLZTLXhEge2PCGnc/n9Xq92+02m812u6X4FPoQomDler0+v9v6P/QF9o1HLIXkyEcAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 02 16 20 36"\n        title=""\n        src="/static/2021-07-02-16-20-36-8dcd5a1dc365e9c77df5fd51b4ebf21e-e52c1.png"\n        srcset="/static/2021-07-02-16-20-36-8dcd5a1dc365e9c77df5fd51b4ebf21e-57381.png 200w,\n/static/2021-07-02-16-20-36-8dcd5a1dc365e9c77df5fd51b4ebf21e-40546.png 400w,\n/static/2021-07-02-16-20-36-8dcd5a1dc365e9c77df5fd51b4ebf21e-e52c1.png 664w"\n        sizes="(max-width: 664px) 100vw, 664px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>出现这种裁剪情况的时候，渲染引擎会为文字部分单独创建一个层，如果出现滚动条，滚动条也会被提升为单独的层。你可以参考下图：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-02-16-20-47-403ddb282ae513e46ba23ecea178fce5-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 35.288966725043785%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAIAAACHqfpvAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAAyklEQVQY032Qvw5EQBDGPahGoxahlGglXsC7KBANLQXRXWLdrd3TkLictTeWc+ISv2Iy2dnvmz9Sje43hFHTQFKjB6WECgghTwFuKW7JaxyjKNJ13bIs27bLsuScS+8JYNMaGeN85l9mASRQgxjHsaIomqYZhpHn+SJey9ewxZSHYSjLsqqqYJFl2SYGYLxhGK7FSZKYpum6ruM4VVVtYqilaep5XhAEfd8fBz5ZnB5/Y3dd5/t+URTHha+X2sT7J3G56XizveG/0QdUtIHGAH/uIwAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 02 16 20 47"\n        title=""\n        src="/static/2021-07-02-16-20-47-403ddb282ae513e46ba23ecea178fce5-fee1c.png"\n        srcset="/static/2021-07-02-16-20-47-403ddb282ae513e46ba23ecea178fce5-a67b7.png 200w,\n/static/2021-07-02-16-20-47-403ddb282ae513e46ba23ecea178fce5-0b187.png 400w,\n/static/2021-07-02-16-20-47-403ddb282ae513e46ba23ecea178fce5-fee1c.png 800w,\n/static/2021-07-02-16-20-47-403ddb282ae513e46ba23ecea178fce5-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>所以说，元素有了层叠上下文的属性或者需要被剪裁，满足这任意一点，就会被提升成为单独一层。</p>\n<h2 id="图层绘制"><a href="#%E5%9B%BE%E5%B1%82%E7%BB%98%E5%88%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>图层绘制</h2>\n<p>在完成图层树的构建之后，渲染引擎会对图层树中的每个图层进行绘制，那么接下来我们看看渲染引擎是怎么实现图层绘制的？</p>\n<p>试想一下，如果给你一张纸，让你先把纸的背景涂成蓝色，然后在中间位置画一个红色的圆，最后再在圆上画个绿色三角形。你会怎么操作呢？</p>\n<p>通常，你会把你的绘制操作分解为三步：</p>\n<ul>\n<li>制蓝色背景；</li>\n<li>在中间绘制一个红色的圆；</li>\n<li>再在圆上绘制绿色三角形</li>\n</ul>\n<p>渲染引擎实现图层的绘制与之类似，会把一个图层的绘制拆分成很多小的绘制指令，然后再把这些指令按照顺序组成一个待绘制列表，如下图所示：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-02-16-21-21-5bf50c6a0589859e0e21d716ffa7e99f-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 52.80210157618214%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABWElEQVQoz21Sy07DQAzs//8H4ggXpB4BobYSqBz6VBGBNM9mkzSvzeblXaZZqWob5mCtbM/YGWekBiAiy7JM0zQMI89zZKSU6j+MdK3rOnAQ8W7bdrvdrtfrxWIRRZGWA3QbcEXmnGdZFoZhURRJkugohKjrGvFwOKCapiliHMeIyF+Rm6ZxXRcF27bR4XleEAS+70MFeehCAg9IVFV1S8YE0EDmBceGmlyWJVodx2GMiR6wAMlbMiTxeSBjZzSBeRLqRSMWVDxvBG9FmR0Ha2tLELEw3JIXQDIj5XfKF+QVFArYRleGnYH5UNW2n9xvG8brh2U6+YwnTvsRqSeL9oXsD3RB1kOwOW6rL7zbfSUh+8nK6Zuh7mbdkaNhc6RNcuqkIRme4byr1Wo+n09nM5GnTqXu9/K7VstE/uby0aR3NiAPof+pqJJji15cevbkqy/HtjQv1v4DYTZ1QqC9FIIAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 02 16 21 21"\n        title=""\n        src="/static/2021-07-02-16-21-21-5bf50c6a0589859e0e21d716ffa7e99f-fee1c.png"\n        srcset="/static/2021-07-02-16-21-21-5bf50c6a0589859e0e21d716ffa7e99f-a67b7.png 200w,\n/static/2021-07-02-16-21-21-5bf50c6a0589859e0e21d716ffa7e99f-0b187.png 400w,\n/static/2021-07-02-16-21-21-5bf50c6a0589859e0e21d716ffa7e99f-fee1c.png 800w,\n/static/2021-07-02-16-21-21-5bf50c6a0589859e0e21d716ffa7e99f-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从图中可以看出，绘制列表中的指令其实非常简单，就是让其执行一个简单的绘制操作，比如绘制粉色矩形或者黑色的线等。而绘制一个元素通常需要好几条绘制指令，因为每个元素的背景、前景、边框都需要单独的指令去绘制。所以在图层绘制阶段，输出的内容就是这些待绘制列表。</p>\n<p>你也可以打开“开发者工具”的“Layers”标签，选择“document”层，来实际体验下绘制列表，如下图所示：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-02-16-21-35-fe1bafa462e925267eb2f89be13b57cf-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 44.833625218914186%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAIAAAC9o5sfAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABMklEQVQoz3WR20rDQBCG8/4v4KUFvdFeCb6BggqlULU5lGLS1uwh2WyS3Z1NmqRZt0eL2I9/h5mBb27WwYSEYYgxwTT9RpRQaitjjHOe7chzzjKeMm6XdpQ7ioIDgENp8jl1U5ZuetNtttja92ZP27ZKSXNGf8T2jtZaCGGr+Y+maZQQ5gJHGcCYjTHd9rR9x7RdV69rc7Y5ZSuD1qAkycrnIH2ZF6NI0GVW4UyhDC5EY54vYo5zB6yt5BcVV090MCpuxhBNksaPwUP6QioP5e4qwcVBjhIxeE0e3fLBW6+myTpAEGC9z4zUC6ZPY4ArH8sFVTUc5DAR16/p8F3eT+TyI25m+EzG1Zz+kUVIJChH2f+SIqLl7Ru9G/PhmEeTVeUj4SF5ivvbKx+BH5cRFUr+AHjg9WbzO6BtAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 02 16 21 35"\n        title=""\n        src="/static/2021-07-02-16-21-35-fe1bafa462e925267eb2f89be13b57cf-fee1c.png"\n        srcset="/static/2021-07-02-16-21-35-fe1bafa462e925267eb2f89be13b57cf-a67b7.png 200w,\n/static/2021-07-02-16-21-35-fe1bafa462e925267eb2f89be13b57cf-0b187.png 400w,\n/static/2021-07-02-16-21-35-fe1bafa462e925267eb2f89be13b57cf-fee1c.png 800w,\n/static/2021-07-02-16-21-35-fe1bafa462e925267eb2f89be13b57cf-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>在该图中，区域 1 就是 document 的绘制列表，拖动区域 2 中的进度条可以重现列表的绘制过程。</p>\n<h2 id="栅格化（raster）操作"><a href="#%E6%A0%85%E6%A0%BC%E5%8C%96%EF%BC%88raster%EF%BC%89%E6%93%8D%E4%BD%9C" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>栅格化（raster）操作</h2>\n<p>绘制列表只是用来记录绘制顺序和绘制指令的列表，而实际上绘制操作是由渲染引擎中的合成线程来完成的。你可以结合下图来看下渲染主线程和合成线程之间的关系：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-02-16-21-55-1ba3be4d39252859208fc5006de0b4ff-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 40.63047285464098%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAIAAAB2/0i6AAAACXBIWXMAAA7DAAAOwwHHb6hkAAABKElEQVQY001QS04DMQztSVkgVUicgwUHYAEHYMGWA0B7hgJSRx1YISqVzid2HOfn4BmmnxdLcWw/+zmzUkrOOY5IKR6hfh6RBkypo6NxJc706vveWouWrCUmy4TeWYfwuanqag1gNI52PKiFFgC7rhvI2lbfIoUJUnQQxPhsQu44fv3s6u9tiEHFDSaxZO+ZYnCIOE3WNl1vxNPHtr94gfkCLl/hamnmC7xemurXJu+QVAyx7YnIOTqRVbZGJGtbDz7hwVqkXQfsuRT5H54ipzR8EABMZPVCUG0iOZYTxJieTfO04ZtVuV3lh7WMK+gHy4ncNE3btspXPXyGEFP27rnGuzd3/06PlYonP6Ymsojoyvv9XtcwMMCMODiQGEswxYOwwbMCJf8Bp8vHQd6RUHkAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 02 16 21 55"\n        title=""\n        src="/static/2021-07-02-16-21-55-1ba3be4d39252859208fc5006de0b4ff-fee1c.png"\n        srcset="/static/2021-07-02-16-21-55-1ba3be4d39252859208fc5006de0b4ff-a67b7.png 200w,\n/static/2021-07-02-16-21-55-1ba3be4d39252859208fc5006de0b4ff-0b187.png 400w,\n/static/2021-07-02-16-21-55-1ba3be4d39252859208fc5006de0b4ff-fee1c.png 800w,\n/static/2021-07-02-16-21-55-1ba3be4d39252859208fc5006de0b4ff-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>如上图所示，当图层的绘制列表准备好之后，主线程会把该绘制列表提交（commit）给合成线程，那么接下来合成线程是怎么工作的呢？</p>\n<p>那我们得先来看看什么是视口，你可以参看下图：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-02-16-22-05-dd52dfb403bb0cf35e50ed7b7324ddb7-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 95.5341506129597%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAATCAIAAAAf7rriAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACdUlEQVQ4y41TWU9TQRTu3zG+GeOLDyYmGt7VkOiTMcENSLS+wQOJaDUYNUoEhESBsERTiJFaWUwUpS1tkbYUsC12A21pb2+X27vM7kwviSba1pM5uZM557vnm+/MsbCaUUoJJpQyBIChGZQwSgiCiDU0CyGUf8Ke/KP20EBnaPzW5qQ1NHbZO3bB9eF+qPbfBmAsgp75XPuJQO9Z34vO8Mgl//D5z7bDjldtLgEmtAnYuyRbWzZ6z/hGroVH2vwD55b7jszbr7tr4GaVVxfyN06tdZ1e7W8NDLW67x1feHB0fqbDe0Cb+9/rN/hdtuPYctdJV0/HZo81aGv59PSQ480VQRsjTOvc22IGnP5qty3R25e8+zxzZ2jv4ePkk9ux6fG0KTdIp2A2A/d2QTQKMxm4m+Z7ipCFx6JFfPOLMpdWR8PS65gyG9enY8pMQun2Vddklkl9z7rdRjBgbG8Z37ZAfMeIRkAqycUQ4A0JTWxVGYNauUQJYIwgVWFYXYirSynVv/KxkIiTbBaXSkTTUG4fyzKpKoI295CEXm7qHJOvaDqmkDG5ahAM7RF11BVlSK/XKwGOFdHUdoXpklbI6YUsUYuk1h/H1+TKzr7QDJN/q819YgdfXFRG1wv9ntygVxr05YfXy5PhytVF+VlEJNV7JgIclKnzB5uNafao8jZhvN8jzl3sTOO5FPJLgkIj2gfGpYIqvyFjvEFYLAyaDIbJComJYjqAklzKF2TNMHhFzQCYNgObI/nnaVElZZ1gBCmlzcHc+CvkhWQV/yzBssGHm0EIadPKZkJFJ/kqLulEg+aMMwDAf1U2k4jo34HV2osbC/YLweUYIDQ5i4UAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 02 16 22 05"\n        title=""\n        src="/static/2021-07-02-16-22-05-dd52dfb403bb0cf35e50ed7b7324ddb7-fee1c.png"\n        srcset="/static/2021-07-02-16-22-05-dd52dfb403bb0cf35e50ed7b7324ddb7-a67b7.png 200w,\n/static/2021-07-02-16-22-05-dd52dfb403bb0cf35e50ed7b7324ddb7-0b187.png 400w,\n/static/2021-07-02-16-22-05-dd52dfb403bb0cf35e50ed7b7324ddb7-fee1c.png 800w,\n/static/2021-07-02-16-22-05-dd52dfb403bb0cf35e50ed7b7324ddb7-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>通常一个页面可能很大，但是用户只能看到其中的一部分，我们把用户可以看到的这个部分叫做视口（viewport）。</p>\n<p>在有些情况下，有的图层可以很大，比如有的页面你使用滚动条要滚动好久才能滚动到底部，但是通过视口，用户只能看到页面的很小一部分，所以在这种情况下，要绘制出所有图层内容的话，就会产生太大的开销，而且也没有必要。</p>\n<p>基于这个原因，合成线程会将图层划分为图块（tile），这些图块的大小通常是 256x256 或者 512x512，如下图所示：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-02-16-22-17-00298b4e3274165a99e51b835b4ed22e-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 87.12784588441332%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAIAAABSJhvpAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACP0lEQVQ4y4WTz2sTQRTH+xcJejbgQRBE0ZuIBxEFT+JBKIj01Gt/ICgoKggelF5KC1JFsBLTiw3V2NqkCk3TmqZJdmd3fuzs/Hjz4mxCJJGkPoZhZ+Z99n3fmzcTnb45h37+lq/dPVucvvz12a3i02urs2fyj06vhL8Cf4Rdh0Gb+Af+vlafPL8xf6P4enJ94d7qk0ufHueWwkrDswjuP/BmYe/+xbXpC4WXN/PPryzP5VZenFsi5XpHC4jjsXBPVeFt5frJj3dyhanbXx5c/TB14v3MqcX90oE/AkL6rjgA+0U2ss+fpd03M5sLDyuLCzvLr0rv5n58ni82d+sZHEcjItvDuqntISWGUsUOESnjQUe3OuYoSRm6UCZhlldEfG5AQnuwj0nShR3a3we2VkWZAIAUgTYQUg2grBYhNVanCc8Eex84aujyttpY9/xQzpkwcKloahkxSrRsO9VWSjpDpchgRyO0xgmRzan0aQ7BvuAsrjcau416tbFfpmHVKKGTFqftLjy+2j0zKQuCuNkiLA49Q7kSnBqdZeh8wXql7Rd8EM7WzlLOAhq1lWhC2gKrnIk6VqDSjtFjIndhEyEIJVkc1CipOlBoY4ibjhBMU38vqPVY2Wh5r10QUtCC6k7Gp8yHdSTQ21v+UsbLNhEYbqyiLIxok0rV1SL7v7Z/22sE7EWyhAVcxixQsoVowRBIQmTccaZ3KijlyMjdTRDOMLAJmtgZ4iDxkZ0SyLnvML1V6vXWaPh4Qzf0Kv8AtNC6+UR6mCwAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 02 16 22 17"\n        title=""\n        src="/static/2021-07-02-16-22-17-00298b4e3274165a99e51b835b4ed22e-fee1c.png"\n        srcset="/static/2021-07-02-16-22-17-00298b4e3274165a99e51b835b4ed22e-a67b7.png 200w,\n/static/2021-07-02-16-22-17-00298b4e3274165a99e51b835b4ed22e-0b187.png 400w,\n/static/2021-07-02-16-22-17-00298b4e3274165a99e51b835b4ed22e-fee1c.png 800w,\n/static/2021-07-02-16-22-17-00298b4e3274165a99e51b835b4ed22e-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>然后合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图。而图块是栅格化执行的最小单位。渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的，运行方式如下图所示：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-02-16-22-27-d76346656d5c88592fc50be9d77a7789-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 59.28196147110333%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABlklEQVQoz21Ry24UMRDc/0QC5aNy5JRwAYkvIBEXpJw4IJZlhYhQok1CZjzjZ/ttU2NPtCBSsnvc3dPt6vKm1ppzTv8BsdrwXBLZjNQGH2OMc9ZiO+ed9YuFQ7+ur3/s90qpxetwjpqVUpZSNmgDFydrZArkUqGYsUxItw/Dz5sDmtVawKDWVJPzloKnXrLcjN5ciOJp98BffFAnl/LlhYQ9uVSvLuTVQWdvlbFLhRFkNEgBx2IwLzmDHqM0UZztsgZl72elidZrS4rexRhBdvm/F+OE0MItx/oXlJSWjx9v7Om+nn4vVyNiMReMUNebsYUQ4zhCJKMVUeNETRcfanSfD/Jsp15/4Z8ONq16uSPtpraDs74ZxIOemEXJe8bf7sS7LXu/feRCggvnvLc+qg0mpfHx3qthkBNj41gt/Wbi7Ot8vp3ffJO3TIIaRw+M82wxKHDGIOF0d1edjSG0F7K1xJzgRXTvc/1T3AE3hNCHRsJorQxJtVhMh7DWuh9WweDoJ/QEiE0TqLOhYWwYnjDPM6ih8A8/EazNMZjYswAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 02 16 22 27"\n        title=""\n        src="/static/2021-07-02-16-22-27-d76346656d5c88592fc50be9d77a7789-fee1c.png"\n        srcset="/static/2021-07-02-16-22-27-d76346656d5c88592fc50be9d77a7789-a67b7.png 200w,\n/static/2021-07-02-16-22-27-d76346656d5c88592fc50be9d77a7789-0b187.png 400w,\n/static/2021-07-02-16-22-27-d76346656d5c88592fc50be9d77a7789-fee1c.png 800w,\n/static/2021-07-02-16-22-27-d76346656d5c88592fc50be9d77a7789-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>通常，栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫快速栅格化，或者 GPU 栅格化，生成的位图被保存在 GPU 内存中。</p>\n<p>相信你还记得，GPU 操作是运行在 GPU 进程中，如果栅格化操作使用了 GPU，那么最终生成位图的操作是在 GPU 中完成的，这就涉及到了跨进程操作。具体形式你可以参考下图：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-02-16-22-41-4688f12be6d789345beb01f329614300-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 75.04378283712785%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAIAAABr+ngCAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAB6ElEQVQoz4VSWW5UMRCcmyJxAyROwAUAIZYgcQwOgMIPX4kCgQlfMJoweZvf4rXbG2W/YVUQJavVXqqr3PYmpWQrnHPGWmXK0IjK9EL0YjTG2N/gHCEgAXETQsB2jTpFztnXEVJww9er7ss2sAsFvgzPOOYZfOu938QYQUa9TPKzUM8++VdX/GLrX27p0fny5GzqTK2VImL2hpyJ3hJRIUN9miYxTjnQxUE+PDfP36unFxrx5NKdfNB7oRLjTvDqjFbIiPhIXpURUwzV9k8kXnoeG+1I+iw5EeQDQwx7KHFUnud5WRaQmZzj4NiTDxiGmI16fCbvntKdN+71jnPEMoTiL9sgwzkzow1UAS9KKY3maL0T5vJafPwmhMQcq7o6r2T0EZzisvrBKqqAgwfLVm9bde90vv92fvBubhdN1ki8oTF/k2EGUUlphn5oG3Fzk5wdxvG66fpx7sQ0TpOUUsCBlBC4RVlXV6ULfZ+tDd5rJT1R9AU4DNqqjKSQcT1scEW5DzP6N0s54Yd13W6363t8NjEMA6Zt26L0sdtQA4f+xFoeb4C64KBW0zRd15Uuoh0Kl5Ple+Z/YOXDF05DBOKogmT96ohH5VuBPRyCCATXRgDI9/v94XD4PxneVpOIpkL9AFbwOt8BvtJaZq0cBo8AAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 02 16 22 41"\n        title=""\n        src="/static/2021-07-02-16-22-41-4688f12be6d789345beb01f329614300-fee1c.png"\n        srcset="/static/2021-07-02-16-22-41-4688f12be6d789345beb01f329614300-a67b7.png 200w,\n/static/2021-07-02-16-22-41-4688f12be6d789345beb01f329614300-0b187.png 400w,\n/static/2021-07-02-16-22-41-4688f12be6d789345beb01f329614300-fee1c.png 800w,\n/static/2021-07-02-16-22-41-4688f12be6d789345beb01f329614300-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从图中可以看出，渲染进程把生成图块的指令发送给 GPU，然后在 GPU 中执行生成图块的位图，并保存在 GPU 的内存中。</p>\n<h2 id="合成和显示"><a href="#%E5%90%88%E6%88%90%E5%92%8C%E6%98%BE%E7%A4%BA" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>合成和显示</h2>\n<p>一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。</p>\n<p>浏览器进程里面有一个叫 viz 的组件，用来接收合成线程发过来的 DrawQuad 命令，然后根据 DrawQuad 命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。</p>\n<p>到这里，经过这一系列的阶段，编写好的 HTML、CSS、JavaScript 等文件，经过浏览器就会显示出漂亮的页面了。</p>\n<h2 id="渲染流水线大总结"><a href="#%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%A4%A7%E6%80%BB%E7%BB%93" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>渲染流水线大总结</h2>\n<p>好了，我们现在已经分析完了整个渲染流程，从 HTML 到 DOM、样式计算、布局、图层、绘制、光栅化、合成和显示。下面我用一张图来总结下这整个渲染流程：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-02-16-23-25-12e192c0842585e51fb9e749122078c7-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 65.23642732049036%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAIAAAAmMtkJAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABr0lEQVQoz5WSyU7cQBCGeUEeJeLEIS+QIxoh5Q0SCYlrDignQoKEUNjCgBgGxDgeZoy7safb3dV7d8qxFcIilPwqeVN9rvqreimlpJQSQgCAkMCF7II1oiCUECrk38IswBsiCC5575EMwWsFMbiUfEp4Dc7K4upsPrmy1gbvfocP3hqjlYKmaR5grU3U/KRggx9q/RTeD9XgmL/bq75MVYrOWuMdhvVGGNUgi8VbOITAFgvGefL2vBQfRrBxCZvjNj6OYP9WpGiiN6kNGywYrZU2Deb3MGPoBF9S23av6G2UlVBmxNN1k8Y84UMufIohxojN9nBd11VVoRkhcW6qCy7AabU/ZSvf+OrXanWXvdnhg8NagUTDWK/33BmIj4VfrEMcanI3yye0mHnnYvBtfyH0lTGPcy4eq9sJpZRQOpsX+fT2ZpLVFWX3hC8q7LT3/LxmJ+dcWZZZlhFCjDH4r5wstg+GFzc5SIH76+EXhTB21I0DSdzu26O4/BnWzrFvo617DX4iPFJzrkd3smwMHjG0/e9wO788ux4efCqLeef0PyqjLscXJ9+3sp/ZH/gXwfHmTslGNTkAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 02 16 23 25"\n        title=""\n        src="/static/2021-07-02-16-23-25-12e192c0842585e51fb9e749122078c7-fee1c.png"\n        srcset="/static/2021-07-02-16-23-25-12e192c0842585e51fb9e749122078c7-a67b7.png 200w,\n/static/2021-07-02-16-23-25-12e192c0842585e51fb9e749122078c7-0b187.png 400w,\n/static/2021-07-02-16-23-25-12e192c0842585e51fb9e749122078c7-fee1c.png 800w,\n/static/2021-07-02-16-23-25-12e192c0842585e51fb9e749122078c7-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>结合上图，一个完整的渲染流程大致可总结为如下</p>\n<ul>\n<li>渲染进程将 HTML 内容转换为能够读懂的 DOM 树结构。</li>\n<li>渲染引擎将 CSS 样式表转化为浏览器可以理解的 styleSheets，计算出 DOM 节点的样式。</li>\n<li>创建布局树，并计算元素的布局信息。</li>\n<li>对布局树进行分层，并生成分层树。</li>\n<li>为每个图层生成绘制列表，并将其提交到合成线程。</li>\n<li>合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。</li>\n<li>合成线程发送绘制图块命令 DrawQuad 给浏览器进程。</li>\n<li>浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上</li>\n</ul>\n<h2 id="相关概念"><a href="#%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>相关概念</h2>\n<p>有了上面介绍渲染流水线的基础，我们再来看看三个和渲染流水线相关的概念——“重排”“重绘”和“合成”。理解了这三个概念对于你后续 Web 的性能优化会有很大帮助。</p>\n<h3 id="更新了元素的几何属性（重排）"><a href="#%E6%9B%B4%E6%96%B0%E4%BA%86%E5%85%83%E7%B4%A0%E7%9A%84%E5%87%A0%E4%BD%95%E5%B1%9E%E6%80%A7%EF%BC%88%E9%87%8D%E6%8E%92%EF%BC%89" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>更新了元素的几何属性（重排）</h3>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-02-16-24-14-7d1130489df189dc3836e35c56e87c90-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 27.845884413309985%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAIAAABM9SnKAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABE0lEQVQY041QTUvDQBDNP67oQSKCKIgnKVovYvsHxP9QsEatsVG0VaGe0o8kxDTZzG6y2e7uuIni2WEOb+bNG+aNhSa00rLSkqMSBuO/w9KISq05TRgJS7riJS2rNRfS9E2WlTTlbwrJuDCUbKhabLQGC15APEeaiDQQsS+zUMtSqQrzAEmg0oVIZpiHKvEVRGYnyqIWOz5sDMi2Q1r9ZOuW2Xd5awCbN3DmrfrTpX0Pu0PYc2F/VNgPxc6QHriGzS/fvxCl5S3hyM06L6ztkUMn7DyR9jMce3D1kY/8+HycdyfQfU1P3Oj0Meq9QW9MLiZwPctqcXN8/STFMjqfasEaR/LHTgO0EowtPiHym+E/Cr8BEGRINvQRRAsAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 02 16 24 14"\n        title=""\n        src="/static/2021-07-02-16-24-14-7d1130489df189dc3836e35c56e87c90-fee1c.png"\n        srcset="/static/2021-07-02-16-24-14-7d1130489df189dc3836e35c56e87c90-a67b7.png 200w,\n/static/2021-07-02-16-24-14-7d1130489df189dc3836e35c56e87c90-0b187.png 400w,\n/static/2021-07-02-16-24-14-7d1130489df189dc3836e35c56e87c90-fee1c.png 800w,\n/static/2021-07-02-16-24-14-7d1130489df189dc3836e35c56e87c90-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从上图可以看出，如果你通过 JavaScript 或者 CSS 修改元素的几何位置属性，例如改变元素的宽度、高度等，那么浏览器会触发重新布局，解析之后的一系列子阶段，这个过程就叫重排。无疑，重排需要更新完整的渲染流水线，所以开销也是最大的</p>\n<h3 id="更新元素的绘制属性（重绘）"><a href="#%E6%9B%B4%E6%96%B0%E5%85%83%E7%B4%A0%E7%9A%84%E7%BB%98%E5%88%B6%E5%B1%9E%E6%80%A7%EF%BC%88%E9%87%8D%E7%BB%98%EF%BC%89" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>更新元素的绘制属性（重绘）</h3>\n<p>接下来，我们再来看看重绘，比如通过 JavaScript 更改某些元素的背景颜色，渲染流水线会怎样调整呢？你可以参考下图：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-02-16-24-33-72a4f59fadf2078de83b2b9f20c01e72-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 25.04378283712785%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAIAAADKYVtkAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAA+ElEQVQY04WPwUrDQBiE85Kee/CgoD6ATyGefQnBYilFkNYqiNBQg7SraJZYSZNsks1ukmb333+7VvHqMJeB+WDGs3+CjdkU0DDTcdQNItr/5AFAyXkjKi2LtkxEmbFsnbOsluKn0dWVkhxaWZdM1bwTvOUFGviGDSKojqb8keZ3b2ufhK+EkOUyeI9e4ipmuR+lzvMVm9F4FmXzz+wpTD6S3Fr0YLfukoi9Ie+N1fno+WZwNRr0z4b+6YO8Xnztj+XRVB5MxPG9PJzIk6ns3cqLwMHa+/1rQCllAMIwpJQaY1zUSrtV1iiLOo1XZBG0NXddhM6ictQWzZgSDgm2Gb0AAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 02 16 24 33"\n        title=""\n        src="/static/2021-07-02-16-24-33-72a4f59fadf2078de83b2b9f20c01e72-fee1c.png"\n        srcset="/static/2021-07-02-16-24-33-72a4f59fadf2078de83b2b9f20c01e72-a67b7.png 200w,\n/static/2021-07-02-16-24-33-72a4f59fadf2078de83b2b9f20c01e72-0b187.png 400w,\n/static/2021-07-02-16-24-33-72a4f59fadf2078de83b2b9f20c01e72-fee1c.png 800w,\n/static/2021-07-02-16-24-33-72a4f59fadf2078de83b2b9f20c01e72-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从图中可以看出，如果修改了元素的背景颜色，那么布局阶段将不会被执行，因为并没有引起几何位置的变换，所以就直接进入了绘制阶段，然后执行之后的一系列子阶段，这个过程就叫重绘。相较于重排操作，重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些。</p>\n<h3 id="直接合成阶段"><a href="#%E7%9B%B4%E6%8E%A5%E5%90%88%E6%88%90%E9%98%B6%E6%AE%B5" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>直接合成阶段</h3>\n<p>那如果你更改一个既不要布局也不要绘制的属性，会发生什么变化呢？渲染引擎将跳过布局和绘制，只执行后续的合成操作，我们把这个过程叫做合成。具体流程参考下图</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-02-16-25-05-b0fa53f2f6f52a78c60b47c9e89274a7-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 23.64273204903678%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAIAAADKYVtkAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAA8ElEQVQY03WQy07DMBRE870sukBQJL6GH+iCBQbSsChqVVVISLRAQClREZRHE8d2bMex4weulS1HczejGWl0IxewRhlJjKSmRU5R2zW9H/QfEcaYUqqbWqBfWn6plnNai4ZxzrXWPiEFa0klCOKolIw0CHaC92WllFTqJscgw6OH7TJ9TZ896Wq5+njfPO7q+A2O10WyLsdBSVZcZvDlB+3L/lSnh5PdwaQe3JIRSOIrcB3HFwDc3y3OnuDhDJ/MyfGsOppWwzk5XZDBFJ9n0DkT9fOtX2g72eZ5zhjbGwGf8LJWF9/bz01uTBeeYILcH/8HEXg+ILrkAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 02 16 25 05"\n        title=""\n        src="/static/2021-07-02-16-25-05-b0fa53f2f6f52a78c60b47c9e89274a7-fee1c.png"\n        srcset="/static/2021-07-02-16-25-05-b0fa53f2f6f52a78c60b47c9e89274a7-a67b7.png 200w,\n/static/2021-07-02-16-25-05-b0fa53f2f6f52a78c60b47c9e89274a7-0b187.png 400w,\n/static/2021-07-02-16-25-05-b0fa53f2f6f52a78c60b47c9e89274a7-fee1c.png 800w,\n/static/2021-07-02-16-25-05-b0fa53f2f6f52a78c60b47c9e89274a7-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>在上图中，我们使用了 CSS 的 transform 来实现动画效果，这可以避开重排和重绘阶段，直接在非主线程上执行合成动画操作。这样的效率是最高的，因为是在非主线程上合成，并没有占用主线程的资源，另外也避开了布局和绘制两个子阶段，所以相对于重绘和重排，合成能大大提升绘制效率。</p>\n<p>至于如何用这些概念去优化页面，我们会在后面相关章节做详细讲解的，这里你只需要先结合“渲染流水线”弄明白这三个概念及原理就行</p>\n<h2 id="总结-4"><a href="#%E6%80%BB%E7%BB%93-4" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总结</h2>\n<p>通过本文的分析，你应该可以看到，Chrome 的渲染流水线还是相当复杂晦涩，且难以理解，不过 Chrome 团队在不断添加新功能的同时，也在不断地重构一些子阶段，目的就是让整体渲染架构变得更加简单和高效，正所谓大道至简。</p>\n<h2 id="思考时间"><a href="#%E6%80%9D%E8%80%83%E6%97%B6%E9%97%B4" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>思考时间</h2>\n<p>在优化 Web 性能的方法中，减少重绘、重排是一种很好的优化方式，那么结合文中的分析，你能总结出来为什么减少重绘、重排能优化 Web 性能吗？那又有那些具体的实践方法能减少重绘、重排呢？</p>\n<ul>\n<li>触发 repaint reflow 的操作尽量放在一起，比如改变 dom 高度和设置 margin 分开写，可能会出发两次重排</li>\n<li>通过虚拟 dom 层计算出操作总得差异，一起提交给浏览器。之前还用过 createdocumentfragment 来汇总 append 的 dom,来减少触发重排重绘次数。</li>\n</ul>',
excerpt:"Chrome 架构 在开始之前，我们一起看下，Chrome 打开一个页面需要启动多少进程？你可以点击 Chrome 浏览器右上角的“选项”菜单，选择“更多工具”子菜单，点击“任务管理器”，这将打开 Chrome 的任务管理器的窗口，如下图 和 Windows…",timeToRead:26,tableOfContents:'<ul>\n<li>\n<p><a href="/browser-working-principle-macro-view/#chrome-%E6%9E%B6%E6%9E%84">Chrome 架构</a></p>\n<ul>\n<li>\n<p><a href="/browser-working-principle-macro-view/#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B">进程和线程</a></p>\n<ul>\n<li><a href="/browser-working-principle-macro-view/#%E4%BB%80%E4%B9%88%E6%98%AF%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86">什么是并行处理</a></li>\n<li><a href="/browser-working-principle-macro-view/#%E7%BA%BF%E7%A8%8B-vs-%E8%BF%9B%E7%A8%8B">线程 VS 进程</a></li>\n</ul>\n</li>\n<li>\n<p><a href="/browser-working-principle-macro-view/#%E5%8D%95%E8%BF%9B%E7%A8%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E6%97%B6%E4%BB%A3">单进程浏览器时代</a></p>\n<ul>\n<li><a href="/browser-working-principle-macro-view/#%E4%B8%8D%E7%A8%B3%E5%AE%9A">不稳定</a></li>\n<li><a href="/browser-working-principle-macro-view/#%E4%B8%8D%E6%B5%81%E7%95%85">不流畅</a></li>\n<li><a href="/browser-working-principle-macro-view/#%E4%B8%8D%E5%AE%89%E5%85%A8">不安全</a></li>\n</ul>\n</li>\n<li>\n<p><a href="/browser-working-principle-macro-view/#%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E6%97%B6%E4%BB%A3">多进程浏览器时代</a></p>\n<ul>\n<li><a href="/browser-working-principle-macro-view/#%E6%97%A9%E6%9C%9F%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%9E%B6%E6%9E%84">早期多进程架构</a></li>\n<li><a href="/browser-working-principle-macro-view/#%E7%9B%AE%E5%89%8D%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%9E%B6%E6%9E%84">目前多进程架构</a></li>\n<li><a href="/browser-working-principle-macro-view/#%E6%9C%AA%E6%9D%A5%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%9E%B6%E6%9E%84">未来面向服务的架构</a></li>\n</ul>\n</li>\n<li><a href="/browser-working-principle-macro-view/#%E6%80%BB%E7%BB%93">总结</a></li>\n</ul>\n</li>\n<li>\n<p><a href="/browser-working-principle-macro-view/#tcp-%E5%8D%8F%E8%AE%AE">TCP 协议</a></p>\n<ul>\n<li>\n<p><a href="/browser-working-principle-macro-view/#%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%8C%85%E7%9A%84%E6%97%85%E7%A8%8B">一个数据包的“旅程”</a></p>\n<ul>\n<li>\n<ul>\n<li><a href="/browser-working-principle-macro-view/#ip%EF%BC%9A%E6%8A%8A%E6%95%B0%E6%8D%AE%E5%8C%85%E9%80%81%E8%BE%BE%E7%9B%AE%E7%9A%84%E4%B8%BB%E6%9C%BA">IP：把数据包送达目的主机</a></li>\n</ul>\n</li>\n<li><a href="/browser-working-principle-macro-view/#udp%EF%BC%9A%E6%8A%8A%E6%95%B0%E6%8D%AE%E5%8C%85%E9%80%81%E8%BE%BE%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F">UDP：把数据包送达应用程序</a></li>\n<li><a href="/browser-working-principle-macro-view/#tcp%EF%BC%9A%E6%8A%8A%E6%95%B0%E6%8D%AE%E5%AE%8C%E6%95%B4%E5%9C%B0%E9%80%81%E8%BE%BE%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F">TCP：把数据完整地送达应用程序</a></li>\n</ul>\n</li>\n<li><a href="/browser-working-principle-macro-view/#%E6%80%BB%E7%BB%93-1">总结</a></li>\n</ul>\n</li>\n<li>\n<p><a href="/browser-working-principle-macro-view/#http-%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B">HTTP 请求流程</a></p>\n<ul>\n<li>\n<p><a href="/browser-working-principle-macro-view/#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%AB%AF%E5%8F%91%E8%B5%B7-http-%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B">浏览器端发起 HTTP 请求流程</a></p>\n<ul>\n<li><a href="/browser-working-principle-macro-view/#%E6%9E%84%E5%BB%BA%E8%AF%B7%E6%B1%82">构建请求</a></li>\n<li><a href="/browser-working-principle-macro-view/#%E6%9F%A5%E6%89%BE%E7%BC%93%E5%AD%98">查找缓存</a></li>\n<li><a href="/browser-working-principle-macro-view/#%E5%87%86%E5%A4%87-ip-%E5%9C%B0%E5%9D%80%E5%92%8C%E7%AB%AF%E5%8F%A3">准备 IP 地址和端口</a></li>\n<li><a href="/browser-working-principle-macro-view/#%E7%AD%89%E5%BE%85-tcp-%E9%98%9F%E5%88%97">等待 TCP 队列</a></li>\n<li><a href="/browser-working-principle-macro-view/#%E5%BB%BA%E7%AB%8B-tcp-%E8%BF%9E%E6%8E%A5">建立 TCP 连接</a></li>\n<li><a href="/browser-working-principle-macro-view/#%E5%8F%91%E9%80%81-http-%E8%AF%B7%E6%B1%82">发送 HTTP 请求</a></li>\n</ul>\n</li>\n<li>\n<p><a href="/browser-working-principle-macro-view/#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%A4%84%E7%90%86-http-%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B">服务器端处理 HTTP 请求流程</a></p>\n<ul>\n<li><a href="/browser-working-principle-macro-view/#%E8%BF%94%E5%9B%9E%E8%AF%B7%E6%B1%82">返回请求</a></li>\n<li><a href="/browser-working-principle-macro-view/#%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5">断开连接</a></li>\n<li><a href="/browser-working-principle-macro-view/#%E9%87%8D%E5%AE%9A%E5%90%91">重定向</a></li>\n</ul>\n</li>\n<li>\n<p><a href="/browser-working-principle-macro-view/#%E9%97%AE%E9%A2%98%E8%A7%A3%E7%AD%94">问题解答</a></p>\n<ul>\n<li><a href="/browser-working-principle-macro-view/#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BE%88%E5%A4%9A%E7%AB%99%E7%82%B9%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%89%93%E5%BC%80%E9%80%9F%E5%BA%A6%E4%BC%9A%E5%BE%88%E5%BF%AB%EF%BC%9F">为什么很多站点第二次打开速度会很快？</a></li>\n<li><a href="/browser-working-principle-macro-view/#%E7%99%BB%E5%BD%95%E7%8A%B6%E6%80%81%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E6%8C%81%E7%9A%84%EF%BC%9F">登录状态是如何保持的？</a></li>\n</ul>\n</li>\n<li><a href="/browser-working-principle-macro-view/#%E6%80%BB%E7%BB%93-2">总结</a></li>\n</ul>\n</li>\n<li>\n<p><a href="/browser-working-principle-macro-view/#%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89">渲染流程（上）</a></p>\n<ul>\n<li><a href="/browser-working-principle-macro-view/#%E6%9E%84%E5%BB%BA-dom-%E6%A0%91">构建 DOM 树</a></li>\n<li>\n<p><a href="/browser-working-principle-macro-view/#%E6%A0%B7%E5%BC%8F%E8%AE%A1%E7%AE%97">样式计算</a></p>\n<ul>\n<li><a href="/browser-working-principle-macro-view/#%E6%8A%8A-css-%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%B5%8F%E8%A7%88%E5%99%A8%E8%83%BD%E5%A4%9F%E7%90%86%E8%A7%A3%E7%9A%84%E7%BB%93%E6%9E%84">把 CSS 转换为浏览器能够理解的结构</a></li>\n<li><a href="/browser-working-principle-macro-view/#%E8%BD%AC%E6%8D%A2%E6%A0%B7%E5%BC%8F%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%B1%9E%E6%80%A7%E5%80%BC%EF%BC%8C%E4%BD%BF%E5%85%B6%E6%A0%87%E5%87%86%E5%8C%96">转换样式表中的属性值，使其标准化</a></li>\n<li><a href="/browser-working-principle-macro-view/#%E8%AE%A1%E7%AE%97%E5%87%BA-dom-%E6%A0%91%E4%B8%AD%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E5%85%B7%E4%BD%93%E6%A0%B7%E5%BC%8F">计算出 DOM 树中每个节点的具体样式</a></li>\n</ul>\n</li>\n<li>\n<p><a href="/browser-working-principle-macro-view/#%E5%B8%83%E5%B1%80%E9%98%B6%E6%AE%B5">布局阶段</a></p>\n<ul>\n<li><a href="/browser-working-principle-macro-view/#%E5%88%9B%E5%BB%BA%E5%B8%83%E5%B1%80%E6%A0%91">创建布局树</a></li>\n<li><a href="/browser-working-principle-macro-view/#%E5%B8%83%E5%B1%80%E8%AE%A1%E7%AE%97">布局计算</a></li>\n</ul>\n</li>\n<li><a href="/browser-working-principle-macro-view/#%E6%80%BB%E7%BB%93-3">总结</a></li>\n</ul>\n</li>\n<li>\n<p><a href="/browser-working-principle-macro-view/#%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B%EF%BC%88%E4%B8%8B%EF%BC%89">渲染流程（下）</a></p>\n<ul>\n<li><a href="/browser-working-principle-macro-view/#%E5%88%86%E5%B1%82">分层</a></li>\n<li><a href="/browser-working-principle-macro-view/#%E5%9B%BE%E5%B1%82%E7%BB%98%E5%88%B6">图层绘制</a></li>\n<li><a href="/browser-working-principle-macro-view/#%E6%A0%85%E6%A0%BC%E5%8C%96%EF%BC%88raster%EF%BC%89%E6%93%8D%E4%BD%9C">栅格化（raster）操作</a></li>\n<li><a href="/browser-working-principle-macro-view/#%E5%90%88%E6%88%90%E5%92%8C%E6%98%BE%E7%A4%BA">合成和显示</a></li>\n<li><a href="/browser-working-principle-macro-view/#%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%A4%A7%E6%80%BB%E7%BB%93">渲染流水线大总结</a></li>\n<li>\n<p><a href="/browser-working-principle-macro-view/#%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5">相关概念</a></p>\n<ul>\n<li><a href="/browser-working-principle-macro-view/#%E6%9B%B4%E6%96%B0%E4%BA%86%E5%85%83%E7%B4%A0%E7%9A%84%E5%87%A0%E4%BD%95%E5%B1%9E%E6%80%A7%EF%BC%88%E9%87%8D%E6%8E%92%EF%BC%89">更新了元素的几何属性（重排）</a></li>\n<li><a href="/browser-working-principle-macro-view/#%E6%9B%B4%E6%96%B0%E5%85%83%E7%B4%A0%E7%9A%84%E7%BB%98%E5%88%B6%E5%B1%9E%E6%80%A7%EF%BC%88%E9%87%8D%E7%BB%98%EF%BC%89">更新元素的绘制属性（重绘）</a></li>\n<li><a href="/browser-working-principle-macro-view/#%E7%9B%B4%E6%8E%A5%E5%90%88%E6%88%90%E9%98%B6%E6%AE%B5">直接合成阶段</a></li>\n</ul>\n</li>\n<li><a href="/browser-working-principle-macro-view/#%E6%80%BB%E7%BB%93-4">总结</a></li>\n<li><a href="/browser-working-principle-macro-view/#%E6%80%9D%E8%80%83%E6%97%B6%E9%97%B4">思考时间</a></li>\n</ul>\n</li>\n</ul>',wordCount:{words:2793},frontmatter:{date:"2021-07-01 14:44:27",path:"/browser-working-principle-macro-view/",tags:"前端, JS, 高级前端",title:"浏览器工作原理与实践——宏观视角上的浏览器",draft:null,catalog_number:null}},nextPost:{html:'<h1 id="背景"><a href="#%E8%83%8C%E6%99%AF" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>背景</h1>\n<p>在浏览器中，我们可以同时打开多个 Tab 页，每个 Tab 页可以粗略理解为一个“独立”的运行环境，即使是全局对象也不会在多个 Tab 间共享。然而有些时候，我们希望能在这些“独立”的 Tab 页面之间同步页面的数据、信息或状态。</p>\n<p>正如下面这个例子：我在列表页点击“收藏”后，对应的详情页按钮会自动更新为“已收藏”状态；类似的，在详情页点击“收藏”后，列表页中按钮也会更新。</p>\n<p><img src="/static/cross-page-message-95ffa84567dab8bfd85806efe647b5a3.gif"></p>\n<h1 id="同源页面间的跨页面通信"><a href="#%E5%90%8C%E6%BA%90%E9%A1%B5%E9%9D%A2%E9%97%B4%E7%9A%84%E8%B7%A8%E9%A1%B5%E9%9D%A2%E9%80%9A%E4%BF%A1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>同源页面间的跨页面通信</h1>\n<p>浏览器的同源策略在下述的一些跨页面通信方法中依然存在限制。因此我们先来看看，在满足同源策略的情况下，都有哪些技术可以用来实现跨页面通信。</p>\n<h2 id="broadcast-channel"><a href="#broadcast-channel" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>BroadCast Channel</h2>\n<p>BroadCast Channel 可以帮我们创建一个用于广播的通信频道，当所有页面都监听同一频道的消息时，其中某一个页面通过它发送的消息就会被其他所有页面收到，它的 API 和用法都非常简单。</p>\n<p>下面的方式就可以创建一个标识为 AlienZHOU 的频道：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="94231681942032330000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`const bc = new BroadcastChannel(\'AlienZHOU\');`, `94231681942032330000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">const</span> bc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BroadcastChannel</span><span class="token punctuation">(</span><span class="token string">\'AlienZHOU\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>各个页面可以通过 onmessage 来监听被广播的消息：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="16081570226160458000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`bc.onmessage = function(e) {\n  const data = e.data;\n  const text = \'[receive] \' + data.msg + \' —— tab \' + data.from;\n  console.log(\'[BroadcastChannel] receive message:\', text);\n};`, `16081570226160458000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js">bc<span class="token punctuation">.</span><span class="token function-variable function">onmessage</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> data <span class="token operator">=</span> e<span class="token punctuation">.</span>data<span class="token punctuation">;</span>\n  <span class="token keyword">const</span> text <span class="token operator">=</span> <span class="token string">\'[receive] \'</span> <span class="token operator">+</span> data<span class="token punctuation">.</span>msg <span class="token operator">+</span> <span class="token string">\' —— tab \'</span> <span class="token operator">+</span> data<span class="token punctuation">.</span>from<span class="token punctuation">;</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'[BroadcastChannel] receive message:\'</span><span class="token punctuation">,</span> text<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>要发送消息时只需要调用实例上的 postMessage 方法即可：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="95466801166499950000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`bc.postMessage(mydata);`, `95466801166499950000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js">bc<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span>mydata<span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<h2 id="service-worker"><a href="#service-worker" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Service Worker</h2>\n<p>Service Worker 是一个可以长期运行在后台的 Worker，能够实现与页面的双向通信。多页面共享间的 Service Worker 可以共享，将 Service Worker 作为消息的处理中心（中央站）即可实现广播效果。</p>\n<p>首先，需要在页面注册 Service Worker：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="99922974874621760000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`/* 页面逻辑 */\nnavigator.serviceWorker.register(\'../util.sw.js\').then(function() {\n  console.log(\'Service Worker 注册成功\');\n});`, `99922974874621760000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">/* 页面逻辑 */</span>\nnavigator<span class="token punctuation">.</span>serviceWorker<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span><span class="token string">\'../util.sw.js\'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'Service Worker 注册成功\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>其中../util.sw.js 是对应的 Service Worker 脚本。Service Worker 本身并不自动具备“广播通信”的功能，需要我们添加些代码，将其改造成消息中转站：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="8570253692486962000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`/* ../util.sw.js Service Worker 逻辑 */\nself.addEventListener(\'message\', function(e) {\n  console.log(\'service worker receive message\', e.data);\n  e.waitUntil(\n    self.clients.matchAll().then(function(clients) {\n      if (!clients || clients.length === 0) {\n        return;\n      }\n      clients.forEach(function(client) {\n        client.postMessage(e.data);\n      });\n    })\n  );\n});`, `8570253692486962000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">/* ../util.sw.js Service Worker 逻辑 */</span>\nself<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">\'message\'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'service worker receive message\'</span><span class="token punctuation">,</span> e<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  e<span class="token punctuation">.</span><span class="token function">waitUntil</span><span class="token punctuation">(</span>\n    self<span class="token punctuation">.</span>clients<span class="token punctuation">.</span><span class="token function">matchAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">clients</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>clients <span class="token operator">||</span> clients<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">return</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n      clients<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">client</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        client<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span>\n  <span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>我们在 Service Worker 中监听了 message 事件，获取页面（从 Service Worker 的角度叫 client）发送的信息。然后通过 self.clients.matchAll() 获取当前注册了该 Service Worker 的所有页面，通过调用每个 client（即页面）的 postMessage 方法，向页面发送消息。这样就把从一处（某个 Tab 页面）收到的消息通知给了其他页面。</p>\n<p>处理完 Service Worker，我们需要在页面监听 Service Worker 发送来的消息：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="24902327822264582000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`/* 页面逻辑 */\nnavigator.serviceWorker.addEventListener(\'message\', function(e) {\n  const data = e.data;\n  const text = \'[receive] \' + data.msg + \' —— tab \' + data.from;\n  console.log(\'[Service Worker] receive message:\', text);\n});`, `24902327822264582000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">/* 页面逻辑 */</span>\nnavigator<span class="token punctuation">.</span>serviceWorker<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">\'message\'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> data <span class="token operator">=</span> e<span class="token punctuation">.</span>data<span class="token punctuation">;</span>\n  <span class="token keyword">const</span> text <span class="token operator">=</span> <span class="token string">\'[receive] \'</span> <span class="token operator">+</span> data<span class="token punctuation">.</span>msg <span class="token operator">+</span> <span class="token string">\' —— tab \'</span> <span class="token operator">+</span> data<span class="token punctuation">.</span>from<span class="token punctuation">;</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'[Service Worker] receive message:\'</span><span class="token punctuation">,</span> text<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>最后，当需要同步消息时，可以调用 Service Worker 的 postMessage 方法：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="60807484964410440000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`/* 页面逻辑 */\nnavigator.serviceWorker.controller.postMessage(mydata);`, `60807484964410440000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">/* 页面逻辑 */</span>\nnavigator<span class="token punctuation">.</span>serviceWorker<span class="token punctuation">.</span>controller<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span>mydata<span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span></span></pre></div>\n<h2 id="localstorage"><a href="#localstorage" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>LocalStorage</h2>\n<p>LocalStorage 作为前端最常用的本地存储，大家应该已经非常熟悉了；但 StorageEvent 这个与它相关的事件有些同学可能会比较陌生。</p>\n<p>当 LocalStorage 变化时，会触发 storage 事件。利用这个特性，我们可以在发送消息时，把消息写入到某个 LocalStorage 中；然后在各个页面内，通过监听 storage 事件即可收到通知。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="6866941840392693000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`window.addEventListener(\'storage\', function(e) {\n  if (e.key === \'ctc-msg\') {\n    const data = JSON.parse(e.newValue);\n    const text = \'[receive] \' + data.msg + \' —— tab \' + data.from;\n    console.log(\'[Storage I] receive message:\', text);\n  }\n});`, `6866941840392693000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js">window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">\'storage\'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>key <span class="token operator">===</span> <span class="token string">\'ctc-msg\'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>newValue<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">const</span> text <span class="token operator">=</span> <span class="token string">\'[receive] \'</span> <span class="token operator">+</span> data<span class="token punctuation">.</span>msg <span class="token operator">+</span> <span class="token string">\' —— tab \'</span> <span class="token operator">+</span> data<span class="token punctuation">.</span>from<span class="token punctuation">;</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'[Storage I] receive message:\'</span><span class="token punctuation">,</span> text<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>在各个页面添加如上的代码，即可监听到 LocalStorage 的变化。当某个页面需要发送消息时，只需要使用我们熟悉的 setItem 方法即可：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="39579283381860655000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`mydata.st = +new Date();\nwindow.localStorage.setItem(\'ctc-msg\', JSON.stringify(mydata));`, `39579283381860655000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js">mydata<span class="token punctuation">.</span>st <span class="token operator">=</span> <span class="token operator">+</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nwindow<span class="token punctuation">.</span>localStorage<span class="token punctuation">.</span><span class="token function">setItem</span><span class="token punctuation">(</span><span class="token string">\'ctc-msg\'</span><span class="token punctuation">,</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>mydata<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span></span></pre></div>\n<p>注意这里有一个细节：我们在 mydata 上添加了一个取当前毫秒时间戳的 .st 属性。这是因为 storage 事件只有在值真正改变时才会触发。举个例子：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="27714348375216157000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`window.localStorage.setItem(\'test\', \'123\');\nwindow.localStorage.setItem(\'test\', \'123\');`, `27714348375216157000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js">window<span class="token punctuation">.</span>localStorage<span class="token punctuation">.</span><span class="token function">setItem</span><span class="token punctuation">(</span><span class="token string">\'test\'</span><span class="token punctuation">,</span> <span class="token string">\'123\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nwindow<span class="token punctuation">.</span>localStorage<span class="token punctuation">.</span><span class="token function">setItem</span><span class="token punctuation">(</span><span class="token string">\'test\'</span><span class="token punctuation">,</span> <span class="token string">\'123\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span></span></pre></div>\n<p>由于第二次的值 123 与第一次的值相同，所以以上的代码只会在第一次 setItem 时触发 storage 事件。因此我们通过设置 st 来保证每次调用时一定会触发 storage 事件。</p>\n<h2 id="阶段性总结-1"><a href="#%E9%98%B6%E6%AE%B5%E6%80%A7%E6%80%BB%E7%BB%93-1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>阶段性总结-1</h2>\n<p>上面我们看到了三种实现跨页面通信的方式，不论是建立广播频道的 Broadcast Channel，还是使用 Service Worker 的消息中转站，抑或是有一些 tricky 的 storage 事件，其都是“广播模式”：一个页面将消息通知给一个“中央站”，再由“中央站”通知给各个页面</p>\n<p>下面我们会看到另外两种跨页面通信方式，我把它称为“共享存储+轮询模式”。</p>\n<h2 id="shared-worker"><a href="#shared-worker" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Shared Worker</h2>\n<p>Shared Worker 是 Worker 家族的另一个成员。普通的 Worker 之间是独立运行、数据互不相通；而多个 Tab 注册的 Shared Worker 则可以实现数据共享。</p>\n<p>Shared Worker 在实现跨页面通信时的问题在于，它无法主动通知所有页面，因此我们会使用轮询的方式，来拉取最新的数据。思路如下：</p>\n<p>让 Shared Worker 支持两种消息。一种是 post，Shared Worker 收到后会将该数据保存下来；另一种是 get，Shared Worker 收到该消息后会将保存的数据通过 postMessage 传给注册它的页面。也就是让页面通过 get 来主动获取（同步）最新消息。具体实现如下：</p>\n<p>首先，我们会在页面中启动一个 Shared Worker，启动方式非常简单：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="2646915869349886000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// 构造函数的第二个参数是 Shared Worker 名称，也可以留空\nconst sharedWorker = new SharedWorker(\'../util.shared.js\', \'ctc\');`, `2646915869349886000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">// 构造函数的第二个参数是 Shared Worker 名称，也可以留空</span>\n<span class="token keyword">const</span> sharedWorker <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SharedWorker</span><span class="token punctuation">(</span><span class="token string">\'../util.shared.js\'</span><span class="token punctuation">,</span> <span class="token string">\'ctc\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span></span></pre></div>\n<p>然后，在该 Shared Worker 中支持 get 与 post 形式的消息：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="68449485955736630000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`/* ../util.shared.js: Shared Worker 代码 */\nlet data = null;\nself.addEventListener(\'connect\', function(e) {\n  const port = e.ports[0];\n  port.addEventListener(\'message\', function(event) {\n    if (event.data.get) {\n      // get 指令则返回存储的消息数据\n      data && port.postMessage(data);\n    } else {\n      // 非 get 指令则存储该消息数据\n      data = event.data;\n    }\n  });\n  port.start();\n});`, `68449485955736630000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">/* ../util.shared.js: Shared Worker 代码 */</span>\n<span class="token keyword">let</span> data <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\nself<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">\'connect\'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> port <span class="token operator">=</span> e<span class="token punctuation">.</span>ports<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n  port<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">\'message\'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>event<span class="token punctuation">.</span>data<span class="token punctuation">.</span>get<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token comment">// get 指令则返回存储的消息数据</span>\n      data <span class="token operator">&amp;&amp;</span> port<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n      <span class="token comment">// 非 get 指令则存储该消息数据</span>\n      data <span class="token operator">=</span> event<span class="token punctuation">.</span>data<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  port<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>之后，页面定时发送 get 指令的消息给 Shared Worker，轮询最新的消息数据，并在页面监听返回信息：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="32260401083458957000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// 定时轮询，发送 get 指令的消息\nsetInterval(function() {\n  sharedWorker.port.postMessage({ get: true });\n}, 1000);\n\n// 监听 get 消息的返回数据\nsharedWorker.port.addEventListener(\n  \'message\',\n  (e) => {\n    const data = e.data;\n    const text = \'[receive] \' + data.msg + \' —— tab \' + data.from;\n    console.log(\'[Shared Worker] receive message:\', text);\n  },\n  false\n);\nsharedWorker.port.start();`, `32260401083458957000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">// 定时轮询，发送 get 指令的消息</span>\n<span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  sharedWorker<span class="token punctuation">.</span>port<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token keyword">get</span><span class="token punctuation">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token comment">// 监听 get 消息的返回数据</span>\nsharedWorker<span class="token punctuation">.</span>port<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span>\n  <span class="token string">\'message\'</span><span class="token punctuation">,</span>\n  <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n    <span class="token keyword">const</span> data <span class="token operator">=</span> e<span class="token punctuation">.</span>data<span class="token punctuation">;</span>\n    <span class="token keyword">const</span> text <span class="token operator">=</span> <span class="token string">\'[receive] \'</span> <span class="token operator">+</span> data<span class="token punctuation">.</span>msg <span class="token operator">+</span> <span class="token string">\' —— tab \'</span> <span class="token operator">+</span> data<span class="token punctuation">.</span>from<span class="token punctuation">;</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'[Shared Worker] receive message:\'</span><span class="token punctuation">,</span> text<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token boolean">false</span>\n<span class="token punctuation">)</span><span class="token punctuation">;</span>\nsharedWorker<span class="token punctuation">.</span>port<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>最后，当要跨页面通信时，只需给 Shared Worker postMessage 即可：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="82041137816977200000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`sharedWorker.port.postMessage(mydata);`, `82041137816977200000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js">sharedWorker<span class="token punctuation">.</span>port<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span>mydata<span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<blockquote>\n<p>注意，如果使用 addEventListener 来添加 Shared Worker 的消息监听，需要显式调用 MessagePort.start 方法，即上文中的 sharedWorker.port.start()；如果使用 onmessage 绑定监听则不需要。</p>\n</blockquote>\n<h2 id="indexeddb"><a href="#indexeddb" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>IndexedDB</h2>\n<p>除了可以利用 Shared Worker 来共享存储数据，还可以使用其他一些“全局性”（支持跨页面）的存储方案。例如 IndexedDB 或 cookie。</p>\n<blockquote>\n<p>鉴于大家对 cookie 已经很熟悉，加之作为“互联网最早期的存储方案之一”，cookie 已经在实际应用中承受了远多于其设计之初的责任，我们下面会使用 IndexedDB 来实现。</p>\n</blockquote>\n<p>其思路很简单：与 Shared Worker 方案类似，消息发送方将消息存至 IndexedDB 中；接收方（例如所有页面）则通过轮询去获取最新的信息。在这之前，我们先简单封装几个 IndexedDB 的工具方法。</p>\n<p>打开数据库连接</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="34138312031666820000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function openStore() {\n  const storeName = \'ctc_aleinzhou\';\n  return new Promise(function(resolve, reject) {\n    if (!(\'indexedDB\' in window)) {\n      return reject(&quot;don\'t support indexedDB&quot;);\n    }\n    const request = indexedDB.open(\'CTC_DB\', 1);\n    request.onerror = reject;\n    request.onsuccess = (e) => resolve(e.target.result);\n    request.onupgradeneeded = function(e) {\n      const db = e.srcElement.result;\n      if (e.oldVersion === 0 && !db.objectStoreNames.contains(storeName)) {\n        const store = db.createObjectStore(storeName, { keyPath: \'tag\' });\n        store.createIndex(storeName + \'Index\', \'tag\', { unique: false });\n      }\n    };\n  });\n}`, `34138312031666820000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span> <span class="token function">openStore</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> storeName <span class="token operator">=</span> <span class="token string">\'ctc_aleinzhou\'</span><span class="token punctuation">;</span>\n  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span><span class="token string">\'indexedDB\'</span> <span class="token keyword">in</span> window<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">return</span> <span class="token function">reject</span><span class="token punctuation">(</span><span class="token string">"don\'t support indexedDB"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n    <span class="token keyword">const</span> request <span class="token operator">=</span> indexedDB<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">\'CTC_DB\'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    request<span class="token punctuation">.</span>onerror <span class="token operator">=</span> reject<span class="token punctuation">;</span>\n    request<span class="token punctuation">.</span><span class="token function-variable function">onsuccess</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">resolve</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>target<span class="token punctuation">.</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    request<span class="token punctuation">.</span><span class="token function-variable function">onupgradeneeded</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">const</span> db <span class="token operator">=</span> e<span class="token punctuation">.</span>srcElement<span class="token punctuation">.</span>result<span class="token punctuation">;</span>\n      <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>oldVersion <span class="token operator">===</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>db<span class="token punctuation">.</span>objectStoreNames<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>storeName<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">const</span> store <span class="token operator">=</span> db<span class="token punctuation">.</span><span class="token function">createObjectStore</span><span class="token punctuation">(</span>storeName<span class="token punctuation">,</span> <span class="token punctuation">{</span> keyPath<span class="token punctuation">:</span> <span class="token string">\'tag\'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        store<span class="token punctuation">.</span><span class="token function">createIndex</span><span class="token punctuation">(</span>storeName <span class="token operator">+</span> <span class="token string">\'Index\'</span><span class="token punctuation">,</span> <span class="token string">\'tag\'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> unique<span class="token punctuation">:</span> <span class="token boolean">false</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>存储数据</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="93378697892002410000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function saveData(db, data) {\n  return new Promise(function(resolve, reject) {\n    const STORE_NAME = \'ctc_aleinzhou\';\n    const tx = db.transaction(STORE_NAME, \'readwrite\');\n    const store = tx.objectStore(STORE_NAME);\n    const request = store.put({ tag: \'ctc_data\', data });\n    request.onsuccess = () => resolve(db);\n    request.onerror = reject;\n  });\n}`, `93378697892002410000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span> <span class="token function">saveData</span><span class="token punctuation">(</span><span class="token parameter">db<span class="token punctuation">,</span> data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">const</span> <span class="token constant">STORE_NAME</span> <span class="token operator">=</span> <span class="token string">\'ctc_aleinzhou\'</span><span class="token punctuation">;</span>\n    <span class="token keyword">const</span> tx <span class="token operator">=</span> db<span class="token punctuation">.</span><span class="token function">transaction</span><span class="token punctuation">(</span><span class="token constant">STORE_NAME</span><span class="token punctuation">,</span> <span class="token string">\'readwrite\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">const</span> store <span class="token operator">=</span> tx<span class="token punctuation">.</span><span class="token function">objectStore</span><span class="token punctuation">(</span><span class="token constant">STORE_NAME</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">const</span> request <span class="token operator">=</span> store<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token punctuation">{</span> tag<span class="token punctuation">:</span> <span class="token string">\'ctc_data\'</span><span class="token punctuation">,</span> data <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    request<span class="token punctuation">.</span><span class="token function-variable function">onsuccess</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">resolve</span><span class="token punctuation">(</span>db<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    request<span class="token punctuation">.</span>onerror <span class="token operator">=</span> reject<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>查询/读取数据</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="33690956485275136000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function query(db) {\n  const STORE_NAME = \'ctc_aleinzhou\';\n  return new Promise(function(resolve, reject) {\n    try {\n      const tx = db.transaction(STORE_NAME, \'readonly\');\n      const store = tx.objectStore(STORE_NAME);\n      const dbRequest = store.get(\'ctc_data\');\n      dbRequest.onsuccess = (e) => resolve(e.target.result);\n      dbRequest.onerror = reject;\n    } catch (err) {\n      reject(err);\n    }\n  });\n}`, `33690956485275136000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span> <span class="token function">query</span><span class="token punctuation">(</span><span class="token parameter">db</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> <span class="token constant">STORE_NAME</span> <span class="token operator">=</span> <span class="token string">\'ctc_aleinzhou\'</span><span class="token punctuation">;</span>\n  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">try</span> <span class="token punctuation">{</span>\n      <span class="token keyword">const</span> tx <span class="token operator">=</span> db<span class="token punctuation">.</span><span class="token function">transaction</span><span class="token punctuation">(</span><span class="token constant">STORE_NAME</span><span class="token punctuation">,</span> <span class="token string">\'readonly\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token keyword">const</span> store <span class="token operator">=</span> tx<span class="token punctuation">.</span><span class="token function">objectStore</span><span class="token punctuation">(</span><span class="token constant">STORE_NAME</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token keyword">const</span> dbRequest <span class="token operator">=</span> store<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">\'ctc_data\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      dbRequest<span class="token punctuation">.</span><span class="token function-variable function">onsuccess</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">resolve</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>target<span class="token punctuation">.</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      dbRequest<span class="token punctuation">.</span>onerror <span class="token operator">=</span> reject<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token function">reject</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>剩下的工作就非常简单了。首先打开数据连接，并初始化数据：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="14861398197652531000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`openStore().then((db) => saveData(db, null));`, `14861398197652531000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token function">openStore</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">db</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">saveData</span><span class="token punctuation">(</span>db<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>对于消息读取，可以在连接与初始化后轮询：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="1017651327750601600"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`openStore()\n  .then((db) => saveData(db, null))\n  .then(function(db) {\n    setInterval(function() {\n      query(db).then(function(res) {\n        if (!res || !res.data) {\n          return;\n        }\n        const data = res.data;\n        const text = \'[receive] \' + data.msg + \' —— tab \' + data.from;\n        console.log(\'[Storage I] receive message:\', text);\n      });\n    }, 1000);\n  });`, `1017651327750601600`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token function">openStore</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">db</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">saveData</span><span class="token punctuation">(</span>db<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">db</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token function">query</span><span class="token punctuation">(</span>db<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">res</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>res <span class="token operator">||</span> <span class="token operator">!</span>res<span class="token punctuation">.</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n          <span class="token keyword">return</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n        <span class="token keyword">const</span> data <span class="token operator">=</span> res<span class="token punctuation">.</span>data<span class="token punctuation">;</span>\n        <span class="token keyword">const</span> text <span class="token operator">=</span> <span class="token string">\'[receive] \'</span> <span class="token operator">+</span> data<span class="token punctuation">.</span>msg <span class="token operator">+</span> <span class="token string">\' —— tab \'</span> <span class="token operator">+</span> data<span class="token punctuation">.</span>from<span class="token punctuation">;</span>\n        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'[Storage I] receive message:\'</span><span class="token punctuation">,</span> text<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>最后，要发送消息时，只需向 IndexedDB 存储数据即可：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="69324872707268970000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`openStore()\n  .then((db) => saveData(db, null))\n  .then(function(db) {\n    // …… 省略上面的轮询代码\n    // 触发 saveData 的方法可以放在用户操作的事件监听内\n    saveData(db, mydata);\n  });`, `69324872707268970000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token function">openStore</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">db</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">saveData</span><span class="token punctuation">(</span>db<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">db</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// …… 省略上面的轮询代码</span>\n    <span class="token comment">// 触发 saveData 的方法可以放在用户操作的事件监听内</span>\n    <span class="token function">saveData</span><span class="token punctuation">(</span>db<span class="token punctuation">,</span> mydata<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h2 id="阶段性总结-2"><a href="#%E9%98%B6%E6%AE%B5%E6%80%A7%E6%80%BB%E7%BB%93-2" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>阶段性总结-2</h2>\n<p>在“广播模式”外，我们又了解了“共享存储+长轮询”这种模式。也许你会认为长轮询没有监听模式优雅，但实际上，有些时候使用“共享存储”的形式时，不一定要搭配长轮询。</p>\n<p>例如，在多 Tab 场景下，我们可能会离开 Tab A 到另一个 Tab B 中操作；过了一会我们从 Tab B 切换回 Tab A 时，希望将之前在 Tab B 中的操作的信息同步回来。这时候，其实只用在 Tab A 中监听 visibilitychange 这样的事件，来做一次信息同步即可。</p>\n<p>下面，我会再介绍一种通信方式，我把它称为“口口相传”模式。</p>\n<h2 id="windowopen--windowopener"><a href="#windowopen--windowopener" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>window.open + window.opener</h2>\n<p>当我们使用 window.open 打开页面时，方法会返回一个被打开页面 window 的引用。而在未显示指定 noopener 时，被打开的页面可以通过 window.opener 获取到打开它的页面的引用 —— 通过这种方式我们就将这些页面建立起了联系（一种树形结构）。</p>\n<p>首先，我们把 window.open 打开的页面的 window 对象收集起来：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="76220326566318870000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`let childWins = [];\ndocument.getElementById(\'btn\').addEventListener(\'click\', function() {\n  const win = window.open(\'./some/sample\');\n  childWins.push(win);\n});`, `76220326566318870000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">let</span> childWins <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\ndocument<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">\'btn\'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">\'click\'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> win <span class="token operator">=</span> window<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">\'./some/sample\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  childWins<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>win<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>然后，当我们需要发送消息的时候，作为消息的发起方，一个页面需要同时通知它打开的页面与打开它的页面：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="85317602465199420000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// 向下传递消息，打开的窗口传递消息给它打开的页面\nchildWins = childWins.filter((w) => !w.closed);\nif (childWins.length > 0) {\n  mydata.fromOpenner = false;\n  childWins.forEach((w) => w.postMessage(mydata));\n}\n\n// 向上传递消息，打开的窗口传递消息给打开它的页面\nif (window.opener && !window.opener.closed) {\n  mydata.fromOpenner = true;\n  window.opener.postMessage(mydata);\n}`, `85317602465199420000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">// 向下传递消息，打开的窗口传递消息给它打开的页面</span>\nchildWins <span class="token operator">=</span> childWins<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">w</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token operator">!</span>w<span class="token punctuation">.</span>closed<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">if</span> <span class="token punctuation">(</span>childWins<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  mydata<span class="token punctuation">.</span>fromOpenner <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>\n  childWins<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">w</span><span class="token punctuation">)</span> <span class="token operator">=></span> w<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span>mydata<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// 向上传递消息，打开的窗口传递消息给打开它的页面</span>\n<span class="token keyword">if</span> <span class="token punctuation">(</span>window<span class="token punctuation">.</span>opener <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>window<span class="token punctuation">.</span>opener<span class="token punctuation">.</span>closed<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  mydata<span class="token punctuation">.</span>fromOpenner <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n  window<span class="token punctuation">.</span>opener<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span>mydata<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>注意，我这里先用 .closed 属性过滤掉已经被关闭的 Tab 窗口。这样，作为消息发送方的任务就完成了。下面看看，作为消息接收方，它需要做什么。</p>\n<p>此时，一个收到消息的页面就不能那么自私了，除了展示收到的消息，它还需要将消息再传递给它所“知道的人”（打开与被它打开的页面）:</p>\n<blockquote>\n<p>需要注意的是，我这里通过判断消息来源，避免将消息回传给发送方，防止消息在两者间死循环的传递。（该方案会有些其他小问题，实际中可以进一步优化）</p>\n</blockquote>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="84716299138583120000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`window.addEventListener(\'message\', function(e) {\n  const data = e.data;\n  const text = \'[receive] \' + data.msg + \' —— tab \' + data.from;\n  console.log(\'[Cross-document Messaging] receive message:\', text);\n  // 向上传递消息，避免消息回传\n  if (window.opener && !window.opener.closed && data.fromOpenner) {\n    window.opener.postMessage(data);\n  }\n  // 过滤掉已经关闭的窗口\n  childWins = childWins.filter((w) => !w.closed);\n  // 避免消息回传\n  if (childWins && !data.fromOpenner) {\n    // 向下传递消息\n    childWins.forEach((w) => w.postMessage(data));\n  }\n});`, `84716299138583120000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js">window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">\'message\'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> data <span class="token operator">=</span> e<span class="token punctuation">.</span>data<span class="token punctuation">;</span>\n  <span class="token keyword">const</span> text <span class="token operator">=</span> <span class="token string">\'[receive] \'</span> <span class="token operator">+</span> data<span class="token punctuation">.</span>msg <span class="token operator">+</span> <span class="token string">\' —— tab \'</span> <span class="token operator">+</span> data<span class="token punctuation">.</span>from<span class="token punctuation">;</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'[Cross-document Messaging] receive message:\'</span><span class="token punctuation">,</span> text<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token comment">// 向上传递消息，避免消息回传</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>window<span class="token punctuation">.</span>opener <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>window<span class="token punctuation">.</span>opener<span class="token punctuation">.</span>closed <span class="token operator">&amp;&amp;</span> data<span class="token punctuation">.</span>fromOpenner<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    window<span class="token punctuation">.</span>opener<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token comment">// 过滤掉已经关闭的窗口</span>\n  childWins <span class="token operator">=</span> childWins<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">w</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token operator">!</span>w<span class="token punctuation">.</span>closed<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token comment">// 避免消息回传</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>childWins <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>data<span class="token punctuation">.</span>fromOpenner<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 向下传递消息</span>\n    childWins<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">w</span><span class="token punctuation">)</span> <span class="token operator">=></span> w<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>这样，每个节点（页面）都肩负起了传递消息的责任，也就是我说的“口口相传”，而消息就在这个树状结构中流转了起来。</p>\n<h2 id="阶段性总结-3"><a href="#%E9%98%B6%E6%AE%B5%E6%80%A7%E6%80%BB%E7%BB%93-3" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>阶段性总结-3</h2>\n<p>显然，“口口相传”的模式存在一个问题：如果页面不是通过在另一个页面内的 window.open 打开的（例如直接在地址栏输入，或从其他网站链接过来），这个联系就被打破了。</p>\n<p>除了上面这六个常见方法，其实还有一种（第七种）做法是通过 WebSocket 这类的“服务器推”技术来进行同步。这好比将我们的“中央站”从前端移到了后端，比如说 Polling/COMET/SSE/WebSocket。</p>\n<h1 id="非同源页面之间的通信"><a href="#%E9%9D%9E%E5%90%8C%E6%BA%90%E9%A1%B5%E9%9D%A2%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>非同源页面之间的通信</h1>\n<p>上面我们介绍了七种前端跨页面通信的方法，但它们大都受到同源策略的限制。然而有时候，我们有两个不同域名的产品线，也希望它们下面的所有页面之间能无障碍地通信。那该怎么办呢？</p>\n<p>要实现该功能，可以使用一个用户不可见的 iframe 作为“桥”。由于 iframe 与父页面间可以通过指定 origin 来忽略同源限制，因此可以在每个页面中嵌入一个 iframe （例如：<code class="language-text">http://sample.com/bridge.html</code>），而这些 iframe 由于使用的是一个 url，因此属于同源页面，其通信方式可以复用上面第一部分提到的各种方式。</p>\n<p>页面与 iframe 通信非常简单，首先需要在页面中监听 iframe 发来的消息，做相应的业务处理：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="78514589878998350000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`/* 业务页面代码 */\nwindow.addEventListener(\'message\', function(e) {\n  // …… do something\n});`, `78514589878998350000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">/* 业务页面代码 */</span>\nwindow<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">\'message\'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// …… do something</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>然后，当页面要与其他的同源或非同源页面通信时，会先给 iframe 发送消息：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="37556594119762380000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`/* 业务页面代码 */\nwindow.frames[0].window.postMessage(mydata, \'*\');`, `37556594119762380000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">/* 业务页面代码 */</span>\nwindow<span class="token punctuation">.</span>frames<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>window<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span>mydata<span class="token punctuation">,</span> <span class="token string">\'*\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span></span></pre></div>\n<p>其中为了简便此处将 postMessage 的第二个参数设为了 *，你也可以设为 iframe 的 URL。iframe 收到消息后，会使用某种跨页面消息通信技术在所有 iframe 间同步消息，例如下面使用的 Broadcast Channel：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="51350829851296240000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`/* iframe 内代码 */\nconst bc = new BroadcastChannel(\'AlienZHOU\');\n// 收到来自页面的消息后，在 iframe 间进行广播\nwindow.addEventListener(\'message\', function(e) {\n  bc.postMessage(e.data);\n});`, `51350829851296240000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">/* iframe 内代码 */</span>\n<span class="token keyword">const</span> bc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BroadcastChannel</span><span class="token punctuation">(</span><span class="token string">\'AlienZHOU\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token comment">// 收到来自页面的消息后，在 iframe 间进行广播</span>\nwindow<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">\'message\'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  bc<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>其他 iframe 收到通知后，则会将该消息同步给所属的页面：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="70899539352584620000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`/* iframe 内代码 */\n// 对于收到的（iframe）广播消息，通知给所属的业务页面\nbc.onmessage = function(e) {\n  window.parent.postMessage(e.data, \'*\');\n};`, `70899539352584620000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">/* iframe 内代码 */</span>\n<span class="token comment">// 对于收到的（iframe）广播消息，通知给所属的业务页面</span>\nbc<span class="token punctuation">.</span><span class="token function-variable function">onmessage</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  window<span class="token punctuation">.</span>parent<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>data<span class="token punctuation">,</span> <span class="token string">\'*\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>下图就是使用 iframe 作为“桥”的非同源页面间通信模式图。</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-06-30-11-37-20-bcab03162a3d07b9021b67604ee7a0ec-d6910.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 568px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 48.767605633802816%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACCklEQVQoz2PYf+DPkqU39u7/lZRU39CwbPeeb8uW396z97uDXRADKwO3Fh+HMienOhebLAcXB+elhYteb9p8b8XKDzt26KmoMGzf+XXK1GNbtr7PzOxoaV23fuPLqTNO7tj11dU5koGFgVODm1WejU2ZnVWajYeT6+qixXeXLjk3cybQCEM1NYZDR/4vXXoXSKaltTY3r92z9++KlY+AXCfHMAZmBmZZFgYJBgZJBiYxZh4u7huLFn3euvXZqtU/d+021tBguHv3586d5x49/puZWT9hwspr19/v3Xvp/sO/9vb+vKJcLVNaq9qqu2Z0OgU6MzMwXN+16/GZM7eOHP5y9aqjhQXD69evt2zZ8ObN84KChhkzljx+fH/bto3v3n2wtfWUUZJ6++bt8SPH3756U9FYycDAcPnUybOXL+/av//lo8cO5uYMDx4+27fvwL17DzMzKiZPWXL7zr39Bw7eufvU3t5XUl781NnTu/fsPnH6ZHphBlDzid27r1y6dPTI4QdXLjtbWTEcOvxty5ZHhw5/jY4uKS+ffvDQ502bH2ze8sjOxp+Bg0HNXl3NTk3dSVNYVYSdlfXonNnv9ux5vn37s23b7ExNGQQFxfn5RQUExLi5+YCIn18MyBUUFGNn52RkYmRgZIAgRmZGFmZmEaC0gIAomOTi5GTAD5iZmCGIkZGRgboAAP0M5FJj0X+RAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 06 30 11 37 20"\n        title=""\n        src="/static/2021-06-30-11-37-20-bcab03162a3d07b9021b67604ee7a0ec-d6910.png"\n        srcset="/static/2021-06-30-11-37-20-bcab03162a3d07b9021b67604ee7a0ec-487ad.png 200w,\n/static/2021-06-30-11-37-20-bcab03162a3d07b9021b67604ee7a0ec-1cefb.png 400w,\n/static/2021-06-30-11-37-20-bcab03162a3d07b9021b67604ee7a0ec-d6910.png 568w"\n        sizes="(max-width: 568px) 100vw, 568px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>其中“同源跨域通信方案”可以使用文章第一部分提到的某种技术。</p>\n<h1 id="总结"><a href="#%E6%80%BB%E7%BB%93" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总结</h1>\n<p>对于同源页面，常见的方式包括：</p>\n<ul>\n<li>广播模式：Broadcast Channe / Service Worker / LocalStorage + StorageEvent</li>\n<li>共享存储模式：Shared Worker / IndexedDB / cookie</li>\n<li>口口相传模式：window.open + window.opener</li>\n<li>基于服务端：Websocket / Comet / SSE 等</li>\n</ul>\n<p>而对于非同源页面，则可以通过嵌入同源 iframe 作为“桥”，将非同源页面通信转换为同源页面通信。</p>',
excerpt:"背景 在浏览器中，我们可以同时打开多个 Tab 页，每个 Tab 页可以粗略理解为一个“独立”的运行环境，即使是全局对象也不会在多个 Tab 间共享。然而有些时候，我们希望能在这些“独立”的 Tab…",frontmatter:{date:"2021-06-30 11:17:28",path:"/browser-cross-page-message/",tags:"前端, 浏览器, 高级前端",title:"浏览器跨页面通信",draft:null}},prePost:{html:'<h1 id="栈空间和堆空间：数据是如何存储的"><a href="#%E6%A0%88%E7%A9%BA%E9%97%B4%E5%92%8C%E5%A0%86%E7%A9%BA%E9%97%B4%EF%BC%9A%E6%95%B0%E6%8D%AE%E6%98%AF%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E7%9A%84" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>栈空间和堆空间：数据是如何存储的</h1>\n<p>对于前端开发者来说，JavaScript 的内存机制是一个不被经常提及的概念，因此很容易被忽视。特别是一些非计算机专业的同学，对内存机制可能没有非常清晰的认识，甚至有些同学根本就不知道 JavaScript 的内存机制是什么。</p>\n<p>但是如果你想成为行业专家，并打造高性能前端应用，那么你就必须要搞清楚 JavaScript 的内存机制了。</p>\n<p>其实，要搞清楚 JavaScript 的内存机制并不是一件很困难的事，在接下来的三篇文章（数据在内存中的存放、JavaScript 处理垃圾回收以及 V8 执行代码）中，我们将通过内存机制的介绍，循序渐进带你走进 JavaScript 内存的世界。</p>\n<p>今天我们讲述第一部分的内容——JavaScript 中的数据是如何存储在内存中的。虽然 JavaScript 并不需要直接去管理内存，但是在实际项目中为了能避开一些不必要的坑，你还是需要了解数据在内存中的存储方式的</p>\n<h2 id="让人疑惑的代码"><a href="#%E8%AE%A9%E4%BA%BA%E7%96%91%E6%83%91%E7%9A%84%E4%BB%A3%E7%A0%81" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>让人疑惑的代码</h2>\n<p>首先，我们先看下面这两段代码：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="82989175208770670000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function foo() {\n  var a = 1;\n  var b = a;\n  a = 2;\n  console.log(a);\n  console.log(b);\n}\nfoo();`, `82989175208770670000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>\n  <span class="token keyword">var</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span>\n  a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="15846359569236013000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function foo() {\n  var a = { name: \'极客时间\' };\n  var b = a;\n  a.name = \'极客邦\';\n  console.log(a);\n  console.log(b);\n}\nfoo();`, `15846359569236013000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">\'极客时间\'</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>\n  <span class="token keyword">var</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span>\n  a<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">\'极客邦\'</span><span class="token punctuation">;</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>若执行上述这两段代码，你知道它们输出的结果是什么吗？下面我们就来一个一个分析下。</p>\n<p>执行第一段代码，打印出来 a 的值是 2，b 的值是 1，这没什么难以理解的。</p>\n<p>接着，再执行第二段代码，你会发现，仅仅改变了 a 中 name 的属性值，但是最终 a 和 b 打印出来的值都是 <code class="language-text">{name: &quot;极客邦&quot;}</code>。这就和我们预期的不一致了，因为我们想改变的仅仅是 a 的内容，但 b 的内容也同时被改变了。</p>\n<p>要彻底弄清楚这个问题，我们就得先从“JavaScript 是什么类型的语言”讲起。</p>\n<h2 id="javascript-是什么类型的语言"><a href="#javascript-%E6%98%AF%E4%BB%80%E4%B9%88%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%AF%AD%E8%A8%80" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>JavaScript 是什么类型的语言</h2>\n<p>每种编程语言都具有内建的数据类型，但它们的数据类型常有不同之处，使用方式也很不一样，比如 C 语言在定义变量之前，就需要确定变量的类型，你可以看下面这段 C 代码：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="64022978401538520000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`int main()\n{\n   int a = 1;\n   char* b = &quot;极客时间&quot;;\n   bool c = true;\n   return 0;\n}`, `64022978401538520000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                cpp 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="cpp"><pre style="counter-reset: linenumber NaN" class="language-cpp line-numbers"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n<span class="token punctuation">{</span>\n   <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>\n   <span class="token keyword">char</span><span class="token operator">*</span> b <span class="token operator">=</span> <span class="token string">"极客时间"</span><span class="token punctuation">;</span>\n   <span class="token keyword">bool</span> c <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n   <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>上述代码声明变量的特点是：在声明变量之前需要先定义变量类型，我们把这种在使用之前就需要确认其变量数据类型的称为静态语言。</p>\n<p>相反地，我们把在运行过程中需要检查数据类型的语言称为动态语言。比如我们所讲的 JavaScript 就是动态语言，因为在声明变量之前并不需要确认其数据类型。</p>\n<p>虽然 C 语言是静态，但是在 C 语言中，我们可以把其他类型数据赋予给一个声明好的变量，如：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="93292007379876070000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`c = a`, `93292007379876070000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">c = a</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>前面代码中，我们把 int 型的变量 a 赋值给了 bool 型的变量 c，这段代码也是可以编译执行的，因为在赋值过程中，C 编译器会把 int 型的变量悄悄转换为 bool 型的变量，我们通常把这种偷偷转换的操作称为隐式类型转换。而支持隐式类型转换的语言称为弱类型语言，不支持隐式类型转换的语言称为强类型语言。在这点上，C 和 JavaScript 都是弱类型语言。</p>\n<p>对于各种语言的类型，你可以参考下图</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-05-11-32-53-de9b1a6002d33cb8f31dff4fcf8163e4-74b93.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 85.39493293591654%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAIAAABSJhvpAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABf0lEQVQ4y5WTS04DMQyGewrWXITTIHEHlpyBK8CiIMGCRTccABZIILVIICRoKaWddh6ZPCaZ2A6ZTIXa0imtpZGi2J9/2/G0XLMhOYuOmgNaa29rIJI4YAC4I1ybBkoLcs3am2ADTpQb/MswBfMHAEiSWGjLDbIspeDaVhkRkzhmyuSGJOdEm5WDXwr+ORgopeo7UVJS9ex8FWmarIG9kxn0s8mNyzUyVWpLyjoFbiyoz6qzL14aLMCP0MmSpCWmMcDkMo0GiBnndb5ikclyyvXbcDLi+M4oK8DnVSGjh7Wt+KyGVyrJWWpL48vx+rwq24EpqKHp1u9KhJFW+fJeZ3h+OG4ffd+3BdWb5lRR+CmubNGSMgLMklTH/ejhKro7m/W7eTmPFEIswn+fqgoq2Cx/7oinC9u9lORiha55xRbgUHOZfLye7PeO90anB7mUkZqz/y5J6M8I3r3JHq/ly22sYMgRaPcfwyuFZcV6itvChOA//2DRNBpPJlLKJvgH2GDiSc51JmIAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 05 11 32 53"\n        title=""\n        src="/static/2021-07-05-11-32-53-de9b1a6002d33cb8f31dff4fcf8163e4-fee1c.png"\n        srcset="/static/2021-07-05-11-32-53-de9b1a6002d33cb8f31dff4fcf8163e4-a67b7.png 200w,\n/static/2021-07-05-11-32-53-de9b1a6002d33cb8f31dff4fcf8163e4-0b187.png 400w,\n/static/2021-07-05-11-32-53-de9b1a6002d33cb8f31dff4fcf8163e4-fee1c.png 800w,\n/static/2021-07-05-11-32-53-de9b1a6002d33cb8f31dff4fcf8163e4-b1a91.png 1200w,\n/static/2021-07-05-11-32-53-de9b1a6002d33cb8f31dff4fcf8163e4-74b93.png 1342w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<h2 id="javascript-的数据类型"><a href="#javascript-%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>JavaScript 的数据类型</h2>\n<p>现在我们知道了，JavaScript 是一种弱类型的、动态的语言。那这些特点意味着什么呢？</p>\n<ul>\n<li>弱类型，意味着你不需要告诉 JavaScript 引擎这个或那个变量是什么数据类型，JavaScript 引擎在运行代码的时候自己会计算出来。</li>\n<li>动态，意味着你可以使用同一个变量保存不同类型的数据</li>\n</ul>\n<p>那么接下来，我们再来看看 JavaScript 的数据类型，你可以看下面这段代码：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="54514291969405560000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`var bar;\nbar = 12;\nbar = \'极客时间\';\nbar = true;\nbar = null;\nbar = { name: \'极客时间\' };`, `54514291969405560000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">var</span> bar<span class="token punctuation">;</span>\nbar <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">;</span>\nbar <span class="token operator">=</span> <span class="token string">\'极客时间\'</span><span class="token punctuation">;</span>\nbar <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\nbar <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\nbar <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">\'极客时间\'</span> <span class="token punctuation">}</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>从上述代码中你可以看出，我们声明了一个 bar 变量，然后可以使用各种类型的数据值赋予给该变量。</p>\n<p>在 JavaScript 中，如果你想要查看一个变量到底是什么类型，可以使用“typeof”运算符。具体使用方式如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="32750134946004030000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`var bar;\nconsole.log(typeof bar); // undefined\nbar = 12;\nconsole.log(typeof bar); // number\nbar = \'极客时间\';\nconsole.log(typeof bar); // string\nbar = true;\nconsole.log(typeof bar); // boolean\nbar = null;\nconsole.log(typeof bar); // object\nbar = { name: \'极客时间\' };\nconsole.log(typeof bar); // object`, `32750134946004030000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">var</span> bar<span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> bar<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined</span>\nbar <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> bar<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// number</span>\nbar <span class="token operator">=</span> <span class="token string">\'极客时间\'</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> bar<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// string</span>\nbar <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> bar<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// boolean</span>\nbar <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> bar<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// object</span>\nbar <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">\'极客时间\'</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> bar<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// object</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>执行这段代码，你可以看到打印出来了不同的数据类型，有 undefined、number、boolean、object 等。那么接下来我们就来谈谈 JavaScript 到底有多少种数据类型。</p>\n<p>其实 JavaScript 中的数据类型一种有 8 种，它们分别是：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-05-11-34-28-f4de02d367abf9d7ef48b6f92606322c-ed3f4.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 55.74534161490683%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAB3UlEQVQoz0VRy24TQRD0VyMhwBEinDggEEJc4DMQ2FKSgyPFShQT2/uY9a5n57lPj3fdg2NfbHrWUZBKre7SVFd3T8/e/tiOPrWDMxi8toihi/D71Qn2+jNcvIdfL58ZfAY/X8D1l+Px2DPj783o4/ryfDV4sx6emUHfDPtw9e4EO/4Kow9w+faZgatzuOhvxt+cmCsuMmbAyFLLQqlS121t9xb21u4Atg08brC0e+hiR+5gs90cDyimnuZeqUku/HRxr9KZKeIqi06oi3jlSvKfyRemXDQ1d86FTthyuippmUUi9UQ6l8zTMtQi0CJ0kCFbznjqcYpxjkkmQ2i0E0tOOtbz52NvejOdjIh/S+OHYD5OogmjM1QqHkjuc+r6LuM/SXSfq+RJXGYLaCS+QLdMEadZznIdCeY5cWdY6KgqknWdFhofi93f6nA49DIV10VSZnEcTdAQY7KYEP+O0TlORJMHEtzhUNgokwQHRv26po2RzllworhnqtTZSsz9Ko/RFss6j3FnJHNFcGxMuhnFZs1bo7qvYoHAC1cUr4UTYm9cjKezNJliI3RGvusbtoY9grattK14OpjgsRSkKlIlcMkw14lghC49ztDNJYwGq4o3RmE8oS6ZWTnnf5oeOk1ATy/iAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 05 11 34 28"\n        title=""\n        src="/static/2021-07-05-11-34-28-f4de02d367abf9d7ef48b6f92606322c-fee1c.png"\n        srcset="/static/2021-07-05-11-34-28-f4de02d367abf9d7ef48b6f92606322c-a67b7.png 200w,\n/static/2021-07-05-11-34-28-f4de02d367abf9d7ef48b6f92606322c-0b187.png 400w,\n/static/2021-07-05-11-34-28-f4de02d367abf9d7ef48b6f92606322c-fee1c.png 800w,\n/static/2021-07-05-11-34-28-f4de02d367abf9d7ef48b6f92606322c-b1a91.png 1200w,\n/static/2021-07-05-11-34-28-f4de02d367abf9d7ef48b6f92606322c-ed3f4.png 1288w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>了解这些类型之后，还有三点需要你注意一下。</p>\n<p>第一点，使用 typeof 检测 Null 类型时，返回的是 Object。这是当初 JavaScript 语言的一个 Bug，一直保留至今，之所以一直没修改过来，主要是为了兼容老的代码。</p>\n<p>第二点，Object 类型比较特殊，它是由上述 7 种类型组成的一个包含了 key-value 对的数据类型。如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="50943526835316800000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`let myObj = {\n  name: \'极客时间\',\n  update: function() {....}\n}`, `50943526835316800000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">let</span> myObj <span class="token operator">=</span> <span class="token punctuation">{</span>\n  name<span class="token punctuation">:</span> <span class="token string">\'极客时间\'</span><span class="token punctuation">,</span>\n  <span class="token function-variable function">update</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">.</span><span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>从中你可以看出来，Object 是由 key-value 组成的，其中的 vaule 可以是任何类型，包括函数，这也就意味着你可以通过 Object 来存储函数，Object 中的函数又称为方法，比如上述代码中的 update 方法。</p>\n<p>第三点，我们把前面的 7 种数据类型称为原始类型，把最后一个对象类型称为引用类型，之所以把它们区分为两种不同的类型，是因为它们在内存中存放的位置不一样。到底怎么个不一样法呢？接下来，我们就来讲解一下 JavaScript 的原始类型和引用类型到底是怎么储存的。</p>\n<h2 id="内存空间"><a href="#%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>内存空间</h2>\n<p>要理解 JavaScript 在运行过程中数据是如何存储的，你就得先搞清楚其存储空间的种类。下面是我画的 JavaScript 的内存模型，你可以参考下：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-05-11-35-12-736885d7c0436c33374eb14a3c7c9f69-4c847.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 618px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 200.32362459546925%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAoCAIAAABxU02MAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACJUlEQVRIx+2STU8TURSG7x9yU4EiJmL4EGpFEsHowgUxLnShRlZ2aAvtFIoffBja0slQqEiNSctURQJJQWKMJq7cGP+BO5k75047xp3nTtF0ZkDI1SXJk5Nz33nfnHtuhvz8oglDjCcnhCGQPeVGaYNsGyineaPYTV3kusNJYN7vINNi0wyZJl7TTZD28WbeFp1mV7gV1HaW6+A8DbI8EqiWb7JcJ8t1saVebjg47K8Wh6rrw2ZpyHr3uLYZMguDVmUUcp3WhmRtyaCebZzvuTaitsNCh7ncZ65cwoXNwgAugpU96+dvgfdvCLc68dsLN0PKZ6R8XEmf5BV7fvQ3msme1U1Lw8s1Kg4bYYtdwhBjOiwMoXLETSJKE5F9dA+ETkTcyBKNh+h4mPfJKG8SyIjXSeh4xIE8AqmpavG5MTPJFrNmIW88ktmSAplZ/OQyO8MTURqXQJmzdiqgphC2vGDMJGtvXpp5VcfroOHA8N5wiSZHbcbogxgPYJ0c8zoJyNI+xO9DPPQbCWL20WMj3+ZmhSED5e/CkJ5VKgw5v6oLcxz+j+GeEgebwNHDvXYmUNIHX+lX1igqQY2Lh4SD9rTrG0b2c214B+5uQ/g9u7pGEx/Ne2+hu8gNf5uME66tG7EP7FYFbmwad7bh8mv68JN5ewvOHRqu53EI1oua3l/mC3cXd4+6M254QeND/rxT/Xj8h/17uE/ThSFnXuwKQ1a+/hDmF2gO/Y3zkq/GAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 05 11 35 12"\n        title=""\n        src="/static/2021-07-05-11-35-12-736885d7c0436c33374eb14a3c7c9f69-4c847.png"\n        srcset="/static/2021-07-05-11-35-12-736885d7c0436c33374eb14a3c7c9f69-9882a.png 200w,\n/static/2021-07-05-11-35-12-736885d7c0436c33374eb14a3c7c9f69-ecdcc.png 400w,\n/static/2021-07-05-11-35-12-736885d7c0436c33374eb14a3c7c9f69-4c847.png 618w"\n        sizes="(max-width: 618px) 100vw, 618px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从图中可以看出， 在 JavaScript 的执行过程中， 主要有三种类型内存空间，分别是代码空间、栈空间和堆空间。</p>\n<p>其中的代码空间主要是存储可执行代码的，这个我们后面再做介绍，今天主要来说说栈空间和堆空间。</p>\n<h2 id="栈空间和堆空间"><a href="#%E6%A0%88%E7%A9%BA%E9%97%B4%E5%92%8C%E5%A0%86%E7%A9%BA%E9%97%B4" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>栈空间和堆空间</h2>\n<p>这里的栈空间就是我们之前反复提及的调用栈，是用来存储执行上下文的。为了搞清楚栈空间是如何存储数据的，我们还是先看下面这段代码：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="97183158737899030000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function foo() {\n  var a = \'极客时间\';\n  var b = a;\n  var c = { name: \'极客时间\' };\n  var d = c;\n}\nfoo();`, `97183158737899030000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token string">\'极客时间\'</span><span class="token punctuation">;</span>\n  <span class="token keyword">var</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span>\n  <span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">\'极客时间\'</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>\n  <span class="token keyword">var</span> d <span class="token operator">=</span> c<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>前面文章我们已经讲解过了，当执行一段代码时，需要先编译，并创建执行上下文，然后再按照顺序执行代码。那么下面我们来看看，当执行到第 3 行代码时，其调用栈的状态，你可以参考下面这张调用栈状态图：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-05-13-36-42-768172f068757544caf5d7cdc266d812-b1a91.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 84.83333333333333%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAIAAABSJhvpAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACr0lEQVQ4y3WTW08TURDH+RDGd76CoA2Y+EVMjN/ERCJECliIDwoSHtpK0RcIGB6kINcWuYQWkLLbG91Lt3vfs/funnM8LVVbgpPJyZyz88vM/jPTh3sNQhgEYRCGrfP/AUKIJPd1k81mU9c05NnQs6BrQc9GvgOJt4LOI/Ks0LV0XSd8Dxz4nqAYm1Vnq2ITTxeN7wVpg1LTtJ6mtXTZSlfsjbKVZR3DAKTHvt6mm+esHklIkYQcScpPFrjB2eLAbGlwrjrwqTqcEJ+l1Edx9eU3xQRGB0Zta8Fh84pT32Wkz5dm/BzMHUkzu8z8qRq/sBLnYCqjvNpgP+zdjG5xim6iv3CnchhQjFjiOWzxvs5iVw5VxpdvoMFjDCiGOaAbGDvLeYFTAEZtmOgEAAghxDAs1OqFmqAqEl8XgiDwPKdcLlE05TvmRZndLcokf+WXxslGB2ZZNp/Pi5JE7gSmOZEErutBhIHt0BWmdMPbjltgxA58qbCy3oLJf5Oytm2TE8PguiYUmEbY9E03cJkT5UeMWhun1qLGzvTZ9pedskHg5Uv1X+UutcPrWr1YFzH0fYTDw/fm6IPqSH/ldb/39uHF/Iu9mkeyVq9UlsC4S210KxgrrZ/SZ3TliOaO9tcPlka2Fsc2F8d+fh1ZWY4v5eQCrydPxYYK7laGgV+TjIkDZXxfju5L0awxceJPttyLHvtTx04sI7/ZbiRzmgnuG5Ico0WSynBKG07pQwlx8CNF5uTxfDWywAwl5acpbSCpPV9VgGHchYlOFUGNHarTHVdiGanlWXk6q5CXmUN1MqMkchqZ7bsw2Rhg6Ngze93CvnUbIxdgF4QOME3z7lbdGlGOrFxAhoYIDlEAUTOEQTtA7a9/5vE+mPSjqirHcaQ3WZYFQSBxvV7ned73/e7M336AjgEMvgWjAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 05 13 36 42"\n        title=""\n        src="/static/2021-07-05-13-36-42-768172f068757544caf5d7cdc266d812-fee1c.png"\n        srcset="/static/2021-07-05-13-36-42-768172f068757544caf5d7cdc266d812-a67b7.png 200w,\n/static/2021-07-05-13-36-42-768172f068757544caf5d7cdc266d812-0b187.png 400w,\n/static/2021-07-05-13-36-42-768172f068757544caf5d7cdc266d812-fee1c.png 800w,\n/static/2021-07-05-13-36-42-768172f068757544caf5d7cdc266d812-b1a91.png 1200w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从图中可以看出来，当执行到第 3 行时，变量 a 和变量 b 的值都被保存在执行上下文中，而执行上下文又被压入到栈中，所以你也可以认为变量 a 和变量 b 的值都是存放在栈中的。</p>\n<p>接下来继续执行第 4 行代码，由于 JavaScript 引擎判断右边的值是一个引用类型，这时候处理的情况就不一样了，JavaScript 引擎并不是直接将该对象存放到变量环境中，而是将它分配到堆空间里面，分配后该对象会有一个在“堆”中的地址，然后再将该数据的地址写进 c 的变量值，最终分配好内存的示意图如下所示：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-05-13-36-59-da3fe5fbe645301d7ca272c4a9b64128-f0bde.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 56.77154582763338%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAB10lEQVQoz3WRz2vUQBTH93/x5J8gPQpeehIUvIiCRy8WFLx6Ubx4FxHcuqUt2GqR/hDRthd/dLut3U3bFFu3uj+SSTPJTJLJJjOZN04SSN2DXx7D8GY+3zfvTQ0AMpEqxYsQeUC+FyIFUKVAchBJvmY6UgVZma8pJTsD2jDYTNt/3bIbu+6cQettalo0xwoDtv6ENq6R+mTQuEpeXo536qWlhtVW110ynNUDZ6mNPh0H07v4xXf7yy9PH0mQeg03p7z5S+G3Z/HeTNR8nvS3Cxhy+HSIWOCrLGLoJBqa3eHQIrE58IvCeeVw56G3MZmEP/VzBcRC8urZ6qRnManE0XLv6cXe4wvG4qM+kQe/HZUwcYYkS4PmA+/jFYaaceRE5JQn9Bw+/GN3BsT8sdmcvrf96u7nD7Nf+4nOKD7KiC+TLGjd99YmIqcVUJvgLk+DCoYV07vxzrm9jG++x7dWgjtr9PpbZ/3Yr3qmW1N4dWJ01hKc8tgag/cHdL5DFvf9BQO/6eAFw5tr+0cWqabNvb3U3hAjLPhIcCazf3quPjP2kSpKlVilMiOEcF0sJVRIrbin9BgTLmgYpiLTe6nGpR1BgrbnvPIaq3x+E8B1XYSQV4hSqv6jv4osWckfUujXAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 05 13 36 59"\n        title=""\n        src="/static/2021-07-05-13-36-59-da3fe5fbe645301d7ca272c4a9b64128-fee1c.png"\n        srcset="/static/2021-07-05-13-36-59-da3fe5fbe645301d7ca272c4a9b64128-a67b7.png 200w,\n/static/2021-07-05-13-36-59-da3fe5fbe645301d7ca272c4a9b64128-0b187.png 400w,\n/static/2021-07-05-13-36-59-da3fe5fbe645301d7ca272c4a9b64128-fee1c.png 800w,\n/static/2021-07-05-13-36-59-da3fe5fbe645301d7ca272c4a9b64128-b1a91.png 1200w,\n/static/2021-07-05-13-36-59-da3fe5fbe645301d7ca272c4a9b64128-f0bde.png 1462w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从上图你可以清晰地观察到，对象类型是存放在堆空间的，在栈空间中只是保留了对象的引用地址，当 JavaScript 需要访问该数据的时候，是通过栈中的引用地址来访问的，相当于多了一道转手流程。</p>\n<p>好了，现在你应该知道了原始类型的数据值都是直接保存在“栈”中的，引用类型的值是存放在“堆”中的。不过你也许会好奇，为什么一定要分“堆”和“栈”两个存储空间呢？所有数据直接存放在“栈”中不就可以了吗？</p>\n<p>答案是不可以的。这是因为 JavaScript 引擎需要用栈来维护程序执行期间上下文的状态，如果栈空间大了话，所有的数据都存放在栈空间里面，那么会影响到上下文切换的效率，进而又影响到整个程序的执行效率。比如文中的 foo 函数执行结束了，JavaScript 引擎需要离开当前的执行上下文，只需要将指针下移到上个执行上下文的地址就可以了，foo 函数执行上下文栈区空间全部回收，具体过程你可以参考下图：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-05-13-37-18-08fb519b5e63747634c74613b337bd19-6b9f0.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 60.83086053412463%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABs0lEQVQoz6VSzW4TMRDOQ3HhEXgbJJ4FceAAZ1Cgl003ahSgIMgKRQ3bZFvRHBAUsl571hvba3u9/sFNhUihnPhkjzQafzPjmW8Q/gODfwWMMXmez+fzxWIRrZSSNs0sy6oKex+sdddk742JXqe1MqazVps+2vh0nKaj0Wg8HidJgjF2WqLLL70SwRmjpbNuEGm23HhcSSCmoYpgBcQ2FMry1esrTKfTyWRSA1lTe4LMEuxJZYtKOWsHsfDVCUFxBkfp1xfPIU3KgyE9P5NdB4QQSrlUwXYPjqq7T7/de1bdeXJ5//B7bHn35x1ZCsGKFV+dimLF8gX7EcOh73sDJGwb37LDM/rwA378ET/KICkgePd7YHEkojOUt1RIZR0Trd8lda3wnBvB+/NlP3ujs2OfvTWfC+v3pi3alm7ZlrdSdYwLGqvtyNfona/fHVcHwzodVS+HMHvvwk0yqjDUTbwIA9T1/uasc/X6ApZ5Xazg9BNZXzjvb+y5lbJEaLPZEADn3B+b18ZA0yBCMG1apW4RSdSG1nq/4X3EjL0x/lfe2xXGGEMIAUDUBuc8upTSv3v5CZczorFUmDZ+AAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 05 13 37 18"\n        title=""\n        src="/static/2021-07-05-13-37-18-08fb519b5e63747634c74613b337bd19-fee1c.png"\n        srcset="/static/2021-07-05-13-37-18-08fb519b5e63747634c74613b337bd19-a67b7.png 200w,\n/static/2021-07-05-13-37-18-08fb519b5e63747634c74613b337bd19-0b187.png 400w,\n/static/2021-07-05-13-37-18-08fb519b5e63747634c74613b337bd19-fee1c.png 800w,\n/static/2021-07-05-13-37-18-08fb519b5e63747634c74613b337bd19-b1a91.png 1200w,\n/static/2021-07-05-13-37-18-08fb519b5e63747634c74613b337bd19-6b9f0.png 1348w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>所以通常情况下，栈空间都不会设置太大，主要用来存放一些原始类型的小数据。而引用类型的数据占用的空间都比较大，所以这一类数据会被存放到堆中，堆空间很大，能存放很多大的数据，不过缺点是分配内存和回收内存都会占用一定的时间。</p>\n<p>解释了程序在执行过程中为什么需要堆和栈两种数据结构后，我们还是回到示例代码那里，看看它最后一步将变量 c 赋值给变量 d 是怎么执行的？</p>\n<p>在 JavaScript 中，赋值操作和其他语言有很大的不同，原始类型的赋值会完整复制变量值，而引用类型的赋值是复制引用地址。</p>\n<p>所以 <code class="language-text">d=c</code> 的操作就是把 c 的引用地址赋值给 d，你可以参考下图</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-05-13-37-35-27cda4d94677a23c74bbb5ba13eb9ec1-22802.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 59.25925925925925%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAB+klEQVQoz32Sz2sTQRzF+5/4H3gRxHoUpWervfagIoLgHyBeLBRBL15q6UE8CqI2mphoi1YkSQstoWotSZM0jXE3s9nZmZ2dnZmd7I9xNtm2KtLHO8wM38/Mg3kTSqlEK45TJ4fOtok6URN6gnGOfYGowJQjjyHKCQu0hRBHc8ODalAvyt23sl6QO6+HB5UU1g/XgTdfcefL+N5Kb+6zNffFubvmPChD4LI01igafTWLF8/gpfPk2SW8eJbm72Rws48MAAaDgWV2f3UahtHbbIGvXdSxiFJpeM2T9dvO+4u8Xw2oKdyW9PvJCFYtE1LqBWTgvZjtL031nl7e+7H9c8A7PUsJFvtUm1RvoY9TAdqOIh5KOJREX5nCTdPmQoTUhguT7funuo9O7+3UuijcN6CKZCxlzBgpX0erF3xr0yMA2e2Awyx2G+BKE2w0umu5Jx+eP1x9+bhQa3/a9w3kp38xsrt+0ylNMrvGmcNITwong78Z3kwOXl2G08voyhs8k/enc+hGCfbxIZwot3INFs9xe2soXclNDY9jJ4bjvau72qUGLjZwYRfm63il6WLKjr4qxN+lvRFKN4pkFIo4Go5fPhbHlmTkz5N/ehJFsW3DMAyzkoyDRYkK48Tzmc+FXo/9l5JYpeVLdHN0BY/h/0rPWZYFADihpL8B15yM3HlDkKoAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 05 13 37 35"\n        title=""\n        src="/static/2021-07-05-13-37-35-27cda4d94677a23c74bbb5ba13eb9ec1-fee1c.png"\n        srcset="/static/2021-07-05-13-37-35-27cda4d94677a23c74bbb5ba13eb9ec1-a67b7.png 200w,\n/static/2021-07-05-13-37-35-27cda4d94677a23c74bbb5ba13eb9ec1-0b187.png 400w,\n/static/2021-07-05-13-37-35-27cda4d94677a23c74bbb5ba13eb9ec1-fee1c.png 800w,\n/static/2021-07-05-13-37-35-27cda4d94677a23c74bbb5ba13eb9ec1-b1a91.png 1200w,\n/static/2021-07-05-13-37-35-27cda4d94677a23c74bbb5ba13eb9ec1-22802.png 1404w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从图中你可以看到，变量 c 和变量 d 都指向了同一个堆中的对象，所以这就很好地解释了文章开头的那个问题，通过 c 修改 name 的值，变量 d 的值也跟着改变，归根结底它们是同一个对象。</p>\n<h2 id="再谈闭包"><a href="#%E5%86%8D%E8%B0%88%E9%97%AD%E5%8C%85" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>再谈闭包</h2>\n<p>现在你知道了作用域内的原始类型数据会被存储到栈空间，引用类型会被存储到堆空间，基于这两点的认知，我们再深入一步，探讨下闭包的内存模型。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="40410138012239450000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function foo() {\n  var myName = \'极客时间\';\n  let test1 = 1;\n  const test2 = 2;\n  var innerBar = {\n    setName: function(newName) {\n      myName = newName;\n    },\n    getName: function() {\n      console.log(test1);\n      return myName;\n    }\n  };\n  return innerBar;\n}\nvar bar = foo();\nbar.setName(\'极客邦\');\nbar.getName();\nconsole.log(bar.getName());`, `40410138012239450000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">var</span> myName <span class="token operator">=</span> <span class="token string">\'极客时间\'</span><span class="token punctuation">;</span>\n  <span class="token keyword">let</span> test1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>\n  <span class="token keyword">const</span> test2 <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>\n  <span class="token keyword">var</span> innerBar <span class="token operator">=</span> <span class="token punctuation">{</span>\n    <span class="token function-variable function">setName</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">newName</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      myName <span class="token operator">=</span> newName<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n    <span class="token function-variable function">getName</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>test1<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token keyword">return</span> myName<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span><span class="token punctuation">;</span>\n  <span class="token keyword">return</span> innerBar<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">var</span> bar <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nbar<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">\'极客邦\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nbar<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>bar<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>当执行这段代码的时候，你应该有过这样的分析：由于变量 myName、test1、test2 都是原始类型数据，所以在执行 foo 函数的时候，它们会被压入到调用栈中；当 foo 函数执行结束之后，调用栈中 foo 函数的执行上下文会被销毁，其内部变量 myName、test1、test2 也应该一同被销毁。</p>\n<p>要解释这个现象，我们就得站在内存模型的角度来分析这段代码的执行流程。</p>\n<ul>\n<li>当 JavaScript 引擎执行到 foo 函数时，首先会编译，并创建一个空执行上下文。</li>\n<li>在编译过程中，遇到内部函数 setName，JavaScript 引擎还要对内部函数做一次快速的词法扫描，发现该内部函数引用了 foo</li>\n<li>函数中的 myName 变量，由于是内部函数引用了外部函数的变量，所以 JavaScript 引擎判断这是一个闭包，于是在堆空间创建换一个“closure(foo)”的对象（这是一个内部对象，JavaScript 是无法访问的），用来保存 myName 变量。</li>\n<li>接着继续扫描到 getName 方法时，发现该函数内部还引用变量 test1，于是 JavaScript 引擎又将 test1 添加到“closure(foo)”对象中。这时候堆中的“closure(foo)”对象中就包含了 myName 和 test1 两个变量了。</li>\n<li>由于 test2 并没有被内部函数引用，所以 test2 依然保存在调用栈中</li>\n</ul>\n<p>通过上面的分析，我们可以画出执行到 foo 函数中 <code class="language-text">return innerBar</code> 语句时的调用栈状态，如下图所示：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-05-13-39-10-f46ac0461abfac3011858d9136484ef6-9131e.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 61.18980169971672%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAB+ElEQVQoz32Sz2/TMBTHe+bf4MiFExcQCHGaBIed+Ce4cAahIQ6cuCEktlUIGIKJCiqGaMcvqRMcWDXYQKUtrGyjaeK2Tu3EyXMSxzF2skogjT09P8n2+/g9631LSqnMmFTalfbMxHxrDg+1kl5xFI28sE/AJmC5TLtDwaaceEw/bFypxNqA9UVoLvLmPF+/yz/fl3FgYAAob7g3PtK5N/1rtd7NhnPl3fDyKnrbdfWtTFMdw0+33TvHJuUz9NEsfXiBPrmYBmMDEwY79jjycOARFgAH/vU33kb0yy42sMzh7QfuqxNBbylJghicmGMphYEnfriHXIAQwsBfu8VeXNr8UB2EaqtfVE4M/OOeWzvJNCwgClEE4ynM+I5lAxkF2PLmT/tzRzYr1wdMbf20lIhT5qlUhd8X3JfHcWsBu4iMez6xMpkaOORRo4vqLft1a1B/X1+tLVfWms/bRdu6a5FXLuPqUdopA/fi0IlhtF85ieBqg5x7Ss9X8MwzOlOF2RU4u4xXOlTfpvmfobc0qZ8Kfj1OU0g4ivm07SRJdsd+B7G2Tb/tjboO7SK/jdiQMJXP3UQRCEBSBHEcCRHrfrQ2Sn8PHZiH0UD9RxtZPnCEhoyxYrsPZ4WyCq3lWXpJmcncioNpE/8q7EDTf8EYe55HCBFCHJjzB95/kOu7c+UVAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 05 13 39 10"\n        title=""\n        src="/static/2021-07-05-13-39-10-f46ac0461abfac3011858d9136484ef6-fee1c.png"\n        srcset="/static/2021-07-05-13-39-10-f46ac0461abfac3011858d9136484ef6-a67b7.png 200w,\n/static/2021-07-05-13-39-10-f46ac0461abfac3011858d9136484ef6-0b187.png 400w,\n/static/2021-07-05-13-39-10-f46ac0461abfac3011858d9136484ef6-fee1c.png 800w,\n/static/2021-07-05-13-39-10-f46ac0461abfac3011858d9136484ef6-b1a91.png 1200w,\n/static/2021-07-05-13-39-10-f46ac0461abfac3011858d9136484ef6-9131e.png 1412w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从上图你可以清晰地看出，当执行到 foo 函数时，闭包就产生了；当 foo 函数执行结束之后，返回的 getName 和 setName 方法都引用 <code class="language-text">clourse(foo)</code> 对象，所以即使 foo 函数退出了，<code class="language-text">clourse(foo)</code> 依然被其内部的 getName 和 setName 方法引用。所以在下次调用 bar.setName 或者 bar.getName 时，创建的执行上下文中就包含了 <code class="language-text">clourse(foo)</code>。</p>\n<p>总的来说，产生闭包的核心有两步：第一步是需要预扫描内部函数；第二步是把内部函数引用的外部变量保存到堆中。</p>\n<h2 id="总结"><a href="#%E6%80%BB%E7%BB%93" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总结</h2>\n<p>好了，今天就讲到这里，下面我来简单总结下今天的要点。</p>\n<p>我们介绍了 JavaScript 中的 8 种数据类型，它们可以分为两大类——原始类型和引用类型。</p>\n<p>其中，原始类型的数据是存放在栈中，引用类型的数据是存放在堆中的。堆中的数据是通过引用和变量关联起来的。也就是说，JavaScript 的变量是没有数据类型的，值才有数据类型，变量可以随时持有任何类型的数据。</p>\n<p>然后我们分析了，在 JavaScript 中将一个原始类型的变量 a 赋值给 b，那么 a 和 b 会相互独立、互不影响；但是将引用类型的变量 a 赋值给变量 b，那会导致 a、b 两个变量都同时指向了堆中的同一块数据。</p>\n<p>最后，我们还站在内存模型的视角分析了闭包的产生过程。</p>\n<h2 id="思考时间"><a href="#%E6%80%9D%E8%80%83%E6%97%B6%E9%97%B4" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>思考时间</h2>\n<p>在实际的项目中，经常需要完整地拷贝一个对象，也就是说拷贝完成之后两个对象之间就不能互相影响。那该如何实现呢？</p>\n<p>结合下面这段代码，你可以分析下它是如何将对象 jack 拷贝给 jack2，然后在完成拷贝操作时两个 jack 还互不影响的呢。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="82707112011065080000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`let jack = {\n  name: \'jack.ma\',\n  age: 40,\n  like: {\n    dog: {\n      color: \'black\',\n      age: 3\n    },\n    cat: {\n      color: \'white\',\n      age: 2\n    }\n  }\n};\nfunction copy(src) {\n  let dest;\n  // 实现拷贝代码，将 src 的值完整地拷贝给 dest\n  // 在这里实现\n  return dest;\n}\nlet jack2 = copy(jack);\n\n// 比如修改 jack2 中的内容，不会影响到 jack 中的值\njack2.like.dog.color = \'green\';\nconsole.log(jack.like.dog.color); // 打印出来的应该是 &quot;black&quot;`, `82707112011065080000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">let</span> jack <span class="token operator">=</span> <span class="token punctuation">{</span>\n  name<span class="token punctuation">:</span> <span class="token string">\'jack.ma\'</span><span class="token punctuation">,</span>\n  age<span class="token punctuation">:</span> <span class="token number">40</span><span class="token punctuation">,</span>\n  like<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n    dog<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n      color<span class="token punctuation">:</span> <span class="token string">\'black\'</span><span class="token punctuation">,</span>\n      age<span class="token punctuation">:</span> <span class="token number">3</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n    cat<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n      color<span class="token punctuation">:</span> <span class="token string">\'white\'</span><span class="token punctuation">,</span>\n      age<span class="token punctuation">:</span> <span class="token number">2</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token keyword">function</span> <span class="token function">copy</span><span class="token punctuation">(</span><span class="token parameter">src</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">let</span> dest<span class="token punctuation">;</span>\n  <span class="token comment">// 实现拷贝代码，将 src 的值完整地拷贝给 dest</span>\n  <span class="token comment">// 在这里实现</span>\n  <span class="token keyword">return</span> dest<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">let</span> jack2 <span class="token operator">=</span> <span class="token function">copy</span><span class="token punctuation">(</span>jack<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token comment">// 比如修改 jack2 中的内容，不会影响到 jack 中的值</span>\njack2<span class="token punctuation">.</span>like<span class="token punctuation">.</span>dog<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token string">\'green\'</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>jack<span class="token punctuation">.</span>like<span class="token punctuation">.</span>dog<span class="token punctuation">.</span>color<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 打印出来的应该是 "black"</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>关于 foo 函数执行上下文销毁过程：foo 函数执行结束之后，当前执行状态的指针下移到栈中的全局执行上下文的位置，foo 函数的执行上下文的那块数据就挪出来，这也就是 foo 函数执行上下文的销毁过程，这个文中有提到，你可以参考“调用栈中切换执行上下文状态“图。</p>\n<p>第二个问题：innerBar 返回后，含有 setName 和 getName 对象，这两个对象里面包含了堆中的 closure(foo) 的引用。虽然 foo 执行上下文销毁了，foo 函数中的对 closure(foo) 的引用也断开了，但是 setName 和 getName 里面又重新建立起来了对 closure(foo) 引用。</p>\n<p>你可以：</p>\n<ul>\n<li>打开开发者工具</li>\n<li>在控制台执行上述代码</li>\n<li>然后选择 Memory 标签，点击 take snapshot 获取 V8 的堆内存快照。</li>\n<li>然后 <code class="language-text">command+f(mac)</code> 或者 <code class="language-text">ctrl+f(win)</code>，搜索 setName，然后你就会发现 setName 对象下面包含了 raw<em>outer</em>scope<em>info</em>or<em>feedback</em>metadata，对闭包的引用数据就在这里面。</li>\n</ul>\n<h1 id="垃圾回收：垃圾数据如何自动回收"><a href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%9A%E5%9E%83%E5%9C%BE%E6%95%B0%E6%8D%AE%E5%A6%82%E4%BD%95%E8%87%AA%E5%8A%A8%E5%9B%9E%E6%94%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>垃圾回收：垃圾数据如何自动回收</h1>\n<p>有些数据被使用之后，可能就不再需要了，我们把这种数据称为垃圾数据。如果这些垃圾数据一直保存在内存中，那么内存会越用越多，所以我们需要对这些垃圾数据进行回收，以释放有限的内存空间</p>\n<h2 id="不同语言的垃圾回收策略"><a href="#%E4%B8%8D%E5%90%8C%E8%AF%AD%E8%A8%80%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>不同语言的垃圾回收策略</h2>\n<p>通常情况下，垃圾数据回收分为手动回收和自动回收两种策略。</p>\n<p>如 C/C++ 就是使用手动回收策略，何时分配内存、何时销毁内存都是由代码控制的，你可以参考下面这段 C 代码：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="11162347571627106000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// 在堆中分配内存\n// 在堆空间中分配 2048 字节的空间，并将分配后的引用地址保存到 p 中\nchar* p = (char*)malloc(2048);\n\n// 使用 p 指向的内存\n{\n  //....\n}\n\n// 使用结束后，销毁这段内存\nfree(p)；\np = NULL；`, `11162347571627106000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                cpp 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="cpp"><pre style="counter-reset: linenumber NaN" class="language-cpp line-numbers"><code class="language-cpp"><span class="token comment">// 在堆中分配内存</span>\n<span class="token comment">// 在堆空间中分配 2048 字节的空间，并将分配后的引用地址保存到 p 中</span>\n<span class="token keyword">char</span><span class="token operator">*</span> p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">2048</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token comment">// 使用 p 指向的内存</span>\n<span class="token punctuation">{</span>\n  <span class="token comment">//....</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// 使用结束后，销毁这段内存</span>\n<span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span>；\np <span class="token operator">=</span> <span class="token constant">NULL</span>；</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>从上面这段 C 代码可以看出来，要使用堆中的一块空间，我们需要先调用 mallco 函数分配内存，然后再使用；当不再需要这块数据的时候，就要手动调用 free 函数来释放内存。如果这段数据已经不再需要了，但是又没有主动调用 free 函数来销毁，那么这种情况就被称为内存泄漏。</p>\n<p>另外一种使用的是自动垃圾回收的策略，如 JavaScript、Java、Python 等语言，产生的垃圾数据是由垃圾回收器来释放的，并不需要手动通过代码来释放。</p>\n<p>对于 JavaScript 而言，也正是这个“自动”释放资源的特性带来了很多困惑，也让一些 JavaScript 开发者误以为可以不关心内存管理，这是一个很大的误解。</p>\n<p>那么在本文，我们将围绕“JavaScript 的数据是如何回收的”这个话题来展开探讨。因为数据是存储在栈和堆两种内存空间中的，所以接下来我们就来分别介绍“栈中的垃圾数据”和“堆中的垃圾数据”是如何回收的。</p>\n<h2 id="调用栈中的数据是如何回收的"><a href="#%E8%B0%83%E7%94%A8%E6%A0%88%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%98%AF%E5%A6%82%E4%BD%95%E5%9B%9E%E6%94%B6%E7%9A%84" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>调用栈中的数据是如何回收的</h2>\n<p>首先是调用栈中的数据，我们还是通过一段示例代码的执行流程来分析其回收机制，具体如下：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="15842334915695133000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function foo() {\n  var a = 1;\n  var b = { name: \'极客邦\' };\n  function showName() {\n    var c = 1;\n    var d = { name: \'极客时间\' };\n  }\n  showName();\n}\nfoo();`, `15842334915695133000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>\n  <span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">\'极客邦\'</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>\n  <span class="token keyword">function</span> <span class="token function">showName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>\n    <span class="token keyword">var</span> d <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">\'极客时间\'</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token function">showName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>当执行到第 6 行代码时，其调用栈和堆空间状态图如下所示：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-05-14-13-12-61833b6271a6466b1560d09e3c39099e-205ae.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 68.10810810810811%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAIAAACgpqunAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACdElEQVQoz22S30/TUBTH9/f4H/igD+qLr775YOIf4JsJia8+KLQlG6BPBAMDUdFIOn5FQjAKDBljQOlWmNbZru3W9de9XbvSn9euq2YYvzk5ybn3fs45956b8T0Podj8IfOiyA3DACWKPDswuMDgE9+3yHcGWxkFWO8YO3+s5Q+lvpVbixR4S5uaacdgfMJlt+CrO8bMbTBzC87eBdM3ffEoyRpmOKU7d9R5U2nPVrSFU/i6epktKrldqaFaA9gTt2Dhenf/sScdesKeJ+yGjjHoKSNpsAvUyAGIXux9HrX2pjiW4TWLb2kocOMjsLlTL9xji4TQagrCj6bAOo6dti1qkPrV/i606aWRs5kH5emHX0vlA84SFICSa5/TZy+nci+mJggcJwh8nCCaPN+vG0WZNrCzJYAV9edf5NGdDlY0sG8Q31NlmKY/v6hjeDabnSTG+yIIguO4FOYUc7Xa2a4r6zV1sw4+sc5cRc2X2w2lO4B1fr+ydJ/awhiGYqrlGl22ujC9s6BCoCuBraODHFx+BNZGGvVTXnN4SUVhPEIUyNv2xjW39jR+eBTqKAIo8v+MyjAvBOWn1LlYx5j3I2dLT0oUfdS0JM1EXn+etrTTJG9IpWe61tKVhqY0XLeXwmynO0+Z+VOQr17ma/7CeThfc5YZ2Lt0kd+vzFAnk9mxidw4jmNjY6Ox5/8+GCvD5ZpRYMCHY/HjSYuk1TjcrOs9J/1GoiiShdW19Q2SLJAkubKyoihKCscu+Qwh6Eg9M51+shWhqzIMAwAwvJJJ0Qj5QRQE4b/EkMJEV+DhwPd9TdNM04QQxl6WZV3X4ybjmv9N9xvm9+Bj8RurGwAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 05 14 13 12"\n        title=""\n        src="/static/2021-07-05-14-13-12-61833b6271a6466b1560d09e3c39099e-fee1c.png"\n        srcset="/static/2021-07-05-14-13-12-61833b6271a6466b1560d09e3c39099e-a67b7.png 200w,\n/static/2021-07-05-14-13-12-61833b6271a6466b1560d09e3c39099e-0b187.png 400w,\n/static/2021-07-05-14-13-12-61833b6271a6466b1560d09e3c39099e-fee1c.png 800w,\n/static/2021-07-05-14-13-12-61833b6271a6466b1560d09e3c39099e-b1a91.png 1200w,\n/static/2021-07-05-14-13-12-61833b6271a6466b1560d09e3c39099e-205ae.png 1480w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从图中可以看出，原始类型的数据被分配到栈中，引用类型的数据会被分配到堆中。当 foo 函数执行结束之后，foo 函数的执行上下文会从堆中被销毁掉，那么它是怎么被销毁的呢？下面我们就来分析一下。</p>\n<p>在上篇文章中，我们简单介绍过了，如果执行到 showName 函数时，那么 JavaScript 引擎会创建 showName 函数的执行上下文，并将 showName 函数的执行上下文压入到调用栈中，最终执行到 showName 函数时，其调用栈就如上图所示。与此同时，还有一个记录当前执行状态的指针（称为 ESP），指向调用栈中 showName 函数的执行上下文，表示当前正在执行 showName 函数。</p>\n<p>接着，当 showName 函数执行完成之后，函数执行流程就进入了 foo 函数，那这时就需要销毁 showName 函数的执行上下文了。ESP 这时候就帮上忙了，JavaScript 会将 ESP 下移到 foo 函数的执行上下文，这个下移操作就是销毁 showName 函数执行上下文的过程。</p>\n<p>你可能会有点懵，ESP 指针向下移动怎么就能把 showName 的执行上下文销毁了呢？具体你可以看下面这张移动 ESP 前后的对比图</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-05-14-13-27-61a4d68f73d41fb85c9268ac972f1816-5e571.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 62.41426611796982%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACVElEQVQoz2VSXU/TUBjez/M/kGjif/DGG29MMGJClGgwMAfsAgVUSGAwUAYRHHV0Wx377ifQbe3Wdm3P+nFOe46nQ8OFT56Lkzzv836eFCEkooAhQSGJEYkgiUJKjMI4jqmKKZIHJiT+x4hgRIUUjjHxwTFvv2Ls+bPB/Ln+hjFf/jQ+162ba6XVaiuKLCmD/e9chtUzpf4qq69WzHVuZE+CFEEImkaN719KQ05UK2252O0dNrVTwSqz5cLRUaN82RL7Fye/8m0j1xgdi+5aefipMlBML0UbCyBUtaE/AbC4YGceXK/NKDdSZxTygigJwqDXk3TL8wGRC+7GI/fjDM+dyk4sDt0UToYOz8TxYmn0oVBe3vu2dPBjkdF32w6CkIp0EYI6Omybh6Vqbiezt53eKTXzPDCcaWW6mxPRWamY2RrINqNsFy8wxgY3DCHCQUA8wAr6XNGcK45fMOHrGnl2Np4t3PZtPzH7IexpOnRN3PoS5J5oB88V9bapezbwk8JxLGiW7xhEb0yYtMcsd7pXshWKQ5CYaXuKbvE64Iubna9Pue1ZTlKvBr7nB0lfcSxrRrdvidWj+srjq/TDC+a0qsFbc2oOg2C3Zb9jraWK+77qp+voLeucSza9ebIRHP3ugfW6s9UEmy1/qwM32sFBx0YwTMwRQl0dlBSTlUclQaM3q6jOjQFwHJFp6fbAznesfEPbr6n5ej9X14uSGSGYmO+AoU+QHwUeJfkf9Eshj0CPhJPYc8g0718zxvdhEMLx2HZd15sCADCZeHfz36eaxv8BsrB/8eJEn6AAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 05 14 13 27"\n        title=""\n        src="/static/2021-07-05-14-13-27-61a4d68f73d41fb85c9268ac972f1816-fee1c.png"\n        srcset="/static/2021-07-05-14-13-27-61a4d68f73d41fb85c9268ac972f1816-a67b7.png 200w,\n/static/2021-07-05-14-13-27-61a4d68f73d41fb85c9268ac972f1816-0b187.png 400w,\n/static/2021-07-05-14-13-27-61a4d68f73d41fb85c9268ac972f1816-fee1c.png 800w,\n/static/2021-07-05-14-13-27-61a4d68f73d41fb85c9268ac972f1816-b1a91.png 1200w,\n/static/2021-07-05-14-13-27-61a4d68f73d41fb85c9268ac972f1816-5e571.png 1458w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从图中可以看出，当 showName 函数执行结束之后，ESP 向下移动到 foo 函数的执行上下文中，上面 showName 的执行上下文虽然保存在栈内存中，但是已经是无效内存了。比如当 foo 函数再次调用另外一个函数时，这块内容会被直接覆盖掉，用来存放另外一个函数的执行上下文。</p>\n<p>所以说，当一个函数执行结束之后，JavaScript 引擎会通过向下移动 ESP 来销毁该函数保存在栈中的执行上下文。</p>\n<h2 id="堆中的数据是如何回收的"><a href="#%E5%A0%86%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%98%AF%E5%A6%82%E4%BD%95%E5%9B%9E%E6%94%B6%E7%9A%84" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>堆中的数据是如何回收的</h2>\n<p>通过上面的讲解，我想现在你应该已经知道，当上面那段代码的 foo 函数执行结束之后，ESP 应该是指向全局执行上下文的，那这样的话，showName 函数和 foo 函数的执行上下文就处于无效状态了，不过保存在堆中的两个对象依然占用着空间，如下图所示</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-05-14-13-55-a9d092b8620c531f9704f0f11d718e85-6ea2c.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 83.11306901615274%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAIAAABSJhvpAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACFElEQVQ4y6WTT28SQRjG+TxGk8abF+PFb+BHMDFeDEYPeuMAJKCFsMSCQICmKi0kSCXgn8SjB1Ej2mhDUizCbtnl37A7M53Z2Z3FabdWiCYl8Tns7Eye37zPTOb1zP5DHnfgnCOEDo9FCDn9wRjbti0MdO8tbRYOm8/I5yfk6yb5tE53qyewcAif4zh8TmJqmialVBj08vXp2sVxfGX6aEVPXwaxc0bh2h9Y1Pk7mG1ZLgwbd/XaJdgMsuk+G31jo+8M/DgDtn7Dkw/3B6+vjndimBgYahhpGI+WhauVzUxyNZWMJRJryWQiHpdKxa1l4a3i89ADaTUi+QP+YDDo8/my2eyycKVciEcDjxNSOp3KpFOifqlUXBYeN+6p9SujLxEIRxB0IeghQz0TZi6MPnr1+nm8G+Uc2+aAm0POwLKVQePOYPsC2IlQMiXogKA+xcMj2KHEMak2gTLiisFkncmGpUBLhtwgjJlH8JvqRiHj38hK+Xwul8tk0snqi4pn5jg2ADOKnr7v3Xg59Na6t7bb3lrv9quDm3X13T6YcXZ82+Xww1gkKoVC4VA47PcH8vn1k9jiJYp4lklti2FkQB3YzBRTkxLxToVhMNC63Z+KIrfbe61WS5ZlTdM8Ljp/TrHa6XTcfnD3deYMomEmk8lCV83LtTqLO562yrw8/2xUcQRVVUU28VUURWTp9/tAXM2ifgGJ3J+m/MWuBAAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 05 14 13 55"\n        title=""\n        src="/static/2021-07-05-14-13-55-a9d092b8620c531f9704f0f11d718e85-fee1c.png"\n        srcset="/static/2021-07-05-14-13-55-a9d092b8620c531f9704f0f11d718e85-a67b7.png 200w,\n/static/2021-07-05-14-13-55-a9d092b8620c531f9704f0f11d718e85-0b187.png 400w,\n/static/2021-07-05-14-13-55-a9d092b8620c531f9704f0f11d718e85-fee1c.png 800w,\n/static/2021-07-05-14-13-55-a9d092b8620c531f9704f0f11d718e85-b1a91.png 1200w,\n/static/2021-07-05-14-13-55-a9d092b8620c531f9704f0f11d718e85-6ea2c.png 1362w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从图中可以看出，1003 和 1050 这两块内存依然被占用。要回收堆中的垃圾数据，就需要用到 JavaScript 中的垃圾回收器了。</p>\n<p>所以，接下来我们就来通过 Chrome 的 JavaScript 引擎 V8 来分析下堆中的垃圾数据是如何回收的。</p>\n<h2 id="代际假说和分代收集"><a href="#%E4%BB%A3%E9%99%85%E5%81%87%E8%AF%B4%E5%92%8C%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>代际假说和分代收集</h2>\n<p>不过在正式介绍 V8 是如何实现回收之前，你需要先学习下代际假说（The Generational Hypothesis）的内容，这是垃圾回收领域中一个重要的术语，后续垃圾回收的策略都是建立在该假说的基础之上的，所以很是重要。</p>\n<p>代际假说有以下两个特点：</p>\n<ul>\n<li>第一个是大部分对象在内存中存在的时间很短，简单来说，就是很多对象一经分配内存，很快就变得不可访问；</li>\n<li>第二个是不死的对象，会活得更久。</li>\n</ul>\n<p>其实这两个特点不仅仅适用于 JavaScript，同样适用于大多数的动态语言，如 Java、Python 等。</p>\n<p>有了代际假说的基础，我们就可以来探讨 V8 是如何实现垃圾回收的了。</p>\n<p>通常，垃圾回收算法有很多种，但是并没有哪一种能胜任所有的场景，你需要权衡各种场景，根据对象的生存周期的不同而使用不同的算法，以便达到最好的效果。</p>\n<p>所以，在 V8 中会把堆分为新生代和老生代两个区域，新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象。</p>\n<p>新生区通常只支持 1 ～ 8M 的容量，而老生区支持的容量就大很多了。对于这两块区域，V8 分别使用两个不同的垃圾回收器，以便更高效地实施垃圾回收。</p>\n<ul>\n<li>副垃圾回收器，主要负责新生代的垃圾回收。</li>\n<li>主垃圾回收器，主要负责老生代的垃圾回收。</li>\n</ul>\n<h2 id="垃圾回收器的工作流程"><a href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>垃圾回收器的工作流程</h2>\n<p>现在你知道了 V8 把堆分成两个区域——新生代和老生代，并分别使用两个不同的垃圾回收器。其实不论什么类型的垃圾回收器，它们都有一套共同的执行流程。</p>\n<p>第一步是标记空间中活动对象和非活动对象。所谓活动对象就是还在使用的对象，非活动对象就是可以进行垃圾回收的对象。</p>\n<p>第二步是回收非活动对象所占据的内存。其实就是在所有的标记完成之后，统一清理内存中所有被标记为可回收的对象。</p>\n<p>第三步是做内存整理。一般来说，频繁回收对象后，内存中就会存在大量不连续空间，我们把这些不连续的内存空间称为内存碎片。当内存中出现了大量的内存碎片之后，如果需要分配较大连续内存的时候，就有可能出现内存不足的情况。所以最后一步需要整理这些内存碎片，但这步其实是可选的，因为有的垃圾回收器不会产生内存碎片，比如接下来我们要介绍的副垃圾回收器。</p>\n<p>那么接下来，我们就按照这个流程来分析新生代垃圾回收器（副垃圾回收器）和老生代垃圾回收器（主垃圾回收器）是如何处理垃圾回收的。</p>\n<h2 id="副垃圾回收器"><a href="#%E5%89%AF%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>副垃圾回收器</h2>\n<p>副垃圾回收器主要负责新生区的垃圾回收。而通常情况下，大多数小的对象都会被分配到新生区，所以说这个区域虽然不大，但是垃圾回收还是比较频繁的。</p>\n<p>新生代中用 Scavenge 算法来处理。所谓 Scavenge 算法，是把新生代空间对半划分为两个区域，一半是对象区域，一半是空闲区域，如下图所示</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-05-14-15-22-e32f50e2eb152a5b001ac254262fa90b-574e5.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 59.45558739255014%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABGklEQVQoz41SaW+DMAzl///AqtuHIsa2klYQyH3ZqQl0PZH2ZCm25eczVb4DIuZ3wIJXf/Wneec+P/bd8fiaTgqx3+2UlO/JFNKPU/vz27Tf2rqEOcIqpJ97XjfNME5X/9pFtbzcgkroqYhPOqKJyFQSHlWYxaTsMOuUF3OwsPDXyjrmScjgHUBy1hqtVczwMOdNNwFDupGRsnbsZI0BgEkIzjl5YGN/msh3lefGutNZK0XGOI7D0P+fTKNiKrb3HhEonZxfpHVn3CavC3PAHcqA3EThgRSmgcam+jJk2tzkUVylt5DuK5eTrgLluNTC4VCTDJyTCeWb4GMrVd5GDMF5TyvcCngmU2jXdXVdt23LGPsqaAtCCE/BF3JCwHoMaWtPAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 05 14 15 22"\n        title=""\n        src="/static/2021-07-05-14-15-22-e32f50e2eb152a5b001ac254262fa90b-fee1c.png"\n        srcset="/static/2021-07-05-14-15-22-e32f50e2eb152a5b001ac254262fa90b-a67b7.png 200w,\n/static/2021-07-05-14-15-22-e32f50e2eb152a5b001ac254262fa90b-0b187.png 400w,\n/static/2021-07-05-14-15-22-e32f50e2eb152a5b001ac254262fa90b-fee1c.png 800w,\n/static/2021-07-05-14-15-22-e32f50e2eb152a5b001ac254262fa90b-b1a91.png 1200w,\n/static/2021-07-05-14-15-22-e32f50e2eb152a5b001ac254262fa90b-574e5.png 1396w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>新加入的对象都会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作。</p>\n<p>在垃圾回收过程中，首先要对对象区域中的垃圾做标记；标记完成之后，就进入垃圾清理阶段，副垃圾回收器会把这些存活的对象复制到空闲区域中，同时它还会把这些对象有序地排列起来，所以这个复制过程，也就相当于完成了内存整理操作，复制后空闲区域就没有内存碎片了。</p>\n<p>完成复制后，对象区域与空闲区域进行角色翻转，也就是原来的对象区域变成空闲区域，原来的空闲区域变成了对象区域。这样就完成了垃圾对象的回收操作，同时这种角色翻转的操作还能让新生代中的这两块区域无限重复使用下去。</p>\n<p>由于新生代中采用的 Scavenge 算法，所以每次执行清理操作时，都需要将存活的对象从对象区域复制到空闲区域。但复制操作需要时间成本，如果新生区空间设置得太大了，那么每次清理的时间就会过久，所以为了执行效率，一般新生区的空间会被设置得比较小。</p>\n<p>也正是因为新生区的空间不大，所以很容易被存活的对象装满整个区域。为了解决这个问题，JavaScript 引擎采用了对象晋升策略，也就是经过两次垃圾回收依然还存活的对象，会被移动到老生区中。</p>\n<h2 id="主垃圾回收器"><a href="#%E4%B8%BB%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>主垃圾回收器</h2>\n<p>主垃圾回收器主要负责老生区中的垃圾回收。除了新生区中晋升的对象，一些大的对象会直接被分配到老生区。因此老生区中的对象有两个特点，一个是对象占用空间大，另一个是对象存活时间长。</p>\n<p>由于老生区的对象比较大，若要在老生区中使用 Scavenge 算法进行垃圾回收，复制这些大的对象将会花费比较多的时间，从而导致回收执行效率不高，同时还会浪费一半的空间。因而，主垃圾回收器是采用标记 - 清除（Mark-Sweep）的算法进行垃圾回收的。下面我们来看看该算法是如何工作的。</p>\n<p>首先是标记过程阶段。标记阶段就是从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素称为活动对象，没有到达的元素就可以判断为垃圾数据。</p>\n<p>比如最开始的那段代码，当 showName 函数执行退出之后，这段代码的调用栈和堆空间如下图所示：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-05-14-15-47-89072468db6e7b2a97e7198cec310d4d-5fe3e.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 57.34265734265735%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAB3UlEQVQoz3VSy27TQBTtX/UrWCOx5A+gC5AQG0RhQUFR0qaIVqgESsVDKAixaClRUZo2sUlSK3Zj2iTYctrYDnb8mkfw2MNkAhQQPTqauSPdM+do7sxQjjRNY5JwEs5pnaQc9BzMTDeMUBJjmowpjWn6nTGd1MS2zINmUzlUw/YWrq+B/TwUVkAli9X3E/HkWhBFtrUuedkGzFTMzJ6VE5yM6K9KkXz8dae0vVut26U59/WsvzePDl+B5grqbXMxD+V6waYyqHSHpSNGp2qAZw27qDgHPfNE72mnpv38nnv7krVw3Xhwq3/nmv92YyqeqB0/6PVPExRSIWsXLqI3l5VWVfNJS7NoErOO0csF68aF4f25Yebm8O5Vv1j4FZvSEMC2YXeskVotKltL7Q8Pa4oqDdCJE7C3YGogz7ubs9ipEYoJcWISMtOfsZ0ALte93GdvsYEWJbLUorkGfKEECAKMcQRQ6d3jjfyV9SfLTwtrq4/yn3Y+njlHENd0TzTCyrG1+2UgaO6+5skm6Ha7giBIknTU0dROX2ZxJKnVkg2jfzaq3wC+G42+TSfPVl3Xy+WyKIoQQnYkhERR9O+ceTcn5eQ1w3g89n0/CAImS//Gf5z/BFMi9nmS5LyGH4XIT95I6xwYAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 05 14 15 47"\n        title=""\n        src="/static/2021-07-05-14-15-47-89072468db6e7b2a97e7198cec310d4d-fee1c.png"\n        srcset="/static/2021-07-05-14-15-47-89072468db6e7b2a97e7198cec310d4d-a67b7.png 200w,\n/static/2021-07-05-14-15-47-89072468db6e7b2a97e7198cec310d4d-0b187.png 400w,\n/static/2021-07-05-14-15-47-89072468db6e7b2a97e7198cec310d4d-fee1c.png 800w,\n/static/2021-07-05-14-15-47-89072468db6e7b2a97e7198cec310d4d-b1a91.png 1200w,\n/static/2021-07-05-14-15-47-89072468db6e7b2a97e7198cec310d4d-5fe3e.png 1430w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从上图你可以大致看到垃圾数据的标记过程，当 showName 函数执行结束之后，ESP 向下移动，指向了 foo 函数的执行上下文，这时候如果遍历调用栈，是不会找到引用 1003 地址的变量，也就意味着 1003 这块数据为垃圾数据，被标记为红色。由于 1050 这块数据被变量 b 引用了，所以这块数据会被标记为活动对象。这就是大致的标记过程。</p>\n<p>接下来就是垃圾的清除过程。它和副垃圾回收器的垃圾清除过程完全不同，你可以理解这个过程是清除掉红色标记数据的过程，可参考下图大致理解下其清除过程：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-05-14-16-00-e7097f5d5eb869f0198529da34626d3c-03014.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 60.6628242074928%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABkUlEQVQoz31R30vCUBT2D+y9lx4jeq//oQiiHuyhPRUFQRDiQzmXmCvXyFwSEqhjUyYquiZs7Yfeu107u3O5JPvYLvfce79zzved1CxGQEjg+wRjEsCWzBKAMKAgMaLzFPyfmSttZ5PYVvhuRrDvI4TgafQCYTyZTqPQp1cAjFBIhiTTquheMkWp9pLN9He33I93uPiyLNu2g7gLURTz+bzneRD6QYAxnldual3uqXyzvva8veGcnSCtDYf9Xk9VVdM0ZVlmWZbn+UqlgmhByIgW5EbzgWWnF6fD7HWpIavnjMEcQ/ORWkVROI6zTBNCQRBqtVqkhbZNfYJO3pT242uVKxRa6QMjvR+Rozqw1ut1vlTi7m4lSQIKmmsmYDAGMflc7k2S5t7Sb24YNU8ol++LReSHiSDvQnMSoUMwsLjsz6zCq27HZo5MXe9omus4v8jJAS4B+oBVV+Ti4Z45HvcHA+j0j8oryOFqe16rN3BcdzQaTiaT/8gBHSYI9pckJLCSDLkNw9B13aHyFo4k1H0DpKGjyMpxZJwAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 05 14 16 00"\n        title=""\n        src="/static/2021-07-05-14-16-00-e7097f5d5eb869f0198529da34626d3c-fee1c.png"\n        srcset="/static/2021-07-05-14-16-00-e7097f5d5eb869f0198529da34626d3c-a67b7.png 200w,\n/static/2021-07-05-14-16-00-e7097f5d5eb869f0198529da34626d3c-0b187.png 400w,\n/static/2021-07-05-14-16-00-e7097f5d5eb869f0198529da34626d3c-fee1c.png 800w,\n/static/2021-07-05-14-16-00-e7097f5d5eb869f0198529da34626d3c-b1a91.png 1200w,\n/static/2021-07-05-14-16-00-e7097f5d5eb869f0198529da34626d3c-03014.png 1388w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>上面的标记过程和清除过程就是标记 - 清除算法，不过对一块内存多次执行标记 - 清除算法后，会产生大量不连续的内存碎片。而碎片过多会导致大对象无法分配到足够的连续内存，于是又产生了另外一种算法——标记 - 整理（Mark-Compact），这个标记过程仍然与标记 - 清除算法里的是一样的，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。你可以参考下图</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-05-14-16-15-8b9ca980923f8eaba0c102b31f37df52-22802.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 49.71509971509971%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABE0lEQVQoz3VRy4qEMBD0/3/GdWdwFg8qIshoVg96FgRBRETRg49N4lYSd8Z5bBFD26nqVHe0TYJzzrAkuMQtv/0PDR+ldFkWyBBj//mDYiBj2/aHYZzO55OE8WlYlgWCECtenue6rtd1rcqt6zoMQ9d1wzimaRqGV0JIRATCKEqSBBwh7vveNE3HcYIgAFu5hRfk8du2LQo9GeYb322P4+j7flVViL8J+bpcwEZh1TACWKOMioDuAAGnD7bRj+d5cRwfxegZMeP3Waq53MWUsaIoXNeFVWTWw8BAwvmK6ymd5mmeZyGWpbWnZtRrvb6KcoFpZVnWNE1ZlnvPt+PjC7/FNImblfMH8asFzBlTxP7WC/ALx7A7GqZJCyYAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 05 14 16 15"\n        title=""\n        src="/static/2021-07-05-14-16-15-8b9ca980923f8eaba0c102b31f37df52-fee1c.png"\n        srcset="/static/2021-07-05-14-16-15-8b9ca980923f8eaba0c102b31f37df52-a67b7.png 200w,\n/static/2021-07-05-14-16-15-8b9ca980923f8eaba0c102b31f37df52-0b187.png 400w,\n/static/2021-07-05-14-16-15-8b9ca980923f8eaba0c102b31f37df52-fee1c.png 800w,\n/static/2021-07-05-14-16-15-8b9ca980923f8eaba0c102b31f37df52-b1a91.png 1200w,\n/static/2021-07-05-14-16-15-8b9ca980923f8eaba0c102b31f37df52-22802.png 1404w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<h2 id="全停顿"><a href="#%E5%85%A8%E5%81%9C%E9%A1%BF" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>全停顿</h2>\n<p>现在你知道了 V8 是使用副垃圾回收器和主垃圾回收器处理垃圾回收的，不过由于 JavaScript 是运行在主线程之上的，一旦执行垃圾回收算法，都需要将正在执行的 JavaScript 脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。我们把这种行为叫做全停顿（Stop-The-World）。</p>\n<p>比如堆中的数据有 1.5GB，V8 实现一次完整的垃圾回收需要 1 秒以上的时间，这也是由于垃圾回收而引起 JavaScript 线程暂停执行的时间，若是这样的时间花销，那么应用的性能和响应能力都会直线下降。主垃圾回收器执行一次完整的垃圾回收流程如下图所示：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-05-14-16-40-e971aec8ff9d9e307046a00b0e265563-4a030.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 40.78374455732946%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAIAAAB2/0i6AAAACXBIWXMAAA7DAAAOwwHHb6hkAAABGElEQVQY06WQsUvDQBTG+x85OTm4iUt1UheHunboIrgKUrsIxeJi7ebg5hIQFyeXKlnU1HCxaRASjtKkNr0Ec5e7e/FuUDtYHfzBHQ/e+977+ErFPyipBwASQBWvE+j68BCwd8dmyKLI4k4vQ5ZwnqZ918Rw78swBa34EiuE1P/hLV/oiHInNHc27e1VVFm721pBlfXHjeWram3pvFg8o5e2HhXwKcYYuwMP8uzCHNeMyYERPJ8cDVr1/nEDNesvrYbb3O+etveu411jfNOLsjT+tp2mKSFECuVdqKVC5kzIN0LwaORjHAyHjAvKOQDXXcEVxaztWVQElFLGWBRFnudN4zhnmp8Dm4faog79kfY8kiQJw/CXgQ8EMrmBWgskLgAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 05 14 16 40"\n        title=""\n        src="/static/2021-07-05-14-16-40-e971aec8ff9d9e307046a00b0e265563-fee1c.png"\n        srcset="/static/2021-07-05-14-16-40-e971aec8ff9d9e307046a00b0e265563-a67b7.png 200w,\n/static/2021-07-05-14-16-40-e971aec8ff9d9e307046a00b0e265563-0b187.png 400w,\n/static/2021-07-05-14-16-40-e971aec8ff9d9e307046a00b0e265563-fee1c.png 800w,\n/static/2021-07-05-14-16-40-e971aec8ff9d9e307046a00b0e265563-b1a91.png 1200w,\n/static/2021-07-05-14-16-40-e971aec8ff9d9e307046a00b0e265563-4a030.png 1378w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>在 V8 新生代的垃圾回收中，因其空间较小，且存活对象较少，所以全停顿的影响不大，但老生代就不一样了。如果在执行垃圾回收的过程中，占用主线程时间过久，就像上面图片展示的那样，花费了 200 毫秒，在这 200 毫秒内，主线程是不能做其他事情的。比如页面正在执行一个 JavaScript 动画，因为垃圾回收器在工作，就会导致这个动画在这 200 毫秒内无法执行的，这将会造成页面的卡顿现象。</p>\n<p>为了降低老生代的垃圾回收而造成的卡顿，V8 将标记过程分为一个个的子标记过程，同时让垃圾回收标记和 JavaScript 应用逻辑交替进行，直到标记阶段完成，我们把这个算法称为增量标记（Incremental Marking）算法。如下图所示：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-05-14-16-53-e6492934c0f0f4ec2d00fbd7e3ffd66d-39487.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 44.47476125511596%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAIAAAC9o5sfAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABEklEQVQoz5WRz0oDMRDG+2T6AOJF0FPVYz2ot/oMngTpSQUtta2lVER8hh704kX2JNoKW7ZrTLLZdrfZZCYmW6kHK9qPYfgI82P+pGDmCRHNP1T4+aSUYoxZQym1fmGYR9waf+DLLPsbns6ZKgwTEwoZDIYkNR/vdChUansjAGc64myswzGOJJq8/gvW4PK1p5dqWKwGp4dXK23TOGqtnpGbF2NE6JU2HkrFzXN/+RIr924XwBy2bXv9tyQid0/xWp3t1l+rx+2tjmhWWtsXvVsvkUH/sbzTPdjbrz2vN/lJlyaCfcOEECGEc6BdIOTZzQYAWmvrXKCeFkwmcv7BZsqUGsWxRRe49kxSSvtb2e8H/wRrNvpsX4BLjwAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 05 14 16 53"\n        title=""\n        src="/static/2021-07-05-14-16-53-e6492934c0f0f4ec2d00fbd7e3ffd66d-fee1c.png"\n        srcset="/static/2021-07-05-14-16-53-e6492934c0f0f4ec2d00fbd7e3ffd66d-a67b7.png 200w,\n/static/2021-07-05-14-16-53-e6492934c0f0f4ec2d00fbd7e3ffd66d-0b187.png 400w,\n/static/2021-07-05-14-16-53-e6492934c0f0f4ec2d00fbd7e3ffd66d-fee1c.png 800w,\n/static/2021-07-05-14-16-53-e6492934c0f0f4ec2d00fbd7e3ffd66d-b1a91.png 1200w,\n/static/2021-07-05-14-16-53-e6492934c0f0f4ec2d00fbd7e3ffd66d-39487.png 1466w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>使用增量标记算法，可以把一个完整的垃圾回收任务拆分为很多小的任务，这些小的任务执行时间比较短，可以穿插在其他的 JavaScript 任务中间执行，这样当执行上述动画效果时，就不会让用户因为垃圾回收任务而感受到页面的卡顿了。</p>\n<h2 id="总结-1"><a href="#%E6%80%BB%E7%BB%93-1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总结</h2>\n<p>首先我们介绍了不同语言的垃圾回收策略，然后又说明了栈中的数据是如何回收的，最后重点讲解了 JavaScript 中的垃圾回收器是如何工作的。</p>\n<p>从上面的分析你也能看出来，无论是垃圾回收的策略，还是处理全停顿的策略，往往都没有一个完美的解决方案，你需要花一些时间来做权衡，而这需要牺牲当前某几方面的指标来换取其他几个指标的提升。</p>\n<p>其实站在工程师的视角，我们经常需要在满足需求的前提下，权衡各个指标的得失，把系统设计得尽可能适应最核心的需求。</p>\n<p>生活中处理事情的原则也与之类似，古人很早就说过“两害相权取其轻，两利相权取其重”，所以与其患得患失，不如冷静地分析哪些才是核心诉求，然后果断决策牺牲哪些以使得利益最大化。</p>\n<h1 id="编译器和解析器：v8-如何执行一段-javascript-代码的"><a href="#%E7%BC%96%E8%AF%91%E5%99%A8%E5%92%8C%E8%A7%A3%E6%9E%90%E5%99%A8%EF%BC%9Av8-%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E4%B8%80%E6%AE%B5-javascript-%E4%BB%A3%E7%A0%81%E7%9A%84" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>编译器和解析器：V8 如何执行一段 JavaScript 代码的</h1>\n<p>前面我们已经花了很多篇幅来介绍 JavaScript 是如何工作的，了解这些内容能帮助你从底层理解 JavaScript 的工作机制，从而能帮助你更好地理解和应用 JavaScript。</p>\n<p>今天这篇文章我们就继续“向下”分析，站在 JavaScript 引擎 V8 的视角，来分析 JavaScript 代码是如何被执行的。</p>\n<p>前端工具和框架的自身更新速度非常快，而且还不断有新的出现。要想追赶上前端工具和框架的更新速度，你就需要抓住那些本质的知识，然后才能更加轻松地理解这些上层应用。比如我们接下来要介绍的 V8 执行机制，能帮助你从底层了解 JavaScript，也能帮助你深入理解语言转换器 Babel、语法检查工具 ESLint、前端框架 Vue 和 React 的一些底层实现机制。因此，了解 V8 的编译流程能让你对语言以及相关工具有更加充分的认识。</p>\n<p>要深入理解 V8 的工作原理，你需要搞清楚一些概念和原理，比如接下来我们要详细讲解的编译器（Compiler）、解释器（Interpreter）、抽象语法树（AST）、字节码（Bytecode）、即时编译器（JIT）等概念，都是你需要重点关注的。</p>\n<h2 id="编译器和解释器"><a href="#%E7%BC%96%E8%AF%91%E5%99%A8%E5%92%8C%E8%A7%A3%E9%87%8A%E5%99%A8" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>编译器和解释器</h2>\n<p>之所以存在编译器和解释器，是因为机器不能直接理解我们所写的代码，所以在执行程序之前，需要将我们所写的代码“翻译”成机器能读懂的机器语言。按语言的执行流程，可以把语言划分为编译型语言和解释型语言。</p>\n<p>编译型语言在程序执行之前，需要经过编译器的编译过程，并且编译之后会直接保留机器能读懂的二进制文件，这样每次运行程序时，都可以直接运行该二进制文件，而不需要再次重新编译了。比如 C/C++、GO 等都是编译型语言。</p>\n<p>而由解释型语言编写的程序，在每次运行时都需要通过解释器对程序进行动态解释和执行。比如 Python、JavaScript 等都属于解释型语言。</p>\n<p>那编译器和解释器是如何“翻译”代码的呢？具体流程你可以参考下图</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-05-14-17-59-b2dc07e44bcdda21710e54d53790c2bc-fc057.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 53.46260387811634%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABn0lEQVQoz2VSS2sUQRDe/yje/QEBr4LBf5CDRy96FAJJIGAOYhAJhARcTNSQiMRE17g7O9M7uzv9qEc/Ut27K4l+9AwfVd1V9VVVL6UUM0KKYYHM05L/JWIsR36ZFFfqee+ValSH1QwcACNcNzBQQtzcwLcKtHUE9pfKRme1tjC3aK2VOD1AHN4MNg7D2htq1GTWqsd7+GwfEkw/XNoHm/5kYEi3T97y+jukrjm4NM+PAiFI+p5kB3DXir43XmsD1pz8ofPKp+Qnhg+uWEPmn4f8ZciionPcmOCcC4vHWQFT9MQFKbL3hEieKUXKQIohn4Ux+GzLmuUT2cFDipivZTcKZy43IoaQgwbGyHgXq4Y19cff/P4HzeYd2e6iwten1M463XVbZ3x8pd1cXYzgbMSricRl2QB4M/j5oh+f7nOtWm/a3XN6uMkTjQju0Q6/7EsSt/2VXn0KZa6ptAmWmqUGY8E6lHhidYBTjaLNM08NGhB+v2JcjerukpQFKCvAIh4lkOgv2in8h2XD/oE46roej8fVaDSu62lBXJR7H7cw9nMkHYofLAAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 05 14 17 59"\n        title=""\n        src="/static/2021-07-05-14-17-59-b2dc07e44bcdda21710e54d53790c2bc-fee1c.png"\n        srcset="/static/2021-07-05-14-17-59-b2dc07e44bcdda21710e54d53790c2bc-a67b7.png 200w,\n/static/2021-07-05-14-17-59-b2dc07e44bcdda21710e54d53790c2bc-0b187.png 400w,\n/static/2021-07-05-14-17-59-b2dc07e44bcdda21710e54d53790c2bc-fee1c.png 800w,\n/static/2021-07-05-14-17-59-b2dc07e44bcdda21710e54d53790c2bc-b1a91.png 1200w,\n/static/2021-07-05-14-17-59-b2dc07e44bcdda21710e54d53790c2bc-fc057.png 1444w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从图中你可以看出这二者的执行流程，大致可阐述为如下：</p>\n<ul>\n<li>在编译型语言的编译过程中，编译器首先会依次对源代码进行词法分析、语法分析，生成抽象语法树（AST），然后是优化代码，最后再生成处理器能够理解的机器码。如果编译成功，将会生成一个可执行的文件。但如果编译过程发生了语法或者其他的错误，那么编译器就会抛出异常，最后的二进制文件也不会生成成功</li>\n<li>在解释型语言的解释过程中，同样解释器也会对源代码进行词法分析、语法分析，并生成抽象语法树（AST），不过它会再基于抽象语法树生成字节码，最后再根据字节码来执行程序、输出结果。</li>\n</ul>\n<h2 id="v8-是如何执行一段-javascript-代码的"><a href="#v8-%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E4%B8%80%E6%AE%B5-javascript-%E4%BB%A3%E7%A0%81%E7%9A%84" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>V8 是如何执行一段 JavaScript 代码的</h2>\n<p>通过上面的介绍，相信你已经了解编译器和解释器了。那接下来，我们就重点分析下 V8 是如何执行一段 JavaScript 代码的。你可以先来“一览全局”，参考下图：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-05-14-18-38-2ed8ee16a1f022fed83c2811bd01ea77-7a87e.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 61.07692307692307%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACMklEQVQoz22SS4/SUBTH+Ux+BxO/gVvd6M7EGBfOzseYmKjRhQs3JmZGRZnhJeUhA0NHRkIpDEJ5BfpgKC20ZSh99/ZxLahRx7n55Z67OL/8T25OCELo++eBPrQcXzY9A3jwouNv7lBQzLOxMfmms5jJVgP0SRXOKx+PiEvPp3eip+akIg1QicIkUhy9eHZy42rj1nW2hNmWs5EFAlJhf7zvUklnA6Sjsw5SrhxmC3m1+d5ovbNHmWECbW5t09tP+EePJaRiqGYoSFfng1f5wcsCIxAJ8fsna7D/ptS/h8z5RsTCX1fwys3ootVvCzmUCRfKxen9LEDyU1dR1vJqNrib4G5/XjL4HlvdFRu7T3PktT2VbmXhMJw8rl/ZsctNgkXxbrh4GG8/iC2Q3MRV1PXYltD1yKhLpwCVsqm0S8bb9XwRw30m5TJZtR8b1SI+h4rYcJJriUVCPmgu0I6haBtZ7Hlk3KXTgArIQCa5leIv73hMpwhPkUUrIp+89bkjERtxX9pcgeDybb7U/SMDMgHoDKDTNp2G41S5XvvwtauTWW+cFrpID0uYbFmqjaaBXOxwBwSP9n7JptABoxigkGDsn/hMAjIxm0xBOn5cxx6mWWqIK/hgkv0reaWtPwwYsi2z9oqzlQ3rB2+rc6DwrjpztbmnzYAm6NJKmy21+QZh6QAQunCBXA8almM7nmEB3bA1w3I9//+20O9t+wfHAbK8NHRdkVdni4UkikHO+UYIfwACYHTKWvHKHgAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 05 14 18 38"\n        title=""\n        src="/static/2021-07-05-14-18-38-2ed8ee16a1f022fed83c2811bd01ea77-fee1c.png"\n        srcset="/static/2021-07-05-14-18-38-2ed8ee16a1f022fed83c2811bd01ea77-a67b7.png 200w,\n/static/2021-07-05-14-18-38-2ed8ee16a1f022fed83c2811bd01ea77-0b187.png 400w,\n/static/2021-07-05-14-18-38-2ed8ee16a1f022fed83c2811bd01ea77-fee1c.png 800w,\n/static/2021-07-05-14-18-38-2ed8ee16a1f022fed83c2811bd01ea77-b1a91.png 1200w,\n/static/2021-07-05-14-18-38-2ed8ee16a1f022fed83c2811bd01ea77-7a87e.png 1300w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从图中可以清楚地看到，V8 在执行过程中既有解释器 Ignition，又有编译器 TurboFan，那么它们是如何配合去执行一段 JavaScript 代码的呢? 下面我们就按照上图来一一分解其执行流程。</p>\n<h3 id="生成抽象语法树（ast）和执行上下文"><a href="#%E7%94%9F%E6%88%90%E6%8A%BD%E8%B1%A1%E8%AF%AD%E6%B3%95%E6%A0%91%EF%BC%88ast%EF%BC%89%E5%92%8C%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>生成抽象语法树（AST）和执行上下文</h3>\n<p>将源代码转换为抽象语法树，并生成执行上下文，而执行上下文我们在前面的文章中已经介绍过很多了，主要是代码在执行过程中的环境信息。</p>\n<p>那么下面我们就得重点讲解下抽象语法树（下面表述中就直接用它的简称 AST 了），看看什么是 AST 以及 AST 的生成过程是怎样的。</p>\n<p>高级语言是开发者可以理解的语言，但是让编译器或者解释器来理解就非常困难了。对于编译器或者解释器来说，它们可以理解的就是 AST 了。所以无论你使用的是解释型语言还是编译型语言，在编译过程中，它们都会生成一个 AST。这和渲染引擎将 HTML 格式文件转换为计算机可以理解的 DOM 树的情况类似。</p>\n<p>你可以结合下面这段代码来直观地感受下什么是 AST：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="14911442154232035000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`var myName = \'极客时间\';\nfunction foo() {\n  return 23;\n}\nmyName = \'geektime\';\nfoo();`, `14911442154232035000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">var</span> myName <span class="token operator">=</span> <span class="token string">\'极客时间\'</span><span class="token punctuation">;</span>\n<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token number">23</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\nmyName <span class="token operator">=</span> <span class="token string">\'geektime\'</span><span class="token punctuation">;</span>\n<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>这段代码经过 javascript-ast 站点处理后，生成的 AST 结构如下：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-05-14-19-46-44c46d8ae0c32eb24edf18b902ae31c3-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 143.95796847635728%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAdCAIAAAAl5NuSAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAC5UlEQVQ4y6WU/U+SURTH+ydbq1yguLbSSAgwLX+r6GUtZyoymJQb6BLNmdAKzRAiKMg2J2zIW0rES8oDCPjw3JcOXHJGgLTOD/d5dnc/95x7zvecM/Q/7Az78DxvMBh0Op12amp2drZTmBACn2Kx2NPTIxKJxSKxQqH4N89gGGNY7Xa7UqlUqVT9/f0bGxvH+6fApGbBYHC5Zlqt1uFwpFKp+O4uqlTgDlqLsTkMVqkZ/CCEJjUamUwmlclU99T7+Ty7vR0sCALAmBlCPCGl8A7Va6hphuomqfM9i7AdXHdCCLz1KBYWpsfKL6aP9E+QY7UdDCTw9RTQ6qEQtz0RGzTGH2piQ+v7C8f7TeDq6VB4bW3N6XRardbQTqjEFyKZzUQhGM/7s+Uf9WubZhvWFYtFIpEMyORS6TW3+2O9VOQk0jphLGwQ3OjoqFx+Qy6Xj4zc5jiuo2wzGEpls62azWaTyTg+/jQQCERjkXQmBXEggo6f3RwGJ0xYfr+/t7e3u7v7/Nkug3amQXDNYXYIDOLnclyeO/wQXX4VmrAnTKt7z3J8mqW9Ccx0SjD8ILiE0Kqrz+mVheiD5ejYYuTRwVGiEWbxWCxWsVh8ta/v4qXLr99WGwNhTE5tDGbJZNLr9brdbtcbfdL/knKfcMZNhTIWBIx4TBBulTBUs1rRMQ3fwb5zyHsBBQcw4sif8mgOw5vrjUEIpK4c2aMTGmrQ0bHH9J2tnbYZzPwjgYeSHu6G8ovavG0ut6QvbzpPgeth/26AcHZrMqwwfruviSjXM/MtG4OpD1RhNs/DJIExCMLCVMjkYtlS4qAYL/LcKTMM+gkG4NDw8KBK5fF4Op1hJ/0DoFaroeBdIpHkujSdzVY32zcGw+DZMBV8Pp/T5XLZbJ7nhvLXL3R7iyS+t0vY3zGQWJjevUnVt+jgFbo01ymMqlqqhDP5mUBhKVIyBkvuVKVBKC1hdihRqJhjvDVeXX0/hQb4Fwh4QJV0syU+AAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 05 14 19 46"\n        title=""\n        src="/static/2021-07-05-14-19-46-44c46d8ae0c32eb24edf18b902ae31c3-fee1c.png"\n        srcset="/static/2021-07-05-14-19-46-44c46d8ae0c32eb24edf18b902ae31c3-a67b7.png 200w,\n/static/2021-07-05-14-19-46-44c46d8ae0c32eb24edf18b902ae31c3-0b187.png 400w,\n/static/2021-07-05-14-19-46-44c46d8ae0c32eb24edf18b902ae31c3-fee1c.png 800w,\n/static/2021-07-05-14-19-46-44c46d8ae0c32eb24edf18b902ae31c3-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从图中可以看出，AST 的结构和代码的结构非常相似，其实你也可以把 AST 看成代码的结构化的表示，编译器或者解释器后续的工作都需要依赖于 AST，而不是源代码。</p>\n<p>AST 是非常重要的一种数据结构，在很多项目中有着广泛的应用。其中最著名的一个项目是 Babel。Babel 是一个被广泛使用的代码转码器，可以将 ES6 代码转为 ES5 代码，这意味着你可以现在就用 ES6 编写程序，而不用担心现有环境是否支持 ES6。Babel 的工作原理就是先将 ES6 源码转换为 AST，然后再将 ES6 语法的 AST 转换为 ES5 语法的 AST，最后利用 ES5 的 AST 生成 JavaScript 源代码。</p>\n<p>除了 Babel 外，还有 ESLint 也使用 AST。ESLint 是一个用来检查 JavaScript 编写规范的插件，其检测流程也是需要将源码转换为 AST，然后再利用 AST 来检查代码规范化的问题。</p>\n<p>现在你知道了什么是 AST 以及它的一些应用，那接下来我们再来看下 AST 是如何生成的。通常，生成 AST 需要经过两个阶段。</p>\n<p>第一阶段是分词（tokenize），又称为词法分析，其作用是将一行行的源码拆解成一个个 token。所谓 token，指的是语法上不可能再分的、最小的单个字符或字符串。你可以参考下图来更好地理解什么 token。</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-05-14-20-00-ccfce4dcfb994f03af63d60a1cd0b5d1-e3990.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 60.36484245439468%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABmElEQVQoz41Su0oDQRTN14ifYJHW0s5CELQTCysbtbYXhUiIKQVFS1HER8BGUQmahQ3ZRx5m3SS7STaPnexjdmYnzuzKGo0GL1PM45x7zr13YsOx8H1fkiSO4xRFGU6M2PgVIaRUKmUymYIghsdJZPoMEaJrFOe6Tq1aHHoWgQMK+ZNcaeorqeRyYu8uz9Mjxohisal10rPgeAEczROnH1jyWRLylYqRVaO9epBcSuw+iEJYM0NC07nZBCeL1sU6QXZY0C/KEHmPoiA0GkipuAXezmXtlycnz7myiFsi6hum3DDlel9QrWrLrndAWYM965PsYZwtSorRJlrd5jlXKjg85/A5m3sl0BoSPHhrWu+M5pmOZ9q9gkqwP9LtoFUEukZqR9veoLJBjX5k1oeoenov7V+CYj0aQSyaLWtVu1mei8szU93DNEN4MIAxnKP3ruNb59NrcuqKPX1TDuUxdmXqOYc7RmQnVMaup91y6tkzKGk/lccDY0ztUBBCiO7/98PYMH1ara7r3W4XAFCr1egmbAEJ0kXYDyj0obVDwqusAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 05 14 20 00"\n        title=""\n        src="/static/2021-07-05-14-20-00-ccfce4dcfb994f03af63d60a1cd0b5d1-fee1c.png"\n        srcset="/static/2021-07-05-14-20-00-ccfce4dcfb994f03af63d60a1cd0b5d1-a67b7.png 200w,\n/static/2021-07-05-14-20-00-ccfce4dcfb994f03af63d60a1cd0b5d1-0b187.png 400w,\n/static/2021-07-05-14-20-00-ccfce4dcfb994f03af63d60a1cd0b5d1-fee1c.png 800w,\n/static/2021-07-05-14-20-00-ccfce4dcfb994f03af63d60a1cd0b5d1-b1a91.png 1200w,\n/static/2021-07-05-14-20-00-ccfce4dcfb994f03af63d60a1cd0b5d1-e3990.png 1206w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从图中可以看出，通过 var myName = “极客时间”简单地定义了一个变量，其中关键字“var”、标识符“myName” 、赋值运算符“=”、字符串“极客时间”四个都是 token，而且它们代表的属性还不一样。</p>\n<p>第二阶段是解析（parse），又称为语法分析，其作用是将上一步生成的 token 数据，根据语法规则转为 AST。如果源码符合语法规则，这一步就会顺利完成。但如果源码存在语法错误，这一步就会终止，并抛出一个“语法错误”。</p>\n<p>这就是 AST 的生成过程，先分词，再解析。</p>\n<p>有了 AST 后，那接下来 V8 就会生成该段代码的执行上下文。至于执行上下文的具体内容，你可以参考前面几篇文章的讲解。</p>\n<h3 id="生成字节码"><a href="#%E7%94%9F%E6%88%90%E5%AD%97%E8%8A%82%E7%A0%81" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>生成字节码</h3>\n<p>有了 AST 和执行上下文后，那接下来的第二步，解释器 Ignition 就登场了，它会根据 AST 生成字节码，并解释执行字节码。</p>\n<p>其实一开始 V8 并没有字节码，而是直接将 AST 转换为机器码，由于执行机器码的效率是非常高效的，所以这种方式在发布后的一段时间内运行效果是非常好的。但是随着 Chrome 在手机上的广泛普及，特别是运行在 512M 内存的手机上，内存占用问题也暴露出来了，因为 V8 需要消耗大量的内存来存放转换后的机器码。为了解决内存占用问题，V8 团队大幅重构了引擎架构，引入字节码，并且抛弃了之前的编译器，最终花了将进四年的时间，实现了现在的这套架构。</p>\n<p>那什么是字节码呢？为什么引入字节码就能解决内存占用问题呢？</p>\n<p>字节码就是介于 AST 和机器码之间的一种代码。但是与特定类型的机器码无关，字节码需要通过解释器将其转换为机器码后才能执行。</p>\n<p>理解了什么是字节码，我们再来对比下高级代码、字节码和机器码，你可以参考下图</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-05-14-20-28-a51833171add1250d3cdc4af5ca00a04-3adf4.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 40.779610194902546%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAIAAAB2/0i6AAAACXBIWXMAAA7DAAAOwwHHb6hkAAAA0ElEQVQY06VQ0Y6DIBDs//9jY04EFBRlqQgUuJuqyeWuSdOk8wLLzOwOe/n+AJc3dTFFWmkN65a2dE+/5lrrC9vBLXZd6MY6NU42pvSw1HpOziU7f/NxC9EfvXzYDC3k3VE6F8iFayvkYKz1pdRz8jzPejSdULIfZPulh56IGJMtk6MxYK21vVRDr4VQoFAqpWKMDzMOY4zgfNS6lJJzTghWCmyMsRDCfQeUQoimaZAFj1CesXEDDdv/D/9dBzTo+2rbaDRNU7dD7uCcI+qz8gfZoNI9AIQfcwAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 05 14 20 28"\n        title=""\n        src="/static/2021-07-05-14-20-28-a51833171add1250d3cdc4af5ca00a04-fee1c.png"\n        srcset="/static/2021-07-05-14-20-28-a51833171add1250d3cdc4af5ca00a04-a67b7.png 200w,\n/static/2021-07-05-14-20-28-a51833171add1250d3cdc4af5ca00a04-0b187.png 400w,\n/static/2021-07-05-14-20-28-a51833171add1250d3cdc4af5ca00a04-fee1c.png 800w,\n/static/2021-07-05-14-20-28-a51833171add1250d3cdc4af5ca00a04-b1a91.png 1200w,\n/static/2021-07-05-14-20-28-a51833171add1250d3cdc4af5ca00a04-3adf4.png 1334w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从图中可以看出，机器码所占用的空间远远超过了字节码，所以使用字节码可以减少系统的内存使用。</p>\n<h3 id="执行代码"><a href="#%E6%89%A7%E8%A1%8C%E4%BB%A3%E7%A0%81" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>执行代码</h3>\n<p>生成字节码之后，接下来就要进入执行阶段了。</p>\n<p>通常，如果有一段第一次执行的字节码，解释器 Ignition 会逐条解释执行。在执行字节码的过程中，如果发现有热点代码（HotSpot），比如一段代码被重复执行多次，这种就称为热点代码，那么后台的编译器 TurboFan 就会把该段热点的字节码编译为高效的机器码，然后当再次执行这段被优化的代码时，只需要执行编译后的机器码就可以了，这样就大大提升了代码的执行效率。</p>\n<p>V8 的解释器和编译器的取名也很有意思。解释器 Ignition 是点火器的意思，编译器 TurboFan 是涡轮增压的意思，寓意着代码启动时通过点火器慢慢发动，一旦启动，涡轮增压介入，其执行效率随着执行时间越来越高效率，因为热点代码都被编译器 TurboFan 转换了机器码，直接执行机器码就省去了字节码“翻译”为机器码的过程。</p>\n<p>其实字节码配合解释器和编译器是最近一段时间很火的技术，比如 Java 和 Python 的虚拟机也都是基于这种技术实现的，我们把这种技术称为即时编译（JIT）。具体到 V8，就是指解释器 Ignition 在解释执行字节码的同时，收集代码信息，当它发现某一部分代码变热了之后，TurboFan 编译器便闪亮登场，把热点的字节码转换为机器码，并把转换后的机器码保存起来，以备下次使用。</p>\n<p>对于 JavaScript 工作引擎，除了 V8 使用了“字节码 +JIT”技术之外，苹果的 SquirrelFish Extreme 和 Mozilla 的 SpiderMonkey 也都使用了该技术。</p>\n<p>这么多语言的工作引擎都使用了“字节码 +JIT”技术，因此理解 JIT 这套工作机制还是很有必要的。你可以结合下图看看 JIT 的工作过程：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-05-14-20-54-8045c545088f5f05a98e2208382f5db2-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 108.66900175131349%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAWCAIAAABPIytRAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACTElEQVQ4y6WTS09TQRTHZ+VCXeHGlRt3Ji40fAuXJvoJdOUnIDFujImG8Igu1IUQsYHEmACiiY/EBlRQEKgRKKb0hX1R7mPu9La9987M37mdaik0tomzuDn3zPnNOfOfcwj+Y5GjLinD75aNyA4mk5jJIBA9wzr0dgzkCU48w+kpML9xaC+waES9zeP6JzHw1R9Ya3q6Z9ZhLMCKgW8lbyHtrJr4SWVPsE6yboCM49Qkzr4AGcOVaGurO7xaxvEJnHkewicncPVDb7AOsD3M7uJ1xp9NuMpYLsteBZONpYxKzcsbjn48zrl2doGTqRS1LMfH5SguzCFhc0ixFY9Xq9V/wep40zRt6vguXcx7fVOhbOPbAWqORR1K6aHkbXAQ+C4L6+SNoOkMhje1VOEvo7YQojOs3AXH286bpg9fNBXSiWpcphnWs0aSck+0w83nMdA/Jy+9E/2vsFBq9qlu1aU9nJvG+RlcfKmUb1xQ/oG1tbgHMmqRwV0ysv8m14zQW9GcIENFMlwgo6X5Am+DdW2Gh7EN93GMRhKiWG2OlxboV0Xei/l3ltlgzM+78u/kte4shajv533XaY1le+8EVeaaZXlAsxbMhdhJpU3bkeFtZZ2jLqDkqfFQP1UrZZVkOhMEQSeY82w2yxjTTXao58KGq1TK5bLomFkt13VNy1byLxX9G19waw13v+PaZ7zPhQB1WLFYVDk6wyqD7TDU6NCKQx7i2FP0RSR5gJsfXbiWYVGV/GBRnUfyh4WRDTyK4/5maKh3DgU9Mla/AbcF1nHyw70qAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 05 14 20 54"\n        title=""\n        src="/static/2021-07-05-14-20-54-8045c545088f5f05a98e2208382f5db2-fee1c.png"\n        srcset="/static/2021-07-05-14-20-54-8045c545088f5f05a98e2208382f5db2-a67b7.png 200w,\n/static/2021-07-05-14-20-54-8045c545088f5f05a98e2208382f5db2-0b187.png 400w,\n/static/2021-07-05-14-20-54-8045c545088f5f05a98e2208382f5db2-fee1c.png 800w,\n/static/2021-07-05-14-20-54-8045c545088f5f05a98e2208382f5db2-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<h2 id="javascript-的性能优化"><a href="#javascript-%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>JavaScript 的性能优化</h2>\n<p>到这里相信你现在已经了解 V8 是如何执行一段 JavaScript 代码的了。在过去几年中，JavaScript 的性能得到了大幅提升，这得益于 V8 团队对解释器和编译器的不断改进和优化。</p>\n<p>虽然在 V8 诞生之初，也出现过一系列针对 V8 而专门优化 JavaScript 性能的方案，比如隐藏类、内联缓存等概念都是那时候提出来的。不过随着 V8 的架构调整，你越来越不需要这些微优化策略了，相反，对于优化 JavaScript 执行效率，你应该将优化的中心聚焦在单次脚本的执行时间和脚本的网络下载上，主要关注以下三点内容</p>\n<ul>\n<li>提升单次脚本的执行速度，避免 JavaScript 的长任务霸占主线程，这样可以使得页面快速响应交互；</li>\n<li>避免大的内联脚本，因为在解析 HTML 的过程中，解析和编译也会占用主线程；</li>\n<li>减少 JavaScript 文件的容量，因为更小的文件会提升下载速度，并且占用更低的内存</li>\n</ul>\n<h2 id="总结-2"><a href="#%E6%80%BB%E7%BB%93-2" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总结</h2>\n<ul>\n<li>首先我们介绍了编译器和解释器的区别。</li>\n<li>紧接着又详细分析了 V8 是如何执行一段 JavaScript 代码的：V8 依据 JavaScript 代码生成 AST 和执行上下文，再基于 AST 生成字节码，然后通过解释器执行字节码，通过编译器来优化编译字节码。</li>\n<li>基于字节码和编译器，我们又介绍了 JIT 技术。</li>\n<li>最后我们延伸说明了下优化 JavaScript 性能的一些策略。</li>\n</ul>\n<p>之所以在本专栏里讲 V8 的执行流程，是因为我觉得编译器和解释器的相关概念和理论对于程序员来说至关重要，向上能让你充分理解一些前端应用的本质，向下能打开计算机编译原理的大门。通过这些知识的学习能让你将很多模糊的概念关联起来，使其变得更加清楚，从而拓宽视野，上升到更高的层次。</p>',
excerpt:"栈空间和堆空间：数据是如何存储的 对于前端开发者来说，JavaScript 的内存机制是一个不被经常提及的概念，因此很容易被忽视。特别是一些非计算机专业的同学，对内存机制可能没有非常清晰的认识，甚至有些同学根本就不知道 JavaScript…",frontmatter:{date:"2021-07-05 11:30:26",path:"/browser-working-principle-v8/",tags:"前端, 浏览器, 高级前端",title:"浏览器工作原理与实践——V8工作原理",draft:null}}},pathContext:{mainPostPath:"/browser-working-principle-macro-view/",nextPostPath:"/browser-cross-page-message/",prePostPath:"/browser-working-principle-v8/"}}}});