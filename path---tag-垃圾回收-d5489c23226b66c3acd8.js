webpackJsonp([0xca80e24d44c],{1375:function(n,a){n.exports={data:{site:{siteMetadata:{title:"女王控的博客",description:'前端工程师，黑猫女王控，欢迎勾搭，技术相关<a href="https://github.com/towavephone" target="_blank">@towavephone</a>，QQ闲聊<a href="tencent://AddContact/?fromId=45&fromSubId=1&subcmd=all&uin=634407147&website=www.oicqzone.com">@towave</a>，bili关注<a href="https://space.bilibili.com/11507708#/" target="_blank">@towave</a>',siteUrl:"https://blog.towavephone.com"}}},pathContext:{posts:[{excerpt:"背景 作为目前最流行的 JavaScript 引擎，V8 引擎从出现的那一刻起便广泛受到人们的关注，我们知道 JavaScript 可以高效地运行在浏览器和 Nodejs 这两大宿主环境中，也是因为背后有强大的 V8 引擎在为其保驾护航，甚至成就了 Chrome 在浏览器中的霸主地位。不得不说，V8 引擎为了追求极致的性能和更好的用户体验，为我们做了太多太多，从原始的 Full-codegen 和 Crankshaft 编译器升级为 Ignition 解释器和 TurboFan…",html:'<h1 id="背景"><a href="#%E8%83%8C%E6%99%AF" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>背景</h1>\n<p>作为目前最流行的 JavaScript 引擎，V8 引擎从出现的那一刻起便广泛受到人们的关注，我们知道 JavaScript 可以高效地运行在浏览器和 Nodejs 这两大宿主环境中，也是因为背后有强大的 V8 引擎在为其保驾护航，甚至成就了 Chrome 在浏览器中的霸主地位。不得不说，V8 引擎为了追求极致的性能和更好的用户体验，为我们做了太多太多，从原始的 Full-codegen 和 Crankshaft 编译器升级为 Ignition 解释器和 TurboFan 编译器的强强组合，到隐藏类、内联缓存和 HotSpot 热点代码收集等一系列强有力的优化策略，V8 引擎正在努力降低整体的内存占用和提升到更高的运行性能。</p>\n<p>本篇主要是从 V8 引擎的垃圾回收机制入手，讲解一下在 JavaScript 代码执行的整个生命周期中 V8 引擎是采取怎样的垃圾回收策略来减少内存占比的，当然这部分的知识并不太影响我们写代码的流程，毕竟在一般情况下我们很少会遇到浏览器端出现内存溢出而导致程序崩溃的情况，但是至少我们对这方面有一定的了解之后，能增强我们在写代码过程中对减少内存占用，避免内存泄漏的主观意识，也许能够帮助你写出更加健壮和对 V8 引擎更加友好的代码。</p>\n<h1 id="为何需要垃圾回收"><a href="#%E4%B8%BA%E4%BD%95%E9%9C%80%E8%A6%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>为何需要垃圾回收</h1>\n<p>在 V8 引擎逐行执行 JavaScript 代码的过程中，当遇到函数的情况时，会为其创建一个函数执行上下文(Context)环境并添加到调用堆栈的栈顶，函数的作用域(handleScope)中包含了该函数中声明的所有变量，当该函数执行完毕后，对应的执行上下文从栈顶弹出，函数的作用域会随之销毁，其包含的所有变量也会统一释放并被自动回收。试想如果在这个作用域被销毁的过程中，其中的变量不被回收，即持久占用内存，那么必然会导致内存暴增，从而引发内存泄漏导致程序的性能直线下降甚至崩溃，因此内存在使用完毕之后理当归还给操作系统以保证内存的重复利用。</p>\n<blockquote>\n<p>这个过程就好比你向亲戚朋友借钱，借得多了却不按时归还，那么你再下次借钱的时候肯定没有那么顺利了，或者说你的亲戚朋友不愿意再借你了，导致你的手头有点儿紧(内存泄漏，性能下降)，所以说有借有还，再借不难嘛，毕竟出来混都是要还的。</p>\n</blockquote>\n<p>但是 JavaScript 作为一门高级编程语言，并不像 C 语言或 C++ 语言中需要手动地申请分配和释放内存，V8 引擎已经帮我们自动进行了内存的分配和管理，好让我们有更多的精力去专注于业务层面的复杂逻辑，这对于我们前端开发人员来说是一项福利，但是随之带来的问题也是显而易见的，那就是由于不用去手动管理内存，导致写代码的过程中不够严谨从而容易引发内存泄漏。</p>\n<h1 id="v8-引擎的内存限制"><a href="#v8-%E5%BC%95%E6%93%8E%E7%9A%84%E5%86%85%E5%AD%98%E9%99%90%E5%88%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>V8 引擎的内存限制</h1>\n<p>虽然 V8 引擎帮助我们实现了自动的垃圾回收管理，解放了我们勤劳的双手，但 V8 引擎中的内存使用也并不是无限制的。具体来说，默认情况下，V8 引擎在 64 位系统下最多只能使用约 1.4GB 的内存，在 32 位系统下最多只能使用约 0.7GB 的内存，在这样的限制下，必然会导致在 node 中无法直接操作大内存对象，比如将一个 2GB 大小的文件全部读入内存进行字符串分析处理，即使物理内存高达 32GB 也无法充分利用计算机的内存资源，那么为什么会有这种限制呢？这个要回到 V8 引擎的设计之初，起初只是作为浏览器端 JavaScript 的执行环境，在浏览器端我们其实很少会遇到使用大量内存的场景，因此也就没有必要将最大内存设置得过高。但这只是一方面，其实还有另外两个主要的原因：</p>\n<h2 id="js-单线程机制"><a href="#js-%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%9C%BA%E5%88%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>JS 单线程机制</h2>\n<p>作为浏览器的脚本语言，JS 的主要用途是与用户交互以及操作 DOM，那么这也决定了其作为单线程的本质，单线程意味着执行的代码必须按顺序执行，在同一时间只能处理一个任务。试想如果 JS 是多线程的，一个线程在删除 DOM 元素的同时，另一个线程对该元素进行修改操作，那么必然会导致复杂的同步问题。既然 JS 是单线程的，那么也就意味着在 V8 执行垃圾回收时，程序中的其他各种逻辑都要进入暂停等待阶段，直到垃圾回收结束后才会再次重新执行 JS 逻辑。因此，由于 JS 的单线程机制，垃圾回收的过程阻碍了主线程逻辑的执行。</p>\n<blockquote>\n<p>虽然 JS 是单线程的，但是为了能够充分利用操作系统的多核 CPU 计算能力，在 HTML5 中引入了新的 Web Worker 标准，其作用就是为 JS 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行。在主线程运行的同时，Worker 在后台运行，两者互不干扰。等到 Worker 线程完成计算任务，再把结果返回给主线程。这样的好处是， 一些计算密集型或高延迟的任务，被 Worker 线程负担，主线程(通常负责 UI 交互)就会很流畅，不会被阻塞或者拖慢。Web Worker 不是 JS 的一部分，而是通过 JS 访问的浏览器特性，其虽然创造了一个多线程的执行环境，但是子线程完全受主线程控制，不能访问浏览器特定的 API，例如操作 DOM，因此这个新标准并没有改变 JS 单线程的本质。</p>\n</blockquote>\n<h2 id="垃圾回收机制"><a href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>垃圾回收机制</h2>\n<p>垃圾回收本身也是一件非常耗时的操作，假设 V8 的堆内存为 1.5G，那么 V8 做一次小的垃圾回收需要 50ms 以上，而做一次非增量式回收甚至需要 1s 以上，可见其耗时之久，而在这 1s 的时间内，浏览器一直处于等待的状态，同时会失去对用户的响应，如果有动画正在运行，也会造成动画卡顿掉帧的情况，严重影响应用程序的性能。因此如果内存使用过高，那么必然会导致垃圾回收的过程缓慢，也就会导致主线程的等待时间越长，浏览器也就越长时间得不到响应。</p>\n<p>基于以上两点，V8 引擎为了减少对应用的性能造成的影响，采用了一种比较粗暴的手段，那就是直接限制堆内存的大小，毕竟在浏览器端一般也不会遇到需要操作几个 G 内存这样的场景。但是在 node 端，涉及到的 I/O 操作可能会比浏览器端更加复杂多样，因此更有可能出现内存溢出的情况。不过也没关系，V8 为我们提供了可配置项来让我们手动地调整内存大小，但是需要在 node 初始化的时候进行配置，我们可以通过如下方式来手动设置。</p>\n<p>我们尝试在 node 命令行中输入以下命令：</p>\n<blockquote>\n<p>本地安装的 node 版本为 v10.14.2，可通过 node -v 查看本地 node 的版本号，不同版本可能会导致下面的命令会有所差异。</p>\n</blockquote>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="5044046087173726000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// 该命令可以用来查看 node 中可用的 V8 引擎的选项及其含义\nnode --v8-options`, `5044046087173726000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                data-tooltip="复制"\n              >\n                <svg class="gatsby-code-button-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M16 1H2v16h2V3h12V1zm-1 4l6 6v12H6V5h9zm-1 7h5.5L14 6.5V12z"/></svg>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="bash"><pre style="counter-reset: linenumber NaN" class="language-bash line-numbers"><code class="language-bash">// 该命令可以用来查看 node 中可用的 V8 引擎的选项及其含义\nnode --v8-options</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span></span></pre></div>\n<p>然后我们会在命令行窗口中看到大量关于 V8 的选项，这里我们暂且只关注图中红色选框中的几个选项：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-06-22-17-29-42-4991c99c7f65952bddb545700afa6667-b1c4a.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 562px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 114.76868327402134%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAXCAIAAACEf/j0AAAACXBIWXMAAA7DAAAOwwHHb6hkAAADoUlEQVQ4y01UaW/jNhCVbVkS71uXdfqQ7ThZpEWzSYOm2P//q/qo7IcOCGpEcK7HeZOkaVpV1TRO83zqumEa5+PxOAxT27Tee+ecNdY5KN4YG0KoylIIuUvTBLLb7XB6Op7HYeoO/XW5Dv0Ive96IYSSCsZGG+icc6WU1iaEUiuVbGCcpsEHBByxhnmaj303nE8XRFZSuihWSS0l/iS8wBfcJN+y3W5xcDqd+76bpmlZroeur+o65okoxgRYW4fsjNHwRAiFSbaPkuDCOIzfcbzFVW+txSFnnOEioYxSyRklRTyJf0wwLpiQQiY5Y9aXh25sDodQN8M0V3UjjSkYywjsFBWq4JxJVVAOEyp4RmlB2b4gycPqF+8+T6ev5fw+Dr+ent76bpHyKsWFs6uSNy0XybHflFyEuCqxCL6se/KXNXVV38b5MozXcbrN89y0QQjLuaHUMR6ksIR4JStAjRPOPedWyIsUyV1J5nyPh+3HwzBWLcCepDY55Ugsp4xwKAURscw0X08Yz4Q8IPKbt00o7/N8G8b7NCH4pe8brT1juigcpZYSWxDHqGXMEOIokfs9y7Ipz5NDunt49+/19jHPP8fx67r8Pc8/qvoR/M3qJ2/vzj5Z8+TsI4SXMrw29UjyIc+mIk+0C3gqtCeapGs79OYZb962fT/UddO1bVPV2I0yeCcpOBUS4BMuqBDJn0reQ/g4Hj/Pp7d+/DifoHxMMyLcrLk7/wjuqs2qu4EU426bbja/O+yVFM/e/3M8fU7T1/n0Pgy/luW9756Uejj3R129luWL9z/K8HPon509Z/t0u0k2UZI83bXO3ZFsP1zn6TLNj/NlGeehrErwoCiKzWZdW5ruCDoz+Z/khFRNC1YNaNK2a9pD27Z12/XDYKwVSuWEGuMpY+hULiOr0LNgGHiWfLf7DDIduhJ89UErTQqaZVmeY8sQG/0MdbvZfct2FXy++WzAwe7QAfHH8wvI3NQN6KEiDSOfMQ2gr0Tawx3mxz7dYyV5lnNwA7QzBsmAsFpHxjLOkR4kW4USFlkthIl8Fkheax1hY4z2/ViWdVVW8xQHkNFobcFQowQdGXaMjlgq6Mgokv0NGHzXdY2aMUSQOdCCMSbaoe3WWWCjpVZlGWwkuvE+4BHiTOIiAVpNUwPty/mCuYVhWIYIHGBbMVsly0ENIAcFwfAl+CUkISRWttZgAA98RcARS2nUhtrj6GPxYSAoBLkg83Wkqf8AQHZmYwqvR8EAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 06 22 17 29 42"\n        title=""\n        src="/static/2021-06-22-17-29-42-4991c99c7f65952bddb545700afa6667-b1c4a.png"\n        srcset="/static/2021-06-22-17-29-42-4991c99c7f65952bddb545700afa6667-3ced9.png 200w,\n/static/2021-06-22-17-29-42-4991c99c7f65952bddb545700afa6667-4c4f5.png 400w,\n/static/2021-06-22-17-29-42-4991c99c7f65952bddb545700afa6667-b1c4a.png 562w"\n        sizes="(max-width: 562px) 100vw, 562px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="65731039585933650000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// 设置新生代内存中单个半空间的内存最小值，单位 MB\nnode --min-semi-space-size=1024 xxx.js\n\n// 设置新生代内存中单个半空间的内存最大值，单位 MB\nnode --max-semi-space-size=1024 xxx.js\n\n// 设置老生代内存最大值，单位 MB\nnode --max-old-space-size=2048 xxx.js`, `65731039585933650000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                data-tooltip="复制"\n              >\n                <svg class="gatsby-code-button-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M16 1H2v16h2V3h12V1zm-1 4l6 6v12H6V5h9zm-1 7h5.5L14 6.5V12z"/></svg>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="bash"><pre style="counter-reset: linenumber NaN" class="language-bash line-numbers"><code class="language-bash">// 设置新生代内存中单个半空间的内存最小值，单位 MB\nnode --min-semi-space-size<span class="token operator">=</span><span class="token number">1024</span> xxx.js\n\n// 设置新生代内存中单个半空间的内存最大值，单位 MB\nnode --max-semi-space-size<span class="token operator">=</span><span class="token number">1024</span> xxx.js\n\n// 设置老生代内存最大值，单位 MB\nnode --max-old-space-size<span class="token operator">=</span><span class="token number">2048</span> xxx.js</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>通过以上方法便可以手动放宽 V8 引擎所使用的内存限制，同时 node 也为我们提供了 process.memoryUsage() 方法来让我们可以查看当前 node 进程所占用的实际内存大小。</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-06-22-17-30-25-d1e74165cfd807b82f95e75395e7900b-0d2ef.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 561px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 13.547237076648841%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAIAAAAcOLh5AAAACXBIWXMAAA7DAAAOwwHHb6hkAAAARUlEQVQI12NQkJdXURLV0pSSkRaXkpTm5OBgYGBgBEJigJKSopychJQUu4oqs4AAMwNJQEdHV0ZGUV6eXUGRg5OTgyS9ADoyBMcr+JAYAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 06 22 17 30 25"\n        title=""\n        src="/static/2021-06-22-17-30-25-d1e74165cfd807b82f95e75395e7900b-0d2ef.png"\n        srcset="/static/2021-06-22-17-30-25-d1e74165cfd807b82f95e75395e7900b-77ffd.png 200w,\n/static/2021-06-22-17-30-25-d1e74165cfd807b82f95e75395e7900b-5ea91.png 400w,\n/static/2021-06-22-17-30-25-d1e74165cfd807b82f95e75395e7900b-0d2ef.png 561w"\n        sizes="(max-width: 561px) 100vw, 561px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>在上图中，包含的几个字段的含义分别如下所示，单位均为字节：</p>\n<ul>\n<li>heapTotal：表示 V8 当前申请到的堆内存总大小。</li>\n<li>heapUsed：表示当前内存使用量。</li>\n<li>external：表示 V8 内部的 C++ 对象所占用的内存。</li>\n<li>rss(resident set size)：表示驻留集大小，是给这个 node 进程分配了多少物理内存，这些物理内存中包含堆，栈和代码片段。对象，闭包等存于堆内存，变量存于栈内存，实际的 JavaScript 源代码存于代码段内存。使用 Worker 线程时，rss 将会是一个对整个进程有效的值，而其他字段则只针对当前线程。</li>\n</ul>\n<blockquote>\n<p>在 JS 中声明对象时，该对象的内存就分配在堆中，如果当前已申请的堆内存已经不够分配新的对象，则会继续申请堆内存直到堆的大小超过 V8 的限制为止。</p>\n</blockquote>\n<h1 id="v8-的垃圾回收策略"><a href="#v8-%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>V8 的垃圾回收策略</h1>\n<p>V8 的垃圾回收策略主要是基于分代式垃圾回收机制，其根据对象的存活时间将内存的垃圾回收进行不同的分代，然后对不同的分代采用不同的垃圾回收算法。</p>\n<h2 id="v8-的内存结构"><a href="#v8-%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>V8 的内存结构</h2>\n<p>在 V8 引擎的堆结构组成中，其实除了新生代和老生代外，还包含其他几个部分，但是垃圾回收的过程主要出现在新生代和老生代，所以对于其他的部分我们没必要做太多的深入，V8 的内存结构主要由以下几个部分组成：</p>\n<ul>\n<li>新生代(new_space)：大多数的对象开始都会被分配在这里，这个区域相对较小但是垃圾回收特别频繁，该区域被分为两半，一半用来分配内存，另一半用于在垃圾回收时将需要保留的对象复制过来。</li>\n<li>老生代(old_space)：新生代中的对象在存活一段时间后就会被转移到老生代内存区，相对于新生代该内存区域的垃圾回收频率较低。老生代又分为老生代指针区和老生代数据区，前者包含大多数可能存在指向其他对象的指针的对象，后者只保存原始数据对象，这些对象没有指向其他对象的指针。</li>\n<li>大对象区(large<em>object</em>space)：存放体积超越其他区域大小的对象，每个对象都会有自己的内存，垃圾回收不会移动大对象区。</li>\n<li>代码区(code_space)：代码对象，会被分配在这里，唯一拥有执行权限的内存区域。</li>\n<li>map 区(map_space)：存放 Cell 和 Map，每个区域都是存放相同大小的元素，结构简单。</li>\n</ul>\n<p>内存结构图如下所示：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-06-22-17-31-50-e500357a5389ed9f85c5e0133c822ec1-787fb.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 720px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 112.22222222222223%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAWCAIAAABPIytRAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAD8klEQVQ4y4WUiVNaRxjA+R/bZoxGCB418WhFE2IY40w6GQ9AgSQar1g84kF0WquAwAOPhApPUI5UOUQeh3gQ5e279r0nat8zY2KTTjvzm52d3e+3++03uyuhKObtwq5xJlxZ++t3FSNdisGVunZrTfvSvXaktqNteL50wiYzmqWjVqlxUWa0yowW+bj9zugSih1KCJLpGw09H/YrlKbqxpkXrePuFr3rgWH5oWFVaeiaWKqetFe9MlUNzVUN/VY5MFc1MFtvct2fcW6lj0W5Z8CnG0A7deY29cKYxuRQdFl+Vpt/6kSatB1GS+WM68cp5P40UjftrJ1y1k47aqedNZP2zfShhCRhu36107CiNZhbO0xvdLNz99oma56MVavmG56N/OF+thpSLwd+QTZbrD6V1f9YaC0+pRkN5U7FnQ1DoRevA7o+R2evc7JndrVZizR3u66YQbYGwtmRAKZ+H1Xa/3qMbKucEQElshM6IkRZPxx8+XrL0G/r6LVP9rxdae5yNKmRJrWrWTNlQ/sCWL838mR+tWHKqTCtqJBwq+NDiz0cOsQlgISdr3a0/dvql++eGtaMXfPO+m5rXc9SXY+9XjdqD+uC+V7/wdM1rMESb7QlFPY9gQZbYvOQlDA06XYuvLNNrC3olxef+35XR8ZU21fsjKv87kH35hvP5rgLNZrdI5ZrFt8P7ecxCc8WipiG22mEgVtssIwJltFh6Wegr5T1lkC0hPOV8P7P3OZ93/MfUQkHcSKmB8FHOCrFNyrwDTm+cfcLaAXurfxE4SYeGZP3C3KBihuIsBKg5WCjAmzIb0KgcsIrB19TATzlMO+T8BCnBTn0CHik4uiNoJM/5afr8sL6/8g6MqT8Vo6Yy7cXypMOqZgFehMh7ErmWCFtHQg9/FYWOEVlBe9d4PsK4UR3rmSICzIR/DcZleM+GY7+p0zH9YSYtgx4K6/8a4RS+4SCy8XofyDU9frMVExDBBS4+xZYLwPrpV/wlAK0BPfcBt7bAL1JKfD+APOocElIOjNH7Q3SMQ0V0dKfiHZTEQ0d1QrrMnEtHdeIszGN2IlryKiajLRDPCrh+bOz4iVNwpPsMSCZAqBwgv5YAAQJhT5B0un9k6M8QVKM8IRwQAmDLHfO8Rccfy7K3NklcUIex7Pp3EE0lkhlDiLRSDa3H08k95Kp8E46lTnZTWJYKp1IJHcTKcgW+bNLwZdcXJxjGTyVw9MHuSSWxdKZeDIHjkI8tZfaP8Yy2WQyheWOPuTJ48OjTCaXTu/HY7uFAlksXoo7s+w5wxVpyJIMJClIUCwDGY7naMgRDAQUpCBPcWcMZIXfkiIhTbMsV+T5i78BGO3U4Mn0OZIAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 06 22 17 31 50"\n        title=""\n        src="/static/2021-06-22-17-31-50-e500357a5389ed9f85c5e0133c822ec1-787fb.png"\n        srcset="/static/2021-06-22-17-31-50-e500357a5389ed9f85c5e0133c822ec1-4591d.png 200w,\n/static/2021-06-22-17-31-50-e500357a5389ed9f85c5e0133c822ec1-bf018.png 400w,\n/static/2021-06-22-17-31-50-e500357a5389ed9f85c5e0133c822ec1-787fb.png 720w"\n        sizes="(max-width: 720px) 100vw, 720px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>上图中的带斜纹的区域代表暂未使用的内存，新生代(new_space)被划分为了两个部分，其中一部分叫做 inactive new space，表示暂未激活的内存区域，另一部分为激活状态，为什么会划分为两个部分呢，在下一小节我们会讲到。</p>\n<h2 id="新生代"><a href="#%E6%96%B0%E7%94%9F%E4%BB%A3" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>新生代</h2>\n<p>在 V8 引擎的内存结构中，新生代主要用于存放存活时间较短的对象。新生代内存是由两个 semispace(半空间) 构成的，内存最大值在 64 位系统和 32 位系统上分别为 32MB 和 16MB，在新生代的垃圾回收过程中主要采用了 Scavenge 算法。</p>\n<p>Scavenge 算法是一种典型的牺牲空间换取时间的算法，对于老生代内存来说，可能会存储大量对象，如果在老生代中使用这种算法，势必会造成内存资源的浪费，但是在新生代内存中，大部分对象的生命周期较短，在时间效率上表现可观，所以还是比较适合这种算法。</p>\n<blockquote>\n<p>在 Scavenge 算法的具体实现中，主要采用了 Cheney 算法，它将新生代内存一分为二，每一个部分的空间称为 semispace，也就是我们在上图中看见的 new_space 中划分的两个区域，其中处于激活状态的区域我们称为 From 空间，未激活(inactive new space)的区域我们称为 To 空间。这两个空间中，始终只有一个处于使用状态，另一个处于闲置状态。我们的程序中声明的对象首先会被分配到 From 空间，当进行垃圾回收时，如果 From 空间中尚有存活对象，则会被复制到 To 空间进行保存，非存活的对象会被自动回收。当复制完成后，From 空间和 To 空间完成一次角色互换，To 空间会变为新的 From 空间，原来的 From 空间则变为 To 空间。</p>\n</blockquote>\n<p>基于以上算法，我们可以画出如下的流程图：</p>\n<ul>\n<li>假设我们在 From 空间中分配了三个对象 A、B、C \n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-06-22-17-33-00-f8017c4fbad5670beaeadd13c4272b70-571e1.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 584px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 23.972602739726025%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAIAAADKYVtkAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAA8UlEQVQY023IwUrDQBgE4NGAIPgEgifZBZ9Dr7VKYw+ePCqKemgfqbXdKvtHD4r8HtQo1KOP0N1rNWm0oRtjrQEhB4ePYRhM/+IyN0qTsUun/yXLv+PUjV1ePnFmwq7tz7RM2B48dsyDsqGyT8reKztQNld2oqzrWtc2k06xe9a1jHseZsBF1Qvqc7QzT9vQPnSlUIVeh1bQX9BD6OgXFXTkzbr37vc/AF1butpdCOqLlzWQD6qANkFboA2QAuWgN1Bc5gUxziP/5RMrt4eCG4Kbq3wq+UTwvuADwUeC9yRfS84lx5KTsrW7ZPlmdPya/gBoj8I7P9GDxQAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 06 22 17 33 00"\n        title=""\n        src="/static/2021-06-22-17-33-00-f8017c4fbad5670beaeadd13c4272b70-571e1.png"\n        srcset="/static/2021-06-22-17-33-00-f8017c4fbad5670beaeadd13c4272b70-2fa92.png 200w,\n/static/2021-06-22-17-33-00-f8017c4fbad5670beaeadd13c4272b70-52932.png 400w,\n/static/2021-06-22-17-33-00-f8017c4fbad5670beaeadd13c4272b70-571e1.png 584w"\n        sizes="(max-width: 584px) 100vw, 584px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </li>\n<li>当程序主线程任务第一次执行完毕后进入垃圾回收时，发现对象 A 已经没有其他引用，则表示可以对其进行回收 \n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-06-22-17-33-20-2f6165964bc33e840bb4189e0d8025af-571e1.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 584px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 25.34246575342466%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAIAAADKYVtkAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABCUlEQVQY02WLPUsDQRiEX2UvsbcUG5tFbGws8gsUCShREYNYK4KC/iqL9WTPQmW3UBA0RCG5FCoKJkWwMN6+d5fPW3dNlIjg8DDMDAzYoYwx7aSD7ainE/tPxti4q7Gj/45gW09h9FDGt5KqFz+qN++P98FLBWs+vvoD7/qo+5RRFxq920byU0tKP8efYO9mz+TECN9K8/yYt5Hy8g5fIXyV8Bzhm4TXCI8JDwhXKQ/THn4HBW6QuYzAFmdOL8bhZN1xlx13CVgW2AKwRWDzwHLAqsCawBQwHDqOHiMcqTnZP1eyV9eZKXlIxT4VewPkDpW7VGxTcUBFnYoWFSEV0S/TIpo8D9cKzS/O+8qx0Wz9lAAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 06 22 17 33 20"\n        title=""\n        src="/static/2021-06-22-17-33-20-2f6165964bc33e840bb4189e0d8025af-571e1.png"\n        srcset="/static/2021-06-22-17-33-20-2f6165964bc33e840bb4189e0d8025af-2fa92.png 200w,\n/static/2021-06-22-17-33-20-2f6165964bc33e840bb4189e0d8025af-52932.png 400w,\n/static/2021-06-22-17-33-20-2f6165964bc33e840bb4189e0d8025af-571e1.png 584w"\n        sizes="(max-width: 584px) 100vw, 584px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </li>\n<li>对象 B 和对象 C 此时依旧处于活跃状态，因此会被复制到 To 空间中进行保存 \n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-06-22-17-33-35-532bf93b525ee571272d1f5bf6026881-571e1.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 584px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 34.24657534246575%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAIAAACHqfpvAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABH0lEQVQY022Qv0vDQBiGv4oKLU76J0nVJorxB/a/ERUUcXLVtIODLtK7tJMNHQTNZauTIC65DB3UCmm0TS6Xu9hEBxv68PAN78e7vJD8ImUUMz/4CjlLpsF47I0iLuT/EHq960v6WKMPF8697nR0x6zTTqapO+9XlN+6/o070inTnbBGwzplNTe9zwMO7fYi4L0C3ilgDdAWIAWQCmgd0Apgu2iMisZbCfcBeTnPXwO4M5dmmtVZvD1vaNDYBFT56zfKc4a90ApKzX4RfwIaTJqVn7rVZetsjZyuWscqOamQA4UcVsiRSvbL1suGFWjkY9f2FPs7Z6vHIB1LJCIzh5AyllKmDzl1RZDjoRMZCeGHfBjFk4ohFz6LZdbOOeYHsMw+uzrT6Q8AAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 06 22 17 33 35"\n        title=""\n        src="/static/2021-06-22-17-33-35-532bf93b525ee571272d1f5bf6026881-571e1.png"\n        srcset="/static/2021-06-22-17-33-35-532bf93b525ee571272d1f5bf6026881-2fa92.png 200w,\n/static/2021-06-22-17-33-35-532bf93b525ee571272d1f5bf6026881-52932.png 400w,\n/static/2021-06-22-17-33-35-532bf93b525ee571272d1f5bf6026881-571e1.png 584w"\n        sizes="(max-width: 584px) 100vw, 584px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </li>\n<li>接下来将 From 空间中的所有非存活对象全部清除 \n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-06-22-17-33-52-9726ff4c9a383916935205fc1e8700ef-571e1.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 584px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 23.972602739726025%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAIAAADKYVtkAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAA/UlEQVQY023LP0vDQBgG8JdGF6X4LVwczGFXBRFEUOvSD+HgoA5+GKm9ditW7xKc1Jg3o+5+gOS2Ev8kvdR4ucZ6DQgKPvyG533hgelP9ETLzywv8ul/mZRfaV58FOXvJ7Qjryt8KvyL8N7oRB6dnUjFHY3CniiZkAMx7grVDlUnUlSonlDnocJYA1xt1/g+sF3gxt6M6awJbBN4f57rRWe44MQWfwOeAk+AJZYpl++txwzgeqfmNMHs/zgAvjXn9pdudN2N6+5rNR5V+9RyUhgkracxrDwcETyx8ZhU7ArBU4KHq3i75usNHK4HL41gZGNGUBqNQC578uw5/wZY0MHuZAOPuwAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 06 22 17 33 52"\n        title=""\n        src="/static/2021-06-22-17-33-52-9726ff4c9a383916935205fc1e8700ef-571e1.png"\n        srcset="/static/2021-06-22-17-33-52-9726ff4c9a383916935205fc1e8700ef-2fa92.png 200w,\n/static/2021-06-22-17-33-52-9726ff4c9a383916935205fc1e8700ef-52932.png 400w,\n/static/2021-06-22-17-33-52-9726ff4c9a383916935205fc1e8700ef-571e1.png 584w"\n        sizes="(max-width: 584px) 100vw, 584px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </li>\n<li>此时 From 空间中的内存已经清空，开始和 To 空间完成一次角色互换 \n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-06-22-17-34-05-dfb5e2816d2666ed74381a7d779e1c1f-571e1.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 584px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 24.315068493150687%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAIAAADKYVtkAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAA4klEQVQY02P4DwO/f//++O3z379//2MB/378/vPh+++vP/8gizKsenJ07dPjQARkrHpyZM2TYxDu2qdHVj99veHZnz3PPm979m35k58rnvxc/eTn2mcgtOrpz+uf/jIwrPVgWu/PsN4XhDb4gRlAEijixrB+H8fGH9wbX/FseMO44QMDBK3/wLT+A8Pa983XvzMwrPNk2uAP0oaCAhg2uLFt2i+w+Sff5nc8G9+CNX+EICYgue4jSLPUjgTlXWmKu1JREVAkTmHXCY1dPwx2v9Df9Vp51yclGAKypXd8mnrnOwDyl8LlqpLmtQAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 06 22 17 34 05"\n        title=""\n        src="/static/2021-06-22-17-34-05-dfb5e2816d2666ed74381a7d779e1c1f-571e1.png"\n        srcset="/static/2021-06-22-17-34-05-dfb5e2816d2666ed74381a7d779e1c1f-2fa92.png 200w,\n/static/2021-06-22-17-34-05-dfb5e2816d2666ed74381a7d779e1c1f-52932.png 400w,\n/static/2021-06-22-17-34-05-dfb5e2816d2666ed74381a7d779e1c1f-571e1.png 584w"\n        sizes="(max-width: 584px) 100vw, 584px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </li>\n<li>当程序主线程在执行第二个任务时，在 From 空间中分配了一个新对象 D \n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-06-22-17-34-18-9d784133a4d66dd33c7d1041f7949f0f-571e1.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 584px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 24.315068493150687%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAIAAADKYVtkAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAA8UlEQVQY02WLzUrDQBSFL1koKhG1PztxLV35FAU32p24se/i3keJM0mTuXUTXLiQ6NaFICJIZmJJm4yxY/PTNKUUWzx8HO498EG5TJqlo7HMi6L8l2k5/cmKkcq+J/nqDg73UDxX2Nyz/EfGnxYvCo+JsC8yN0juA3nHE8dXPX+CIq1wePqW5ADGqUbOgZzNocuDdIC0gbjbVO3Qrxr90M3BFh0CiYFEGonAiK5fxuvyHx24bW+Y7l7vV7fCuvm5bw03yUKOtaqNeC7r9mWTdevsap1ug10cOA+HTLVQnOD7MQZHGNZQNlA2mdy15c2rmgHmKMMDEqw7bAAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 06 22 17 34 18"\n        title=""\n        src="/static/2021-06-22-17-34-18-9d784133a4d66dd33c7d1041f7949f0f-571e1.png"\n        srcset="/static/2021-06-22-17-34-18-9d784133a4d66dd33c7d1041f7949f0f-2fa92.png 200w,\n/static/2021-06-22-17-34-18-9d784133a4d66dd33c7d1041f7949f0f-52932.png 400w,\n/static/2021-06-22-17-34-18-9d784133a4d66dd33c7d1041f7949f0f-571e1.png 584w"\n        sizes="(max-width: 584px) 100vw, 584px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </li>\n<li>任务执行完毕后再次进入垃圾回收，发现对象 D 已经没有其他引用，表示可以对其进行回收 \n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-06-22-17-34-36-959fd55b7df97865b42353996491ecc0-571e1.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 584px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 24.315068493150687%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAIAAADKYVtkAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABAUlEQVQY02P4DwO/f//++O3T379//2OAP//+v/71/933P99+/UEWZ1j15Ojap8eBCMhY9eTImifHINy1T4+sfvp647Nf25/9uP/y7O+Xq7Y9ebf8yZ91T3+uffZr1dNfNz79YWBY68G03p9hvS8IbfADM4AkUMSNYf0+no1fGDb87NmZ9f8Qg/bmMwzrfzKtf8+0/iPD2o8t178zMKzzZNrgD9KGggIYNrixbdovvPkrw8bfPbvz/x9m1d50mmH9L6YN75k2fGRY97HlxncGqR0JyrvSFHeloiKgSJzizuPau74o7vo691DN/xNy7nsvS+76qbLrg/KuT9I7Pk298wMAM/vDh7TLzdUAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 06 22 17 34 36"\n        title=""\n        src="/static/2021-06-22-17-34-36-959fd55b7df97865b42353996491ecc0-571e1.png"\n        srcset="/static/2021-06-22-17-34-36-959fd55b7df97865b42353996491ecc0-2fa92.png 200w,\n/static/2021-06-22-17-34-36-959fd55b7df97865b42353996491ecc0-52932.png 400w,\n/static/2021-06-22-17-34-36-959fd55b7df97865b42353996491ecc0-571e1.png 584w"\n        sizes="(max-width: 584px) 100vw, 584px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </li>\n<li>对象 B 和对象 C 此时依旧处于活跃状态，再次被复制到 To 空间中进行保存 \n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-06-22-17-35-11-e67af06ef83021cdef540c743494d024-571e1.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 584px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 33.9041095890411%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAIAAACHqfpvAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABRElEQVQY023QzUoCURjG8RctKKRF61yKFEGrClq2iYo+hC7BRRFto9p4AXUBXUQ4Hxbm6Exi2cbMTS2ioKXOoOU4OnNmzjlzToOQVPbnt3t2D/DvMMWmY1Gf8qF8xpuYfyDa9X6tUNCrJaNWNGrZxsNVvZJrPOb1mmIEqoreUg2i6d5764U2s6X6Z6bhFwwcuNbJa5fCiLgWkRMReROk7b6tvgRIKyDlJ2QbJC+lHPNbWLwsg0jCUjskdyBtHj0jCAur43JiTFoH4acNEJZHpdxkxgERp3In/A4W5BKkSVhoh8QOXJiHTwhm8sklbXf+Zi+m7scHtIO4loxp93OqM6ui8/Ipr0R3itUpFU+r5rRmRZXO2ZsLlo2snmO7roO9P3oudonvEeoHLzJCGSOMD/icQXCa6xGEqOf5QyjGxEaEMf5vX5/wO02KVqrnAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 06 22 17 35 11"\n        title=""\n        src="/static/2021-06-22-17-35-11-e67af06ef83021cdef540c743494d024-571e1.png"\n        srcset="/static/2021-06-22-17-35-11-e67af06ef83021cdef540c743494d024-2fa92.png 200w,\n/static/2021-06-22-17-35-11-e67af06ef83021cdef540c743494d024-52932.png 400w,\n/static/2021-06-22-17-35-11-e67af06ef83021cdef540c743494d024-571e1.png 584w"\n        sizes="(max-width: 584px) 100vw, 584px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </li>\n<li>再次将 From 空间中的所有非存活对象全部清除 \n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-06-22-17-35-24-54e071248ddf02c21edc35bb5abb15ab-571e1.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 584px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 24.315068493150687%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAIAAADKYVtkAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAA3ElEQVQY02XLQUrDQBQG4CddNUKFkhEP4M5ztLgQGxd1U7DewAt4JvOiSWYWltKlad3oIjeYTHFhOoXEJJPEGKIk+PPx+OHxQ/mbRKVhJFWuyn8piuIrU2Gc7pPOF5jwltvNQqztYG3zFxpsmHiteUx8MFEwkTKR2Tx95InDk6pX3CDzZQ498/zQMjS8BHMC+McAHAE+A2aAn4A7sGr446C6D7u79wj6eDF4mmpWe1m5Ahx3xi3N+C2GE+f6jM1O6Wzozol7ozdudXdK6IpQRWhIqGw7pvLIkfd+/A3OMMJ+pq0diAAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 06 22 17 35 24"\n        title=""\n        src="/static/2021-06-22-17-35-24-54e071248ddf02c21edc35bb5abb15ab-571e1.png"\n        srcset="/static/2021-06-22-17-35-24-54e071248ddf02c21edc35bb5abb15ab-2fa92.png 200w,\n/static/2021-06-22-17-35-24-54e071248ddf02c21edc35bb5abb15ab-52932.png 400w,\n/static/2021-06-22-17-35-24-54e071248ddf02c21edc35bb5abb15ab-571e1.png 584w"\n        sizes="(max-width: 584px) 100vw, 584px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </li>\n<li>From 空间和 To 空间继续完成一次角色互换 \n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-06-22-17-35-36-248fd62ae00932abd9aaca76d671adcf-571e1.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 584px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 24.315068493150687%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAIAAADKYVtkAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAA1klEQVQY02P4Dwb//v378fvH+28fv/36AeL+Rwc/fv99++3Xzz9/kQUZdr44deDlmb0vzmx6dnLTsxNbnp/e/uIsGJ3e8eLNjhf/drz4tePF723Pf29+9mv7899ANoR798tfBpb1ntybArg2+jJs8EdCAQwb3Bk27GPY8Ithw3uGDR+REROQXPex5cZ3Bs6NfjybQ4EkquZAsOb9DBt+49D8oeXGDwbJbRHaO6JVtkcLbosX3RYnAkXxItvCRbcfFd3+W3T7B9Htn5CR2PZPfFs/9t/+CQDeY8LYROTmQQAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 06 22 17 35 36"\n        title=""\n        src="/static/2021-06-22-17-35-36-248fd62ae00932abd9aaca76d671adcf-571e1.png"\n        srcset="/static/2021-06-22-17-35-36-248fd62ae00932abd9aaca76d671adcf-2fa92.png 200w,\n/static/2021-06-22-17-35-36-248fd62ae00932abd9aaca76d671adcf-52932.png 400w,\n/static/2021-06-22-17-35-36-248fd62ae00932abd9aaca76d671adcf-571e1.png 584w"\n        sizes="(max-width: 584px) 100vw, 584px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </li>\n</ul>\n<p>通过以上的流程图，我们可以很清楚地看到，Scavenge 算法的垃圾回收过程主要就是将存活对象在 From 空间和 To 空间之间进行复制，同时完成两个空间之间的角色互换，因此该算法的缺点也比较明显，浪费了一半的内存用于复制。</p>\n<h2 id="对象晋升"><a href="#%E5%AF%B9%E8%B1%A1%E6%99%8B%E5%8D%87" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>对象晋升</h2>\n<p>当一个对象在经过多次复制之后依旧存活，那么它会被认为是一个生命周期较长的对象，在下一次进行垃圾回收时，该对象会被直接转移到老生代中，这种对象从新生代转移到老生代的过程我们称之为晋升。</p>\n<p>对象晋升的条件主要有以下两个：</p>\n<ul>\n<li>对象是否经历过一次 Scavenge 算法</li>\n<li>To 空间的内存占比是否已经超过 25%</li>\n</ul>\n<p>默认情况下，我们创建的对象都会分配在 From 空间中，当进行垃圾回收时，在将对象从 From 空间复制到 To 空间之前，会先检查该对象的内存地址来判断是否已经经历过一次 Scavenge 算法，如果地址已经发生变动则会将该对象转移到老生代中，不会再被复制到 To 空间，可以用以下的流程图来表示：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-06-22-17-38-03-5132fb1d614bd6aba9022cd968c15c8b-700d4.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 540px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 74.07407407407408%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAIAAABr+ngCAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABqElEQVQoz5VSS0tCQRT2DwT9iX5A1KpN1NaNiwJxE0QQLQoqWgjRQohqJYRlRAWS5SJEgiIqKrTS3mZWVvbU8oVdX/eq1ztzprla4oPMvjkMzJzzzTfnISFZAF2E3Ef2D/y6o4DB6l88D5kyKPnt/AWSQrLxcXjirHXaIddctk052uN8KO/6m7z5ptY65TpXz8JNl/6ul80wVZFzSApxqhbmfDE+wAoMACYVISk+iiIZnNeCAgfGIOQNAMrJYhgXuwXEVS5VibIYB6wTu4fQST12ygizQQDRS04Qd0/8wvQ4sv48vvYyvvqk8rG3P+RsbsBsgaUGzLXILkXWOrIjwa8qHgiTSgmYWP1G1XEjbcTMlWL0tMnF7BZ/GxDEDsGlwCcN2N5CgksEseJ19ml3xKa/71txK6kZHgY8CUdpziCGIj5qBVrq/+ScAxWBKE8S9LsEF1NpfXGBlVWbR8mkEAlywViaSaN4tX3OvbTj1cxdd+jv+nWubsPDICdEqhvPbNONbuXYafO8s1Ntl046ZIlM+B+zffO5vefVWj7mzO+zNv8y/9eofAHFKkK/3tdHPwAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 06 22 17 38 03"\n        title=""\n        src="/static/2021-06-22-17-38-03-5132fb1d614bd6aba9022cd968c15c8b-700d4.png"\n        srcset="/static/2021-06-22-17-38-03-5132fb1d614bd6aba9022cd968c15c8b-555fa.png 200w,\n/static/2021-06-22-17-38-03-5132fb1d614bd6aba9022cd968c15c8b-eb4c6.png 400w,\n/static/2021-06-22-17-38-03-5132fb1d614bd6aba9022cd968c15c8b-700d4.png 540w"\n        sizes="(max-width: 540px) 100vw, 540px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>如果对象没有经历过 Scavenge 算法，会被复制到 To 空间，但是如果此时 To 空间的内存占比已经超过 25%，则该对象依旧会被转移到老生代，如下图所示:</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-06-22-17-38-13-8d8e70e500ab9e2fb9b84d9218f2d765-cf31b.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 480px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 83.33333333333334%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAIAAABSJhvpAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAB4klEQVQ4y5VTzUsbQRTPVaR/gr37H3jopUoL6tWDBz8qKRS8+HFS/wOVaC8VmjSBUtKSSiuo+AkmQTC2um5Ndm1XEtpYw7abjYkxrsnOvDedaCIJhroZfjAzb95v3u+9x7MhQ8ZYLPNF0BZEbVlMLgp/P59kw9x48/SfZUMGfJuPTjgO2uci3W+kAYfYsR6fKZIRLJE/RsdmxHaX1OeW7LNi53rcYZFc1Kakt0Pq+5Dq21V9IdX781ywJLvyQoDRe/xrkQEJIjWAFXg4JIDUOrkU7kpbLZwFy5YKDTx7BA4so1p2dg++98JuM3xtwegou5RLZpPwP5JGzKsMe5WRD8ooh/fHUDqfKJFRdeOWDQONVOyk37rQ/4AFGqi+lEemG0aBsuPM4ZTw9NVh11t50BnpnxJaNSNWjkwvWXIRxUew8xB2mjD8hJ1tIeQBS91K5BSX/MwjD3iOnnuO7E6pL3V1Up0zEvLnHSQX7haGIsmZqQszlbvGhanzAldW2+Q+BmUZwn+iAKSOVt2sAmHn+ZpuiNW4JRdPv7KCpK/sa2thfSOiryZych2D8Sk6Pi20OaXe15Geyf3Hm/HZOgaDk/lgeOQXbtk+fdC2GX9Zx2Bwqf7fc8FTZ/DUxQ/H6W0rsv8Bj0aod/QbzHgAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 06 22 17 38 13"\n        title=""\n        src="/static/2021-06-22-17-38-13-8d8e70e500ab9e2fb9b84d9218f2d765-cf31b.png"\n        srcset="/static/2021-06-22-17-38-13-8d8e70e500ab9e2fb9b84d9218f2d765-ad6a6.png 200w,\n/static/2021-06-22-17-38-13-8d8e70e500ab9e2fb9b84d9218f2d765-552c4.png 400w,\n/static/2021-06-22-17-38-13-8d8e70e500ab9e2fb9b84d9218f2d765-cf31b.png 480w"\n        sizes="(max-width: 480px) 100vw, 480px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>之所以有 25% 的内存限制是因为 To 空间在经历过一次 Scavenge 算法后会和 From 空间完成角色互换，会变为 From 空间，后续的内存分配都是在 From 空间中进行的，如果内存使用过高甚至溢出，则会影响后续对象的分配，因此超过这个限制之后对象会被直接转移到老生代来进行管理。</p>\n<h2 id="老生代"><a href="#%E8%80%81%E7%94%9F%E4%BB%A3" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>老生代</h2>\n<p>在老生代中，因为管理着大量的存活对象，如果依旧使用 Scavenge 算法的话，很明显会浪费一半的内存，因此已经不再使用 Scavenge 算法，而是采用新的算法 Mark-Sweep(标记清除) 和 Mark-Compact(标记整理) 来进行管理。</p>\n<p>在早前我们可能听说过一种算法叫做引用计数，该算法的原理比较简单，就是看对象是否还有其他引用指向它，如果没有指向该对象的引用，则该对象会被视为垃圾并被垃圾回收器回收，示例如下：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="27312465797501616000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// 创建了两个对象 obj1 和 obj2，其中 obj2 作为 obj1 的属性被 obj1 引用，因此不会被垃圾回收\nlet obj1 = {\n  obj2: {\n    a: 1\n  }\n};\n\n// 创建 obj3 并将 obj1 赋值给 obj3，让两个对象指向同一个内存地址\nlet obj3 = obj1;\n\n// 将 obj1 重新赋值，此时原来 obj1 指向的对象现在只由 obj3 来表示\nobj1 = null;\n\n// 创建 obj4 并将 obj3.obj2 赋值给 obj4\n// 此时 obj2 所指向的对象有两个引用：一个是作为 obj3 的属性，另一个是变量 obj4\nlet obj4 = obj3.obj2;\n\n// 将 obj3 重新赋值，此时本可以对 obj3 指向的对象进行回收，但是因为 obj3.obj2 被 obj4 所引用，因此依旧不能被回收\nobj3 = null;\n\n// 此时 obj3.obj2 已经没有指向它的引用，因此 obj3 指向的对象在此时可以被回收\nobj4 = null;`, `27312465797501616000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                data-tooltip="复制"\n              >\n                <svg class="gatsby-code-button-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M16 1H2v16h2V3h12V1zm-1 4l6 6v12H6V5h9zm-1 7h5.5L14 6.5V12z"/></svg>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">// 创建了两个对象 obj1 和 obj2，其中 obj2 作为 obj1 的属性被 obj1 引用，因此不会被垃圾回收</span>\n<span class="token keyword">let</span> obj1 <span class="token operator">=</span> <span class="token punctuation">{</span>\n  obj2<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n    a<span class="token punctuation">:</span> <span class="token number">1</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n<span class="token comment">// 创建 obj3 并将 obj1 赋值给 obj3，让两个对象指向同一个内存地址</span>\n<span class="token keyword">let</span> obj3 <span class="token operator">=</span> obj1<span class="token punctuation">;</span>\n\n<span class="token comment">// 将 obj1 重新赋值，此时原来 obj1 指向的对象现在只由 obj3 来表示</span>\nobj1 <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n\n<span class="token comment">// 创建 obj4 并将 obj3.obj2 赋值给 obj4</span>\n<span class="token comment">// 此时 obj2 所指向的对象有两个引用：一个是作为 obj3 的属性，另一个是变量 obj4</span>\n<span class="token keyword">let</span> obj4 <span class="token operator">=</span> obj3<span class="token punctuation">.</span>obj2<span class="token punctuation">;</span>\n\n<span class="token comment">// 将 obj3 重新赋值，此时本可以对 obj3 指向的对象进行回收，但是因为 obj3.obj2 被 obj4 所引用，因此依旧不能被回收</span>\nobj3 <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n\n<span class="token comment">// 此时 obj3.obj2 已经没有指向它的引用，因此 obj3 指向的对象在此时可以被回收</span>\nobj4 <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>上述例子在经过一系列操作后最终对象会被垃圾回收，但是一旦我们碰到循环引用的场景，就会出现问题，我们看下面的例子：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="97844187817338630000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function foo() {\n  let a = {};\n  let b = {};\n  a.a1 = b;\n  b.b1 = a;\n}\nfoo();`, `97844187817338630000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                data-tooltip="复制"\n              >\n                <svg class="gatsby-code-button-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M16 1H2v16h2V3h12V1zm-1 4l6 6v12H6V5h9zm-1 7h5.5L14 6.5V12z"/></svg>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\n  <span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\n  a<span class="token punctuation">.</span>a1 <span class="token operator">=</span> b<span class="token punctuation">;</span>\n  b<span class="token punctuation">.</span>b1 <span class="token operator">=</span> a<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>这个例子中我们将对象 a 的 a1 属性指向对象 b，将对象 b 的 b1 属性指向对象 a，形成两个对象相互引用，在 foo 函数执行完毕后，函数的作用域已经被销毁，作用域中包含的变量 a 和 b 本应该可以被回收，但是因为采用了引用计数的算法，两个变量均存在指向自身的引用，因此依旧无法被回收，导致内存泄漏。</p>\n<p>因此为了避免循环引用导致的内存泄漏问题，截至 2012 年所有的现代浏览器均放弃了这种算法，转而采用新的 Mark-Sweep(标记清除) 和 Mark-Compact(标记整理) 算法。在上面循环引用的例子中，因为变量 a 和变量 b 无法从 window 全局对象访问到，因此无法对其进行标记，所以最终会被回收。</p>\n<p>Mark-Sweep(标记清除) 分为标记和清除两个阶段，在标记阶段会遍历堆中的所有对象，然后标记活着的对象，在清除阶段中，会将死亡的对象进行清除。Mark-Sweep 算法主要是通过判断某个对象是否可以被访问到，从而知道该对象是否应该被回收，具体步骤如下：</p>\n<ul>\n<li>垃圾回收器会在内部构建一个根列表，用于从根节点出发去寻找那些可以被访问到的变量。比如在 JavaScript 中，window 全局对象可以看成一个根节点。</li>\n<li>然后，垃圾回收器从所有根节点出发，遍历其可以访问到的子节点，并将其标记为活动的，根节点不能到达的地方即为非活动的，将会被视为垃圾。</li>\n<li>最后，垃圾回收器将会释放所有非活动的内存块，并将其归还给操作系统。</li>\n</ul>\n<blockquote>\n<p>以下几种情况都可以作为根节点：</p>\n<ol>\n<li>全局对象</li>\n<li>本地函数的局部变量和参数</li>\n<li>当前嵌套调用链上的其他函数的变量和参数</li>\n</ol>\n</blockquote>\n<p><img src="/static/mark-and-sweep-4001ac135e9b2a0b54eae529b54de40b.gif"></p>\n<p>但是 Mark-Sweep 算法存在一个问题，就是在经历过一次标记清除后，内存空间可能会出现不连续的状态，因为我们所清理的对象的内存地址可能不是连续的，所以就会出现内存碎片的问题，导致后面如果需要分配一个大对象而空闲内存不足以分配，就会提前触发垃圾回收，而这次垃圾回收其实是没必要的，因为我们确实有很多空闲内存，只不过是不连续的。</p>\n<p>为了解决这种内存碎片的问题，Mark-Compact(标记整理) 算法被提了出来，该算法主要就是用来解决内存的碎片化问题的，回收过程中将死亡对象清除后，在整理的过程中，会将活动的对象往堆内存的一端进行移动，移动完成后再清理掉边界外的全部内存，我们可以用如下流程图来表示：</p>\n<ul>\n<li>假设在老生代中有 A、B、C、D 四个对象 \n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-06-22-17-42-58-02146b35347e02606a5aa6bdcca1c15f-571e1.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 584px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 24.315068493150687%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAIAAADKYVtkAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAAvUlEQVQY02P4jwN8+fnn+68/f//9+48bMKx6embNs3NrnkLQqbVPH6999nvds+9LHn1b9PDbqqc/1j37sRYDAcWvf/rNwLA2kHljGOP6UMYNIUwbfBjWz2NY/4th/TuGDR9AaD0WxAQk135ovv6NgWF9IPemSLaNYeybQnk2+zNvmM+w4TfDhvcMGz7iQkxAct1HkGbJ7dmKOwvkd+Yr7MyV35GmuHOt8q5fyrs+KO/6hAup7Poks+PTlDvfAdL8yzJg2bK4AAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 06 22 17 42 58"\n        title=""\n        src="/static/2021-06-22-17-42-58-02146b35347e02606a5aa6bdcca1c15f-571e1.png"\n        srcset="/static/2021-06-22-17-42-58-02146b35347e02606a5aa6bdcca1c15f-2fa92.png 200w,\n/static/2021-06-22-17-42-58-02146b35347e02606a5aa6bdcca1c15f-52932.png 400w,\n/static/2021-06-22-17-42-58-02146b35347e02606a5aa6bdcca1c15f-571e1.png 584w"\n        sizes="(max-width: 584px) 100vw, 584px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </li>\n<li>在垃圾回收的标记阶段，将对象 A 和对象 C 标记为活动的 \n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-06-22-17-43-11-8ba8a885a323c9afe3d52c7ccb040825-571e1.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 584px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 24.315068493150687%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAIAAADKYVtkAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAAyUlEQVQY02P4jwF+//33+cfvn7//fvv55823X99+/fmPAzC8e7lx+dPzj1/u+PNq3Zqnh9Y+fbD66d9FD78vffRjyaMf8+4DyZ9rn/1CQ6ue/rr+6Q/Dyd2cDOsjVuyS/XaAlXmjC8P6+QzrfzNseM+w4SMCrUdBTEBy7cfma98YTu7hY9gUuWqPwpdDPLybPRg3LGTYgKEZFTEByXVgzRcPa4nuKNhy2PrHcTWlXQnyu9Yp7fqltOuD0q5PuJDyrk/SOz5NufMdAC9x0C83XvdEAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 06 22 17 43 11"\n        title=""\n        src="/static/2021-06-22-17-43-11-8ba8a885a323c9afe3d52c7ccb040825-571e1.png"\n        srcset="/static/2021-06-22-17-43-11-8ba8a885a323c9afe3d52c7ccb040825-2fa92.png 200w,\n/static/2021-06-22-17-43-11-8ba8a885a323c9afe3d52c7ccb040825-52932.png 400w,\n/static/2021-06-22-17-43-11-8ba8a885a323c9afe3d52c7ccb040825-571e1.png 584w"\n        sizes="(max-width: 584px) 100vw, 584px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </li>\n<li>在垃圾回收的整理阶段，将活动的对象往堆内存的一端移动 \n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-06-22-17-43-27-f2581df55e79c7e62233e8ef412aeef6-571e1.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 584px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 32.19178082191781%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAIAAABM9SnKAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABDElEQVQY03WQvU7DMBRGbymv0xkkWJB4nzLQpi1VAi/AyNQyVGzELrAw8CPEQodOyI4FKVSiZUwUCcVp7NgmCSpiKFdnuMN3pHs/MKtGZEoIaZSKuAi5MFqvjMHJe9amn7Z3ZrO5zYKu13OYf+DJFok7lFuENwnvetxhySHjbaYGL8xMO8nb0WLeh9pdCuejNbxbwU8V7K8Pt8C9BiQAh4CiAhz9LFUUgpvtXGLzAMkNpONNqN2n4I6qF6U8zOVtQKWMljL6lYNCvsLmERa3IMcbcDyR9edZkw4aZLZPggY9tahvUWnR2MrP/kOLxnsk6zGiJvWvVyf+6EP5edGH1kortexC/0eeSLWRJd96Tg9jQCpIhwAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 06 22 17 43 27"\n        title=""\n        src="/static/2021-06-22-17-43-27-f2581df55e79c7e62233e8ef412aeef6-571e1.png"\n        srcset="/static/2021-06-22-17-43-27-f2581df55e79c7e62233e8ef412aeef6-2fa92.png 200w,\n/static/2021-06-22-17-43-27-f2581df55e79c7e62233e8ef412aeef6-52932.png 400w,\n/static/2021-06-22-17-43-27-f2581df55e79c7e62233e8ef412aeef6-571e1.png 584w"\n        sizes="(max-width: 584px) 100vw, 584px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </li>\n<li>在垃圾回收的清除阶段，将活动对象左侧的内存全部回收 \n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-06-22-17-43-41-a1930246745280684fe2f5a24dada040-571e1.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 584px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 24.315068493150687%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAIAAADKYVtkAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAAtElEQVQY02P4jwH+/P335efvP3//fv7x++XX399///2PAzCsevpr7TMEWvfsF1Bk/v0fix/9mH//+4y73xY+/LEOKvtz1bN/b1/u+/96zY+XO39+vsPAsPYD0/qPDGhoAxB9AJEbP4FIkCBQ2TuG9b+P7LH+f5Dh+z6Wb7ebwJo3QFQTQEwb3oM073P8f5j55wH2b3eaGKR2fFLZ9VmJCKS866P0zr9nj4b8P6Hw+ZjGl/vTAAym1oKnkiXRAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 06 22 17 43 41"\n        title=""\n        src="/static/2021-06-22-17-43-41-a1930246745280684fe2f5a24dada040-571e1.png"\n        srcset="/static/2021-06-22-17-43-41-a1930246745280684fe2f5a24dada040-2fa92.png 200w,\n/static/2021-06-22-17-43-41-a1930246745280684fe2f5a24dada040-52932.png 400w,\n/static/2021-06-22-17-43-41-a1930246745280684fe2f5a24dada040-571e1.png 584w"\n        sizes="(max-width: 584px) 100vw, 584px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </li>\n</ul>\n<p>至此就完成了一次老生代垃圾回收的全部过程，我们在前文中说过，由于 JS 的单线程机制，垃圾回收的过程会阻碍主线程同步任务的执行，待执行完垃圾回收后才会再次恢复执行主任务的逻辑，这种行为被称为全停顿(stop-the-world)。在标记阶段同样会阻碍主线程的执行，一般来说，老生代会保存大量存活的对象，如果在标记阶段将整个堆内存遍历一遍，那么势必会造成严重的卡顿。</p>\n<p>因此，为了减少垃圾回收带来的停顿时间，V8 引擎又引入了 Incremental Marking(增量标记) 的概念，即将原本需要一次性遍历堆内存的操作改为增量标记的方式，先标记堆内存中的一部分对象，然后暂停，将执行权重新交给 JS 主线程，待主线程任务执行完毕后再从原来暂停标记的地方继续标记，直到标记完整个堆内存。这个理念其实有点像 React 框架中的 Fiber 架构，只有在浏览器的空闲时间才会去遍历 Fiber Tree 执行对应的任务，否则延迟执行，尽可能少地影响主线程的任务，避免应用卡顿，提升应用性能。</p>\n<p>得益于增量标记的好处，V8 引擎后续继续引入了延迟清理(lazy sweeping)和增量式整理(incremental compaction)，让清理和整理的过程也变成增量式的。同时为了充分利用多核 CPU 的性能，也将引入并行标记和并行清理，进一步地减少垃圾回收对主线程的影响，为应用提升更多的性能。</p>\n<h1 id="如何避免内存泄漏"><a href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>如何避免内存泄漏</h1>\n<p>在我们写代码的过程中，基本上都不太会关注写出怎样的代码才能有效地避免内存泄漏，或者说浏览器和大部分的前端框架在底层已经帮助我们处理了常见的内存泄漏问题，但是我们还是有必要了解一下常见的几种避免内存泄漏的方式，毕竟在面试过程中也是经常考察的要点。</p>\n<h2 id="尽可能少地创建全局变量"><a href="#%E5%B0%BD%E5%8F%AF%E8%83%BD%E5%B0%91%E5%9C%B0%E5%88%9B%E5%BB%BA%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>尽可能少地创建全局变量</h2>\n<p>在 ES5 中以 var 声明的方式在全局作用域中创建一个变量时，或者在函数作用域中不以任何声明的方式创建一个变量时，都会无形地挂载到 window 全局对象上，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="69971954848586960000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`var a = 1; // 等价于 window.a = 1;`, `69971954848586960000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                data-tooltip="复制"\n              >\n                <svg class="gatsby-code-button-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M16 1H2v16h2V3h12V1zm-1 4l6 6v12H6V5h9zm-1 7h5.5L14 6.5V12z"/></svg>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 等价于 window.a = 1;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="21869176801012523000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function foo() {\n  a = 1;\n}`, `21869176801012523000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                data-tooltip="复制"\n              >\n                <svg class="gatsby-code-button-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M16 1H2v16h2V3h12V1zm-1 4l6 6v12H6V5h9zm-1 7h5.5L14 6.5V12z"/></svg>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span></span></pre></div>\n<p>等价于</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="59026433393337310000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function foo() {\n  window.a = 1;\n}`, `59026433393337310000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                data-tooltip="复制"\n              >\n                <svg class="gatsby-code-button-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M16 1H2v16h2V3h12V1zm-1 4l6 6v12H6V5h9zm-1 7h5.5L14 6.5V12z"/></svg>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  window<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span></span></pre></div>\n<p>我们在 foo 函数中创建了一个变量 a 但是忘记使用 var 来声明，此时会意想不到地创建一个全局变量并挂载到 window 对象上，另外还有一种比较隐蔽的方式来创建全局变量：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="71039460150475660000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function foo() {\n  this.a = 1;\n}\nfoo(); // 相当于 window.foo()`, `71039460150475660000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                data-tooltip="复制"\n              >\n                <svg class="gatsby-code-button-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M16 1H2v16h2V3h12V1zm-1 4l6 6v12H6V5h9zm-1 7h5.5L14 6.5V12z"/></svg>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 相当于 window.foo()</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>当 foo 函数在调用时，它所指向的运行上下文环境为 window 全局对象，因此函数中的 this 指向的其实是 window，也就无意创建了一个全局变量。当进行垃圾回收时，在标记阶段因为 window 对象可以作为根节点，在 window 上挂载的属性均可以被访问到，并将其标记为活动的从而常驻内存，因此也就不会被垃圾回收，只有在整个进程退出时全局作用域才会被销毁。如果你遇到需要必须使用全局变量的场景，那么请保证一定要在全局变量使用完毕后将其设置为 null 从而触发回收机制。</p>\n<h2 id="手动清除定时器"><a href="#%E6%89%8B%E5%8A%A8%E6%B8%85%E9%99%A4%E5%AE%9A%E6%97%B6%E5%99%A8" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>手动清除定时器</h2>\n<p>在我们的应用中经常会有使用 setTimeout 或者 setInterval 等定时器的场景，定时器本身是一个非常有用的功能，但是如果我们稍不注意，忘记在适当的时间手动清除定时器，那么很有可能就会导致内存泄漏，示例如下：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="8019553951235969000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`const numbers = [];\nconst foo = function() {\n  for (let i = 0; i < 100000; i++) {\n    numbers.push(i);\n  }\n};\nwindow.setInterval(foo, 1000);`, `8019553951235969000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                data-tooltip="复制"\n              >\n                <svg class="gatsby-code-button-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M16 1H2v16h2V3h12V1zm-1 4l6 6v12H6V5h9zm-1 7h5.5L14 6.5V12z"/></svg>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">const</span> numbers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n<span class="token keyword">const</span> <span class="token function-variable function">foo</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    numbers<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\nwindow<span class="token punctuation">.</span><span class="token function">setInterval</span><span class="token punctuation">(</span>foo<span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>在这个示例中，由于我们没有手动清除定时器，导致回调任务会不断地执行下去，回调中所引用的 numbers 变量也不会被垃圾回收，最终导致 numbers 数组长度无限递增，从而引发内存泄漏。</p>\n<h2 id="少用闭包"><a href="#%E5%B0%91%E7%94%A8%E9%97%AD%E5%8C%85" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>少用闭包</h2>\n<p>闭包是 JS 中的一个高级特性，巧妙地利用闭包可以帮助我们实现很多高级功能。一般来说，我们在查找变量时，在本地作用域中查找不到就会沿着作用域链从内向外单向查找，但是闭包的特性可以让我们在外部作用域访问内部作用域中的变量，示例如下：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="20884041146423902000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function foo() {\n  let local = 123;\n  return function() {\n    return local;\n  };\n}\nconst bar = foo();\nconsole.log(bar()); // -> 123`, `20884041146423902000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                data-tooltip="复制"\n              >\n                <svg class="gatsby-code-button-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M16 1H2v16h2V3h12V1zm-1 4l6 6v12H6V5h9zm-1 7h5.5L14 6.5V12z"/></svg>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">let</span> local <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>\n  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> local<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">const</span> bar <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// -> 123</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>在这个示例中，foo 函数执行完毕后会返回一个匿名函数，该函数内部引用了 foo 函数中的局部变量 local，并且通过变量 bar 来引用这个匿名的函数定义，通过这种闭包的方式我们就可以在 foo 函数的外部作用域中访问到它的局部变量 local。一般情况下，当 foo 函数执行完毕后，它的作用域会被销毁，但是由于存在变量引用其返回的匿名函数，导致作用域无法得到释放，也就导致 local 变量无法回收，只有当我们取消掉对匿名函数的引用才会进入垃圾回收阶段。</p>\n<h2 id="清除-dom-引用"><a href="#%E6%B8%85%E9%99%A4-dom-%E5%BC%95%E7%94%A8" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>清除 DOM 引用</h2>\n<p>以往我们在操作 DOM 元素时，为了避免多次获取 DOM 元素，我们会将 DOM 元素存储在一个数据字典中，示例如下：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="14197480736252844000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`const elements = {\n  button: document.getElementById(\'button\')\n};\n\nfunction removeButton() {\n  document.body.removeChild(document.getElementById(\'button\'));\n}`, `14197480736252844000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                data-tooltip="复制"\n              >\n                <svg class="gatsby-code-button-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M16 1H2v16h2V3h12V1zm-1 4l6 6v12H6V5h9zm-1 7h5.5L14 6.5V12z"/></svg>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">const</span> elements <span class="token operator">=</span> <span class="token punctuation">{</span>\n  button<span class="token punctuation">:</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">\'button\'</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n<span class="token keyword">function</span> <span class="token function">removeButton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">\'button\'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>在这个示例中，我们想调用 removeButton 方法来清除 button 元素，但是由于在 elements 字典中存在对 button 元素的引用，所以即使我们通过 removeChild 方法移除了 button 元素，它其实还是依旧存储在内存中无法得到释放，只有我们手动清除对 button 元素的引用才会被垃圾回收。</p>\n<h2 id="弱引用"><a href="#%E5%BC%B1%E5%BC%95%E7%94%A8" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>弱引用</h2>\n<p>通过前几个示例我们会发现如果我们一旦疏忽，就会容易地引发内存泄漏的问题，为此，在 ES6 中为我们新增了两个有效的数据结构 WeakMap 和 WeakSet，就是为了解决内存泄漏的问题而诞生的。其表示弱引用，它的键名所引用的对象均是弱引用，弱引用是指垃圾回收的过程中不会将键名对该对象的引用考虑进去，只要所引用的对象没有其他的引用了，垃圾回收机制就会释放该对象所占用的内存。这也就意味着我们不需要关心 WeakMap 中键名对其他对象的引用，也不需要手动地进行引用清除，我们尝试在 node 中演示一下过程(参考阮一峰 ES6 标准入门中的示例，自己手动实现了一遍)。</p>\n<p>首先打开 node 命令行，输入以下命令：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="26105822742265848000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`node --expose-gc // --expose-gc 表示允许手动执行垃圾回收机制`, `26105822742265848000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                data-tooltip="复制"\n              >\n                <svg class="gatsby-code-button-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M16 1H2v16h2V3h12V1zm-1 4l6 6v12H6V5h9zm-1 7h5.5L14 6.5V12z"/></svg>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="bash"><pre style="counter-reset: linenumber NaN" class="language-bash line-numbers"><code class="language-bash">node --expose-gc // --expose-gc 表示允许手动执行垃圾回收机制</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>然后我们执行下面的代码</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="18555401804385284000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// 手动执行一次垃圾回收保证内存数据准确\n> global.gc();\nundefined\n\n// 查看当前占用的内存，主要关心 heapUsed 字段，大小约为 4.4MB\n> process.memoryUsage();\n{ rss: 21626880,\n  heapTotal: 7585792,\n  heapUsed: 4708440,\n  external: 8710 }\n\n// 创建一个 WeakMap\n> let wm = new WeakMap();\nundefined\n\n// 创建一个数组并赋值给变量 key\n> let key = new Array(1000000);\nundefined\n\n// 将 WeakMap 的键名指向该数组\n// 此时该数组存在两个引用，一个是 key，一个是 WeakMap 的键名\n// 注意 WeakMap 是弱引用\n> wm.set(key, 1);\nWeakMap { [items unknown] }\n\n// 手动执行一次垃圾回收\n> global.gc();\nundefined\n\n// 再次查看内存占用大小，heapUsed 已经增加到约 12MB\n> process.memoryUsage();\n{ rss: 30232576,\n  heapTotal: 17694720,\n  heapUsed: 13068464,\n  external: 8688 }\n\n// 手动清除变量 key 对数组的引用\n// 注意这里并没有清除 WeakMap 中键名对数组的引用\n> key = null;\nnull\n\n// 再次执行垃圾回收\n> global.gc()\nundefined\n\n// 查看内存占用大小，发现 heapUsed 已经回到了之前的大小(这里约为 4.8M，原来为 4.4M，稍微有些浮动)\n> process.memoryUsage();\n{ rss: 22110208,\n  heapTotal: 9158656,\n  heapUsed: 5089752,\n  external: 8698 }`, `18555401804385284000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                data-tooltip="复制"\n              >\n                <svg class="gatsby-code-button-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M16 1H2v16h2V3h12V1zm-1 4l6 6v12H6V5h9zm-1 7h5.5L14 6.5V12z"/></svg>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">// 手动执行一次垃圾回收保证内存数据准确</span>\n<span class="token operator">></span> global<span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">undefined</span>\n\n<span class="token comment">// 查看当前占用的内存，主要关心 heapUsed 字段，大小约为 4.4MB</span>\n<span class="token operator">></span> process<span class="token punctuation">.</span><span class="token function">memoryUsage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">{</span> rss<span class="token punctuation">:</span> <span class="token number">21626880</span><span class="token punctuation">,</span>\n  heapTotal<span class="token punctuation">:</span> <span class="token number">7585792</span><span class="token punctuation">,</span>\n  heapUsed<span class="token punctuation">:</span> <span class="token number">4708440</span><span class="token punctuation">,</span>\n  external<span class="token punctuation">:</span> <span class="token number">8710</span> <span class="token punctuation">}</span>\n\n<span class="token comment">// 创建一个 WeakMap</span>\n<span class="token operator">></span> <span class="token keyword">let</span> wm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">undefined</span>\n\n<span class="token comment">// 创建一个数组并赋值给变量 key</span>\n<span class="token operator">></span> <span class="token keyword">let</span> key <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token number">1000000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">undefined</span>\n\n<span class="token comment">// 将 WeakMap 的键名指向该数组</span>\n<span class="token comment">// 此时该数组存在两个引用，一个是 key，一个是 WeakMap 的键名</span>\n<span class="token comment">// 注意 WeakMap 是弱引用</span>\n<span class="token operator">></span> wm<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nWeakMap <span class="token punctuation">{</span> <span class="token punctuation">[</span>items unknown<span class="token punctuation">]</span> <span class="token punctuation">}</span>\n\n<span class="token comment">// 手动执行一次垃圾回收</span>\n<span class="token operator">></span> global<span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">undefined</span>\n\n<span class="token comment">// 再次查看内存占用大小，heapUsed 已经增加到约 12MB</span>\n<span class="token operator">></span> process<span class="token punctuation">.</span><span class="token function">memoryUsage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">{</span> rss<span class="token punctuation">:</span> <span class="token number">30232576</span><span class="token punctuation">,</span>\n  heapTotal<span class="token punctuation">:</span> <span class="token number">17694720</span><span class="token punctuation">,</span>\n  heapUsed<span class="token punctuation">:</span> <span class="token number">13068464</span><span class="token punctuation">,</span>\n  external<span class="token punctuation">:</span> <span class="token number">8688</span> <span class="token punctuation">}</span>\n\n<span class="token comment">// 手动清除变量 key 对数组的引用</span>\n<span class="token comment">// 注意这里并没有清除 WeakMap 中键名对数组的引用</span>\n<span class="token operator">></span> key <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n<span class="token keyword">null</span>\n\n<span class="token comment">// 再次执行垃圾回收</span>\n<span class="token operator">></span> global<span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n<span class="token keyword">undefined</span>\n\n<span class="token comment">// 查看内存占用大小，发现 heapUsed 已经回到了之前的大小(这里约为 4.8M，原来为 4.4M，稍微有些浮动)</span>\n<span class="token operator">></span> process<span class="token punctuation">.</span><span class="token function">memoryUsage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">{</span> rss<span class="token punctuation">:</span> <span class="token number">22110208</span><span class="token punctuation">,</span>\n  heapTotal<span class="token punctuation">:</span> <span class="token number">9158656</span><span class="token punctuation">,</span>\n  heapUsed<span class="token punctuation">:</span> <span class="token number">5089752</span><span class="token punctuation">,</span>\n  external<span class="token punctuation">:</span> <span class="token number">8698</span> <span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>在上述示例中，我们发现虽然我们没有手动清除 WeakMap 中的键名对数组的引用，但是内存依旧已经回到原始的大小，说明该数组已经被回收，那么这个也就是弱引用的具体含义了。</p>',
id:"/github/workspace/blog/一文搞懂V8引擎的垃圾回收/index.md absPath of file >>> MarkdownRemark",timeToRead:9,frontmatter:{date:"2021-06-22 17:21:47",path:"/v8-garbage-collection/",tags:"前端, 高级前端, 垃圾回收",title:"一文搞懂V8引擎的垃圾回收",draft:null}}],length:1,tag:"垃圾回收",pagesSum:1,page:1}}}});