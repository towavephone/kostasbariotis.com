webpackJsonp([0xbcede5359667],{1432:function(n,a){n.exports={data:{site:{siteMetadata:{title:"女王控的博客",description:'前端工程师，黑猫女王控，欢迎勾搭，技术相关<a href="https://github.com/towavephone" target="_blank">@towavephone</a>，QQ闲聊<a href="tencent://AddContact/?fromId=45&fromSubId=1&subcmd=all&uin=634407147&website=www.oicqzone.com">@towave</a>，bili关注<a href="https://space.bilibili.com/11507708#/" target="_blank">@towave</a>',siteUrl:"https://blog.towavephone.com"}}},pathContext:{posts:[{excerpt:"页面性能分析：利用 chrome 做 web 性能分析 “浏览器中的页面循环系统”模块我们已经介绍完了，循环系统是页面的基础，理解了循环系统能让我们从本质上更好地理解页面的工作方式，加深我们对一些前端概念的理解。 接下来我们就要进入新的模块了，也就是“浏览器中的页面”模块，正如专栏简介中所言，页面是浏览器的核心，浏览器中的所有功能点都是服务于页面的，而 Chrome 开发者工具又是工程师调试页面的核心工具，所以在这个模块的开篇，我想先带你来深入了解下 Chrome 开发者工具。 Chrome…",html:'<h1 id="页面性能分析：利用-chrome-做-web-性能分析"><a href="#%E9%A1%B5%E9%9D%A2%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%EF%BC%9A%E5%88%A9%E7%94%A8-chrome-%E5%81%9A-web-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>页面性能分析：利用 chrome 做 web 性能分析</h1>\n<p>“浏览器中的页面循环系统”模块我们已经介绍完了，循环系统是页面的基础，理解了循环系统能让我们从本质上更好地理解页面的工作方式，加深我们对一些前端概念的理解。</p>\n<p>接下来我们就要进入新的模块了，也就是“浏览器中的页面”模块，正如专栏简介中所言，页面是浏览器的核心，浏览器中的所有功能点都是服务于页面的，而 Chrome 开发者工具又是工程师调试页面的核心工具，所以在这个模块的开篇，我想先带你来深入了解下 Chrome 开发者工具。</p>\n<p>Chrome 开发者工具（简称 DevTools）是一组网页制作和调试的工具，内嵌于 Google Chrome 浏览器中。Chrome 开发者工具非常重要，所蕴含的内容也是非常多的，熟练使用它能让你更加深入地了解浏览器内部工作原理。（Chrome 开发者工具也在不停地迭代改进，如果你想使用最新版本，可以使用 Chrome Canary。）</p>\n<p>作为这一模块的第一篇文章，我们主要聚焦页面的源头和网络数据的接收，这些发送和接收的数据都能体现在开发者工具的网络面板上。不过为了你能更好地理解和掌握，我们会先对 Chrome 开发者工具做一个大致的介绍，然后再深入剖析网络面板</p>\n<h2 id="chrome-开发者工具"><a href="#chrome-%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Chrome 开发者工具</h2>\n<p>Chrome 开发者工具有很多重要的面板，比如与性能相关的有网络面板、Performance 面板、内存面板等，与调试页面相关的有 Elements 面板、Sources 面板、Console 面板等。</p>\n<p>你可以在浏览器窗口的右上方选择 Chrome 菜单，然后选择“更多工具–> 开发者工具”来打开 Chrome 开发者工具。打开的页面如下图所示：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-07-09-50-03-ef7efb2c0e645f82c9f3c1d3d39db515-af263.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 23.647798742138363%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAIAAADKYVtkAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAAt0lEQVQY03WOWwvCMAyF/f9/zBtOxTdR7OrUtpnVNo2bu9Vsvijix+EQQnKSkQNjkqlaTFhc5KsZLGfsejGGZHJdz4Gbm6QgKstnOUD0aJo2xjiSaQrZ0aqLkqm9nD0YZ7QHfRJCbHfnwz4/ZTetnHN+AL2/2vuzavrlg5AaAIkCPdjfCkQulCJTqZQmz30I+E3bDpcRQ1EU9QdVVTW914iE6HmUX62/6bquX44/cOo73lrLHv/zAnqMGqo5nVDeAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 07 09 50 03"\n        title=""\n        src="/static/2021-07-07-09-50-03-ef7efb2c0e645f82c9f3c1d3d39db515-fee1c.png"\n        srcset="/static/2021-07-07-09-50-03-ef7efb2c0e645f82c9f3c1d3d39db515-a67b7.png 200w,\n/static/2021-07-07-09-50-03-ef7efb2c0e645f82c9f3c1d3d39db515-0b187.png 400w,\n/static/2021-07-07-09-50-03-ef7efb2c0e645f82c9f3c1d3d39db515-fee1c.png 800w,\n/static/2021-07-07-09-50-03-ef7efb2c0e645f82c9f3c1d3d39db515-b1a91.png 1200w,\n/static/2021-07-07-09-50-03-ef7efb2c0e645f82c9f3c1d3d39db515-af263.png 1590w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从图中可以看出，它一共包含了 10 个功能面板，包括了 Elements、Console、Sources、NetWork、Performance、Memory、Application、Security、Audits 和 Layers。</p>\n<p>关于这 10 个面板的大致功能，我做了一个表格，感兴趣的话，你可以详细看下：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-07-09-50-19-23f102ef79c83df6cfb97ff2fdcc3a2c-a7cc8.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 53.85714285714286%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABnElEQVQoz22QS0/cMBDH8+l6pBSJWw/9LpWqrhASEh+FQ9kuUHHnsTwusCVvx4md+G3HSTgwyW6hVJV+Gtlj/2fmP0Fa2+NrdHJTQDxeFv8wX6KTWzw9vTG/QUeXWUx18OMq3fo2/3zwa/v7z+3ZYh0/wWG2+Dhb7O6ffTk839k7/RtIfvg6P7pIAmcFRg/WYMUzVsccaJKGxjUJ4apErgTSErW2fIfBfacD3yrZRENLFEsIfqR4JZvEKtTqwilkZT5Ghfq2ek859CbovDYye+7qhoRpfJ+Ed7T8rXjatwSSrwyeApD8QzWKWycZCSVLJEtZHUEJXkeMRnCGEuBFNAkAH7TIO1dtsOXQmdFzVTzo0VsGhkUTgxIirzfAdXRhMOBtuWHtGcS0XMEzo2FVrCq8AqVi6QhPQWxV7qcNvbV97TyOXUeCJbBbWj3B2GJaGOB0YXVhZG4k0iLzFmRkg508O8Np+QiVtADPYUOe+ORW8xQWCQdoC616V3mLJ9ZjF+PYnbdSlH2nnGFaUiUJ4B3vWrGm9/J/iOfBvwCro0q9MVEWugAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 07 09 50 19"\n        title=""\n        src="/static/2021-07-07-09-50-19-23f102ef79c83df6cfb97ff2fdcc3a2c-fee1c.png"\n        srcset="/static/2021-07-07-09-50-19-23f102ef79c83df6cfb97ff2fdcc3a2c-a67b7.png 200w,\n/static/2021-07-07-09-50-19-23f102ef79c83df6cfb97ff2fdcc3a2c-0b187.png 400w,\n/static/2021-07-07-09-50-19-23f102ef79c83df6cfb97ff2fdcc3a2c-fee1c.png 800w,\n/static/2021-07-07-09-50-19-23f102ef79c83df6cfb97ff2fdcc3a2c-b1a91.png 1200w,\n/static/2021-07-07-09-50-19-23f102ef79c83df6cfb97ff2fdcc3a2c-a7cc8.png 1400w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>简单来说，Chrome 开发者工具为我们提供了通过界面访问或者编辑 DOM 和 CSSOM 的能力，还提供了强大的调试功能和查看性能指标的能力。</p>\n<p>OK，接下来我们就要重点看下其中重要的 Network 面板，即网络面板</p>\n<h2 id="网络面板"><a href="#%E7%BD%91%E7%BB%9C%E9%9D%A2%E6%9D%BF" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>网络面板</h2>\n<p>网络面板由控制器、过滤器、抓图信息、时间线、详细列表和下载信息概要这 6 个区域构成（如下图所示）。</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-07-09-50-45-b7e1dcc8d872bc75e34bb2ad48f0c4a0-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 52.80210157618214%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAB7klEQVQozzWQS4+bMBRG5yf3p3TfxbTTabuqumi7GFXqNAkZEmKDIQGDAYMDA4g8JoE8mgeTXiepdPTp+Op+WPhmsW82f3fNqjquashmXR/XdXPm9T/SN6vTdn1lU7/ud6fT6ebtQDyYnKm63TeHXTz4raLHnqkMSFuzFGR2ECTtE1ezGBpK8JD2jDLJZfnWyh5Y8cT8Pg+NJMFC6OMxgIXMNosU10Wx0JPkMocdJES2WMhya7wMMr7ln6vwywv7NHM/ztn9zL2T4t1PKchdObqd0Q/A1HkP88no3brUZfkHn2Nf4O9f886vjaVWpFuT7op0K6LUV3+qjbMbCnilKxVqbZ9jWYYff5ku0M9OrJCJ4WbaqMBOjuyp4UkZ2DApdbdADpBpQ5iXmK6yiSyPJnWcTtgf5LQI6w55zxkj5ilWRrjQPP9pRNskwX6o2rxHgdyMUhwss5ksq3lNRRl1Saw5CXJT7OWGn+qsIEEGgr1k4F4kxQwWChLm2K8u5eWhWc5r59EIVfhqLBBL9RBugExQEKpOrHngkLAQ9b2cwM3h9eY37fE3Ky1Mmxv02Q4Sy0tHgTDdsc3jYSRMPyW09OKc8szhBY0mfgLHupyfH6xpdqv6wD1gH7qHM8ezyyP3jvycEcAua4eAHmfywf4Bt9Q7GfH89l4AAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 07 09 50 45"\n        title=""\n        src="/static/2021-07-07-09-50-45-b7e1dcc8d872bc75e34bb2ad48f0c4a0-fee1c.png"\n        srcset="/static/2021-07-07-09-50-45-b7e1dcc8d872bc75e34bb2ad48f0c4a0-a67b7.png 200w,\n/static/2021-07-07-09-50-45-b7e1dcc8d872bc75e34bb2ad48f0c4a0-0b187.png 400w,\n/static/2021-07-07-09-50-45-b7e1dcc8d872bc75e34bb2ad48f0c4a0-fee1c.png 800w,\n/static/2021-07-07-09-50-45-b7e1dcc8d872bc75e34bb2ad48f0c4a0-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<h3 id="控制器"><a href="#%E6%8E%A7%E5%88%B6%E5%99%A8" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>控制器</h3>\n<p>其中，控制器有 4 个比较重要的功能，我们按照下文中的这张图来简单介绍下。</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-07-09-51-02-42d6620dc9869662b20e6522e8bfcab1-f3ec4.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 64.36781609195403%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAIAAAAmMtkJAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAB4ElEQVQoz6VSy4rUQBTtL/IfXLka/Al/wbXg3oUK6oALFyrDgLOwd4LiYsAZsLVx0aF70klXpR5JqlKPTjqpPNvb7WJ6wAHBSzg3N3VO5dxbNdr+R4wOi2HYYVG3x5Pk+XdxNpNPzvGbCbWue3bBnl7Qqh3GXvroczhlxd/FWdkenVzdfbt4+IXdezd/8HEZ5839k/nRe8+6/vFXfOflz/HC3BB3XVcUxSZfS23Hs+TVJfnk8Rfnwdk0ktqc/kCvvwU0zT5M8elk5UViO/TX4rIsEaKZssbkbm0NXuVKySwvjOaMEsJQGCAcccYqk6Uxa5pmNPR9b9SwNlVRhMsgRCQiSRgufER4IlKRGmvhSeBNSKW00lpkah6wTVmOoNFOq8EaV9c4ihDyg2CO0QJTEkWUU6qyDBRGG6O1haw0bIZIstlsduJt3wM2Tc15Eiynvv8LIQJUKaQUWZoKISSjjPOYMQ7+AZM4rip33bNzLk4SSkJCfM6BFGdmXTpn8xxMAVautuucxTHCYDEqd7YPxPBnhK5WK48QOpsti9K1Xde2LcwGkqsbmE+apoQQjHFVVTeOyu0DvgLWdd3v2wH8UwICp9kHlMMwjG67erAGDNgIqP90PQ8D3IJDGI6U8jbOb+Rb1c1kDW/jAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 07 09 51 02"\n        title=""\n        src="/static/2021-07-07-09-51-02-42d6620dc9869662b20e6522e8bfcab1-fee1c.png"\n        srcset="/static/2021-07-07-09-51-02-42d6620dc9869662b20e6522e8bfcab1-a67b7.png 200w,\n/static/2021-07-07-09-51-02-42d6620dc9869662b20e6522e8bfcab1-0b187.png 400w,\n/static/2021-07-07-09-51-02-42d6620dc9869662b20e6522e8bfcab1-fee1c.png 800w,\n/static/2021-07-07-09-51-02-42d6620dc9869662b20e6522e8bfcab1-b1a91.png 1200w,\n/static/2021-07-07-09-51-02-42d6620dc9869662b20e6522e8bfcab1-f3ec4.png 1392w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<ul>\n<li>红色圆点的按钮，表示“开始 / 暂停抓包”，这个功能很常见，很容易理解。</li>\n<li>“全局搜索”按钮，这个功能就非常重要了，可以在所有下载资源中搜索相关内容，还可以快速定位到某几个你想要的文件上。</li>\n<li>Disable cache，即“禁止从 Cache 中加载资源”的功能，它在调试 Web 应用的时候非常有用，因为开启了 Cache 会影响到网络性能测试的结果。</li>\n<li>Online 按钮，是“模拟 2G/3G”功能，它可以限制带宽，模拟弱网情况下页面的展现情况，然后你就可以根据实际展示情况来动态调整策略，以便让 Web 应用更加适用于这些弱网</li>\n</ul>\n<h3 id="过滤器"><a href="#%E8%BF%87%E6%BB%A4%E5%99%A8" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>过滤器</h3>\n<p>网络面板中的过滤器，主要就是起过滤功能。因为有时候一个页面有太多内容在详细列表区域中展示了，而你可能只想查看 JavaScript 文件或者 CSS 文件，这时候就可以通过过滤器模块来筛选你想要的文件类型。</p>\n<h3 id="抓图信息"><a href="#%E6%8A%93%E5%9B%BE%E4%BF%A1%E6%81%AF" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>抓图信息</h3>\n<p>抓图信息区域，可以用来分析用户等待页面加载时间内所看到的内容，分析用户实际的体验情况。比如，如果页面加载 1 秒多之后屏幕截图还是白屏状态，这时候就需要分析是网络还是代码的问题了。（勾选面板上的“Capture screenshots”即可启用屏幕截图。）</p>\n<h3 id="时间线"><a href="#%E6%97%B6%E9%97%B4%E7%BA%BF" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>时间线</h3>\n<p>时间线，主要用来展示 HTTP、HTTPS、WebSocket 加载的状态和时间的一个关系，用于直观感受页面的加载过程。如果是多条竖线堆叠在一起，那说明这些资源被同时被加载。至于具体到每个文件的加载信息，还需要用到下面要讲的详细列表。</p>\n<h3 id="详细列表"><a href="#%E8%AF%A6%E7%BB%86%E5%88%97%E8%A1%A8" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>详细列表</h3>\n<p>这个区域是最重要的，它详细记录了每个资源从发起请求到完成请求这中间所有过程的状态，以及最终请求完成的数据信息。通过该列表，你就能很容易地去诊断一些网络问题。</p>\n<p>详细列表是我们本篇文章介绍的重点，不过内容比较多，所以放到最后去专门介绍了。</p>\n<h3 id="下载信息概要"><a href="#%E4%B8%8B%E8%BD%BD%E4%BF%A1%E6%81%AF%E6%A6%82%E8%A6%81" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>下载信息概要</h3>\n<p>下载信息概要中，你要重点关注下 DOMContentLoaded 和 Load 两个事件，以及这两个事件的完成时间。</p>\n<ul>\n<li>DOMContentLoaded，这个事件发生后，说明页面已经构建好 DOM 了，这意味着构建 DOM 所需要的 HTML 文件、JavaScript 文件、CSS 文件都已经下载完成了。</li>\n<li>Load，说明浏览器已经加载了所有的资源（图像、样式表等）</li>\n</ul>\n<p>通过下载信息概要面板，你可以查看触发这两个事件所花费的时间。</p>\n<h2 id="网络面板中的详细列表"><a href="#%E7%BD%91%E7%BB%9C%E9%9D%A2%E6%9D%BF%E4%B8%AD%E7%9A%84%E8%AF%A6%E7%BB%86%E5%88%97%E8%A1%A8" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>网络面板中的详细列表</h2>\n<p>下面我们就来重点介绍网络面板中的详细列表，这里面包含了大量有用的信息</p>\n<h3 id="列表的属性"><a href="#%E5%88%97%E8%A1%A8%E7%9A%84%E5%B1%9E%E6%80%A7" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>列表的属性</h3>\n<p>列表的属性比较多，比如 Name、Status、Type、Initiator 等等，这个不难理解。当然，你还可以通过点击右键的下拉菜单来添加其他属性，这里我就不再赘述了，你可以自己上手实操一下。</p>\n<p>另外，你也可以按照列表的属性来给列表排序，默认情况下，列表是按请求发起的时间来排序的，最早发起请求的资源在顶部。当然也可以按照返回状态码、请求类型、请求时长、内容大小等基础属性排序，只需点击相应属性即可。</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-07-09-53-01-18b08f827a18ed29c60483a7f3cc1708-56259.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 60.89644513137558%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABrklEQVQoz41Qy3KbQBDkp/Kz+YrccvEhVT5YsS3LziEYUGwFWEDSPtg3ixCkQcotrsoUtTXTMz3dQ6QPDc9i+b6176n8lbDsVWzxxmKb8iyhyU+WIk/4gi8v8FeAvXfRYfeW3n5Lv69ublbx6r7aPJDndfn0WP/YIMnX95evvOCbx+plnd3d5U8PwZrIeq8k/xofP33efonFNA39OCnn+/N5GMcwDK4LTKrzNNkudP3J932rHUpEZLQsfu+SHbnN6FtFtZIdpilzznVdZ7QRQpCShBAE50opKSU9MpTj+RxZowipGKXBSiVbrQ0axyP13iNBielmf+j7HokxRmvNmEA5juNMzvO8qhvKOVt2o8GFuJCttW0rSVUDFAKr52AU5NOVXJblfn8QS4AMt5TSi20og1w3DRa17UyWUlHKZ9sz2eqiKKqqhjJfyOGq3C3KblYmFZRBhm3GOKXidPqrXMB2VTPAi+3rzW652cw313Wz2BZQhgKl7HpzH7q2FVivtMJiWMVWpTSYmHDewz+uBegWMyiNscMwzOTpX4HG9B8RfdTAFYSQpmnw2z+a+QPsnqMS4hOnggAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 07 09 53 01"\n        title=""\n        src="/static/2021-07-07-09-53-01-18b08f827a18ed29c60483a7f3cc1708-fee1c.png"\n        srcset="/static/2021-07-07-09-53-01-18b08f827a18ed29c60483a7f3cc1708-a67b7.png 200w,\n/static/2021-07-07-09-53-01-18b08f827a18ed29c60483a7f3cc1708-0b187.png 400w,\n/static/2021-07-07-09-53-01-18b08f827a18ed29c60483a7f3cc1708-fee1c.png 800w,\n/static/2021-07-07-09-53-01-18b08f827a18ed29c60483a7f3cc1708-b1a91.png 1200w,\n/static/2021-07-07-09-53-01-18b08f827a18ed29c60483a7f3cc1708-56259.png 1294w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<h3 id="详细信息"><a href="#%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>详细信息</h3>\n<p>如果你选中详细列表中的一项，右边就会出现该项的详细信息，如下所示：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-07-09-53-26-311e36009422d59a8e38c15e698b0e77-8edaa.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 82.97213622291021%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAIAAABSJhvpAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAC/ElEQVQ4y22RW2/TZhjH+RBc7WNME5om7YL7adK422fhZhebAHEQG6KiqF1ak7Y5NixNQ0URQpA0PYSkSUpiu/Ep8fm148Sn+Gz8BlC7jUc//f28sn6vree5YlmWbduLsJOY27ZmzLlpwM0CRXfhG8syrblpu6Zlm6YJj6blum4cx1cIghwlxTAjmmJoSmbJtQPw/SPxuwfszepUE5jmgPtpSf7hFvHrioTTEkPTQ4JS1QmUeZ4HQJGBAlRNVjVdU08p+VmDy56Iez0RyOwHWrz7enZ7T16uTSRVU1RZlCXd1KE85gRVGD2tq7/8zd9YE3Ld8Fw6+qe7+o7Kv6ULL4eQGpNvjItJ7hPFfXJ7ny6SWh/K9IiTRsM7r8C396hrD0eP6n6br68cP0TaTwqD9QqxtUtldshMmYSZ9FUqWybT2KQDZVmWJVEcUMLhgGsRQFbtIXf0uoPU+rmj81KTLHdG1e74xSX2WswOr2FQZll2zHLmVPENEJpKGPgG3RDrj9X3iN3PuVjBx7f/TclHswE4gzJQ1LkxfTN07ted+++sAzb2+CO29pfUTE3aiH626WB5B8+7eOELRRfd8kEPyn4QJY9bb52rv7Hf/M7/UYtD8URoLMnNlNpGoInlvfPi1+UIujEKwgrmV1CPMWKPO2Te/CmepMTjVXhFC7EH2UTz8GKCi297aOazHF+uKExizh+Lh49Ba23WS0PONowPm3M8Z6EZG83OsZzdT3ugeyG7QWz6selGQSKPO9LB1vR0x+zuJhjdCsxOZdou66c7Rnd31io5/ADKAfxYnD71fl5XbyCTjX5sdY6HqaVx7hlf2JCfZ2bV0rS6fcGLklbO2ujZhbzSdH9ckq4vg9VebLUb6PIDZnOFSj9N4HIpPpvicympiAj5dbGACJlVvfd+MbDFb8+ciDdiTo/sIA4mso73DQIzCcwYognmorep8zmdMLRJ3Jso/xtYMrJLTXTp+NX6LCcLCxd82pzrOKIg8BynABCFIdxCFP2XOP4IyJhtBgnZ+SIAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 07 09 53 26"\n        title=""\n        src="/static/2021-07-07-09-53-26-311e36009422d59a8e38c15e698b0e77-fee1c.png"\n        srcset="/static/2021-07-07-09-53-26-311e36009422d59a8e38c15e698b0e77-a67b7.png 200w,\n/static/2021-07-07-09-53-26-311e36009422d59a8e38c15e698b0e77-0b187.png 400w,\n/static/2021-07-07-09-53-26-311e36009422d59a8e38c15e698b0e77-fee1c.png 800w,\n/static/2021-07-07-09-53-26-311e36009422d59a8e38c15e698b0e77-b1a91.png 1200w,\n/static/2021-07-07-09-53-26-311e36009422d59a8e38c15e698b0e77-8edaa.png 1292w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>你可以在此查看请求列表中任意一项的请求行和请求头信息，还可以查看响应行、响应头和响应体。然后你可以根据这些查看的信息来判断你的业务逻辑是否正确，或者有时候也可以用来逆向推导别人网站的业务逻辑。</p>\n<h3 id="单个资源的时间线"><a href="#%E5%8D%95%E4%B8%AA%E8%B5%84%E6%BA%90%E7%9A%84%E6%97%B6%E9%97%B4%E7%BA%BF" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>单个资源的时间线</h3>\n<p>了解了每个资源的详细请求信息之后，我们再来分析单个资源请求时间线，这就涉及具体的 HTTP 请求流程了。</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-07-09-53-50-ee8c5554c2d4230d5958c3f13aea2522-57c91.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 37.65182186234818%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAIAAAB2/0i6AAAACXBIWXMAAA7DAAAOwwHHb6hkAAABAUlEQVQY02P4++8/EAEBkICwMRFY+h8QwdVAAAMQ//n14/Gda98+vgWrgckQARj23Psy7+yb6QduLzr9fNnVz+uvf1p06SOIvPhh441Pc8+923zz0+8/fz6eOfXr+ZM773/NOftuyaWPH7//BmluO/gictWD/B3PszY/Sdz8In/7s+j1zwq2PYlcdb9w2+PAZffKdj75+u37kwWzv18+e/TZL/+ld2PXPnr28SdI89+/f379/EHQhT9+/frz5w+6s//+/fvly9cfP358ByMQ4zsQfQczEODTp09/MTVDAgkZYFqLKxQZMBW9ffv23r17Hz9+BDIeP3789OlToOuwagYAeP/A5lSxFy0AAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 07 09 53 50"\n        title=""\n        src="/static/2021-07-07-09-53-50-ee8c5554c2d4230d5958c3f13aea2522-fee1c.png"\n        srcset="/static/2021-07-07-09-53-50-ee8c5554c2d4230d5958c3f13aea2522-a67b7.png 200w,\n/static/2021-07-07-09-53-50-ee8c5554c2d4230d5958c3f13aea2522-0b187.png 400w,\n/static/2021-07-07-09-53-50-ee8c5554c2d4230d5958c3f13aea2522-fee1c.png 800w,\n/static/2021-07-07-09-53-50-ee8c5554c2d4230d5958c3f13aea2522-b1a91.png 1200w,\n/static/2021-07-07-09-53-50-ee8c5554c2d4230d5958c3f13aea2522-57c91.png 1482w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>我们介绍过发起一个 HTTP 请求之后，浏览器首先查找缓存，如果缓存没有命中，那么继续发起 DNS 请求获取 IP 地址，然后利用 IP 地址和服务器端建立 TCP 连接，再发送 HTTP 请求，等待服务器响应；不过，如果服务器响应头中包含了重定向的信息，那么整个流程就需要重新再走一遍。这就是在浏览器中一个 HTTP 请求的基础流程。</p>\n<p>那详细列表中是如何表示出这个流程的呢？这就要重点看下时间线面板了</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-07-09-54-24-cc965f0ae609a55cd5be0788d105afaf-0ac43.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 93.7984496124031%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAATCAIAAAAf7rriAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABoUlEQVQ4y6VU6U6DQBjk/Z/Gq/4wqU9grLH6Q6mBcN/LvbtcdWAJYEqbqBMKdHfnm/mOVjr+A1LbtlmWOY6j63qapoZheJ7n+76iKK7jeF5w+FKTJC3Lslggz3POuYQAeIvjOIoiQggC0QE4QWmZZNSP8qJkFf8Bxlhd1z0ZTFVVnQHY+IVtfGAJfNxhG5pd110gNE1TVRVkcawng2DbNlIlA4T4aQixAg1N00zTRLEksRoPQMjpHPZWlafDszK+wHMYhqjEOcOTchAEMxki6BOqvXQ7KC+v47SORiJNJD+SRc64ixAAs96Tl+t0f5/uN+nrbVMSsY5eImHXdWcyOJOmeDHe/Kerj91G3t3JzzefBaFiF0MBMsTHgolWJQOwd7m3KAqU5pxRZFTfsizYPjckXdtNfYZnHB6V8TBME1wsofKr5Eft4RDJvU3a93kuGAyQKAgDFzXDhE7dXoK3+VaOtzLjtIAynI/krKh1t7ADWtVNN2BVnNcdrVqRNmTGnEvW+ISFCW/alZE8DYfBRsNG8t//DC60RPzI4XA5BUt8A1lsT6oVgRWDAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 07 09 54 24"\n        title=""\n        src="/static/2021-07-07-09-54-24-cc965f0ae609a55cd5be0788d105afaf-fee1c.png"\n        srcset="/static/2021-07-07-09-54-24-cc965f0ae609a55cd5be0788d105afaf-a67b7.png 200w,\n/static/2021-07-07-09-54-24-cc965f0ae609a55cd5be0788d105afaf-0b187.png 400w,\n/static/2021-07-07-09-54-24-cc965f0ae609a55cd5be0788d105afaf-fee1c.png 800w,\n/static/2021-07-07-09-54-24-cc965f0ae609a55cd5be0788d105afaf-b1a91.png 1200w,\n/static/2021-07-07-09-54-24-cc965f0ae609a55cd5be0788d105afaf-0ac43.png 1290w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>那面板中这各项到底是什么含义呢？</p>\n<blockquote>\n<p>第一个是 Queuing，也就是排队的意思，当浏览器发起一个请求的时候，会有很多原因导致该请求不能被立即执行，而是需要排队等待。导致请求处于排队状态的原因有很多。</p>\n</blockquote>\n<ul>\n<li>首先，页面中的资源是有优先级的，比如 CSS、HTML、JavaScript 等都是页面中的核心文件，所以优先级最高；而图片、视频、音频这类资源就不是核心资源，优先级就比较低。通常当后者遇到前者时，就需要“让路”，进入待排队状态。</li>\n<li>其次，我们前面也提到过，浏览器会为每个域名最多维护 6 个 TCP 连接，如果发起一个 HTTP 请求时，这 6 个 TCP 连接都处于忙碌状态，那么这个请求就会处于排队状态。</li>\n<li>最后，网络进程在为数据分配磁盘空间时，新的 HTTP 请求也需要短暂地等待磁盘分配结束。</li>\n</ul>\n<p>等待排队完成之后，就要进入发起连接的状态了。不过在发起连接之前，还有一些原因可能导致连接过程被推迟，这个推迟就表现在面板中的 Stalled 上，它表示停滞的意思。</p>\n<p>这里需要额外说明的是，如果你使用了代理服务器，还会增加一个 Proxy Negotiation 阶段，也就是代理协商阶段，它表示代理服务器连接协商所用的时间，不过在上图中没有体现出来，因为这里我们没有使用代理服务器。</p>\n<p>接下来，就到了 Initial connection/SSL 阶段了，也就是和服务器建立连接的阶段，这包括了建立 TCP 连接所花费的时间；不过如果你使用了 HTTPS 协议，那么还需要一个额外的 SSL 握手时间，这个过程主要是用来协商一些加密信息的。（关于 SSL 协商的详细过程，我们会在 Web 安全模块中介绍。）</p>\n<p>和服务器建立好连接之后，网络进程会准备请求数据，并将其发送给网络，这就是 Request sent 阶段。通常这个阶段非常快，因为只需要把浏览器缓冲区的数据发送出去就结束了，并不需要判断服务器是否接收到了，所以这个时间通常不到 1 毫秒。</p>\n<p>数据发送出去了，接下来就是等待接收服务器第一个字节的数据，这个阶段称为 Waiting (TTFB)，通常也称为“第一字节时间”。 TTFB 是反映服务端响应速度的重要指标，对服务器来说，TTFB 时间越短，就说明服务器响应越快。</p>\n<p>接收到第一个字节之后，进入陆续接收完整数据的阶段，也就是 Content Download 阶段，这意味着从第一字节时间到接收到全部响应数据所用的时间</p>\n<h2 id="优化时间线上耗时项"><a href="#%E4%BC%98%E5%8C%96%E6%97%B6%E9%97%B4%E7%BA%BF%E4%B8%8A%E8%80%97%E6%97%B6%E9%A1%B9" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>优化时间线上耗时项</h2>\n<p>了解了时间线面板上的各项含义之后，我们就可以根据这个请求的时间线来实现相关的优化操作了。</p>\n<h3 id="排队（queuing）时间过久"><a href="#%E6%8E%92%E9%98%9F%EF%BC%88queuing%EF%BC%89%E6%97%B6%E9%97%B4%E8%BF%87%E4%B9%85" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>排队（Queuing）时间过久</h3>\n<p>排队时间过久，大概率是由浏览器为每个域名最多维护 6 个连接导致的。那么基于这个原因，你就可以让 1 个站点下面的资源放在多个域名下面，比如放到 3 个域名下面，这样就可以同时支持 18 个连接了，这种方案称为域名分片技术。除了域名分片技术外，我个人还建议你把站点升级到 HTTP2，因为 HTTP2 已经没有每个域名最多维护 6 个 TCP 连接的限制了。</p>\n<h3 id="第一字节时间（ttfb）时间过久"><a href="#%E7%AC%AC%E4%B8%80%E5%AD%97%E8%8A%82%E6%97%B6%E9%97%B4%EF%BC%88ttfb%EF%BC%89%E6%97%B6%E9%97%B4%E8%BF%87%E4%B9%85" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>第一字节时间（TTFB）时间过久</h3>\n<p>这可能的原因有如下：</p>\n<ul>\n<li>服务器生成页面数据的时间过久。对于动态网页来说，服务器收到用户打开一个页面的请求时，首先要从数据库中读取该页面需要的数据，然后把这些数据传入到模板中，模板渲染后，再返回给用户。服务器在处理这个数据的过程中，可能某个环节会出问题。</li>\n<li>网络的原因。比如使用了低带宽的服务器，或者本来用的是电信的服务器，可联通的网络用户要来访问你的服务器，这样也会拖慢网速。</li>\n<li>发送请求头时带上了多余的用户信息。比如一些不必要的 Cookie 信息，服务器接收到这些 Cookie 信息之后可能需要对每一项都做处理，这样就加大了服务器的处理时长。</li>\n</ul>\n<p>对于这三种问题，你要有针对性地出一些解决方案。面对第一种服务器的问题，你可以想办法去提高服务器的处理速度，比如通过增加各种缓存的技术；针对第二种网络问题，你可以使用 CDN 来缓存一些静态文件；至于第三种，你在发送请求时就去尽可能地减少一些不必要的 Cookie 数据信息</p>\n<h3 id="content-download-时间过久"><a href="#content-download-%E6%97%B6%E9%97%B4%E8%BF%87%E4%B9%85" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Content Download 时间过久</h3>\n<p>如果单个请求的 Content Download 花费了大量时间，有可能是字节数太多的原因导致的。这时候你就需要减少文件大小，比如压缩、去掉源码中不必要的注释等方法。</p>\n<h2 id="总结"><a href="#%E6%80%BB%E7%BB%93" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总结</h2>\n<p>首先我们简单介绍了 Chrome 开发者工具 10 个基础的面板信息；然后重点剖析了网络面板，再结合之前介绍的网络请求流程来重点分析了网络面板中时间线的各个指标的含义；最后我们还简要分析了时间线中各项指标出现异常的可能原因，并给出了一些优化方案。</p>\n<p>其实通过今天的分析，我们可以得出这样一个结论：如果你要去做一些实践性的项目优化，理解其背后的理论至关重要。因为理论就是一条“线”，它会把各种实践的内容“串”在一起，然后你可以围绕着这条“线”来排查问题</p>',
id:"/github/workspace/blog/浏览器工作原理与实践——浏览器中的页面/index.md absPath of file >>> MarkdownRemark",timeToRead:5,frontmatter:{date:"2021-07-07 09:41:05",path:"/browser-working-principle-page/",tags:"前端, 浏览器, 高级前端",title:"浏览器工作原理与实践——浏览器中的页面",draft:null}},{excerpt:"消息队列和事件循环：页面是怎么活起来的 前面我们讲到了每个渲染进程都有一个主线程，并且主线程非常繁忙，既要处理 DOM，又要计算样式，还要处理布局，同时还需要处理 JavaScript…",html:'<h1 id="消息队列和事件循环：页面是怎么活起来的"><a href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%EF%BC%9A%E9%A1%B5%E9%9D%A2%E6%98%AF%E6%80%8E%E4%B9%88%E6%B4%BB%E8%B5%B7%E6%9D%A5%E7%9A%84" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>消息队列和事件循环：页面是怎么活起来的</h1>\n<p>前面我们讲到了每个渲染进程都有一个主线程，并且主线程非常繁忙，既要处理 DOM，又要计算样式，还要处理布局，同时还需要处理 JavaScript 任务以及各种输入事件。要让这么多不同类型的任务在主线程中有条不紊地执行，这就需要一个系统来统筹调度这些任务，这个统筹调度系统就是我们今天要讲的消息队列和事件循环系统。</p>\n<p>在写这篇文章之前，我翻阅了大量的资料，却发现没有一篇文章能把消息循环系统给讲清楚的，所以我决定用一篇文章来专门介绍页面的事件循环系统。事件循环非常底层且非常重要，学会它能让你理解页面到底是如何运行的，所以在本篇文章中，我们会将页面的事件循环给梳理清楚、讲透彻。</p>\n<p>为了能让你更加深刻地理解事件循环机制，我们就从最简单的场景来分析，然后带你一步步了解浏览器页面主线程是如何运作的。</p>\n<p>需要说明的是，文章中的代码我会采用 C++ 来示范。如果你不熟悉 C++，也没有关系，这里并没有涉及到任何复杂的知识点，只要你了解 JavaScript 或 Python，你就会看懂</p>\n<h2 id="使用单线程处理安排好的任务"><a href="#%E4%BD%BF%E7%94%A8%E5%8D%95%E7%BA%BF%E7%A8%8B%E5%A4%84%E7%90%86%E5%AE%89%E6%8E%92%E5%A5%BD%E7%9A%84%E4%BB%BB%E5%8A%A1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>使用单线程处理安排好的任务</h2>\n<p>我们先从最简单的场景讲起，比如有如下一系列的任务：</p>\n<ul>\n<li>任务 1：1+2</li>\n<li>任务 2：20/5</li>\n<li>任务 3：7*8</li>\n<li>任务 4：打印出任务 1、任务 2、任务 3 的运算结果</li>\n</ul>\n<p>现在要在一个线程中去执行这些任务，通常我们会这样编写代码</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="21530141145354076000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`void MainThread() {\n  int num1 = 1+2; // 任务 1\n  int num2 = 20/5; // 任务 2\n  int num3 = 7*8; // 任务 3\n  print(&quot; 最终计算的值为:%d,%d,%d&quot;,num, num2, num3)； // 任务 4\n}`, `21530141145354076000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                data-tooltip="复制"\n              >\n                <svg class="gatsby-code-button-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M16 1H2v16h2V3h12V1zm-1 4l6 6v12H6V5h9zm-1 7h5.5L14 6.5V12z"/></svg>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="cpp"><pre style="counter-reset: linenumber NaN" class="language-cpp line-numbers"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">MainThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">int</span> num1 <span class="token operator">=</span> <span class="token number">1</span><span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// 任务 1</span>\n  <span class="token keyword">int</span> num2 <span class="token operator">=</span> <span class="token number">20</span><span class="token operator">/</span><span class="token number">5</span><span class="token punctuation">;</span> <span class="token comment">// 任务 2</span>\n  <span class="token keyword">int</span> num3 <span class="token operator">=</span> <span class="token number">7</span><span class="token operator">*</span><span class="token number">8</span><span class="token punctuation">;</span> <span class="token comment">// 任务 3</span>\n  <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">" 最终计算的值为:%d,%d,%d"</span><span class="token punctuation">,</span>num<span class="token punctuation">,</span> num2<span class="token punctuation">,</span> num3<span class="token punctuation">)</span>； <span class="token comment">// 任务 4</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>在上面的执行代码中，我们把所有任务代码按照顺序写进主线程里，等线程执行时，这些任务会按照顺序在线程中依次被执行；等所有任务执行完成之后，线程会自动退出。可以参考下图来直观地理解下其执行过程：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-05-15-34-41-14ad4d9a6ca3928b729da147297fc26b-ed3f4.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 55.590062111801245%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABc0lEQVQoz6VSuVLDMBDN31HyC/wNP5BjaGhS0FLQkDAThmFiQ0NBAUzuOD4kW7YTy5IV62AdTwJh0qF5eiPt6mlXq22Yf4zG742UknFeFAVMIQQwr7d7hqG1Pi1mjKfrNQ4jH6EoIsABxgDPDxAOwR6RuCzL0+I8z8ezGQpDL0ARIV4QgBKEwGB0Vu7naATZKX1SzNjHaOzjcLpwMImB3QDPl+7S9ebOaun6o9milBJOQu6AI3HBmcgiQYkWmWRJkcdiE5Z5zBLEUszXodkmr464+1KHyFUSQrDHQcdL6NULb1l526IdmzWHtDWksG5ZtG3nYO/YtGmLs25xcSsw1Q2onlSS88x67iZMPExNb6Jq9KeqP/nB/UQN5ur6TZ7fbC+ftutCV2nrKngVXytptDCKV5DsDyAEfIg9jnvvoSmpktujN0MNoJQ1diXZ3Vi7TOUqpQanMaWqDujGydaB/yCEZFmGEErTNEmSzWZj9rccuuQbn+duCydzpwcAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 05 15 34 41"\n        title=""\n        src="/static/2021-07-05-15-34-41-14ad4d9a6ca3928b729da147297fc26b-fee1c.png"\n        srcset="/static/2021-07-05-15-34-41-14ad4d9a6ca3928b729da147297fc26b-a67b7.png 200w,\n/static/2021-07-05-15-34-41-14ad4d9a6ca3928b729da147297fc26b-0b187.png 400w,\n/static/2021-07-05-15-34-41-14ad4d9a6ca3928b729da147297fc26b-fee1c.png 800w,\n/static/2021-07-05-15-34-41-14ad4d9a6ca3928b729da147297fc26b-b1a91.png 1200w,\n/static/2021-07-05-15-34-41-14ad4d9a6ca3928b729da147297fc26b-ed3f4.png 1288w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<h2 id="在线程运行过程中处理新任务"><a href="#%E5%9C%A8%E7%BA%BF%E7%A8%8B%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%A4%84%E7%90%86%E6%96%B0%E4%BB%BB%E5%8A%A1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>在线程运行过程中处理新任务</h2>\n<p>但并不是所有的任务都是在执行之前统一安排好的，大部分情况下，新的任务是在线程运行过程中产生的。比如在线程执行过程中，又接收到了一个新的任务要求计算“10+2”，那上面那种方式就无法处理这种情况了。</p>\n<p>要想在线程运行过程中，能接收并执行新的任务，就需要采用事件循环机制。我们可以通过一个 for 循环语句来监听是否有新的任务，如下面的示例代码：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="28339691376664343000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// GetInput\n// 等待用户从键盘输入一个数字，并返回该输入的数字\nint GetInput() {\n  int input_number = 0;\n  cout<<&quot;请输入一个数:&quot;;\n  cin>>input_number;\n  return input_number;\n}\n\n// 主线程(Main Thread)\nvoid MainThread() {\n  for(;;){\n    int first_num = GetInput();\n    int second_num = GetInput();\n    result_num = first_num + second_num;\n    print(&quot;最终计算的值为:%d&quot;,result_num);\n  }\n}`, `28339691376664343000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                data-tooltip="复制"\n              >\n                <svg class="gatsby-code-button-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M16 1H2v16h2V3h12V1zm-1 4l6 6v12H6V5h9zm-1 7h5.5L14 6.5V12z"/></svg>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="cpp"><pre style="counter-reset: linenumber NaN" class="language-cpp line-numbers"><code class="language-cpp"><span class="token comment">// GetInput</span>\n<span class="token comment">// 等待用户从键盘输入一个数字，并返回该输入的数字</span>\n<span class="token keyword">int</span> <span class="token function">GetInput</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">int</span> input_number <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>\n  cout<span class="token operator">&lt;&lt;</span><span class="token string">"请输入一个数:"</span><span class="token punctuation">;</span>\n  cin<span class="token operator">>></span>input_number<span class="token punctuation">;</span>\n  <span class="token keyword">return</span> input_number<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// 主线程(Main Thread)</span>\n<span class="token keyword">void</span> <span class="token function">MainThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n    <span class="token keyword">int</span> first_num <span class="token operator">=</span> <span class="token function">GetInput</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">int</span> second_num <span class="token operator">=</span> <span class="token function">GetInput</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    result_num <span class="token operator">=</span> first_num <span class="token operator">+</span> second_num<span class="token punctuation">;</span>\n    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"最终计算的值为:%d"</span><span class="token punctuation">,</span>result_num<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>相较于第一版的线程，这一版的线程做了两点改进。</p>\n<ul>\n<li>第一点引入了循环机制，具体实现方式是在线程语句最后添加了一个 for 循环语句，线程会一直循环执行。</li>\n<li>第二点是引入了事件，可以在线程运行过程中，等待用户输入的数字，等待过程中线程处于暂停状态，一旦接收到用户输入的信息，那么线程会被激活，然后执行相加运算，最后输出结果。</li>\n</ul>\n<p>通过引入事件循环机制，就可以让该线程“活”起来了，我们每次输入两个数字，都会打印出两数字相加的结果，你可以结合下图来参考下这个改进版的线程：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-05-15-36-22-cf284cfa7deb324afd661f712c7b9a60-29961.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 82.36272878535773%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAIAAACZeshMAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABqElEQVQoz42Ty07cMBSG86BsWCBYsIQdGxa8QCUkVAlWLFhxa4vUMiosgUpFDCBoCa3IaEqYXBzHThzfOYkJjBDT4ZdlHV8+H19+e3a0tNaqlZQSaugZnuCNIo0xeZ7jRi7IsowQAv3jYciTpmmv1/N9v9/vuxghNJz8f5lJoyYzyTCGOCf07cymlm4D055Zam2S6EGJAkaaMvrMQLlxN1HpunXdx4sHbH5fbF1JO7SA90RYS+K74OKbNapAUXJ/R5L73u0VRVHM7HpXbf8yP0M7/UnsXqt6U6aF3W7PLg8/rEzcILtyzFZP6NqP8uMR2ejy2S9yaofTHNky2jovJzZFIYzL70nFq4pCo3u6t742gyvzO7G3qC5+agNsD//qyW0+wMxy0rnhc19F+QzXt2RUfTzOBM1eXYlrLJ/Imc9i4bteOigroZ77PTtObl431J0/2v+X5hgxVoE45+Ph9kLrl0NJPBgM4jgGw4Bt3gU7XiodRVEYhgAHQZAkyXvhISO96G24KApKKWMMzAy/oixL2CR8DDD8+F8FGPBQg7FhFYBx4+1X8CMYAZeRWApgQAAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 05 15 36 22"\n        title=""\n        src="/static/2021-07-05-15-36-22-cf284cfa7deb324afd661f712c7b9a60-fee1c.png"\n        srcset="/static/2021-07-05-15-36-22-cf284cfa7deb324afd661f712c7b9a60-a67b7.png 200w,\n/static/2021-07-05-15-36-22-cf284cfa7deb324afd661f712c7b9a60-0b187.png 400w,\n/static/2021-07-05-15-36-22-cf284cfa7deb324afd661f712c7b9a60-fee1c.png 800w,\n/static/2021-07-05-15-36-22-cf284cfa7deb324afd661f712c7b9a60-b1a91.png 1200w,\n/static/2021-07-05-15-36-22-cf284cfa7deb324afd661f712c7b9a60-29961.png 1202w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<h2 id="处理其他线程发送过来的任务"><a href="#%E5%A4%84%E7%90%86%E5%85%B6%E4%BB%96%E7%BA%BF%E7%A8%8B%E5%8F%91%E9%80%81%E8%BF%87%E6%9D%A5%E7%9A%84%E4%BB%BB%E5%8A%A1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>处理其他线程发送过来的任务</h2>\n<p>上面我们改进了线程的执行方式，引入了事件循环机制，可以让其在执行过程中接受新的任务。不过在第二版的线程模型中，所有的任务都是来自于线程内部的，如果另外一个线程想让主线程执行一个任务，利用第二版的线程模型是无法做到的。</p>\n<p>那下面我们就来看看其他线程是如何发送消息给渲染主线程的，具体形式你可以参考下图：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-05-15-36-37-f640306f8b3ea0982b29ce147087fce9-5cdb5.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 70.18072289156628%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAIAAACgpqunAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABqElEQVQoz41SbU/bQAzmL6P9nP0CJNBA6gZ8Qkj9tEpo00rE2sIUhaZpmijkck3uzrGNr1fe1lXaI+fii++xn3N8wMz9v8AvQMTdKBFJ6EBiSqluiza8jDHj8Xg0Gg2HwyRJnHNt60OySEhrLb4nSxoJ8A6KfJml83SerHUj21AqAAAkxQeyqKuLGHpUlsQ65IfH5TReTOJ0Ei/WwEVLsxKBPFnEfSB3XXN99bnU5nxGgzsYROYsMqeR/fKjObs15xM4+WUPL9x9RUzQvpLDBcTR9SrIw6eKNmq94EaJaAZnVaPcHtn8vr/Fipw/iKpGIUsKrQlg753JA7fkckXWbsgKNxL6bEFdR/wflbnI2Hkyq4p17R27ZrB7KwPYu+jKOFhqXuQ6q2y25rzlVS1fKNcYl+77HDuQ7ux22+ib0UnVum9TGkzpq9jv/vinPrqpT2/NxYyOI/x06f488Vu35YIyMaJExoiQJKvEmJwYoS2zefIwbepSLtOjk1NMfRhBT5ZHaGH/AguSwxuGP9cjhrg1JjhSckv+C5LrcYM0TfM8F0fW9+P5imenpyUDdr7C3AAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 05 15 36 37"\n        title=""\n        src="/static/2021-07-05-15-36-37-f640306f8b3ea0982b29ce147087fce9-fee1c.png"\n        srcset="/static/2021-07-05-15-36-37-f640306f8b3ea0982b29ce147087fce9-a67b7.png 200w,\n/static/2021-07-05-15-36-37-f640306f8b3ea0982b29ce147087fce9-0b187.png 400w,\n/static/2021-07-05-15-36-37-f640306f8b3ea0982b29ce147087fce9-fee1c.png 800w,\n/static/2021-07-05-15-36-37-f640306f8b3ea0982b29ce147087fce9-b1a91.png 1200w,\n/static/2021-07-05-15-36-37-f640306f8b3ea0982b29ce147087fce9-5cdb5.png 1328w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从上图可以看出，渲染主线程会频繁接收到来自于 IO 线程的一些任务，接收到这些任务之后，渲染进程就需要着手处理，比如接收到资源加载完成的消息后，渲染进程就要着手进行 DOM 解析了；接收到鼠标点击的消息后，渲染主线程就要开始执行相应的 JavaScript 脚本来处理该点击事件。</p>\n<p>那么如何设计好一个线程模型，能让其能够接收其他线程发送的消息呢？</p>\n<p>一个通用模式是使用消息队列。在解释如何实现之前，我们先说说什么是消息队列，可以参考下图：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-05-15-36-49-b9932e0a0b3732be6d12a4f8e7aec6b5-0a2a7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 33.43239227340268%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAIAAACHqfpvAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABFklEQVQY032QS0+DQBSF+WOuXPggGlf+Bn+Sr8RFY6ML122JTXwU4wot0CCEEoYCnaC0oVBmYJgZaXXTxnpzF+ec3JObfAJfHcrYP7t2LHBKGaVZlsYRxPMZ3zx1PUsmWTJFCP14gXxGnJAc40d1KPXdVzPomWPZGPU+whfDfzbDWsi1sKBsePeq+6A6uCzpLGFVJZD4i6dJalsnd/bODTy6VA6brnjxtnXlbJ++7zXcg4a9e6aIt1A8V/avwXHTRp5LgLMolzDkKMfz7MnwW/q4qwFpEEgqaOlBR/U6eiBpvtQH7QGsw7YWdHWfFEU1iRdlVhG+SoItbTKNwdCKwhEl5Z8AlsA2cC5KkiOM6yeU/oZ0nfk38Hd+EIyNiqYAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 05 15 36 49"\n        title=""\n        src="/static/2021-07-05-15-36-49-b9932e0a0b3732be6d12a4f8e7aec6b5-fee1c.png"\n        srcset="/static/2021-07-05-15-36-49-b9932e0a0b3732be6d12a4f8e7aec6b5-a67b7.png 200w,\n/static/2021-07-05-15-36-49-b9932e0a0b3732be6d12a4f8e7aec6b5-0b187.png 400w,\n/static/2021-07-05-15-36-49-b9932e0a0b3732be6d12a4f8e7aec6b5-fee1c.png 800w,\n/static/2021-07-05-15-36-49-b9932e0a0b3732be6d12a4f8e7aec6b5-b1a91.png 1200w,\n/static/2021-07-05-15-36-49-b9932e0a0b3732be6d12a4f8e7aec6b5-0a2a7.png 1346w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从图中可以看出，消息队列是一种数据结构，可以存放要执行的任务。它符合队列“先进先出”的特点，也就是说要添加任务的话，添加到队列的尾部；要取出任务的话，从队列头部去取。</p>\n<p>有了队列之后，我们就可以继续改造线程模型了，改造方案如下图所示：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-05-15-37-02-0559f3d4e4ffa48ccad5e3695fcd821a-eb890.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 66.13119143239625%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAIAAAAmMtkJAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACCklEQVQoz3VS227TQBDNLyOhliIhfoBnoIAqISQeUQpJWim8FNpKbaER4DZx6jR2nNRJnNjry+5674ydUCoqjo6smdWcnTnrqRljWIXiHvIsS9OUUgqx4EWc0SijSnImBBdCa11TSuV5jjGWEo7ULQsuh67XvxrkhCql55l8e86eHfHzwWLcv3QdB/Q1uCDPie87/qhzGph6VzT7qrGiXX4/2ao9UI/afBDpSWY2W8nM96aTMed8JS4HVEowaQg3+ZoaV8yY0cbsX8nnZ6LhmAMXMgNtwWk5NliCXOkS5v9wQnHyzYV6KIO2pRgihFCCEF4uOYp+Wf0Xx+Odo+vXX69fHjivDofbh+6bY3f7i/Pu1AsuLbGYYUrFqjOIoyhKk6QI52YyPDmzNhqDp43u4/rFww/W1sfe5m73SdPeqlsbu/aFc2NwSihdd4Yx4C9JKSkhmJDR2Oc4MYLNJyNBUsPIIvAlzQ2nmuGCMcIYFIt/PANEQeIwAONKyuXsBk6yFGVJfP8t/o4Nm6CURGg6CElnGLmRdJH+4cVurJyQW34yjJWH9Ajp9z9VZ6rK1+aVGKIgCLI0cT3rs41bXb7XK/Z6rNVjzV6xb/MqLiBt99mDJt35DmMqWLp159UCSiFhU/+QVxR3gvI8wVBWykACfmt3neiKUmmUZuEimoeLJM1yTCKUwlbc1tziNySS08FDlEaXAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 05 15 37 02"\n        title=""\n        src="/static/2021-07-05-15-37-02-0559f3d4e4ffa48ccad5e3695fcd821a-fee1c.png"\n        srcset="/static/2021-07-05-15-37-02-0559f3d4e4ffa48ccad5e3695fcd821a-a67b7.png 200w,\n/static/2021-07-05-15-37-02-0559f3d4e4ffa48ccad5e3695fcd821a-0b187.png 400w,\n/static/2021-07-05-15-37-02-0559f3d4e4ffa48ccad5e3695fcd821a-fee1c.png 800w,\n/static/2021-07-05-15-37-02-0559f3d4e4ffa48ccad5e3695fcd821a-b1a91.png 1200w,\n/static/2021-07-05-15-37-02-0559f3d4e4ffa48ccad5e3695fcd821a-eb890.png 1494w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从上图可以看出，我们的改造可以分为下面三个步骤：</p>\n<ul>\n<li>添加一个消息队列；</li>\n<li>IO 线程中产生的新任务添加进消息队列尾部；</li>\n<li>渲染主线程会循环地从消息队列头部中读取任务，执行任务。</li>\n</ul>\n<p>有了这些步骤之后，那么接下来我们就可以按步骤使用代码来实现第三版的线程模型。</p>\n<p>首先，构造一个队列。当然，在本篇文章中我们不需要考虑队列实现的细节，只是构造队列的接口：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="47676630806681895000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`class TaskQueue{\n  public:\n  Task takeTask(); // 取出队列头部的一个任务\n  void pushTask(Task task); // 添加一个任务到队列尾部\n};`, `47676630806681895000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                data-tooltip="复制"\n              >\n                <svg class="gatsby-code-button-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M16 1H2v16h2V3h12V1zm-1 4l6 6v12H6V5h9zm-1 7h5.5L14 6.5V12z"/></svg>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="cpp"><pre style="counter-reset: linenumber NaN" class="language-cpp line-numbers"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">TaskQueue</span><span class="token punctuation">{</span>\n  <span class="token keyword">public</span><span class="token operator">:</span>\n  Task <span class="token function">takeTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 取出队列头部的一个任务</span>\n  <span class="token keyword">void</span> <span class="token function">pushTask</span><span class="token punctuation">(</span>Task task<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 添加一个任务到队列尾部</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>接下来，改造主线程，让主线程从队列中读取任务：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="782684282083545600"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`TaskQueue task_queue；\nvoid ProcessTask();\nvoid MainThread(){\n  for(;;){\n    Task task = task_queue.takeTask();\n    ProcessTask(task);\n  }\n}`, `782684282083545600`)"\n            >\n              <div\n                class="gatsby-code-button"\n                data-tooltip="复制"\n              >\n                <svg class="gatsby-code-button-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M16 1H2v16h2V3h12V1zm-1 4l6 6v12H6V5h9zm-1 7h5.5L14 6.5V12z"/></svg>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="cpp"><pre style="counter-reset: linenumber NaN" class="language-cpp line-numbers"><code class="language-cpp">TaskQueue task_queue；\n<span class="token keyword">void</span> <span class="token function">ProcessTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">void</span> <span class="token function">MainThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n    Task task <span class="token operator">=</span> task_queue<span class="token punctuation">.</span><span class="token function">takeTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token function">ProcessTask</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>在上面的代码中，我们添加了一个消息队列的对象，然后在主线程的 for 循环代码块中，从消息队列中读取一个任务，然后执行该任务，主线程就这样一直循环往下执行，因此只要消息队列中有任务，主线程就会去执行。</p>\n<p>主线程的代码就这样改造完成了。这样改造后，主线程执行的任务都全部从消息队列中获取。所以如果有其他线程想要发送任务让主线程去执行，只需要将任务添加到该消息队列中就可以了，添加任务的代码如下：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="4351097400772219400"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`Task clickTask;\ntask_queue.pushTask(clickTask)`, `4351097400772219400`)"\n            >\n              <div\n                class="gatsby-code-button"\n                data-tooltip="复制"\n              >\n                <svg class="gatsby-code-button-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M16 1H2v16h2V3h12V1zm-1 4l6 6v12H6V5h9zm-1 7h5.5L14 6.5V12z"/></svg>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="cpp"><pre style="counter-reset: linenumber NaN" class="language-cpp line-numbers"><code class="language-cpp">Task clickTask<span class="token punctuation">;</span>\ntask_queue<span class="token punctuation">.</span><span class="token function">pushTask</span><span class="token punctuation">(</span>clickTask<span class="token punctuation">)</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span></span></pre></div>\n<p>由于是多个线程操作同一个消息队列，所以在添加任务和取出任务时还会加上一个同步锁，这块内容也要注意下。</p>\n<h2 id="处理其他进程发送过来的任务"><a href="#%E5%A4%84%E7%90%86%E5%85%B6%E4%BB%96%E8%BF%9B%E7%A8%8B%E5%8F%91%E9%80%81%E8%BF%87%E6%9D%A5%E7%9A%84%E4%BB%BB%E5%8A%A1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>处理其他进程发送过来的任务</h2>\n<p>通过使用消息队列，我们实现了线程之间的消息通信。在 Chrome 中，跨进程之间的任务也是频繁发生的，那么如何处理其他进程发送过来的任务？你可以参考下图：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-05-15-38-28-02da4c333940e73b4389e085ab5e2544-794d5.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 78.69986168741356%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAIAAACZeshMAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACW0lEQVQoz3VSX0/UQBC/r+mn0BD1RT6A8VkUE1+RBDlPxb9vEKIi+CD2jt5xd3CAR6+93Xa32223+9dpGwgQmUw2s7P7m5nfzLSklEVRlJUIVausT5HzJEYpJY1TSeEHxTQurC6LUoqyNMa0OOeUpkJkeani3CS5ibmmwk5Rurvf743OksIyoX+eqqUd8Xhbfu9Nx7/3DrtdDeAsy3CcnIy++QHr9N1G37yvdWNgP43dx2HlaffMvc/SOffr3C5+oRmehbOZUqqV5zkkt0a7WuylWmuMNdZqW/lXPfV0T610bR9Vdygb+LaAMFy0sVCGsdfg10I5t3/CD7wJ2BBRCFGBoWyEcUFIyRieHL36MX62dfRye/R8c7i0OXqxBTpc3p4sbx2u7Y7TkV+SJC+gqXVmxlgYRZJSFfzFfvfJ18HC28GjdwcL7e7d9d7DTu8B6Mbwfttb/DA4n85cSgoBVddg4AzU4S5FEROC5pHVMktpgiKnJSMJiZGW8JqDQk6gCfzKq5xtRcqFYZRQCkaEMElZY1CWVU2B/l10FOQ/YJpgzlIwGE1yXoEZiXnGGpQy7jw19ccLMIUVYbzk0c44WtlXa3/yjq/bvnrtiQ5M+ECteeKNr8GG8856uepVQy3EBRghHAbjk+kEZfo0JEfTeZDwIOYhKUDPInocxGHCz3De8djxPIdthRlVS9LwaMo2WqYkTnAE7YJlrqhKkaUEnDwlrqn4irQuLeghdBNjjBCCnWuIwSyi+XwWhs1QnLsWoXU1kq4FPsHZdPGG59bMN6JEEaSsBDbR3SL/AGN0f51WcJ54AAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 05 15 38 28"\n        title=""\n        src="/static/2021-07-05-15-38-28-02da4c333940e73b4389e085ab5e2544-fee1c.png"\n        srcset="/static/2021-07-05-15-38-28-02da4c333940e73b4389e085ab5e2544-a67b7.png 200w,\n/static/2021-07-05-15-38-28-02da4c333940e73b4389e085ab5e2544-0b187.png 400w,\n/static/2021-07-05-15-38-28-02da4c333940e73b4389e085ab5e2544-fee1c.png 800w,\n/static/2021-07-05-15-38-28-02da4c333940e73b4389e085ab5e2544-b1a91.png 1200w,\n/static/2021-07-05-15-38-28-02da4c333940e73b4389e085ab5e2544-794d5.png 1446w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从图中可以看出，渲染进程专门有一个 IO 线程用来接收其他进程传进来的消息，接收到消息之后，会将这些消息组装成任务发送给渲染主线程，后续的步骤就和前面讲解的“处理其他线程发送的任务”一样了，这里就不再重复了。</p>\n<h2 id="消息队列中的任务类型"><a href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%B8%AD%E7%9A%84%E4%BB%BB%E5%8A%A1%E7%B1%BB%E5%9E%8B" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>消息队列中的任务类型</h2>\n<p>现在你知道页面主线程是如何接收外部任务的了，那接下来我们再来看看消息队列中的任务类型有哪些。你可以参考下 Chromium 的<a href="https://cs.chromium.org/chromium/src/third_party/blink/public/platform/task_type.h" target="_blank" rel="nofollow noreferrer noopener">官方源码</a>，这里面包含了很多内部消息类型，如输入事件（鼠标滚动、点击、移动）、微任务、文件读写、WebSocket、JavaScript 定时器等等。</p>\n<p>除此之外，消息队列中还包含了很多与页面相关的事件，如 JavaScript 执行、解析 DOM、样式计算、布局计算、CSS 动画等。</p>\n<p>以上这些事件都是在主线程中执行的，所以在编写 Web 应用时，你还需要衡量这些事件所占用的时长，并想办法解决单个任务占用主线程过久的问题。</p>\n<h2 id="如何安全退出"><a href="#%E5%A6%82%E4%BD%95%E5%AE%89%E5%85%A8%E9%80%80%E5%87%BA" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>如何安全退出</h2>\n<p>当页面主线程执行完成之后，又该如何保证页面主线程能够安全退出呢？Chrome 是这样解决的，确定要退出当前页面时，页面主线程会设置一个退出标志的变量，在每次执行完一个任务时，判断是否有设置退出标志。</p>\n<p>如果设置了，那么就直接中断当前的所有任务，退出线程，你可以参考下面代码：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="51540106393579860000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`TaskQueue task_queue；\nvoid ProcessTask();\nbool keep_running = true;\nvoid MainThread() {\n  for(;;){\n    Task task = task_queue.takeTask();\n    ProcessTask(task);\n    if(!keep_running) // 如果设置了退出标志，那么直接退出线程循环\n      break;\n  }\n}`, `51540106393579860000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                data-tooltip="复制"\n              >\n                <svg class="gatsby-code-button-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M16 1H2v16h2V3h12V1zm-1 4l6 6v12H6V5h9zm-1 7h5.5L14 6.5V12z"/></svg>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="cpp"><pre style="counter-reset: linenumber NaN" class="language-cpp line-numbers"><code class="language-cpp">TaskQueue task_queue；\n<span class="token keyword">void</span> <span class="token function">ProcessTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">bool</span> keep_running <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n<span class="token keyword">void</span> <span class="token function">MainThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n    Task task <span class="token operator">=</span> task_queue<span class="token punctuation">.</span><span class="token function">takeTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token function">ProcessTask</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>keep_running<span class="token punctuation">)</span> <span class="token comment">// 如果设置了退出标志，那么直接退出线程循环</span>\n      <span class="token keyword">break</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h2 id="页面使用单线程的缺点"><a href="#%E9%A1%B5%E9%9D%A2%E4%BD%BF%E7%94%A8%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%BC%BA%E7%82%B9" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>页面使用单线程的缺点</h2>\n<p>上面讲述的就是页面线程的循环系统是如何工作的，那接下来，我们继续探讨页面线程的一些特征。</p>\n<p>通过上面的介绍，你应该清楚了，页面线程所有执行的任务都来自于消息队列。消息队列是“先进先出”的属性，也就是说放入队列中的任务，需要等待前面的任务被执行完，才会被执行。鉴于这个属性，就有如下两个问题需要解决。</p>\n<h3 id="如何处理高优先级的任务"><a href="#%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E9%AB%98%E4%BC%98%E5%85%88%E7%BA%A7%E7%9A%84%E4%BB%BB%E5%8A%A1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>如何处理高优先级的任务</h3>\n<p>比如一个典型的场景是监控 DOM 节点的变化情况（节点的插入、修改、删除等动态变化），然后根据这些变化来处理相应的业务逻辑。一个通用的设计的是，利用 JavaScript 设计一套监听接口，当变化发生时，渲染引擎同步调用这些接口，这是一个典型的观察者模式。</p>\n<p>不过这个模式有个问题，因为 DOM 变化非常频繁，如果每次发生变化的时候，都直接调用相应的 JavaScript 接口，那么这个当前的任务执行时间会被拉长，从而导致执行效率的下降。</p>\n<p>如果将这些 DOM 变化做成异步的消息事件，添加到消息队列的尾部，那么又会影响到监控的实时性，因为在添加到消息队列的过程中，可能前面就有很多任务在排队了。</p>\n<p>这也就是说，如果 DOM 发生变化，采用同步通知的方式，会影响当前任务的执行效率；如果采用异步方式，又会影响到监控的实时性</p>\n<p>那该如何权衡效率和实时性呢？</p>\n<p>针对这种情况，微任务就应用而生了，下面我们来看看微任务是如何权衡效率和实时性的。</p>\n<p>通常我们把消息队列中的任务称为宏任务，每个宏任务中都包含了一个微任务队列，在执行宏任务的过程中，如果 DOM 有变化，那么就会将该变化添加到微任务列表中，这样就不会影响到宏任务的继续执行，因此也就解决了执行效率的问题。</p>\n<p>等宏任务中的主要功能都直接完成之后，这时候，渲染引擎并不着急去执行下一个宏任务，而是执行当前宏任务中的微任务，因为 DOM 变化的事件都保存在这些微任务队列中，这样也就解决了实时性问题。</p>\n<h3 id="如何解决单个任务执行时长过久的问题"><a href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%8D%95%E4%B8%AA%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C%E6%97%B6%E9%95%BF%E8%BF%87%E4%B9%85%E7%9A%84%E9%97%AE%E9%A2%98" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>如何解决单个任务执行时长过久的问题</h3>\n<p>因为所有的任务都是在单线程中执行的，所以每次只能执行一个任务，而其他任务就都处于等待状态。如果其中一个任务执行时间过久，那么下一个任务就要等待很长时间。可以参考下图：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-05-15-40-26-fbe86c8a14dcdaf3adaf8d1ce8e6c092-e7341.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 52.22052067381316%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABQUlEQVQoz5VQa0vCUBjejy36IkIfhKAgocCoP9CXoCK6fFogpMYSxUg3DWKgYm4MraPn5BzbnCv1XDpraXSvw8N7Xp7zPOe9COwPh0xB3/PCTyYaiEeuA04O4OEe2N95MnsvNP3dHIp8BPWVmB6LqpF5r2UEPCHfmkMPjwRjnjwiqC0t1qML9cjc1+ZZJ5/btpqNByltlWUrnx07TigO5W+V+X+OZZqoa0Jg2xa6qdjiMRSPtN1tlDp1Msl+23A9x7V6GE9eK/Pu+NUyKrBvFqtAkmu569ucamTF89L6ViaeSMU3MqsJeW2zkL4sVO+UWlvtjM6aZDimAiHBYFojr3V7cocpgMr3VAGsBNhVlykogIxYEXKG87QMqKTj5Ytxx6UC+//hA9MPC+MUmWKCydD3B5438IYcPMeEzl7DbfHwDK/qLvi4DRj8AAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 05 15 40 26"\n        title=""\n        src="/static/2021-07-05-15-40-26-fbe86c8a14dcdaf3adaf8d1ce8e6c092-fee1c.png"\n        srcset="/static/2021-07-05-15-40-26-fbe86c8a14dcdaf3adaf8d1ce8e6c092-a67b7.png 200w,\n/static/2021-07-05-15-40-26-fbe86c8a14dcdaf3adaf8d1ce8e6c092-0b187.png 400w,\n/static/2021-07-05-15-40-26-fbe86c8a14dcdaf3adaf8d1ce8e6c092-fee1c.png 800w,\n/static/2021-07-05-15-40-26-fbe86c8a14dcdaf3adaf8d1ce8e6c092-b1a91.png 1200w,\n/static/2021-07-05-15-40-26-fbe86c8a14dcdaf3adaf8d1ce8e6c092-e7341.png 1306w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从图中你可以看到，如果在执行动画过程中，其中有个 JavaScript 任务因执行时间过久，占用了动画单帧的时间，这样会给用户制造了卡顿的感觉，这当然是极不好的用户体验。针对这种情况，JavaScript 可以通过回调功能来规避这种问题，也就是让要执行的 JavaScript 任务滞后执行。至于浏览器是如何实现回调功能的，我们在后面的章节中再详细介绍。</p>\n<h2 id="实践：浏览器页面是如何运行的"><a href="#%E5%AE%9E%E8%B7%B5%EF%BC%9A%E6%B5%8F%E8%A7%88%E5%99%A8%E9%A1%B5%E9%9D%A2%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%90%E8%A1%8C%E7%9A%84" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>实践：浏览器页面是如何运行的</h2>\n<p>有了上面的基础知识之后，我们最后来看看浏览器的页面是如何运行的。</p>\n<p>你可以打开开发者工具，点击“Performance”标签，选择左上角的“start porfiling and load page”来记录整个页面加载过程中的事件执行情况，如下图所示：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-05-15-40-55-fe1a25c4b0d62bf2788fbf2f76146412-604fe.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 68.09338521400778%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAIAAACgpqunAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABwUlEQVQoz32SaW+bQBCG/f//UKV8y4ekquTa5jAOMTc+MDbgZS+Ohe3s2jhK02b06GUG5t0RMDOMMaXkRl1jQlTCGOWcQXDOu64FHgEpPBJCSClngR/EcZIm+yTZbb04DKIk2afpIYpiP4QqCqM4CEGiOI6UprHnvWNcK7PtrpeOtVwvTde0t5a9NW84/toJ1rZna5xN6LxFoHDHXL0taqLN75sXz/2ZXcq8KEpUn4rS2u42Uf4yN55ff63M1W/Lni9eDWNuGAvLNo95djz4bdcr8wmdzuTS9pK1I29BJaID5jLdFX6Q5Vl1KcpznoRL331y9ouUtQMmTdO0ykyaAWy0GR5wdcrYDbIfZdMrOimLQ+0+bTLjxHuJuYAPp8zQzZpPZno/ThAudCm4kMURrX9YuXthnWoeRjlN1h2aYdJPwLTyhJN5gs5MN3+YR5ijkVMy8k4pnUqdSEoEJj3rJJR3c3XF1yuqqmsFqpOyAkVqXyiDDarht+CJmmCluO/1kiBUEYxwXTGKH3AGEIBpOCwco0wr5yq5b9j5UgoB7/BXyOkqxy9xf2Mw92KQX0K7lN4m/C9m/3QihK46yrL8xvwHgEMaMgvgciAAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 05 15 40 55"\n        title=""\n        src="/static/2021-07-05-15-40-55-fe1a25c4b0d62bf2788fbf2f76146412-fee1c.png"\n        srcset="/static/2021-07-05-15-40-55-fe1a25c4b0d62bf2788fbf2f76146412-a67b7.png 200w,\n/static/2021-07-05-15-40-55-fe1a25c4b0d62bf2788fbf2f76146412-0b187.png 400w,\n/static/2021-07-05-15-40-55-fe1a25c4b0d62bf2788fbf2f76146412-fee1c.png 800w,\n/static/2021-07-05-15-40-55-fe1a25c4b0d62bf2788fbf2f76146412-b1a91.png 1200w,\n/static/2021-07-05-15-40-55-fe1a25c4b0d62bf2788fbf2f76146412-604fe.png 1542w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从图中可以看出，我们点击展开了 Main 这个项目，其记录了主线程执行过程中的所有任务。图中灰色的就是一个个任务，每个任务下面还有子任务，其中的 Parse HTML 任务，是把 HTML 解析为 DOM 的任务。值得注意的是，在执行 Parse HTML 的时候，如果遇到 JavaScript 脚本，那么会暂停当前的 HTML 解析而去执行 JavaScript 脚本。</p>\n<p>至于 Performance 工具，在后面的章节中我们还会详细介绍，在这里你只需要建立一个直观的印象就可以了。</p>\n<h2 id="总结"><a href="#%E6%80%BB%E7%BB%93" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总结</h2>\n<ul>\n<li>如果有一些确定好的任务，可以使用一个单线程来按照顺序处理这些任务，这是第一版线程模型。</li>\n<li>要在线程执行过程中接收并处理新的任务，就需要引入循环语句和事件系统，这是第二版线程模型。</li>\n<li>如果要接收其他线程发送过来的任务，就需要引入消息队列，这是第三版线程模型。</li>\n<li>如果其他进程想要发送任务给页面主线程，那么先通过 IPC 把任务发送给渲染进程的 IO 线程，IO 线程再把任务发送给页面主线程。</li>\n<li>消息队列机制并不是太灵活，为了适应效率和实时性，引入了微任务</li>\n</ul>\n<p>基于消息队列的设计是目前使用最广的消息架构，无论是安卓还是 Chrome 都采用了类似的任务机制，所以理解了本篇文章的内容后，你再理解其他项目的任务机制也会比较轻松。</p>\n<h1 id="webapi：settimeout-是怎么实现的"><a href="#webapi%EF%BC%9Asettimeout-%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Webapi：setTimeout 是怎么实现的</h1>\n<p>本篇文章主要介绍的是 setTimeout。其实说起 setTimeout 方法，从事开发的同学想必都不会陌生，它就是一个定时器，用来指定某个函数在多少毫秒之后执行。它会返回一个整数，表示定时器的编号，同时你还可以通过该编号来取消这个定时器。下面的示例代码就演示了定时器最基础的使用方式：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="47271442524891820000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function showName() {\n  console.log(\'极客时间\');\n}\nvar timerID = setTimeout(showName, 200);`, `47271442524891820000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                data-tooltip="复制"\n              >\n                <svg class="gatsby-code-button-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M16 1H2v16h2V3h12V1zm-1 4l6 6v12H6V5h9zm-1 7h5.5L14 6.5V12z"/></svg>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span> <span class="token function">showName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'极客时间\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">var</span> timerID <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span>showName<span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>执行上述代码，输出的结果也很明显，通过 setTimeout 指定在 200 毫秒之后调用 showName 函数，并输出“极客时间”四个字。</p>\n<p>简单了解了 setTimeout 的使用方法后，那接下来我们就来看看浏览器是如何实现定时器的，然后再介绍下定时器在使用过程中的一些注意事项</p>\n<h2 id="浏览器怎么实现-settimeout"><a href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0-settimeout" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>浏览器怎么实现 setTimeout</h2>\n<p>要了解定时器的工作原理，就得先来回顾下之前讲的事件循环系统，我们知道渲染进程中所有运行在主线程上的任务都需要先添加到消息队列，然后事件循环系统再按照顺序执行消息队列中的任务。下面我们来看看那些典型的事件</p>\n<ul>\n<li>当接收到 HTML 文档数据，渲染引擎就会将“解析 DOM”事件添加到消息队列中，</li>\n<li>当用户改变了 Web 页面的窗口大小，渲染引擎就会将“重新布局”的事件添加到消息队列中。</li>\n<li>当触发了 JavaScript 引擎垃圾回收机制，渲染引擎会将“垃圾回收”任务添加到消息队列中。</li>\n<li>同样，如果要执行一段异步 JavaScript 代码，也是需要将执行任务添加到消息队列中</li>\n</ul>\n<p>以上列举的只是一小部分事件，这些事件被添加到消息队列之后，事件循环系统就会按照消息队列中的顺序来执行事件。</p>\n<p>所以说要执行一段异步任务，需要先将任务添加到消息队列中。不过通过定时器设置回调函数有点特别，它们需要在指定的时间间隔内被调用，但消息队列中的任务是按照顺序执行的，所以为了保证回调函数能在指定时间内执行，你不能将定时器的回调函数直接添加到消息队列中。</p>\n<p>那么该怎么设计才能让定时器设置的回调事件在规定时间内被执行呢？你也可以思考下，如果让你在消息循环系统的基础之上加上定时器的功能，你会如何设计？</p>\n<p>在 Chrome 中除了正常使用的消息队列之外，还有另外一个消息队列，这个队列中维护了需要延迟执行的任务列表，包括了定时器和 Chromium 内部一些需要延迟执行的任务。所以当通过 JavaScript 创建一个定时器时，渲染进程会将该定时器的回调任务添加到延迟队列中</p>\n<p>源码中延迟执行队列的定义如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="63293161325167890000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`DelayedIncomingQueue delayed_incoming_queue;`, `63293161325167890000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                data-tooltip="复制"\n              >\n                <svg class="gatsby-code-button-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M16 1H2v16h2V3h12V1zm-1 4l6 6v12H6V5h9zm-1 7h5.5L14 6.5V12z"/></svg>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="cpp"><pre style="counter-reset: linenumber NaN" class="language-cpp line-numbers"><code class="language-cpp">DelayedIncomingQueue delayed_incoming_queue<span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>当通过 JavaScript 调用 setTimeout 设置回调函数的时候，渲染进程将会创建一个回调任务，包含了回调函数 showName、当前发起时间、延迟执行时间，其模拟代码如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="20480144404992664000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`struct DelayTask{\n  int64 id；\n  CallBackFunction cbf;\n  int start_time;\n  int delay_time;\n};\nDelayTask timerTask;\ntimerTask.cbf = showName;\ntimerTask.start_time = getCurrentTime(); // 获取当前时间\ntimerTask.delay_time = 200; // 设置延迟执行时间`, `20480144404992664000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                data-tooltip="复制"\n              >\n                <svg class="gatsby-code-button-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M16 1H2v16h2V3h12V1zm-1 4l6 6v12H6V5h9zm-1 7h5.5L14 6.5V12z"/></svg>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="cpp"><pre style="counter-reset: linenumber NaN" class="language-cpp line-numbers"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">DelayTask</span><span class="token punctuation">{</span>\n  int64 id；\n  CallBackFunction cbf<span class="token punctuation">;</span>\n  <span class="token keyword">int</span> start_time<span class="token punctuation">;</span>\n  <span class="token keyword">int</span> delay_time<span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\nDelayTask timerTask<span class="token punctuation">;</span>\ntimerTask<span class="token punctuation">.</span>cbf <span class="token operator">=</span> showName<span class="token punctuation">;</span>\ntimerTask<span class="token punctuation">.</span>start_time <span class="token operator">=</span> <span class="token function">getCurrentTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取当前时间</span>\ntimerTask<span class="token punctuation">.</span>delay_time <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span> <span class="token comment">// 设置延迟执行时间</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>创建好回调任务之后，再将该任务添加到延迟执行队列中，代码如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="63509107422723350000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`delayed_incoming_queue.push(timerTask);`, `63509107422723350000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                data-tooltip="复制"\n              >\n                <svg class="gatsby-code-button-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M16 1H2v16h2V3h12V1zm-1 4l6 6v12H6V5h9zm-1 7h5.5L14 6.5V12z"/></svg>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="cpp"><pre style="counter-reset: linenumber NaN" class="language-cpp line-numbers"><code class="language-cpp">delayed_incoming_queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>timerTask<span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>现在通过定时器发起的任务就被保存到延迟队列中了，那接下来我们再来看看消息循环系统是怎么触发延迟队列的。</p>\n<p>我们可以来完善上一篇文章中消息循环的代码，在其中加入执行延迟队列的代码，如下所示</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="62707540651113920000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`void ProcessTimerTask(){\n  // 从 delayed_incoming_queue 中取出已经到期的定时器任务\n  // 依次执行这些任务\n}\n\nTaskQueue task_queue；\nvoid ProcessTask();\nbool keep_running = true;\nvoid MainTherad(){\n  for(;;){\n    // 执行消息队列中的任务\n    Task task = task_queue.takeTask();\n    ProcessTask(task);\n\n    // 执行延迟队列中的任务\n    ProcessDelayTask()\n\n    if(!keep_running) // 如果设置了退出标志，那么直接退出线程循环\n        break;\n  }\n}`, `62707540651113920000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                data-tooltip="复制"\n              >\n                <svg class="gatsby-code-button-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M16 1H2v16h2V3h12V1zm-1 4l6 6v12H6V5h9zm-1 7h5.5L14 6.5V12z"/></svg>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="cpp"><pre style="counter-reset: linenumber NaN" class="language-cpp line-numbers"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">ProcessTimerTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n  <span class="token comment">// 从 delayed_incoming_queue 中取出已经到期的定时器任务</span>\n  <span class="token comment">// 依次执行这些任务</span>\n<span class="token punctuation">}</span>\n\nTaskQueue task_queue；\n<span class="token keyword">void</span> <span class="token function">ProcessTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">bool</span> keep_running <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n<span class="token keyword">void</span> <span class="token function">MainTherad</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n    <span class="token comment">// 执行消息队列中的任务</span>\n    Task task <span class="token operator">=</span> task_queue<span class="token punctuation">.</span><span class="token function">takeTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token function">ProcessTask</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    <span class="token comment">// 执行延迟队列中的任务</span>\n    <span class="token function">ProcessDelayTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n\n    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>keep_running<span class="token punctuation">)</span> <span class="token comment">// 如果设置了退出标志，那么直接退出线程循环</span>\n        <span class="token keyword">break</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>从上面代码可以看出来，我们添加了一个 ProcessDelayTask 函数，该函数是专门用来处理延迟执行任务的。这里我们要重点关注它的执行时机，在上段代码中，处理完消息队列中的一个任务之后，就开始执行 ProcessDelayTask 函数。ProcessDelayTask 函数会根据发起时间和延迟时间计算出到期的任务，然后依次执行这些到期的任务。等到期的任务执行完成之后，再继续下一个循环过程。通过这样的方式，一个完整的定时器就实现了。</p>\n<p>设置一个定时器，JavaScript 引擎会返回一个定时器的 ID。那通常情况下，当一个定时器的任务还没有被执行的时候，也是可以取消的，具体方法是调用 clearTimeout 函数，并传入需要取消的定时器的 ID。如下面代码所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="29394113060296110000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`clearTimeout(timer_id)`, `29394113060296110000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                data-tooltip="复制"\n              >\n                <svg class="gatsby-code-button-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M16 1H2v16h2V3h12V1zm-1 4l6 6v12H6V5h9zm-1 7h5.5L14 6.5V12z"/></svg>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="cpp"><pre style="counter-reset: linenumber NaN" class="language-cpp line-numbers"><code class="language-cpp"><span class="token function">clearTimeout</span><span class="token punctuation">(</span>timer_id<span class="token punctuation">)</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>其实浏览器内部实现取消定时器的操作也是非常简单的，就是直接从 <code class="language-text">delayed_incoming_queue</code> 延迟队列中，通过 ID 查找到对应的任务，然后再将其从队列中删除掉就可以了。</p>\n<h2 id="使用-settimeout-的一些注意事项"><a href="#%E4%BD%BF%E7%94%A8-settimeout-%E7%9A%84%E4%B8%80%E4%BA%9B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>使用 setTimeout 的一些注意事项</h2>\n<p>现在你应该知道在浏览器内部定时器是如何工作的了。不过在使用定时器的过程中，如果你不了解定时器的一些细节，那么很有可能掉进定时器的一些陷阱里。所以接下来，我们就来讲解一下在使用定时器过程中存在的那些陷阱。</p>\n<h3 id="如果当前任务执行时间过久，会影延迟到期定时器任务的执行"><a href="#%E5%A6%82%E6%9E%9C%E5%BD%93%E5%89%8D%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C%E6%97%B6%E9%97%B4%E8%BF%87%E4%B9%85%EF%BC%8C%E4%BC%9A%E5%BD%B1%E5%BB%B6%E8%BF%9F%E5%88%B0%E6%9C%9F%E5%AE%9A%E6%97%B6%E5%99%A8%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%89%A7%E8%A1%8C" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>如果当前任务执行时间过久，会影延迟到期定时器任务的执行</h3>\n<p>在使用 setTimeout 的时候，有很多因素会导致回调函数执行比设定的预期值要久，其中一个就是当前任务执行时间过久从而导致定时器设置的任务被延后执行。我们先看下面这段代码：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="42577597544357010000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function bar() {\n  console.log(\'bar\');\n}\nfunction foo() {\n  setTimeout(bar, 0);\n  for (let i = 0; i < 5000; i++) {\n    let i = 5 + 8 + 8 + 8;\n    console.log(i);\n  }\n}\nfoo();`, `42577597544357010000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                data-tooltip="复制"\n              >\n                <svg class="gatsby-code-button-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M16 1H2v16h2V3h12V1zm-1 4l6 6v12H6V5h9zm-1 7h5.5L14 6.5V12z"/></svg>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'bar\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token function">setTimeout</span><span class="token punctuation">(</span>bar<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">5</span> <span class="token operator">+</span> <span class="token number">8</span> <span class="token operator">+</span> <span class="token number">8</span> <span class="token operator">+</span> <span class="token number">8</span><span class="token punctuation">;</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>这段代码中，在执行 foo 函数的时候使用 setTimeout 设置了一个 0 延时的回调任务，设置好回调任务后，foo 函数会继续执行 5000 次 for 循环。</p>\n<p>通过 setTimeout 设置的回调任务被放入了消息队列中并且等待下一次执行，这里并不是立即执行的；要执行消息队列中的下个任务，需要等待当前的任务执行完成，由于当前这段代码要执行 5000 次的 for 循环，所以当前这个任务的执行时间会比较久一点。这势必会影响到下个任务的执行时间。</p>\n<p>你也可以打开 Performance 来看看其执行过程，如下图所示：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-06-15-26-14-7bb0e7e6c04df25dfd7d09d82763354e-44aed.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 49.67741935483871%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAByElEQVQoz2P4+fPn9eu3rl69ef3Grdu3boMAiLyDYCMEQeSdO3dv37n7/fuP////Mzx9+qS5Mm1ye25LdYZfoI+vv7ePn5dfgI+3r6dvgA+QDRTxAzOAsj7+Xt7eTh4uVjdv3gBpfv78eUtTXXdnc3NTXVJyckxsTFx8XExsbGx8XGwcCMXEAYViQWygeHREZu2kggmb7z96BtJ85+5deUUlAUFhYRFRCQkJSTCQgpBgIAkFUlIycqJCvIHVqzNWfrxxD6z5xYtXNeU1jfVNLa2dza3dTS2dDc0dDc0gsh6EOoGosbWrqamtqbG5trLeIrBE2TLm0tVbIM2vX32YWDtxdsfUOR1TZ7VNWtI3e/30JWsmL1g3bcnWOcu2zVywbvLsxd2T53ROW9Azc3L9NE1DVyF583MXwX7+9v3nsTPXjpy6evj4xcNHzx09fuH4iUsnTl48eOxy46Lz1XNOlc062bX05LGTlw6funr01JVzF66du3j969dvIM3/cYP2fb9il31PXPmjbe9vIPffP3QFIM1/0QFU1emHv3de/7n7xs9TD37++4dFBRabf//+/fbt21evXn399Pbzu5ffPr398/s7VqcBACg8m/5TKF3FAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 06 15 26 14"\n        title=""\n        src="/static/2021-07-06-15-26-14-7bb0e7e6c04df25dfd7d09d82763354e-fee1c.png"\n        srcset="/static/2021-07-06-15-26-14-7bb0e7e6c04df25dfd7d09d82763354e-a67b7.png 200w,\n/static/2021-07-06-15-26-14-7bb0e7e6c04df25dfd7d09d82763354e-0b187.png 400w,\n/static/2021-07-06-15-26-14-7bb0e7e6c04df25dfd7d09d82763354e-fee1c.png 800w,\n/static/2021-07-06-15-26-14-7bb0e7e6c04df25dfd7d09d82763354e-b1a91.png 1200w,\n/static/2021-07-06-15-26-14-7bb0e7e6c04df25dfd7d09d82763354e-44aed.png 1550w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从图中可以看到，执行 foo 函数所消耗的时长是 500 毫秒，这也就意味着通过 setTimeout 设置的任务会被推迟到 500 毫秒以后再去执行，而设置 setTimeout 的回调延迟时间是 0。</p>\n<h3 id="如果-settimeout-存在嵌套调用，那么系统会设置最短时间间隔为-4-毫秒"><a href="#%E5%A6%82%E6%9E%9C-settimeout-%E5%AD%98%E5%9C%A8%E5%B5%8C%E5%A5%97%E8%B0%83%E7%94%A8%EF%BC%8C%E9%82%A3%E4%B9%88%E7%B3%BB%E7%BB%9F%E4%BC%9A%E8%AE%BE%E7%BD%AE%E6%9C%80%E7%9F%AD%E6%97%B6%E9%97%B4%E9%97%B4%E9%9A%94%E4%B8%BA-4-%E6%AF%AB%E7%A7%92" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>如果 setTimeout 存在嵌套调用，那么系统会设置最短时间间隔为 4 毫秒</h3>\n<p>也就是说在定时器函数里面嵌套调用定时器，也会延长定时器的执行时间，可以先看下面的这段代码：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="25127266357021114000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function cb() {\n  setTimeout(cb, 0);\n}\nsetTimeout(cb, 0);`, `25127266357021114000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                data-tooltip="复制"\n              >\n                <svg class="gatsby-code-button-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M16 1H2v16h2V3h12V1zm-1 4l6 6v12H6V5h9zm-1 7h5.5L14 6.5V12z"/></svg>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span> <span class="token function">cb</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token function">setTimeout</span><span class="token punctuation">(</span>cb<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token function">setTimeout</span><span class="token punctuation">(</span>cb<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>上述这段代码你有没有看出存在什么问题？</p>\n<p>你还是可以通过 Performance 来记录下这段代码的执行过程，如下图所示</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-06-15-27-09-d3fa068a4d0d5ef6fc33dae934bd357a-68b8a.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 40.07537688442211%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAIAAAB2/0i6AAAACXBIWXMAAA7DAAAOwwHHb6hkAAABiUlEQVQY03WOS0sCURiG3RWmEmnM1JyZ0+Ro2lTaLpK8T7eFLU1nnEydGaVVkxIUBFbQHxCidbZo2T8SpTLX3SB1OmcWbqKXh4/nfPB+HMv9Q3M/KxYVNZ3JlhRV0crp/cxhoahqlUxWlOV8uXIk5mRRyqnlinyQz4iSomrdt65hGJZ6/dLucLjdHAVoFAjnTGGQAEAjIIRogYRhIIKiAMuyrVYLl8+vGgQXWllP0XyC9EbhsuAObsKlJM0n6cUE5Y8TnijpjSEB/gRe8klvINZ9fcbls+vbMXKNDe6SC8IUlyB8woxfcHFJlwchoOnkMNOmT3sFp0eAfOzluYPLFzd347Oh+dU9wO8Svi2K3yF9W6R/e8ZkJCMnFrbRvzods3xab1hsAXRyko1bwYaDidroyAQI25iwnYlgp/HEMBG0sYKIiw21221cbj4+pdLagVqTinpOrcpaTSzoUqkqK9UconQiFhE6Qirp5lPPq8e9Xg+XjT8ZDAbfXx9fn+/9/o8x7BvG0Pgnv/cXvdBpUYdPAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 06 15 27 09"\n        title=""\n        src="/static/2021-07-06-15-27-09-d3fa068a4d0d5ef6fc33dae934bd357a-fee1c.png"\n        srcset="/static/2021-07-06-15-27-09-d3fa068a4d0d5ef6fc33dae934bd357a-a67b7.png 200w,\n/static/2021-07-06-15-27-09-d3fa068a4d0d5ef6fc33dae934bd357a-0b187.png 400w,\n/static/2021-07-06-15-27-09-d3fa068a4d0d5ef6fc33dae934bd357a-fee1c.png 800w,\n/static/2021-07-06-15-27-09-d3fa068a4d0d5ef6fc33dae934bd357a-b1a91.png 1200w,\n/static/2021-07-06-15-27-09-d3fa068a4d0d5ef6fc33dae934bd357a-68b8a.png 1592w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>上图中的竖线就是定时器的函数回调过程，从图中可以看出，前面五次调用的时间间隔比较小，嵌套调用超过五次以上，后面每次的调用最小时间间隔是 4 毫秒。之所以出现这样的情况，是因为在 Chrome 中，定时器被嵌套调用 5 次以上，系统会判断该函数方法被阻塞了，如果定时器的调用时间间隔小于 4 毫秒，那么浏览器会将每次调用的时间间隔设置为 4 毫秒。下面是 Chromium 实现 4 毫秒延迟的代码，你可以看下：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="84335350638675180000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`static const int kMaxTimerNestingLevel = 5;\n\n// Chromium uses a minimum timer interval of 4ms. We\'d like to go\n// lower; however, there are poorly coded websites out there which do\n// create CPU-spinning loops.  Using 4ms prevents the CPU from\n// spinning too busily and provides a balance between CPU spinning and\n// the smallest possible interval timer.\nstatic constexpr base::TimeDelta kMinimumInterval = base::TimeDelta::FromMilliseconds(4);`, `84335350638675180000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                data-tooltip="复制"\n              >\n                <svg class="gatsby-code-button-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M16 1H2v16h2V3h12V1zm-1 4l6 6v12H6V5h9zm-1 7h5.5L14 6.5V12z"/></svg>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="cpp"><pre style="counter-reset: linenumber NaN" class="language-cpp line-numbers"><code class="language-cpp"><span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> kMaxTimerNestingLevel <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>\n\n<span class="token comment">// Chromium uses a minimum timer interval of 4ms. We\'d like to go</span>\n<span class="token comment">// lower; however, there are poorly coded websites out there which do</span>\n<span class="token comment">// create CPU-spinning loops.  Using 4ms prevents the CPU from</span>\n<span class="token comment">// spinning too busily and provides a balance between CPU spinning and</span>\n<span class="token comment">// the smallest possible interval timer.</span>\n<span class="token keyword">static</span> <span class="token keyword">constexpr</span> base<span class="token operator">::</span>TimeDelta kMinimumInterval <span class="token operator">=</span> base<span class="token operator">::</span>TimeDelta<span class="token operator">::</span><span class="token function">FromMilliseconds</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="83431294781497620000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`base::TimeDelta interval_milliseconds =\n      std::max(base::TimeDelta::FromMilliseconds(1), interval);\n\n  if (interval_milliseconds < kMinimumInterval &&\n      nesting_level_ >= kMaxTimerNestingLevel)\n    interval_milliseconds = kMinimumInterval;\n\n  if (single_shot)\n    StartOneShot(interval_milliseconds, FROM_HERE);\n  else\n    StartRepeating(interval_milliseconds, FROM_HERE);`, `83431294781497620000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                data-tooltip="复制"\n              >\n                <svg class="gatsby-code-button-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M16 1H2v16h2V3h12V1zm-1 4l6 6v12H6V5h9zm-1 7h5.5L14 6.5V12z"/></svg>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="cpp"><pre style="counter-reset: linenumber NaN" class="language-cpp line-numbers"><code class="language-cpp">base<span class="token operator">::</span>TimeDelta interval_milliseconds <span class="token operator">=</span>\n      std<span class="token operator">::</span><span class="token function">max</span><span class="token punctuation">(</span>base<span class="token operator">::</span>TimeDelta<span class="token operator">::</span><span class="token function">FromMilliseconds</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> interval<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>interval_milliseconds <span class="token operator">&lt;</span> kMinimumInterval <span class="token operator">&amp;&amp;</span>\n      nesting_level_ <span class="token operator">>=</span> kMaxTimerNestingLevel<span class="token punctuation">)</span>\n    interval_milliseconds <span class="token operator">=</span> kMinimumInterval<span class="token punctuation">;</span>\n\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>single_shot<span class="token punctuation">)</span>\n    <span class="token function">StartOneShot</span><span class="token punctuation">(</span>interval_milliseconds<span class="token punctuation">,</span> FROM_HERE<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">else</span>\n    <span class="token function">StartRepeating</span><span class="token punctuation">(</span>interval_milliseconds<span class="token punctuation">,</span> FROM_HERE<span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>所以，一些实时性较高的需求就不太适合使用 setTimeout 了，比如你用 setTimeout 来实现 JavaScript 动画就不是一个很好的主意。</p>\n<h3 id="未激活的页面，settimeout-执行最小间隔是-1000-毫秒"><a href="#%E6%9C%AA%E6%BF%80%E6%B4%BB%E7%9A%84%E9%A1%B5%E9%9D%A2%EF%BC%8Csettimeout-%E6%89%A7%E8%A1%8C%E6%9C%80%E5%B0%8F%E9%97%B4%E9%9A%94%E6%98%AF-1000-%E6%AF%AB%E7%A7%92" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>未激活的页面，setTimeout 执行最小间隔是 1000 毫秒</h3>\n<p>除了前面的 4 毫秒延迟，还有一个很容易被忽略的地方，那就是未被激活的页面中定时器最小值大于 1000 毫秒，也就是说，如果标签不是当前的激活标签，那么定时器最小的时间间隔是 1000 毫秒，目的是为了优化后台页面的加载损耗以及降低耗电量。这一点你在使用定时器的时候要注意。</p>\n<h3 id="延时执行时间有最大值"><a href="#%E5%BB%B6%E6%97%B6%E6%89%A7%E8%A1%8C%E6%97%B6%E9%97%B4%E6%9C%89%E6%9C%80%E5%A4%A7%E5%80%BC" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>延时执行时间有最大值</h3>\n<p>除了要了解定时器的回调函数时间比实际设定值要延后之外，还有一点需要注意下，那就是 Chrome、Safari、Firefox 都是以 32 个 bit 来存储延时值的，32bit 最大只能存放的数字是 2147483647 毫秒，这就意味着，如果 setTimeout 设置的延迟值大于 2147483647 毫秒（大约 24.8 天）时就会溢出，这导致定时器会被立即执行。你可以运行下面这段代码：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="2872120437757930000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function showName() {\n  console.log(\'极客时间\');\n}\nvar timerID = setTimeout(showName, 2147483648); // 会被理解调用执行`, `2872120437757930000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                data-tooltip="复制"\n              >\n                <svg class="gatsby-code-button-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M16 1H2v16h2V3h12V1zm-1 4l6 6v12H6V5h9zm-1 7h5.5L14 6.5V12z"/></svg>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span> <span class="token function">showName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'极客时间\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">var</span> timerID <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span>showName<span class="token punctuation">,</span> <span class="token number">2147483648</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 会被理解调用执行</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>运行后可以看到，这段代码是立即被执行的。但如果将延时值修改为小于 2147483647 毫秒的某个值，那么执行时就没有问题了。</p>\n<h3 id="使用-settimeout-设置的回调函数中的-this-不符合直觉"><a href="#%E4%BD%BF%E7%94%A8-settimeout-%E8%AE%BE%E7%BD%AE%E7%9A%84%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84-this-%E4%B8%8D%E7%AC%A6%E5%90%88%E7%9B%B4%E8%A7%89" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>使用 setTimeout 设置的回调函数中的 this 不符合直觉</h3>\n<p>如果被 setTimeout 推迟执行的回调函数是某个对象的方法，那么该方法中的 this 关键字将指向全局环境，而不是定义时所在的那个对象。这点在前面介绍 this 的时候也提过，你可以看下面这段代码的执行结果：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="72015277177050630000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`var name = 1;\nvar MyObj = {\n  name: 2,\n  showName: function() {\n    console.log(this.name);\n  }\n};\nsetTimeout(MyObj.showName, 1000);`, `72015277177050630000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                data-tooltip="复制"\n              >\n                <svg class="gatsby-code-button-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M16 1H2v16h2V3h12V1zm-1 4l6 6v12H6V5h9zm-1 7h5.5L14 6.5V12z"/></svg>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>\n<span class="token keyword">var</span> MyObj <span class="token operator">=</span> <span class="token punctuation">{</span>\n  name<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span>\n  <span class="token function-variable function">showName</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token function">setTimeout</span><span class="token punctuation">(</span>MyObj<span class="token punctuation">.</span>showName<span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>这里输出的是 1，因为这段代码在编译的时候，执行上下文中的 this 会被设置为全局 window，如果是严格模式，会被设置为 undefined。</p>\n<p>那么该怎么解决这个问题呢？通常可以使用下面这两种方法。</p>\n<p>第一种是将 MyObj.showName 放在匿名函数中执行，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="38216785568767780000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// 箭头函数\nsetTimeout(() => {\n  MyObj.showName();\n}, 1000);\n// 或者 function 函数\nsetTimeout(function() {\n  MyObj.showName();\n}, 1000);`, `38216785568767780000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                data-tooltip="复制"\n              >\n                <svg class="gatsby-code-button-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M16 1H2v16h2V3h12V1zm-1 4l6 6v12H6V5h9zm-1 7h5.5L14 6.5V12z"/></svg>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">// 箭头函数</span>\n<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  MyObj<span class="token punctuation">.</span><span class="token function">showName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token comment">// 或者 function 函数</span>\n<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  MyObj<span class="token punctuation">.</span><span class="token function">showName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>第二种是使用 bind 方法，将 showName 绑定在 MyObj 上面，代码如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="82027758413937900000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`setTimeout(MyObj.showName.bind(MyObj), 1000);`, `82027758413937900000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                data-tooltip="复制"\n              >\n                <svg class="gatsby-code-button-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M16 1H2v16h2V3h12V1zm-1 4l6 6v12H6V5h9zm-1 7h5.5L14 6.5V12z"/></svg>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token function">setTimeout</span><span class="token punctuation">(</span>MyObj<span class="token punctuation">.</span><span class="token function">showName</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>MyObj<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<h2 id="总结-1"><a href="#%E6%80%BB%E7%BB%93-1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总结</h2>\n<ul>\n<li>首先，为了支持定时器的实现，浏览器增加了延时队列。</li>\n<li>其次，由于消息队列排队和一些系统级别的限制，通过 setTimeout 设置的回调任务并非总是可以实时地被执行，这样就不能满足一些实时性要求较高的需求了。</li>\n<li>最后，在定时器中使用过程中，还存在一些陷阱，需要你多加注意。</li>\n</ul>\n<p>通过分析和讲解，你会发现函数 setTimeout 在时效性上面有很多先天的不足，所以对于一些时间精度要求比较高的需求，应该有针对性地采取一些其他的方案</p>\n<h1 id="webapi：xmlhttprequest-是怎么实现的"><a href="#webapi%EF%BC%9Axmlhttprequest-%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Webapi：XMLHttpRequest 是怎么实现的</h1>\n<p>自从网页中引入了 JavaScript，我们就可以操作 DOM 树中任意一个节点，例如隐藏/显示节点、改变颜色、获得或改变文本内容、为元素添加事件响应函数等等，几乎可以“为所欲为”了。</p>\n<p>不过在 XMLHttpRequest 出现之前，如果服务器数据有更新，依然需要重新刷新整个页面。而 XMLHttpRequest 提供了从 Web 服务器获取数据的能力，如果你想要更新某条数据，只需要通过 XMLHttpRequest 请求服务器提供的接口，就可以获取到服务器的数据，然后再操作 DOM 来更新页面内容，整个过程只需要更新网页的一部分就可以了，而不用像之前那样还得刷新整个页面，这样既有效率又不会打扰到用户。</p>\n<p>关于 XMLHttpRequest，本来我是想一带而过的，后来发现这个 WebAPI 用于教学非常好。首先前面讲了那么网络内容，现在可以通过它把 HTTP 协议实践一遍；其次，XMLHttpRequest 是一个非常典型的 WebAPI，通过它来讲解浏览器是如何实现 WebAPI 的很合适，这对于你理解其他 WebAPI 也有非常大的帮助，同时在这个过程中我们还可以把一些安全问题给串起来。</p>\n<p>但在深入讲解 XMLHttpRequest 之前，我们得先介绍下同步回调和异步回调这两个概念，这会帮助你更加深刻地理解 WebAPI 是怎么工作的</p>\n<h2 id="回调函数-vs-系统调用栈"><a href="#%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0-vs-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%A0%88" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>回调函数 VS 系统调用栈</h2>\n<p>那什么是回调函数呢（Callback Function）？</p>\n<p>将一个函数作为参数传递给另外一个函数，那作为参数的这个函数就是回调函数。简化的代码如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="82574368993845560000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`let callback = function() {\n  console.log(\'i am do homework\');\n};\nfunction doWork(cb) {\n  console.log(\'start do work\');\n  cb();\n  console.log(\'end do work\');\n}\ndoWork(callback);`, `82574368993845560000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                data-tooltip="复制"\n              >\n                <svg class="gatsby-code-button-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M16 1H2v16h2V3h12V1zm-1 4l6 6v12H6V5h9zm-1 7h5.5L14 6.5V12z"/></svg>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">let</span> <span class="token function-variable function">callback</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'i am do homework\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token keyword">function</span> <span class="token function">doWork</span><span class="token punctuation">(</span><span class="token parameter">cb</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'start do work\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token function">cb</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'end do work\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token function">doWork</span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>在上面示例代码中，我们将一个匿名函数赋值给变量 callback，同时将 callback 作为参数传递给了 doWork() 函数，这时在函数 doWork() 中 callback 就是回调函数。</p>\n<p>上面的回调方法有个特点，就是回调函数 callback 是在主函数 doWork 返回之前执行的，我们把这个回调过程称为同步回调。</p>\n<p>既然有同步回调，那肯定也有异步回调。下面我们再来看看异步回调的例子：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="66019276749797600000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`let callback = function() {\n  console.log(\'i am do homework\');\n};\nfunction doWork(cb) {\n  console.log(\'start do work\');\n  setTimeout(cb, 1000);\n  console.log(\'end do work\');\n}\ndoWork(callback);`, `66019276749797600000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                data-tooltip="复制"\n              >\n                <svg class="gatsby-code-button-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M16 1H2v16h2V3h12V1zm-1 4l6 6v12H6V5h9zm-1 7h5.5L14 6.5V12z"/></svg>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">let</span> <span class="token function-variable function">callback</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'i am do homework\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token keyword">function</span> <span class="token function">doWork</span><span class="token punctuation">(</span><span class="token parameter">cb</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'start do work\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token function">setTimeout</span><span class="token punctuation">(</span>cb<span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'end do work\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token function">doWork</span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>在这个例子中，我们使用了 setTimeout 函数让 callback 在 doWork 函数执行结束后，又延时了 1 秒再执行，这次 callback 并没有在主函数 doWork 内部被调用，我们把这种回调函数在主函数外部执行的过程称为异步回调。</p>\n<p>现在你应该知道什么是同步回调和异步回调了，那下面我们再深入点，站在消息循环的视角来看看同步回调和异步回调的区别。理解了这些，可以让你从本质上理解什么是回调。</p>\n<p>你应该已经知道浏览器页面是通过事件循环机制来驱动的，每个渲染进程都有一个消息队列，页面主线程按照顺序来执行消息队列中的事件，如执行 JavaScript 事件、解析 DOM 事件、计算布局事件、用户输入事件等等，如果页面有新的事件产生，那新的事件将会追加到事件队列的尾部。所以可以说是消息队列和主线程循环机制保证了页面有条不紊地运行。</p>\n<p>这里还需要补充一点，那就是当循环系统在执行一个任务的时候，都要为这个任务维护一个系统调用栈。这个系统调用栈类似于 JavaScript 的调用栈，只不过系统调用栈是 Chromium 的开发语言 C++ 来维护的，其完整的调用栈信息你可以通过 chrome://tracing/ 来抓取。当然，你也可以通过 Performance 来抓取它核心的调用信息，如下图所示：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-06-17-50-52-6f37242a303832ef121ac1f50821cbde-d868f.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 31.25827814569536%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAIAAABM9SnKAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABEklEQVQY021Pa0/CQBDs//8dRhPRpDFRUlKkFaStpFYD+EoRSMQg0gd9XO/a7a2rxQ8mTvZ2Z2cnm1tFlGXOWMHyIk85SwGElCAlUtS1rGWDH06P9BpriQBArbL+jNULXRtMWvr04Nxr6U+67WuG1TGdnuVeDr2OeaMZdm/oda/vSdf7o+5g1Hf9jAlFVLD0nU2YjOeJPf3wZtlqE78+Gg/jW/Xo2DLt5YtlGe3TQ/V54t45+tlJ+0ozVuudRFSgliWgqOiHSD1l4oDIRbWYv0dhRmKSFovZW5pxXmG0g+02y5kgp4KI+6ukbILcZVkyxugsLjiRCuDXRsNvNEXB/1AULAyDXRyHQRBFkeD873y/4guajEtjKmtvyQAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 06 17 50 52"\n        title=""\n        src="/static/2021-07-06-17-50-52-6f37242a303832ef121ac1f50821cbde-fee1c.png"\n        srcset="/static/2021-07-06-17-50-52-6f37242a303832ef121ac1f50821cbde-a67b7.png 200w,\n/static/2021-07-06-17-50-52-6f37242a303832ef121ac1f50821cbde-0b187.png 400w,\n/static/2021-07-06-17-50-52-6f37242a303832ef121ac1f50821cbde-fee1c.png 800w,\n/static/2021-07-06-17-50-52-6f37242a303832ef121ac1f50821cbde-b1a91.png 1200w,\n/static/2021-07-06-17-50-52-6f37242a303832ef121ac1f50821cbde-d868f.png 1510w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>这幅图记录了一个 Parse HTML 的任务执行过程，其中黄色的条目表示执行 JavaScript 的过程，其他颜色的条目表示浏览器内部系统的执行过程。</p>\n<p>通过该图你可以看出来，Parse HTML 任务在执行过程中会遇到一系列的子过程，比如在解析页面的过程中遇到了 JavaScript 脚本，那么就暂停解析过程去执行该脚本，等执行完成之后，再恢复解析过程。然后又遇到了样式表，这时候又开始解析样式表……直到整个任务执行完成。</p>\n<p>需要说明的是，整个 Parse HTML 是一个完整的任务，在执行过程中的脚本解析、样式表解析都是该任务的子过程，其下拉的长条就是执行过程中调用栈的信息。</p>\n<p>每个任务在执行过程中都有自己的调用栈，那么同步回调就是在当前主函数的上下文中执行回调函数，这个没有太多可讲的。下面我们主要来看看异步回调过程，异步回调是指回调函数在主函数之外执行，一般有两种方式</p>\n<ul>\n<li>第一种是把异步函数做成一个任务，添加到消息队列尾部；</li>\n<li>第二种是把异步函数添加到微任务队列中，这样就可以在当前任务的末尾处执行微任务了</li>\n</ul>\n<h2 id="xmlhttprequest-运作机制"><a href="#xmlhttprequest-%E8%BF%90%E4%BD%9C%E6%9C%BA%E5%88%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>XMLHttpRequest 运作机制</h2>\n<p>理解了什么是同步回调和异步回调，接下来我们就来分析 XMLHttpRequest 背后的实现机制，具体工作过程你可以参考下图：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-06-17-51-21-3b86b8c6f2c0d3d3341a6661100522e4-b0aef.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 57.42574257425742%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABmElEQVQoz3VS227bMAzNJ/Vhv7S/6QcMfeg/JMjzsA4Dhr20WNJla2pnTerUjWMpsq37hRztFF2BoAeUQFA8PJSoESICQOoRaZE/RFKMiaLDIQ4Gx6O3GFHIWuu8TzFA9HX1XDxuqtZBCkz6VW2CD1o7qZTUzrn4tkRPVko3gvGGc4u7xnzL5XSZ8r19Enp8y0AyI0UK7lW/d17JUqq62uZlOdvjHYfxEqdLWFTpScbJnYqqicFjUnjaNt3TDn2n4KNVySlt7I/FWh/2GY/j3y0lzXZwdd8WwiOGnKWrh7QR8KLcdh0ry2w+v5nN89XfLMtuZz/N83ZRNJNfnJI+TvyHC3fxXaDZnn9pzj65y+vwX5meohG8Ltecs7re1axGr+8rPf3Tuo7fFPZrbtZ7iWBzDqS8PioTmZj9eKxGKVAJlAeQB/Td6mDHpBy6BBrR4QlelPudM1MUpixN8WiqCqPftPB5pahsBEzDUw9fYPCPZFohBBKnUTvqfzBPoPl6H0PA9zE6DZGC1lrR9LWmpqSUnHOqdpr5D9Ztc8a8+Ms6AAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 06 17 51 21"\n        title=""\n        src="/static/2021-07-06-17-51-21-3b86b8c6f2c0d3d3341a6661100522e4-fee1c.png"\n        srcset="/static/2021-07-06-17-51-21-3b86b8c6f2c0d3d3341a6661100522e4-a67b7.png 200w,\n/static/2021-07-06-17-51-21-3b86b8c6f2c0d3d3341a6661100522e4-0b187.png 400w,\n/static/2021-07-06-17-51-21-3b86b8c6f2c0d3d3341a6661100522e4-fee1c.png 800w,\n/static/2021-07-06-17-51-21-3b86b8c6f2c0d3d3341a6661100522e4-b1a91.png 1200w,\n/static/2021-07-06-17-51-21-3b86b8c6f2c0d3d3341a6661100522e4-b0aef.png 1414w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>这是 XMLHttpRequest 的总执行流程图，下面我们就来分析从发起请求到接收数据的完整流程。</p>\n<p>我们先从 XMLHttpRequest 的用法开始，首先看下面这样一段请求代码：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="23980811453905936000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function GetWebData(URL) {\n  /**\n   * 1: 新建 XMLHttpRequest 请求对象\n   */\n  let xhr = new XMLHttpRequest();\n\n  /**\n   * 2: 注册相关事件回调处理函数\n   */\n  xhr.onreadystatechange = function() {\n    switch (xhr.readyState) {\n      case 0: // 请求未初始化\n        console.log(\'请求未初始化\');\n        break;\n      case 1: // OPENED\n        console.log(\'OPENED\');\n        break;\n      case 2: // HEADERS_RECEIVED\n        console.log(\'HEADERS_RECEIVED\');\n        break;\n      case 3: // LOADING\n        console.log(\'LOADING\');\n        break;\n      case 4: // DONE\n        if (this.status == 200 || this.status == 304) {\n          console.log(this.responseText);\n        }\n        console.log(\'DONE\');\n        break;\n    }\n  };\n\n  xhr.ontimeout = function(e) {\n    console.log(\'ontimeout\');\n  };\n  xhr.onerror = function(e) {\n    console.log(\'onerror\');\n  };\n\n  /**\n   * 3: 打开请求\n   */\n  xhr.open(\'Get\', URL, true); // 创建一个 Get 请求, 采用异步\n\n  /**\n   * 4: 配置参数\n   */\n  xhr.timeout = 3000; // 设置 xhr 请求的超时时间\n  xhr.responseType = \'text\'; // 设置响应返回的数据格式\n  xhr.setRequestHeader(\'X_TEST\', \'time.geekbang\');\n\n  /**\n   * 5: 发送请求\n   */\n  xhr.send();\n}`, `23980811453905936000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                data-tooltip="复制"\n              >\n                <svg class="gatsby-code-button-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M16 1H2v16h2V3h12V1zm-1 4l6 6v12H6V5h9zm-1 7h5.5L14 6.5V12z"/></svg>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span> <span class="token function">GetWebData</span><span class="token punctuation">(</span><span class="token parameter"><span class="token constant">URL</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">/**\n   * 1: 新建 XMLHttpRequest 请求对象\n   */</span>\n  <span class="token keyword">let</span> xhr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token comment">/**\n   * 2: 注册相关事件回调处理函数\n   */</span>\n  xhr<span class="token punctuation">.</span><span class="token function-variable function">onreadystatechange</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">switch</span> <span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>readyState<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">case</span> <span class="token number">0</span><span class="token punctuation">:</span> <span class="token comment">// 请求未初始化</span>\n        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'请求未初始化\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">break</span><span class="token punctuation">;</span>\n      <span class="token keyword">case</span> <span class="token number">1</span><span class="token punctuation">:</span> <span class="token comment">// OPENED</span>\n        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'OPENED\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">break</span><span class="token punctuation">;</span>\n      <span class="token keyword">case</span> <span class="token number">2</span><span class="token punctuation">:</span> <span class="token comment">// HEADERS_RECEIVED</span>\n        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'HEADERS_RECEIVED\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">break</span><span class="token punctuation">;</span>\n      <span class="token keyword">case</span> <span class="token number">3</span><span class="token punctuation">:</span> <span class="token comment">// LOADING</span>\n        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'LOADING\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">break</span><span class="token punctuation">;</span>\n      <span class="token keyword">case</span> <span class="token number">4</span><span class="token punctuation">:</span> <span class="token comment">// DONE</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">==</span> <span class="token number">200</span> <span class="token operator">||</span> <span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">==</span> <span class="token number">304</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>responseText<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'DONE\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">break</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n  xhr<span class="token punctuation">.</span><span class="token function-variable function">ontimeout</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'ontimeout\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">;</span>\n  xhr<span class="token punctuation">.</span><span class="token function-variable function">onerror</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'onerror\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n  <span class="token comment">/**\n   * 3: 打开请求\n   */</span>\n  xhr<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">\'Get\'</span><span class="token punctuation">,</span> <span class="token constant">URL</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 创建一个 Get 请求, 采用异步</span>\n\n  <span class="token comment">/**\n   * 4: 配置参数\n   */</span>\n  xhr<span class="token punctuation">.</span>timeout <span class="token operator">=</span> <span class="token number">3000</span><span class="token punctuation">;</span> <span class="token comment">// 设置 xhr 请求的超时时间</span>\n  xhr<span class="token punctuation">.</span>responseType <span class="token operator">=</span> <span class="token string">\'text\'</span><span class="token punctuation">;</span> <span class="token comment">// 设置响应返回的数据格式</span>\n  xhr<span class="token punctuation">.</span><span class="token function">setRequestHeader</span><span class="token punctuation">(</span><span class="token string">\'X_TEST\'</span><span class="token punctuation">,</span> <span class="token string">\'time.geekbang\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token comment">/**\n   * 5: 发送请求\n   */</span>\n  xhr<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>上面是一段利用了 XMLHttpRequest 来请求数据的代码，再结合上面的流程图，我们可以分析下这段代码是怎么执行的</p>\n<h3 id="创建-xmlhttprequest-对象"><a href="#%E5%88%9B%E5%BB%BA-xmlhttprequest-%E5%AF%B9%E8%B1%A1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>创建 XMLHttpRequest 对象</h3>\n<p>当执行到 let xhr = new XMLHttpRequest() 后，JavaScript 会创建一个 XMLHttpRequest 对象 xhr，用来执行实际的网络请求操作。</p>\n<h3 id="为-xhr-对象注册回调函数"><a href="#%E4%B8%BA-xhr-%E5%AF%B9%E8%B1%A1%E6%B3%A8%E5%86%8C%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>为 xhr 对象注册回调函数</h3>\n<p>因为网络请求比较耗时，所以要注册回调函数，这样后台任务执行完成之后就会通过调用回调函数来告诉其执行结果。</p>\n<p>XMLHttpRequest 的回调函数主要有下面几种：</p>\n<ul>\n<li>ontimeout，用来监控超时请求，如果后台请求超时了，该函数会被调用；</li>\n<li>onerror，用来监控出错信息，如果后台请求出错了，该函数会被调用；</li>\n<li>onreadystatechange，用来监控后台请求过程中的状态，比如可以监控到 HTTP 头加载完成的消息、HTTP 响应体消息以及数据加载完成的消息等。</li>\n</ul>\n<h3 id="配置基础的请求信息"><a href="#%E9%85%8D%E7%BD%AE%E5%9F%BA%E7%A1%80%E7%9A%84%E8%AF%B7%E6%B1%82%E4%BF%A1%E6%81%AF" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>配置基础的请求信息</h3>\n<p>注册好回调事件之后，接下来就需要配置基础的请求信息了，首先要通过 open 接口配置一些基础的请求信息，包括请求的地址、请求方法（是 get 还是 post）和请求方式（同步还是异步请求）。</p>\n<p>然后通过 xhr 内部属性类配置一些其他可选的请求信息，你可以参考文中示例代码，我们通过 xhr.timeout = 3000 来配置超时时间，也就是说如果请求超过 3000 毫秒还没有响应，那么这次请求就被判断为失败了。</p>\n<p>我们还可以通过 xhr.responseType = “text” 来配置服务器返回的格式，将服务器返回的数据自动转换为自己想要的格式，如果将 responseType 的值设置为 json，那么系统会自动将服务器返回的数据转换为 JavaScript 对象格式。下面的图表是我列出的一些返回类型的描述：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-06-17-52-35-d6dd01b803d27862029c63d9610c71ea-c7aa5.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 52.40174672489083%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABvUlEQVQoz01Qy27TQBTNFyGhpqxYIvEN8BVIkHTDAj4A/gRiRxVZIbY0qloEDbbr1zw8M/b47dgex+6C6zpApaOrozNz5twzs7I56Fu8uQrWW7K6QKsLPEHbAghgc0XPL+mk3E+ib8nn7zgu1czm+dO35y8/fnv2bjNfrJ6crU/P9HEu9ZOFdvJGe/Hh6/P3Xx6/1uYL7XS5ni91OHr06tOlI2ddp7KMFWVYVUIIx/N2ANO8RsgIApsQUwjPcW+AY2xy7lB667o3GBt9r2ZD39UFHdrwrpNNFUTclNwKmVGmqN2zQzPqg5IwJzLxvgkHMPd9xwOzyHCvZBb7AfkdMiuVnmAWowaQrom6Jnw4D23U7vnRHHG7qfjdIalykiV+keJ9QYsU5SmKhF1mBN4Fw0Oo+q+Zop17+yMOHbCJwJoIIwbFu7pkg4onw33yEdDo2BluZwkCqS4hEAOqnOYJymIviVxYATYqM6zq8N8K/5MDvEulq2qRJ37ErSRyoCqQWNiefY29n4KZnBr7gjQVg7Y9mMfO7ZicSB95vwJiVDlLpZ8nuMgoiOn4f4ZgNihpjFKJeGDBjr1KVB1B8h/Q9gegQgkMNQAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 06 17 52 35"\n        title=""\n        src="/static/2021-07-06-17-52-35-d6dd01b803d27862029c63d9610c71ea-fee1c.png"\n        srcset="/static/2021-07-06-17-52-35-d6dd01b803d27862029c63d9610c71ea-a67b7.png 200w,\n/static/2021-07-06-17-52-35-d6dd01b803d27862029c63d9610c71ea-0b187.png 400w,\n/static/2021-07-06-17-52-35-d6dd01b803d27862029c63d9610c71ea-fee1c.png 800w,\n/static/2021-07-06-17-52-35-d6dd01b803d27862029c63d9610c71ea-b1a91.png 1200w,\n/static/2021-07-06-17-52-35-d6dd01b803d27862029c63d9610c71ea-c7aa5.png 1374w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>假如你还需要添加自己专用的请求头属性，可以通过 xhr.setRequestHeader 来添加。</p>\n<h3 id="发起请求"><a href="#%E5%8F%91%E8%B5%B7%E8%AF%B7%E6%B1%82" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>发起请求</h3>\n<p>一切准备就绪之后，就可以调用 xhr.send 来发起网络请求了。你可以对照上面那张请求流程图，可以看到：渲染进程会将请求发送给网络进程，然后网络进程负责资源的下载，等网络进程接收到数据之后，就会利用 IPC 来通知渲染进程；渲染进程接收到消息之后，会将 xhr 的回调函数封装成任务并添加到消息队列中，等主线程循环系统执行到该任务的时候，就会根据相关的状态来调用对应的回调函数</p>\n<ul>\n<li>如果网络请求出错了，就会执行 xhr.onerror；</li>\n<li>如果超时了，就会执行 xhr.ontimeout；</li>\n<li>如果是正常的数据接收，就会执行 onreadystatechange 来反馈相应的状态。</li>\n</ul>\n<p>这就是一个完整的 XMLHttpRequest 请求流程，如果你感兴趣，可以参考下 Chromium 对 <a href="https://chromium.googlesource.com/chromium/src/+/refs/heads/master/third_party/blink/renderer/core/xmlhttprequest/" target="_blank" rel="nofollow noreferrer noopener">XMLHttpRequest 的实现</a>。</p>\n<h2 id="xmlhttprequest-使用过程中的坑"><a href="#xmlhttprequest-%E4%BD%BF%E7%94%A8%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%9D%91" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>XMLHttpRequest 使用过程中的“坑”</h2>\n<p>上述过程看似简单，但由于浏览器很多安全策略的限制，所以会导致你在使用过程中踩到非常多的“坑”。</p>\n<p>浏览器安全问题是前端工程师避不开的一道坎，通常在使用过程中遇到的“坑”，很大一部分都是由安全策略引起的，不管你喜不喜欢，它都在这里。本来很完美的一个方案，正是由于加了安全限制，导致使用起来非常麻烦。</p>\n<p>而你要做的就是去正视这各种的安全问题。也就是说要想更加完美地使用 XMLHttpRequest，你就要了解浏览器的安全策略。</p>\n<p>下面我们就来看看在使用 XMLHttpRequest 的过程中所遇到的跨域问题和混合内容问题。</p>\n<h3 id="跨域问题"><a href="#%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>跨域问题</h3>\n<p>比如在极客邦的官网使用 XMLHttpRequest 请求极客时间的页面内容，由于极客邦的官网是 www.geekbang.org，极客时间的官网是 time.geekbang.org，它们不是同一个源，所以就涉及到了跨域（在 A 站点中去访问不同源的 B 站点的内容）。默认情况下，跨域请求是不被允许的，你可以看下面的示例代码：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="99486840895781240000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`var xhr = new XMLHttpRequest();\nvar url = \'https://time.geekbang.org/\';\nfunction handler() {\n  switch (xhr.readyState) {\n    case 0: // 请求未初始化\n      console.log(\' 请求未初始化 \');\n      break;\n    case 1: // OPENED\n      console.log(\'OPENED\');\n      break;\n    case 2: // HEADERS_RECEIVED\n      console.log(\'HEADERS_RECEIVED\');\n      break;\n    case 3: // LOADING\n      console.log(\'LOADING\');\n      break;\n    case 4: // DONE\n      if (this.status == 200 || this.status == 304) {\n        console.log(this.responseText);\n      }\n      console.log(\'DONE\');\n      break;\n  }\n}\n\nfunction callOtherDomain() {\n  if (xhr) {\n    xhr.open(\'GET\', url, true);\n    xhr.onreadystatechange = handler;\n    xhr.send();\n  }\n}\ncallOtherDomain();`, `99486840895781240000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                data-tooltip="复制"\n              >\n                <svg class="gatsby-code-button-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M16 1H2v16h2V3h12V1zm-1 4l6 6v12H6V5h9zm-1 7h5.5L14 6.5V12z"/></svg>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">var</span> xhr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">var</span> url <span class="token operator">=</span> <span class="token string">\'https://time.geekbang.org/\'</span><span class="token punctuation">;</span>\n<span class="token keyword">function</span> <span class="token function">handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">switch</span> <span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>readyState<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">case</span> <span class="token number">0</span><span class="token punctuation">:</span> <span class="token comment">// 请求未初始化</span>\n      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\' 请求未初始化 \'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token keyword">break</span><span class="token punctuation">;</span>\n    <span class="token keyword">case</span> <span class="token number">1</span><span class="token punctuation">:</span> <span class="token comment">// OPENED</span>\n      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'OPENED\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token keyword">break</span><span class="token punctuation">;</span>\n    <span class="token keyword">case</span> <span class="token number">2</span><span class="token punctuation">:</span> <span class="token comment">// HEADERS_RECEIVED</span>\n      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'HEADERS_RECEIVED\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token keyword">break</span><span class="token punctuation">;</span>\n    <span class="token keyword">case</span> <span class="token number">3</span><span class="token punctuation">:</span> <span class="token comment">// LOADING</span>\n      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'LOADING\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token keyword">break</span><span class="token punctuation">;</span>\n    <span class="token keyword">case</span> <span class="token number">4</span><span class="token punctuation">:</span> <span class="token comment">// DONE</span>\n      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">==</span> <span class="token number">200</span> <span class="token operator">||</span> <span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">==</span> <span class="token number">304</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>responseText<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'DONE\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token keyword">break</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">function</span> <span class="token function">callOtherDomain</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>xhr<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    xhr<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">\'GET\'</span><span class="token punctuation">,</span> url<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    xhr<span class="token punctuation">.</span>onreadystatechange <span class="token operator">=</span> handler<span class="token punctuation">;</span>\n    xhr<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n<span class="token function">callOtherDomain</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>你可以在控制台测试下。首先通过浏览器打开 www.geekbang.org，然后打开控制台，在控制台输入以上示例代码，再执行，会看到请求被 Block 了。控制台的提示信息如下：</p>\n<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">Access to XMLHttpRequest at &#39;https://time.geekbang.org/&#39; from origin &#39;https://www.geekbang.org&#39; has been blocked by CORS policy: No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource.</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>因为 www.geekbang.org 和 time.geekbang.com 不属于一个域，所以以上访问就属于跨域访问了，这次访问失败就是由于跨域问题导致的。</p>\n<h3 id="https-混合内容的问题"><a href="#https-%E6%B7%B7%E5%90%88%E5%86%85%E5%AE%B9%E7%9A%84%E9%97%AE%E9%A2%98" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>HTTPS 混合内容的问题</h3>\n<p>了解完跨域问题后，我们再来看看 HTTPS 的混合内容。HTTPS 混合内容是 HTTPS 页面中包含了不符合 HTTPS 安全要求的内容，比如包含了 HTTP 资源，通过 HTTP 加载的图像、视频、样式表、脚本等，都属于混合内容。</p>\n<p>通常，如果 HTTPS 请求页面中使用混合内容，浏览器会针对 HTTPS 混合内容显示警告，用来向用户表明此 HTTPS 页面包含不安全的资源。比如打开站点 <a href="https://www.iteye.com/groups" target="_blank" rel="nofollow noreferrer noopener">https://www.iteye.com/groups</a> ，可以通过控制台看到混合内容的警告，参考下图：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-06-17-55-02-6993958a4ad8300358f3b888530c3d6b-4be21.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 37.532467532467535%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAIAAAB2/0i6AAAACXBIWXMAAA7DAAAOwwHHb6hkAAABZUlEQVQY03WO2XKjMBRE+f+PSqqCx8bYGLMYs4lVYg+SzNixkQSB5HXm1Klbdbv6oaUXJQ9MXhQ/SbdKP79wN97wIhsIG/CvfCD8L10S8bjxOx0HMgkmVVc59/ddplexVkYaBFoeHjNfTT0VhUcEDk2q98j8hEabalV0uNVOX9hlqPKhk0h+yC5vDVBqoBTBDnp/KqAml48yUFJHht4WmO/Aei9DBcNTn2tDZTXJCUNdvKiEmyT0zCJzqtxGiZUAI4st4GkwsdYQeVlkxuG5Kbw7ze4kGx81JXCg+SSeUhudgL6pfRU5culuc2cHDDky5NjapPY2NjfoqsDrrvL3eNkfazg91+GxDfY/s10dGbvSNdDl1AGnCew6uNSBXSxzXBM559I1K9+q19xuQruL1k4b2OIxSHxkgnHO+HpH9iMXXExczGKepnme5t8CG9kCX2vru+TS/C+ezy9Kad/3bdsszP/hG/Hrsj26RDttAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 06 17 55 02"\n        title=""\n        src="/static/2021-07-06-17-55-02-6993958a4ad8300358f3b888530c3d6b-fee1c.png"\n        srcset="/static/2021-07-06-17-55-02-6993958a4ad8300358f3b888530c3d6b-a67b7.png 200w,\n/static/2021-07-06-17-55-02-6993958a4ad8300358f3b888530c3d6b-0b187.png 400w,\n/static/2021-07-06-17-55-02-6993958a4ad8300358f3b888530c3d6b-fee1c.png 800w,\n/static/2021-07-06-17-55-02-6993958a4ad8300358f3b888530c3d6b-b1a91.png 1200w,\n/static/2021-07-06-17-55-02-6993958a4ad8300358f3b888530c3d6b-4be21.png 1540w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从上图可以看出，通过 HTML 文件加载的混合资源，虽然给出警告，但大部分类型还是能加载的。而使用 XMLHttpRequest 请求时，浏览器认为这种请求可能是攻击者发起的，会阻止此类危险的请求。比如我通过浏览器打开地址 <code class="language-text">https://www.iteye.com/groups</code>，然后通过控制台，使用 XMLHttpRequest 来请求 <code class="language-text">http://img-ads.csdn.net/2018/201811150919211586.jpg</code>，这时候请求就会报错，出错信息如下图所示：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-06-17-55-11-fd0668221db3d0cc98c4a7935b9e93f5-ff8ad.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 48.883666274970615%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABAElEQVQoz52R3WrDMAyF+/5PNpouScMKK+xiNCRNE//Ltpw4dqexi/ZmkE0cbGH4JB1rl3NeU1xzuv89dgQro40RyxxJPnicvfUQ12UTjDPGuKSUqX2iyGmJM91b4PvIWXfrtEENkqmRq5FqbRqbGjCuur5jE3OSM9YP/adgw1bPxgF4+M+HifF2bdug5CxFUAKl9HxybPKc0UtCnwOSKEkBnTHo7APWdaHLva0PUO6hKa/14VK8XKqibaqhqcampHM6Hd35hO9v0/FVfpyfPFuzgl7NjxRyhoJ/DwIajXJKeK2iswlt8jaTAj7gZw+0LHDOhwCOVu0pl0qBtb95/gJibERyYvjvZQAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 06 17 55 11"\n        title=""\n        src="/static/2021-07-06-17-55-11-fd0668221db3d0cc98c4a7935b9e93f5-fee1c.png"\n        srcset="/static/2021-07-06-17-55-11-fd0668221db3d0cc98c4a7935b9e93f5-a67b7.png 200w,\n/static/2021-07-06-17-55-11-fd0668221db3d0cc98c4a7935b9e93f5-0b187.png 400w,\n/static/2021-07-06-17-55-11-fd0668221db3d0cc98c4a7935b9e93f5-fee1c.png 800w,\n/static/2021-07-06-17-55-11-fd0668221db3d0cc98c4a7935b9e93f5-b1a91.png 1200w,\n/static/2021-07-06-17-55-11-fd0668221db3d0cc98c4a7935b9e93f5-95179.png 1600w,\n/static/2021-07-06-17-55-11-fd0668221db3d0cc98c4a7935b9e93f5-ff8ad.png 1702w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<h2 id="总结-2"><a href="#%E6%80%BB%E7%BB%93-2" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总结</h2>\n<p>首先我们介绍了回调函数和系统调用栈；接下来我们站在循环系统的视角，分析了 XMLHttpRequest 是怎么工作的；最后又说明了由于一些安全因素的限制，在使用 XMLHttpRequest 的过程中会遇到跨域问题和混合内容的问题。</p>\n<p>本篇文章跨度比较大，不是单纯地讲一个问题，而是将回调类型、循环系统、网络请求和安全问题“串联”起来了。</p>\n<p>对比上一篇文章，setTimeout 是直接将延迟任务添加到延迟队列中，而 XMLHttpRequest 发起请求，是由浏览器的其他进程或者线程去执行，然后再将执行结果利用 IPC 的方式通知渲染进程，之后渲染进程再将对应的消息添加到消息队列中。如果你搞懂了 setTimeout 和 XMLHttpRequest 的工作机制后，再来理解其他 WebAPI 就会轻松很多了，因为大部分 WebAPI 的工作逻辑都是类似的。</p>\n<h1 id="宏任务和微任务：不是所有的任务都是一个待遇"><a href="#%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BE%AE%E4%BB%BB%E5%8A%A1%EF%BC%9A%E4%B8%8D%E6%98%AF%E6%89%80%E6%9C%89%E7%9A%84%E4%BB%BB%E5%8A%A1%E9%83%BD%E6%98%AF%E4%B8%80%E4%B8%AA%E5%BE%85%E9%81%87" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>宏任务和微任务：不是所有的任务都是一个待遇</h1>\n<p>在前面几篇文章中，我们介绍了消息队列，并结合消息队列介绍了两种典型的 WebAPI——setTimeout 和 XMLHttpRequest，通过这两个 WebAPI 我们搞清楚了浏览器的消息循环系统是怎么工作的。不过随着浏览器的应用领域越来越广泛，消息队列中这种粗时间颗粒度的任务已经不能胜任部分领域的需求，所以又出现了一种新的技术——微任务。微任务可以在实时性和效率之间做一个有效的权衡。</p>\n<p>从目前的情况来看，微任务已经被广泛地应用，基于微任务的技术有 MutationObserver、Promise 以及以 Promise 为基础开发出来的很多其他的技术。所以微任务的重要性也与日俱增，了解其底层的工作原理对于你读懂别人的代码，以及写出更高效、更具现代的代码有着决定性的作用。</p>\n<p>有微任务，也就有宏任务，那这二者到底有什么区别？它们又是如何相互取长补短的？</p>\n<h2 id="宏任务"><a href="#%E5%AE%8F%E4%BB%BB%E5%8A%A1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>宏任务</h2>\n<p>前面我们已经介绍过了，页面中的大部分任务都是在主线程上执行的，这些任务包括了：</p>\n<ul>\n<li>渲染事件（如解析 DOM、计算布局、绘制）；</li>\n<li>用户交互事件（如鼠标点击、滚动页面、放大缩小等）；</li>\n<li>JavaScript 脚本执行事件；</li>\n<li>网络请求完成、文件读写完成事件。</li>\n</ul>\n<p>为了协调这些任务有条不紊地在主线程上执行，页面进程引入了消息队列和事件循环机制，渲染进程内部会维护多个消息队列，比如延迟执行队列和普通的消息队列。然后主线程采用一个 for 循环，不断地从这些任务队列中取出任务并执行任务。我们把这些消息队列中的任务称为宏任务。</p>\n<p>消息队列中的任务是通过事件循环系统来执行的，这里我们可以看看在 WHATWG 规范中是怎么定义事件循环机制的。</p>\n<p>由于规范需要支持语义上的完备性，所以通常写得都会比较啰嗦，这里我就大致总结了下 WHATWG 规范定义的大致流程：</p>\n<ul>\n<li>先从多个消息队列中选出一个最老的任务，这个任务称为 oldestTask；</li>\n<li>然后循环系统记录任务开始执行的时间，并把这个 oldestTask 设置为当前正在执行的任务；</li>\n<li>当任务执行完成之后，删除当前正在执行的任务，并从对应的消息队列中删除掉这个 oldestTask；</li>\n<li>最后统计执行完成的时长等信息。</li>\n</ul>\n<p>以上就是消息队列中宏任务的执行过程，通过前面的学习，相信你也很熟悉这套执行流程了。</p>\n<p>宏任务可以满足我们大部分的日常需求，不过如果有对时间精度要求较高的需求，宏任务就难以胜任了，下面我们就来分析下为什么宏任务难以满足对时间精度要求较高的任务。</p>\n<p>前面我们说过，页面的渲染事件、各种 IO 的完成事件、执行 JavaScript 脚本的事件、用户交互的事件等都随时有可能被添加到消息队列中，而且添加事件是由系统操作的，JavaScript 代码不能准确掌控任务要添加到队列中的位置，控制不了任务在消息队列中的位置，所以很难控制开始执行任务的时间。为了直观理解，你可以看下面这段代码：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="13113136619550470000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`<!DOCTYPE html>\n<html>\n  <body>\n    <div id=&quot;demo&quot;>\n      <ol>\n        <li>test</li>\n      </ol>\n    </div>\n  </body>\n  <script type=&quot;text/javascript&quot;>\n    function timerCallback2() {\n      console.log(2);\n    }\n    function timerCallback() {\n      console.log(1);\n      setTimeout(timerCallback2, 0);\n    }\n    setTimeout(timerCallback, 0);\n  </script>\n</html>`, `13113136619550470000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                data-tooltip="复制"\n              >\n                <svg class="gatsby-code-button-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M16 1H2v16h2V3h12V1zm-1 4l6 6v12H6V5h9zm-1 7h5.5L14 6.5V12z"/></svg>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>demo<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ol</span><span class="token punctuation">></span></span>\n        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ol</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">\n    <span class="token keyword">function</span> <span class="token function">timerCallback2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n    <span class="token keyword">function</span> <span class="token function">timerCallback</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token function">setTimeout</span><span class="token punctuation">(</span>timerCallback2<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n    <span class="token function">setTimeout</span><span class="token punctuation">(</span>timerCallback<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>在这段代码中，我的目的是想通过 setTimeout 来设置两个回调任务，并让它们按照前后顺序来执行，中间也不要再插入其他的任务，因为如果这两个任务的中间插入了其他的任务，就很有可能会影响到第二个定时器的执行时间了。</p>\n<p>但实际情况是我们不能控制的，比如在你调用 setTimeout 来设置回调任务的间隙，消息队列中就有可能被插入很多系统级的任务。你可以打开 Performance 工具，来记录下这段任务的执行过程，也可参考文中我记录的图片：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-06-17-57-31-729686ac6d9ac5e589055eaaeb1f77b9-3c94e.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 43.279172821270315%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAIAAAC9o5sfAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABrElEQVQoz32RPW/TUBSG/RuYkGBm6dK9IAQDA8rCyoQYWZDgXzAjZiRagVqQAqhQaJQPRQgatylxaxc7aUnSOrXje23XubHv9+XSEokO8OgsRzrvkc55DCUl51wIoX4jZ/UPpEbIU3RnFAU+HoUUM0o5YZIwVRBZYJwXf8jzHOshDWFCKl2MS86YzhtpelJv1Wutqu3a7S9ly/zo2c2h6x1ud0bdg4Hj9p0f4X7f3/N6HXNna23gNiDwMVVCSINzGSRwOB6lCI97687yTb96Hxd8cnQc1yrxuzew/DqufEo2WtMs6a4/7L69Q5IuFTosjMkUBSCkku+NrEbPLFefvXj/9KtvbTZftecv1eYufpu/vHHlwv6Du0SpVv+kvIvMIxYhpH9ljOOg0f7ctOr2Qf1JY3hjUd1aEivOz35n1StdbZcWtkoLm9fm7Ef33KjzeBVcf65uL+KKsytFbui7JxmCIFGM7oRq6Tt9aVE/078UDCGVT2mawsMhDAKUZeag+OCyNY+G8VQJbpwTMZMk/2PrL86HpTr1pwghAAAIQAxhFEW6PRs4UyVmm38BrgrfBu/ZH9gAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 06 17 57 31"\n        title=""\n        src="/static/2021-07-06-17-57-31-729686ac6d9ac5e589055eaaeb1f77b9-fee1c.png"\n        srcset="/static/2021-07-06-17-57-31-729686ac6d9ac5e589055eaaeb1f77b9-a67b7.png 200w,\n/static/2021-07-06-17-57-31-729686ac6d9ac5e589055eaaeb1f77b9-0b187.png 400w,\n/static/2021-07-06-17-57-31-729686ac6d9ac5e589055eaaeb1f77b9-fee1c.png 800w,\n/static/2021-07-06-17-57-31-729686ac6d9ac5e589055eaaeb1f77b9-b1a91.png 1200w,\n/static/2021-07-06-17-57-31-729686ac6d9ac5e589055eaaeb1f77b9-3c94e.png 1354w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>setTimeout 函数触发的回调函数都是宏任务，如图中，左右两个黄色块就是 setTimeout 触发的两个定时器任务。</p>\n<p>现在你可以重点观察上图中间浅红色区域，这里有很多一段一段的任务，这些是被渲染引擎插在两个定时器任务中间的任务。试想一下，如果中间被插入的任务执行时间过久的话，那么就会影响到后面任务的执行了。</p>\n<p>所以说宏任务的时间粒度比较大，执行的时间间隔是不能精确控制的，对一些高实时性的需求就不太符合了，比如后面要介绍的监听 DOM 变化的需求。</p>\n<h2 id="微任务"><a href="#%E5%BE%AE%E4%BB%BB%E5%8A%A1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>微任务</h2>\n<p>在理解了宏任务之后，下面我们就可以来看看什么是微任务了。在上一篇文章中，我们介绍过异步回调的概念，其主要有两种方式。</p>\n<p>第一种是把异步回调函数封装成一个宏任务，添加到消息队列尾部，当循环系统执行到该任务的时候执行回调函数。这种比较好理解，我们前面介绍的 setTimeout 和 XMLHttpRequest 的回调函数都是通过这种方式来实现的。</p>\n<p>第二种方式的执行时机是在主函数执行结束之后、当前宏任务结束之前执行回调函数，这通常都是以微任务形式体现的。</p>\n<p>那这里说的微任务到底是什么呢？</p>\n<p>微任务就是一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前。</p>\n<p>不过要搞清楚微任务系统是怎么运转起来的，就得站在 V8 引擎的层面来分析下。</p>\n<p>我们知道当 JavaScript 执行一段脚本的时候，V8 会为其创建一个全局执行上下文，在创建全局执行上下文的同时，V8 引擎也会在内部创建一个微任务队列。顾名思义，这个微任务队列就是用来存放微任务的，因为在当前宏任务执行的过程中，有时候会产生多个微任务，这时候就需要使用这个微任务队列来保存这些微任务了。不过这个微任务队列是给 V8 引擎内部使用的，所以你是无法通过 JavaScript 直接访问的。</p>\n<p>也就是说每个宏任务都关联了一个微任务队列。那么接下来，我们就需要分析两个重要的时间点——微任务产生的时机和执行微任务队列的时机。</p>\n<p>我们先来看看微任务是怎么产生的？在现代浏览器里面，产生微任务有两种方式。</p>\n<p>第一种方式是使用 MutationObserver 监控某个 DOM 节点，然后再通过 JavaScript 来修改这个节点，或者为这个节点添加、删除部分子节点，当 DOM 节点发生变化时，就会产生 DOM 变化记录的微任务。</p>\n<p>第二种方式是使用 Promise，当调用 Promise.resolve() 或者 Promise.reject() 的时候，也会产生微任务。</p>\n<p>通过 DOM 节点变化产生的微任务或者使用 Promise 产生的微任务都会被 JavaScript 引擎按照顺序保存到微任务队列中。</p>\n<p>好了，现在微任务队列中有了微任务了，那接下来就要看看微任务队列是何时被执行的。</p>\n<p>通常情况下，在当前宏任务中的 JavaScript 快执行完成时，也就在 JavaScript 引擎准备退出全局执行上下文并清空调用栈的时候，JavaScript 引擎会检查全局执行上下文中的微任务队列，然后按照顺序执行队列中的微任务。WHATWG 把执行微任务的时间点称为检查点。当然除了在退出全局执行上下文式这个检查点之外，还有其他的检查点，不过不是太重要，这里就不做介绍了。</p>\n<p>如果在执行微任务的过程中，产生了新的微任务，同样会将该微任务添加到微任务队列中，V8 引擎一直循环执行微任务队列中的任务，直到队列为空才算执行结束。也就是说在执行微任务过程中产生的新的微任务并不会推迟到下个宏任务中执行，而是在当前的宏任务中继续执行。</p>\n<p>为了直观地理解什么是微任务，你可以参考下面我画的示意图（由于内容比较多，我将其分为了两张）：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-06-17-58-03-916d1ee0ce7a4f58a92960abc8e3ead3-62dab.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 47.447447447447445%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAIAAAC9o5sfAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABxUlEQVQoz1VR30/aUBjlrxsxPvtAptPs2Sdf92I0ZsmSZS8+sGQuRigiiGgGBqPZFEdCIkqBgtoSNbZ3/UF7W/qLtvT2rkCIevIl934599zvyzkRPEUQBBij8Jx04zt+zfpvgRCKTBiM/Hsgn3dhmZYu7oUyo1S6smFa4SN3DMd1oKpa9sC07ElpmhYJlb5tY8/O1EAsxy6mqPkdciHDLBcB1HTXcQAAiqIgf+i5zutdDMMIxci3bKwreZKfI+iFRONDqh1LtFYKj5puBgESBDGcPHC9XFNKNCBByskmTLX1Bx6OJ5smVqXkFb9R1b9V/n0pc5t1Y/mkJ8iq1deUXs+zDFZU187Yg7r485zOX4Ovl2KpI47EKFzb1gsVmjn7LR1leqVf4lH283EXyH3sOchx8NBlebh92qKJHSqdftgjDoniKa2MDENjn4uU+CnbWCP+ru9VV3er6ydPat+cshiag/nUbTR+MxuvzX6/iW7dXtwJE/HI8RzJv8+Dj/vMUrq9dPi8UhoZ9iLWrdguE92m38WvZ340o8nnPx0QwdNkWyzMNqR8nc3Vng5IvtCWwmCm+WNvOOxwkOJUilUoDrY4NfzuP6NF0aqXxnOsAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 06 17 58 03"\n        title=""\n        src="/static/2021-07-06-17-58-03-916d1ee0ce7a4f58a92960abc8e3ead3-fee1c.png"\n        srcset="/static/2021-07-06-17-58-03-916d1ee0ce7a4f58a92960abc8e3ead3-a67b7.png 200w,\n/static/2021-07-06-17-58-03-916d1ee0ce7a4f58a92960abc8e3ead3-0b187.png 400w,\n/static/2021-07-06-17-58-03-916d1ee0ce7a4f58a92960abc8e3ead3-fee1c.png 800w,\n/static/2021-07-06-17-58-03-916d1ee0ce7a4f58a92960abc8e3ead3-b1a91.png 1200w,\n/static/2021-07-06-17-58-03-916d1ee0ce7a4f58a92960abc8e3ead3-62dab.png 1332w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>该示意图是在执行一个 ParseHTML 的宏任务，在执行过程中，遇到了 JavaScript 脚本，那么就暂停解析流程，进入到 JavaScript 的执行环境。从图中可以看到，全局上下文中包含了微任务列表。</p>\n<p>在 JavaScript 脚本的后续执行过程中，分别通过 Promise 和 removeChild 创建了两个微任务，并被添加到微任务列表中。接着 JavaScript 执行结束，准备退出全局执行上下文，这时候就到了检查点了，JavaScript 引擎会检查微任务列表，发现微任务列表中有微任务，那么接下来，依次执行这两个微任务。等微任务队列清空之后，就退出全局执行上下文。</p>\n<p>以上就是微任务的工作流程，从上面分析我们可以得出如下几个结论：</p>\n<ul>\n<li>微任务和宏任务是绑定的，每个宏任务在执行时，会创建自己的微任务队列。</li>\n<li>微任务的执行时长会影响到当前宏任务的时长。比如一个宏任务在执行过程中，产生了 100 个微任务，执行每个微任务的时间是 10 毫秒，那么执行这 100 个微任务的时间就是 1000 毫秒，也可以说这 100 个微任务让宏任务的执行时间延长了 1000 毫秒。所以你在写代码的时候一定要注意控制微任务的执行时长。</li>\n<li>在一个宏任务中，分别创建一个用于回调的宏任务和微任务，无论什么情况下，微任务都早于宏任务执行。</li>\n</ul>\n<h2 id="监听-dom-变化方法演变"><a href="#%E7%9B%91%E5%90%AC-dom-%E5%8F%98%E5%8C%96%E6%96%B9%E6%B3%95%E6%BC%94%E5%8F%98" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>监听 DOM 变化方法演变</h2>\n<p>现在知道了微任务是怎么工作的，那接下来我们再来看看微任务是如何应用在 MutationObserver 中的。MutationObserver 是用来监听 DOM 变化的一套方法，而监听 DOM 变化一直是前端工程师一项非常核心的需求。</p>\n<p>比如许多 Web 应用都利用 HTML 与 JavaScript 构建其自定义控件，与一些内置控件不同，这些控件不是固有的。为了与内置控件一起良好地工作，这些控件必须能够适应内容更改、响应事件和用户交互。因此，Web 应用需要监视 DOM 变化并及时地做出响应。</p>\n<p>虽然监听 DOM 的需求是如此重要，不过早期页面并没有提供对监听的支持，所以那时要观察 DOM 是否变化，唯一能做的就是轮询检测，比如使用 setTimeout 或者 setInterval 来定时检测 DOM 是否有改变。这种方式简单粗暴，但是会遇到两个问题：如果时间间隔设置过长，DOM 变化响应不够及时；反过来如果时间间隔设置过短，又会浪费很多无用的工作量去检查 DOM，会让页面变得低效。</p>\n<p>直到 2000 年的时候引入了 Mutation Event，Mutation Event 采用了观察者的设计模式，当 DOM 有变动时就会立刻触发相应的事件，这种方式属于同步回调。</p>\n<p>采用 Mutation Event 解决了实时性的问题，因为 DOM 一旦发生变化，就会立即调用 JavaScript 接口。但也正是这种实时性造成了严重的性能问题，因为每次 DOM 变动，渲染引擎都会去调用 JavaScript，这样会产生较大的性能开销。比如利用 JavaScript 动态创建或动态修改 50 个节点内容，就会触发 50 次回调，而且每个回调函数都需要一定的执行时间，这里我们假设每次回调的执行时间是 4 毫秒，那么 50 次回调的执行时间就是 200 毫秒，若此时浏览器正在执行一个动画效果，由于 Mutation Event 触发回调事件，就会导致动画的卡顿。</p>\n<p>也正是因为使用 Mutation Event 会导致页面性能问题，所以 Mutation Event 被反对使用，并逐步从 Web 标准事件中删除了。</p>\n<p>为了解决了 Mutation Event 由于同步调用 JavaScript 而造成的性能问题，从 DOM4 开始，推荐使用 MutationObserver 来代替 Mutation Event。MutationObserver API 可以用来监视 DOM 的变化，包括属性的变化、节点的增减、内容的变化等。</p>\n<p>那么相比较 Mutation Event，MutationObserver 到底做了哪些改进呢？</p>\n<p>首先，MutationObserver 将响应函数改成异步调用，可以不用在每次 DOM 变化都触发异步调用，而是等多次 DOM 变化后，一次触发异步调用，并且还会使用一个数据结构来记录这期间所有的 DOM 变化。这样即使频繁地操纵 DOM，也不会对性能造成太大的影响。</p>\n<p>我们通过异步调用和减少触发次数来缓解了性能问题，那么如何保持消息通知的及时性呢？如果采用 setTimeout 创建宏任务来触发回调的话，那么实时性就会大打折扣，因为上面我们分析过，在两个任务之间，可能会被渲染进程插入其他的事件，从而影响到响应的实时性。</p>\n<p>这时候，微任务就可以上场了，在每次 DOM 节点发生变化的时候，渲染引擎将变化记录封装成微任务，并将微任务添加进当前的微任务队列中。这样当执行到检查点的时候，V8 引擎就会按照顺序执行微任务了。</p>\n<p>综上所述， MutationObserver 采用了“异步 + 微任务”的策略。</p>\n<ul>\n<li>通过异步操作解决了同步操作的性能问题；</li>\n<li>通过微任务解决了实时性的问题。</li>\n</ul>\n<h2 id="总结-3"><a href="#%E6%80%BB%E7%BB%93-3" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总结</h2>\n<p>首先我们回顾了宏任务，然后在宏任务的基础之上，我们分析了异步回调函数的两种形式，其中最后一种回调的方式就是通过微任务来实现的。</p>\n<p>接下来我们详细分析了浏览器是如何实现微任务的，包括微任务队列、检查点等概念。</p>\n<p>最后我们介绍了监听 DOM 变化技术方案的演化史，从轮询到 Mutation Event 再到最新使用的 MutationObserver。MutationObserver 方案的核心就是采用了微任务机制，有效地权衡了实时性和执行效率的问题。</p>\n<h1 id="使用-promise-告别回调函数"><a href="#%E4%BD%BF%E7%94%A8-promise-%E5%91%8A%E5%88%AB%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>使用 Promise 告别回调函数</h1>\n<p>在上一篇文章中我们聊到了微任务是如何工作的，并介绍了 MutationObserver 是如何利用微任务来权衡性能和效率的。今天我们就接着来聊聊微任务的另外一个应用 Promise，DOM/BOM API 中新加入的 API 大多数都是建立在 Promise 上的，而且新的前端框架也使用了大量的 Promise。可以这么说，Promise 已经成为现代前端的“水”和“电”，很是关键，所以深入学习 Promise 势在必行。</p>\n<p>不过，Promise 的知识点有那么多，而我们只有一篇文章来介绍，那应该怎么讲解呢？具体讲解思路是怎样的呢？</p>\n<p>如果你想要学习一门新技术，最好的方式是先了解这门技术是如何诞生的，以及它所解决的问题是什么。了解了这些后，你才能抓住这门技术的本质。所以本文我们就来重点聊聊 JavaScript 引入 Promise 的动机，以及解决问题的几个核心关键点。</p>\n<p>要谈动机，我们一般都是先从问题切入，那么 Promise 到底解决了什么问题呢？在正式开始介绍之前，我想有必要明确下，Promise 解决的是异步编码风格的问题，而不是一些其他的问题，所以接下来我们聊的话题都是围绕编码风格展开的</p>\n<h2 id="异步编程的问题：代码逻辑不连续"><a href="#%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9A%E4%BB%A3%E7%A0%81%E9%80%BB%E8%BE%91%E4%B8%8D%E8%BF%9E%E7%BB%AD" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>异步编程的问题：代码逻辑不连续</h2>\n<p>首先我们来回顾下 JavaScript 的异步编程模型，你应该已经非常熟悉页面的事件循环系统了，也知道页面中任务都是执行在主线程之上的，相对于页面来说，主线程就是它整个的世界，所以在执行一项耗时的任务时，比如下载网络文件任务、获取摄像头等设备信息任务，这些任务都会放到页面主线程之外的进程或者线程中去执行，这样就避免了耗时任务“霸占”页面主线程的情况。你可以结合下图来看看这个处理过程：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-07-09-21-26-007246b0e3bebe20095091d4e5b51a4e-2cdbf.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 68.9041095890411%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAIAAACgpqunAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACfUlEQVQoz21SS08TURTuf/E3GF249JEY/RdudEPcuNCd0YgxcSE+CljjQjEElAWKTUtfUKGUtrYUpICdGdppKe2087jPmbkz1zsFGxP5cnJy7jn3O/ecLzfk+T7FyLeRR09NxNyB3Pk3iYdJRBlzXVtUHYIEMcQ9Vu8Ya02cG9pGE2UUEJfgsgTTCsipKKcGyfQhTkqwU93ZqTW/yc6OqnOfhTj3lna1jzk5WVWiW41ktfEgpV+cdy7MufdSZrIifS9J2V+N+7HW9XdKeezOxLOZc5/oVL4riMHLcg/8UMB6vb+m0mxlO7k8+zX+eTH+JRH9kFtPzK/V3sc238ZKC5tyv7a/d9CKq17tyAxedl0XIcQFHBr4UsQdP289uYaeXmXjl/hqRFKUleXv2US0Ud8Tdd/3hIcQCmJISAAgYsyzCWGck3YVZGb1zGInPncUnelV8l3dMAGEmBDbEddc5jGfWwCyIZkhhEVHzpxhY184WT5IJGMrq+mVTCKfTROM/pZOIYYVRCEYi9d6Lzb60xvdcNEIFwZT653nmeaj6MFEqv4qLT2OSy9zvcmi8aaghwv6ZFGfyBuZ/Z4gCrLf6KNSwywfDootWFJBUdLKbbR1TPc1+rtPt49JpQ3LLXBilTYoqqCli2F5iHkeApaLLAYN7hHOMMeG8L6DbQwphg6GLkEjcwhkFFmGHowtRBPbizY/D83bi827se7YknprQQ5vaiLp+fxk0dG6J8FIbdYf6EKtVK17+XXhZmTrxnTpSmT3YfqYuxQJkf8DpXQwGARk0ca2bXEm1LaIbeHAAHUxdUawh6BDjAI/+NtnwaYEQWAYhmmamqaJIc+89gdS6e5pSRHYswAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 07 09 21 26"\n        title=""\n        src="/static/2021-07-07-09-21-26-007246b0e3bebe20095091d4e5b51a4e-fee1c.png"\n        srcset="/static/2021-07-07-09-21-26-007246b0e3bebe20095091d4e5b51a4e-a67b7.png 200w,\n/static/2021-07-07-09-21-26-007246b0e3bebe20095091d4e5b51a4e-0b187.png 400w,\n/static/2021-07-07-09-21-26-007246b0e3bebe20095091d4e5b51a4e-fee1c.png 800w,\n/static/2021-07-07-09-21-26-007246b0e3bebe20095091d4e5b51a4e-b1a91.png 1200w,\n/static/2021-07-07-09-21-26-007246b0e3bebe20095091d4e5b51a4e-2cdbf.png 1460w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>上图展示的是一个标准的异步编程模型，页面主线程发起了一个耗时的任务，并将任务交给另外一个进程去处理，这时页面主线程会继续执行消息队列中的任务。等该进程处理完这个任务后，会将该任务添加到渲染进程的消息队列中，并排队等待循环系统的处理。排队结束之后，循环系统会取出消息队列中的任务进行处理，并触发相关的回调操作。</p>\n<p>这就是页面编程的一大特点：异步回调。</p>\n<p>Web 页面的单线程架构决定了异步回调，而异步回调影响到了我们的编码方式，到底是如何影响的呢？</p>\n<p>假设有一个下载的需求，使用 XMLHttpRequest 来实现，具体的实现方式你可以参考下面这段代码：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="33856863440321170000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// 执行状态\nfunction onResolve(response) {\n  console.log(response);\n}\nfunction onReject(error) {\n  console.log(error);\n}\n\nlet xhr = new XMLHttpRequest();\nxhr.ontimeout = function(e) {\n  onReject(e);\n};\nxhr.onerror = function(e) {\n  onReject(e);\n};\nxhr.onreadystatechange = function() {\n  onResolve(xhr.response);\n};\n\n// 设置请求类型，请求 URL，是否同步信息\nlet URL = \'https://time.geekbang.com\';\nxhr.open(\'Get\', URL, true);\n\n// 设置参数\nxhr.timeout = 3000; // 设置 xhr 请求的超时时间\nxhr.responseType = \'text\'; // 设置响应返回的数据格式\nxhr.setRequestHeader(\'X_TEST\', \'time.geekbang\');\n\n// 发出请求\nxhr.send();`, `33856863440321170000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                data-tooltip="复制"\n              >\n                <svg class="gatsby-code-button-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M16 1H2v16h2V3h12V1zm-1 4l6 6v12H6V5h9zm-1 7h5.5L14 6.5V12z"/></svg>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">// 执行状态</span>\n<span class="token keyword">function</span> <span class="token function">onResolve</span><span class="token punctuation">(</span><span class="token parameter">response</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">function</span> <span class="token function">onReject</span><span class="token punctuation">(</span><span class="token parameter">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">let</span> xhr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nxhr<span class="token punctuation">.</span><span class="token function-variable function">ontimeout</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token function">onReject</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\nxhr<span class="token punctuation">.</span><span class="token function-variable function">onerror</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token function">onReject</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\nxhr<span class="token punctuation">.</span><span class="token function-variable function">onreadystatechange</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token function">onResolve</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>response<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n<span class="token comment">// 设置请求类型，请求 URL，是否同步信息</span>\n<span class="token keyword">let</span> <span class="token constant">URL</span> <span class="token operator">=</span> <span class="token string">\'https://time.geekbang.com\'</span><span class="token punctuation">;</span>\nxhr<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">\'Get\'</span><span class="token punctuation">,</span> <span class="token constant">URL</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token comment">// 设置参数</span>\nxhr<span class="token punctuation">.</span>timeout <span class="token operator">=</span> <span class="token number">3000</span><span class="token punctuation">;</span> <span class="token comment">// 设置 xhr 请求的超时时间</span>\nxhr<span class="token punctuation">.</span>responseType <span class="token operator">=</span> <span class="token string">\'text\'</span><span class="token punctuation">;</span> <span class="token comment">// 设置响应返回的数据格式</span>\nxhr<span class="token punctuation">.</span><span class="token function">setRequestHeader</span><span class="token punctuation">(</span><span class="token string">\'X_TEST\'</span><span class="token punctuation">,</span> <span class="token string">\'time.geekbang\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token comment">// 发出请求</span>\nxhr<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>我们执行上面这段代码，可以正常输出结果的。但是，这短短的一段代码里面竟然出现了五次回调，这么多的回调会导致代码的逻辑不连贯、不线性，非常不符合人的直觉，这就是异步回调影响到我们的编码方式。</p>\n<p>那有什么方法可以解决这个问题吗？当然有，我们可以封装这堆凌乱的代码，降低处理异步回调的次数。</p>\n<h2 id="封装异步代码，让处理流程变得线性"><a href="#%E5%B0%81%E8%A3%85%E5%BC%82%E6%AD%A5%E4%BB%A3%E7%A0%81%EF%BC%8C%E8%AE%A9%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B%E5%8F%98%E5%BE%97%E7%BA%BF%E6%80%A7" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>封装异步代码，让处理流程变得线性</h2>\n<p>由于我们重点关注的是输入内容（请求信息）和输出内容（回复信息），至于中间的异步请求过程，我们不想在代码里面体现太多，因为这会干扰核心的代码逻辑。整体思路如下图所示：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-07-09-22-21-653caa17dff3967dd4c65dbe4f8088d3-abd93.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 49.36886395511922%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABW0lEQVQoz5WRTU7CQBiGuZlbV17CC7jwAC5deAU2LkwgGE2MIcaGUBPUtKGmJE1LQdvOtNDfYaydIrRTnBZJ1MDCN5nNfO/z/dZWu5XTFXgvnLjYZaixV/xW9VPGwrQ4uFgcXi/oH5yFK0dta8rlMmNKyKIppzdKmi2ZMkrplsoYY9u2w0pxHDPj1AbmSAWWEdiGBw3rbWy9aniG8jxPCEk8d64MaEpKGELIcZxQSR9qISbjTl043dOFO32oW8BRWifi2f7E0JzJNJ4hNFTDq2aGohJ2HKfb7fb7fVmWIQTsB+gD5fEWAMv0PzoPPb7d0kWOxJg1jzAONTW4bORrmFXmeV4URUmSLFDCEEBlZKrPbfn86L5V7wkvhgmSJGEhNvl6qd8zE0IQYhlxFEVrBwr8ieubEjduHLvqk+tH3tT5nM83y/4Bb9fmbrT4552r9oog8H3fY03twr8AklwuG3/VCaAAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 07 09 22 21"\n        title=""\n        src="/static/2021-07-07-09-22-21-653caa17dff3967dd4c65dbe4f8088d3-fee1c.png"\n        srcset="/static/2021-07-07-09-22-21-653caa17dff3967dd4c65dbe4f8088d3-a67b7.png 200w,\n/static/2021-07-07-09-22-21-653caa17dff3967dd4c65dbe4f8088d3-0b187.png 400w,\n/static/2021-07-07-09-22-21-653caa17dff3967dd4c65dbe4f8088d3-fee1c.png 800w,\n/static/2021-07-07-09-22-21-653caa17dff3967dd4c65dbe4f8088d3-b1a91.png 1200w,\n/static/2021-07-07-09-22-21-653caa17dff3967dd4c65dbe4f8088d3-abd93.png 1426w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从图中你可以看到，我们将 XMLHttpRequest 请求过程的代码封装起来了，重点关注输入数据和输出结果。</p>\n<p>那我们就按照这个思路来改造代码。首先，我们把输入的 HTTP 请求信息全部保存到一个 request 的结构中，包括请求地址、请求头、请求方式、引用地址、同步请求还是异步请求、安全设置等信息。request 结构如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="70803207077001450000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`//makeRequest 用来构造 request 对象\nfunction makeRequest(request_url) {\n  let request = {\n    method: \'Get\',\n    url: request_url,\n    headers: \'\',\n    body: \'\',\n    credentials: false,\n    sync: true,\n    responseType: \'text\',\n    referrer: \'\'\n  };\n  return request;\n}`, `70803207077001450000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                data-tooltip="复制"\n              >\n                <svg class="gatsby-code-button-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M16 1H2v16h2V3h12V1zm-1 4l6 6v12H6V5h9zm-1 7h5.5L14 6.5V12z"/></svg>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">//makeRequest 用来构造 request 对象</span>\n<span class="token keyword">function</span> <span class="token function">makeRequest</span><span class="token punctuation">(</span><span class="token parameter">request_url</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">let</span> request <span class="token operator">=</span> <span class="token punctuation">{</span>\n    method<span class="token punctuation">:</span> <span class="token string">\'Get\'</span><span class="token punctuation">,</span>\n    url<span class="token punctuation">:</span> request_url<span class="token punctuation">,</span>\n    headers<span class="token punctuation">:</span> <span class="token string">\'\'</span><span class="token punctuation">,</span>\n    body<span class="token punctuation">:</span> <span class="token string">\'\'</span><span class="token punctuation">,</span>\n    credentials<span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>\n    sync<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>\n    responseType<span class="token punctuation">:</span> <span class="token string">\'text\'</span><span class="token punctuation">,</span>\n    referrer<span class="token punctuation">:</span> <span class="token string">\'\'</span>\n  <span class="token punctuation">}</span><span class="token punctuation">;</span>\n  <span class="token keyword">return</span> request<span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>然后就可以封装请求过程了，这里我们将所有的请求细节封装进 XFetch 函数，XFetch 代码如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="21292697169747600000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`//[in] request，请求信息，请求头，延时值，返回类型等\n//[out] resolve, 执行成功，回调该函数\n//[out] reject  执行失败，回调该函数\nfunction XFetch(request, resolve, reject) {\n  let xhr = new XMLHttpRequest();\n  xhr.ontimeout = function(e) {\n    reject(e);\n  };\n  xhr.onerror = function(e) {\n    reject(e);\n  };\n  xhr.onreadystatechange = function() {\n    if ((xhr.status = 200)) resolve(xhr.response);\n  };\n  xhr.open(request.method, URL, request.sync);\n  xhr.timeout = request.timeout;\n  xhr.responseType = request.responseType;\n  // 补充其他请求信息\n  //...\n  xhr.send();\n}`, `21292697169747600000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                data-tooltip="复制"\n              >\n                <svg class="gatsby-code-button-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M16 1H2v16h2V3h12V1zm-1 4l6 6v12H6V5h9zm-1 7h5.5L14 6.5V12z"/></svg>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">//[in] request，请求信息，请求头，延时值，返回类型等</span>\n<span class="token comment">//[out] resolve, 执行成功，回调该函数</span>\n<span class="token comment">//[out] reject  执行失败，回调该函数</span>\n<span class="token keyword">function</span> <span class="token function">XFetch</span><span class="token punctuation">(</span><span class="token parameter">request<span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">let</span> xhr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  xhr<span class="token punctuation">.</span><span class="token function-variable function">ontimeout</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token function">reject</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">;</span>\n  xhr<span class="token punctuation">.</span><span class="token function-variable function">onerror</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token function">reject</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">;</span>\n  xhr<span class="token punctuation">.</span><span class="token function-variable function">onreadystatechange</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>status <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">resolve</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>response<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">;</span>\n  xhr<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span>request<span class="token punctuation">.</span>method<span class="token punctuation">,</span> <span class="token constant">URL</span><span class="token punctuation">,</span> request<span class="token punctuation">.</span>sync<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  xhr<span class="token punctuation">.</span>timeout <span class="token operator">=</span> request<span class="token punctuation">.</span>timeout<span class="token punctuation">;</span>\n  xhr<span class="token punctuation">.</span>responseType <span class="token operator">=</span> request<span class="token punctuation">.</span>responseType<span class="token punctuation">;</span>\n  <span class="token comment">// 补充其他请求信息</span>\n  <span class="token comment">//...</span>\n  xhr<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>这个 XFetch 函数需要一个 request 作为输入，然后还需要两个回调函数 resolve 和 reject，当请求成功时回调 resolve 函数，当请求出现问题时回调 reject 函数。</p>\n<p>有了这些后，我们就可以来实现业务代码了，具体的实现方式如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="91655977422749020000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`XFetch(\n  makeRequest(\'https://time.geekbang.org\'),\n  function resolve(data) {\n    console.log(data);\n  },\n  function reject(e) {\n    console.log(e);\n  }\n);`, `91655977422749020000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                data-tooltip="复制"\n              >\n                <svg class="gatsby-code-button-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M16 1H2v16h2V3h12V1zm-1 4l6 6v12H6V5h9zm-1 7h5.5L14 6.5V12z"/></svg>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token function">XFetch</span><span class="token punctuation">(</span>\n  <span class="token function">makeRequest</span><span class="token punctuation">(</span><span class="token string">\'https://time.geekbang.org\'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n  <span class="token keyword">function</span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token keyword">function</span> <span class="token function">reject</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h2 id="新的问题：回调地狱"><a href="#%E6%96%B0%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9A%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>新的问题：回调地狱</h2>\n<p>上面的示例代码已经比较符合人的线性思维了，在一些简单的场景下运行效果也是非常好的，不过一旦接触到稍微复杂点的项目时，你就会发现，如果嵌套了太多的回调函数就很容易使得自己陷入了回调地狱，不能自拔。你可以参考下面这段让人凌乱的代码：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="78256345373762010000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`XFetch(makeRequest(\'https://time.geekbang.org/?category\'),\n  function resolve(response) {\n      console.log(response)\n      XFetch(makeRequest(\'https://time.geekbang.org/column\'),\n          function resolve(response) {\n              console.log(response)\n              XFetch(makeRequest(\'https://time.geekbang.org\')\n                  function resolve(response) {\n                      console.log(response)\n                  }, function reject(e) {\n                      console.log(e)\n                  })\n          }, function reject(e) {\n              console.log(e)\n          })\n  }, function reject(e) {\n      console.log(e)\n  })`, `78256345373762010000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                data-tooltip="复制"\n              >\n                <svg class="gatsby-code-button-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M16 1H2v16h2V3h12V1zm-1 4l6 6v12H6V5h9zm-1 7h5.5L14 6.5V12z"/></svg>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token function">XFetch</span><span class="token punctuation">(</span><span class="token function">makeRequest</span><span class="token punctuation">(</span><span class="token string">\'https://time.geekbang.org/?category\'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n  <span class="token keyword">function</span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token parameter">response</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span>\n      <span class="token function">XFetch</span><span class="token punctuation">(</span><span class="token function">makeRequest</span><span class="token punctuation">(</span><span class="token string">\'https://time.geekbang.org/column\'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n          <span class="token keyword">function</span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token parameter">response</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n              console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span>\n              <span class="token function">XFetch</span><span class="token punctuation">(</span><span class="token function">makeRequest</span><span class="token punctuation">(</span><span class="token string">\'https://time.geekbang.org\'</span><span class="token punctuation">)</span>\n                  <span class="token keyword">function</span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token parameter">response</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span>\n                  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token function">reject</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>\n                  <span class="token punctuation">}</span><span class="token punctuation">)</span>\n          <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token function">reject</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n              console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>\n          <span class="token punctuation">}</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token function">reject</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>这段代码是先请求 time.geekbang.org/?category，如果请求成功的话，那么再请求 time.geekbang.org/column，如果再次请求成功的话，就继续请求 time.geekbang.org。也就是说这段代码用了三层嵌套请求，就已经让代码变得混乱不堪，所以，我们还需要解决这种嵌套调用后混乱的代码结构。</p>\n<p>这段代码之所以看上去很乱，归结其原因有两点：</p>\n<ul>\n<li>第一是嵌套调用，下面的任务依赖上个任务的请求结果，并在上个任务的回调函数内部执行新的业务逻辑，这样当嵌套层次多了之后，代码的可读性就变得非常差了。</li>\n<li>第二是任务的不确定性，执行每个任务都有两种可能的结果（成功或者失败），所以体现在代码中就需要对每个任务的执行结果做两次判断，这种对每个任务都要进行一次额外的错误处理的方式，明显增加了代码的混乱程度。</li>\n</ul>\n<p>原因分析出来后，那么问题的解决思路就很清晰了：</p>\n<ul>\n<li>第一是消灭嵌套调用；</li>\n<li>第二是合并多个任务的错误处理。</li>\n</ul>\n<p>这么讲可能有点抽象，不过 Promise 已经帮助我们解决了这两个问题。那么接下来我们就来看看 Promise 是怎么消灭嵌套调用和合并多个任务的错误处理的。</p>\n<h2 id="promise：消灭嵌套调用和多次错误处理"><a href="#promise%EF%BC%9A%E6%B6%88%E7%81%AD%E5%B5%8C%E5%A5%97%E8%B0%83%E7%94%A8%E5%92%8C%E5%A4%9A%E6%AC%A1%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Promise：消灭嵌套调用和多次错误处理</h2>\n<p>首先，我们使用 Promise 来重构 XFetch 的代码，示例代码如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="72673983806106214000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function XFetch(request) {\n  function executor(resolve, reject) {\n    let xhr = new XMLHttpRequest();\n    xhr.open(\'GET\', request.url, true);\n    xhr.ontimeout = function(e) {\n      reject(e);\n    };\n    xhr.onerror = function(e) {\n      reject(e);\n    };\n    xhr.onreadystatechange = function() {\n      if (this.readyState === 4) {\n        if (this.status === 200) {\n          resolve(this.responseText, this);\n        } else {\n          let error = {\n            code: this.status,\n            response: this.response\n          };\n          reject(error, this);\n        }\n      }\n    };\n    xhr.send();\n  }\n  return new Promise(executor);\n}`, `72673983806106214000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                data-tooltip="复制"\n              >\n                <svg class="gatsby-code-button-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M16 1H2v16h2V3h12V1zm-1 4l6 6v12H6V5h9zm-1 7h5.5L14 6.5V12z"/></svg>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span> <span class="token function">XFetch</span><span class="token punctuation">(</span><span class="token parameter">request</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">function</span> <span class="token function">executor</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">let</span> xhr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    xhr<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">\'GET\'</span><span class="token punctuation">,</span> request<span class="token punctuation">.</span>url<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    xhr<span class="token punctuation">.</span><span class="token function-variable function">ontimeout</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token function">reject</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span><span class="token punctuation">;</span>\n    xhr<span class="token punctuation">.</span><span class="token function-variable function">onerror</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token function">reject</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span><span class="token punctuation">;</span>\n    xhr<span class="token punctuation">.</span><span class="token function-variable function">onreadystatechange</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>readyState <span class="token operator">===</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">===</span> <span class="token number">200</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n          <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>responseText<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n          <span class="token keyword">let</span> error <span class="token operator">=</span> <span class="token punctuation">{</span>\n            code<span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>status<span class="token punctuation">,</span>\n            response<span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>response\n          <span class="token punctuation">}</span><span class="token punctuation">;</span>\n          <span class="token function">reject</span><span class="token punctuation">(</span>error<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n      <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span><span class="token punctuation">;</span>\n    xhr<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span>executor<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>接下来，我们再利用 XFetch 来构造请求流程，代码如下：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="26679067431965350000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`var x1 = XFetch(makeRequest(\'https://time.geekbang.org/?category\'));\nvar x2 = x1.then((value) => {\n  console.log(value);\n  return XFetch(makeRequest(\'https://www.geekbang.org/column\'));\n});\nvar x3 = x2.then((value) => {\n  console.log(value);\n  return XFetch(makeRequest(\'https://time.geekbang.org\'));\n});\nx3.catch((error) => {\n  console.log(error);\n});`, `26679067431965350000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                data-tooltip="复制"\n              >\n                <svg class="gatsby-code-button-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M16 1H2v16h2V3h12V1zm-1 4l6 6v12H6V5h9zm-1 7h5.5L14 6.5V12z"/></svg>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">var</span> x1 <span class="token operator">=</span> <span class="token function">XFetch</span><span class="token punctuation">(</span><span class="token function">makeRequest</span><span class="token punctuation">(</span><span class="token string">\'https://time.geekbang.org/?category\'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">var</span> x2 <span class="token operator">=</span> x1<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">return</span> <span class="token function">XFetch</span><span class="token punctuation">(</span><span class="token function">makeRequest</span><span class="token punctuation">(</span><span class="token string">\'https://www.geekbang.org/column\'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">var</span> x3 <span class="token operator">=</span> x2<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">return</span> <span class="token function">XFetch</span><span class="token punctuation">(</span><span class="token function">makeRequest</span><span class="token punctuation">(</span><span class="token string">\'https://time.geekbang.org\'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nx3<span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">error</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>你可以观察上面这两段代码，重点关注下 Promise 的使用方式。</p>\n<ul>\n<li>首先我们引入了 Promise，在调用 XFetch 时，会返回一个 Promise 对象。</li>\n<li>构建 Promise 对象时，需要传入一个 executor 函数，XFetch 的主要业务流程都在 executor 函数中执行。</li>\n<li>如果运行在 excutor 函数中的业务执行成功了，会调用 resolve 函数；如果执行失败了，则调用 reject 函数。</li>\n<li>在 excutor 函数中调用 resolve 函数时，会触发 promise.then 设置的回调函数；而调用 reject 函数时，会触发 promise.catch 设置的回调函数</li>\n</ul>\n<p>以上简单介绍了 Promise 一些主要的使用方法，通过引入 Promise，上面这段代码看起来就非常线性了，也非常符合人的直觉，是不是很酷？基于这段代码，我们就可以来分析 Promise 是如何消灭嵌套回调和合并多个错误处理了。</p>\n<p>我们先来看看 Promise 是怎么消灭嵌套回调的。产生嵌套函数的一个主要原因是在发起任务请求时会带上回调函数，这样当任务处理结束之后，下个任务就只能在回调函数中来处理了。</p>\n<p>Promise 主要通过下面两步解决嵌套回调问题的。</p>\n<p>首先，Promise 实现了回调函数的延时绑定。回调函数的延时绑定在代码上体现就是先创建 Promise 对象 x1，通过 Promise 的构造函数 executor 来执行业务逻辑；创建好 Promise 对象 x1 之后，再使用 x1.then 来设置回调函数。示范代码如下：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="14414015693061910000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// 创建 Promise 对象 x1，并在 executor 函数中执行业务逻辑\nfunction executor(resolve, reject) {\n  resolve(100);\n}\nlet x1 = new Promise(executor);\n\n//x1 延迟绑定回调函数 onResolve\nfunction onResolve(value) {\n  console.log(value);\n}\nx1.then(onResolve);`, `14414015693061910000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                data-tooltip="复制"\n              >\n                <svg class="gatsby-code-button-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M16 1H2v16h2V3h12V1zm-1 4l6 6v12H6V5h9zm-1 7h5.5L14 6.5V12z"/></svg>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">// 创建 Promise 对象 x1，并在 executor 函数中执行业务逻辑</span>\n<span class="token keyword">function</span> <span class="token function">executor</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">let</span> x1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span>executor<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token comment">//x1 延迟绑定回调函数 onResolve</span>\n<span class="token keyword">function</span> <span class="token function">onResolve</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\nx1<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>onResolve<span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>其次，需要将回调函数 onResolve 的返回值穿透到最外层。因为我们会根据 onResolve 函数的传入值来决定创建什么类型的 Promise 任务，创建好的 Promise 对象需要返回到最外层，这样就可以摆脱嵌套循环了。你可以先看下面的代码：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-07-09-26-17-4eedf9f9ac4ef89eccb3ce4b18a2644d-311f8.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 86.61971830985915%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAIAAABSJhvpAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABzUlEQVQ4y6WS224TMRCG86aIq3IDXFXc8CaIG3rTt0CqQKBIiFYKqGqU0j0kbLIeez1rr49r47RN2RwqKvHLsrSr+Twz/8wobsv3Dg3TXnW2S8d63TmZ7tZwrnmr26ZjfejvgkcPWAjrG6WZFaSslvnialHnixXJq6oCOisLQIIaqYS+97vwnaxNSY1sOeMEZRt8TGn6dHyIYSd2D1YqaBWsDUpF5XrRGd5oRBU2pQ7f2IW1tRVblXSekyyHbMmrZVNra4atbcEuu+Yn79vTk/bDO5xc/uaxIpxAQci8WlECzDobD2kNy/Nv5y+ef3919PPomRp/liEWC04Bshs2KyjhSJlgrBPCAJVd540ZGKYmF9M3r6/eHv86fonjL6k5Z60xRgjFUXc6teJ8mk9y2acrhE31azhI0d9ch3mhvn6yANgs62yC1SVvWDI/Pq6/hjnvAZEwquYXavpRFmNrlHMp2ybdQAM4faQf3itlIP8B0zNERnnXUFjVAkAYY2+jDsJbo/KNkOsloc2DMf8u+37DTC8FUo41IGsk5yoZ9VQ4tYjKlKwFWi/KeZpN3F/LRzOnzQwhPk2j+B86AKfBEELqugaA+laUUufcfuQf9J7Wa/K5hOwAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 07 09 26 17"\n        title=""\n        src="/static/2021-07-07-09-26-17-4eedf9f9ac4ef89eccb3ce4b18a2644d-fee1c.png"\n        srcset="/static/2021-07-07-09-26-17-4eedf9f9ac4ef89eccb3ce4b18a2644d-a67b7.png 200w,\n/static/2021-07-07-09-26-17-4eedf9f9ac4ef89eccb3ce4b18a2644d-0b187.png 400w,\n/static/2021-07-07-09-26-17-4eedf9f9ac4ef89eccb3ce4b18a2644d-fee1c.png 800w,\n/static/2021-07-07-09-26-17-4eedf9f9ac4ef89eccb3ce4b18a2644d-b1a91.png 1200w,\n/static/2021-07-07-09-26-17-4eedf9f9ac4ef89eccb3ce4b18a2644d-311f8.png 1420w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>现在我们知道了 Promise 通过回调函数延迟绑定和回调函数返回值穿透的技术，解决了循环嵌套。</p>\n<p>那接下来我们再来看看 Promise 是怎么处理异常的，你可以回顾上篇文章思考题留的那段代码，我把这段代码也贴在文中了，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="95075071949469940000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function executor(resolve, reject) {\n  let rand = Math.random();\n  console.log(1);\n  console.log(rand);\n  if (rand > 0.5) resolve();\n  else reject();\n}\nvar p0 = new Promise(executor);\n\nvar p1 = p0.then((value) => {\n  console.log(\'succeed-1\');\n  return new Promise(executor);\n});\n\nvar p3 = p1.then((value) => {\n  console.log(\'succeed-2\');\n  return new Promise(executor);\n});\n\nvar p4 = p3.then((value) => {\n  console.log(\'succeed-3\');\n  return new Promise(executor);\n});\n\np4.catch((error) => {\n  console.log(\'error\');\n});\nconsole.log(2);`, `95075071949469940000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                data-tooltip="复制"\n              >\n                <svg class="gatsby-code-button-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M16 1H2v16h2V3h12V1zm-1 4l6 6v12H6V5h9zm-1 7h5.5L14 6.5V12z"/></svg>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span> <span class="token function">executor</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">let</span> rand <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>rand<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>rand <span class="token operator">></span> <span class="token number">0.5</span><span class="token punctuation">)</span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">else</span> <span class="token function">reject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">var</span> p0 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span>executor<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token keyword">var</span> p1 <span class="token operator">=</span> p0<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'succeed-1\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span>executor<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token keyword">var</span> p3 <span class="token operator">=</span> p1<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'succeed-2\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span>executor<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token keyword">var</span> p4 <span class="token operator">=</span> p3<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'succeed-3\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span>executor<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\np4<span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">error</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'error\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>这段代码有四个 Promise 对象：p0 ～ p4。无论哪个对象里面抛出异常，都可以通过最后一个对象 p4.catch 来捕获异常，通过这种方式可以将所有 Promise 对象的错误合并到一个函数来处理，这样就解决了每个任务都需要单独处理异常的问题。</p>\n<p>之所以可以使用最后一个对象来捕获所有异常，是因为 Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被 onReject 函数处理或 catch 语句捕获为止。具备了这样“冒泡”的特性后，就不需要在每个 Promise 对象中单独捕获异常了。至于 Promise 错误的“冒泡”性质是怎么实现的，就留给你课后思考了。</p>\n<p>通过这种方式，我们就消灭了嵌套调用和频繁的错误处理，这样使得我们写出来的代码更加优雅，更加符合人的线性思维。</p>\n<h2 id="promise-与微任务"><a href="#promise-%E4%B8%8E%E5%BE%AE%E4%BB%BB%E5%8A%A1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Promise 与微任务</h2>\n<p>讲了这么多，我们似乎还没有将微任务和 Promise 关联起来，那么 Promise 和微任务的关系到底体现哪里呢？</p>\n<p>我们可以结合下面这个简单的 Promise 代码来回答这个问题：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="42846195550771760000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function executor(resolve, reject) {\n  resolve(100);\n}\nlet demo = new Promise(executor);\n\nfunction onResolve(value) {\n  console.log(value);\n}\ndemo.then(onResolve);`, `42846195550771760000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                data-tooltip="复制"\n              >\n                <svg class="gatsby-code-button-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M16 1H2v16h2V3h12V1zm-1 4l6 6v12H6V5h9zm-1 7h5.5L14 6.5V12z"/></svg>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span> <span class="token function">executor</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">let</span> demo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span>executor<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token keyword">function</span> <span class="token function">onResolve</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\ndemo<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>onResolve<span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>对于上面这段代码，我们需要重点关注下它的执行顺序。</p>\n<p>首先执行 new Promise 时，Promise 的构造函数会被执行，不过由于 Promise 是 V8 引擎提供的，所以暂时看不到 Promise 构造函数的细节。</p>\n<p>接下来，Promise 的构造函数会调用 Promise 的参数 executor 函数。然后在 executor 中执行了 resolve，resolve 函数也是在 V8 内部实现的，那么 resolve 函数到底做了什么呢？我们知道，执行 resolve 函数，会触发 demo.then 设置的回调函数 onResolve，所以可以推测，resolve 函数内部调用了通过 demo.then 设置的 onResolve 函数。</p>\n<p>不过这里需要注意一下，由于 Promise 采用了回调函数延迟绑定技术，所以在执行 resolve 函数的时候，回调函数还没有绑定，那么只能推迟回调函数的执行。</p>\n<p>这样按顺序陈述可能把你绕晕了，下面来模拟实现一个 Promise，我们会实现它的构造函数、resolve 方法以及 then 方法，以方便你能看清楚 Promise 的背后都发生了什么。这里我们就把这个对象称为 Bromise，下面就是 Bromise 的实现代码：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="94698530957575900000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function Bromise(executor) {\n  var onResolve_ = null;\n  var onReject_ = null;\n  // 模拟实现 resolve 和 then，暂不支持 rejcet\n  this.then = function(onResolve, onReject) {\n    onResolve_ = onResolve;\n  };\n  function resolve(value) {\n    //setTimeout(()=>{\n    onResolve_(value);\n    // },0)\n  }\n  executor(resolve, null);\n}`, `94698530957575900000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                data-tooltip="复制"\n              >\n                <svg class="gatsby-code-button-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M16 1H2v16h2V3h12V1zm-1 4l6 6v12H6V5h9zm-1 7h5.5L14 6.5V12z"/></svg>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Bromise</span><span class="token punctuation">(</span><span class="token parameter">executor</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">var</span> onResolve_ <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n  <span class="token keyword">var</span> onReject_ <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n  <span class="token comment">// 模拟实现 resolve 和 then，暂不支持 rejcet</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">then</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">onResolve<span class="token punctuation">,</span> onReject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    onResolve_ <span class="token operator">=</span> onResolve<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">;</span>\n  <span class="token keyword">function</span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">//setTimeout(()=>{</span>\n    <span class="token function">onResolve_</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token comment">// },0)</span>\n  <span class="token punctuation">}</span>\n  <span class="token function">executor</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>观察上面这段代码，我们实现了自己的构造函数、resolve、then 方法。接下来我们使用 Bromise 来实现我们的业务代码，实现后的代码如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="21877161193527984000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function executor(resolve, reject) {\n  resolve(100);\n}\n// 将 Promise 改成我们自己的 Bromsie\nlet demo = new Bromise(executor);\n\nfunction onResolve(value) {\n  console.log(value);\n}\ndemo.then(onResolve);`, `21877161193527984000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                data-tooltip="复制"\n              >\n                <svg class="gatsby-code-button-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M16 1H2v16h2V3h12V1zm-1 4l6 6v12H6V5h9zm-1 7h5.5L14 6.5V12z"/></svg>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span> <span class="token function">executor</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token comment">// 将 Promise 改成我们自己的 Bromsie</span>\n<span class="token keyword">let</span> demo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Bromise</span><span class="token punctuation">(</span>executor<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token keyword">function</span> <span class="token function">onResolve</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\ndemo<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>onResolve<span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>执行这段代码，我们发现执行出错，输出的内容是：</p>\n<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">Uncaught TypeError: onResolve_ is not a function\n    at resolve (&lt;anonymous&gt;:10:13)\n    at executor (&lt;anonymous&gt;:17:5)\n    at new Bromise (&lt;anonymous&gt;:13:5)\n    at &lt;anonymous&gt;:19:12</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>之所以出现这个错误，是由于 Bromise 的延迟绑定导致的，在调用到 onResolve* 函数的时候，Bromise.then 还没有执行，所以执行上述代码的时候，当然会报“onResolve* is not a function“的错误了。</p>\n<p>也正是因为此，我们要改造 Bromise 中的 resolve 方法，让 resolve 延迟调用 onResolve_。</p>\n<p>要让 resolve 中的 onResolve* 函数延后执行，可以在 resolve 函数里面加上一个定时器，让其延时执行 onResolve* 函数，你可以参考下面改造后的代码：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="30857265657121325000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function resolve(value) {\n  setTimeout(() => {\n    onResolve_(value);\n  }, 0);\n}`, `30857265657121325000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                data-tooltip="复制"\n              >\n                <svg class="gatsby-code-button-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M16 1H2v16h2V3h12V1zm-1 4l6 6v12H6V5h9zm-1 7h5.5L14 6.5V12z"/></svg>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n    <span class="token function">onResolve_</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>上面采用了定时器来推迟 onResolve 的执行，不过使用定时器的效率并不是太高，好在我们有微任务，所以 Promise 又把这个定时器改造成了微任务了，这样既可以让 onResolve_ 延时被调用，又提升了代码的执行效率。这就是 Promise 中使用微任务的原因了</p>\n<h2 id="总结-4"><a href="#%E6%80%BB%E7%BB%93-4" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总结</h2>\n<p>首先，我们回顾了 Web 页面是单线程架构模型，这种模型决定了我们编写代码的形式——异步编程。基于异步编程模型写出来的代码会把一些关键的逻辑点打乱，所以这种风格的代码不符合人的线性思维方式。接下来我们试着把一些不必要的回调接口封装起来，简单封装取得了一定的效果，不过，在稍微复杂点的场景下依然存在着回调地狱的问题。然后我们分析了产生回调地狱的原因：</p>\n<ul>\n<li>多层嵌套的问题；</li>\n<li>每种任务的处理结果存在两种可能性（成功或失败），那么需要在每种任务执行结束后分别处理这两种可能性。</li>\n</ul>\n<p>Promise 通过回调函数延迟绑定、回调函数返回值穿透和错误“冒泡”技术解决了上面的两个问题。</p>\n<p>最后，我们还分析了 Promise 之所以要使用微任务是由 Promise 回调函数延迟绑定技术导致的。</p>\n<h1 id="async-await-使用同步方式写异步代码"><a href="#async-await-%E4%BD%BF%E7%94%A8%E5%90%8C%E6%AD%A5%E6%96%B9%E5%BC%8F%E5%86%99%E5%BC%82%E6%AD%A5%E4%BB%A3%E7%A0%81" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>async await 使用同步方式写异步代码</h1>\n<p>在上篇文章中，我们介绍了怎么使用 Promise 来实现回调操作，使用 Promise 能很好地解决回调地狱的问题，但是这种方式充满了 Promise 的 then() 方法，如果处理流程比较复杂的话，那么整段代码将充斥着 then，语义化不明显，代码不能很好地表示执行流程。</p>\n<p>比如下面这样一个实际的使用场景：我先请求极客邦的内容，等返回信息之后，我再请求极客邦的另外一个资源。下面代码展示的是使用 fetch 来实现这样的需求，fetch 被定义在 window 对象中，可以用它来发起对远程资源的请求，该方法返回的是一个 Promise 对象，这和我们上篇文章中讲的 XFetch 很像，只不过 fetch 是浏览器原生支持的，没有利用 XMLHttpRequest 来封装。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="72188322222499820000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`fetch(\'https://www.geekbang.org\')\n  .then((response) => {\n    console.log(response);\n    return fetch(\'https://www.geekbang.org/test\');\n  })\n  .then((response) => {\n    console.log(response);\n  })\n  .catch((error) => {\n    console.log(error);\n  });`, `72188322222499820000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                data-tooltip="复制"\n              >\n                <svg class="gatsby-code-button-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M16 1H2v16h2V3h12V1zm-1 4l6 6v12H6V5h9zm-1 7h5.5L14 6.5V12z"/></svg>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">\'https://www.geekbang.org\'</span><span class="token punctuation">)</span>\n  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">response</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">return</span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">\'https://www.geekbang.org/test\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span>\n  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">response</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span>\n  <span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">error</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>从这段 Promise 代码可以看出来，使用 promise.then 也是相当复杂，虽然整个请求流程已经线性化了，但是代码里面包含了大量的 then 函数，使得代码依然不是太容易阅读。基于这个原因，ES7 引入了 async/await，这是 JavaScript 异步编程的一个重大改进，提供了在不阻塞主线程的情况下使用同步代码实现异步访问资源的能力，并且使得代码逻辑更加清晰。你可以参考下面这段代码：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="54504616868227470000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`async function foo() {\n  try {\n    let response1 = await fetch(\'https://www.geekbang.org\');\n    console.log(\'response1\');\n    console.log(response1);\n    let response2 = await fetch(\'https://www.geekbang.org/test\');\n    console.log(\'response2\');\n    console.log(response2);\n  } catch (err) {\n    console.error(err);\n  }\n}\nfoo();`, `54504616868227470000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                data-tooltip="复制"\n              >\n                <svg class="gatsby-code-button-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M16 1H2v16h2V3h12V1zm-1 4l6 6v12H6V5h9zm-1 7h5.5L14 6.5V12z"/></svg>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">try</span> <span class="token punctuation">{</span>\n    <span class="token keyword">let</span> response1 <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">\'https://www.geekbang.org\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'response1\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>response1<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">let</span> response2 <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">\'https://www.geekbang.org/test\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'response2\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>response2<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>通过上面代码，你会发现整个异步处理的逻辑都是使用同步代码的方式来实现的，而且还支持 try catch 来捕获异常，这就是完全在写同步代码，所以是非常符合人的线性思维的。但是很多人都习惯了异步回调的编程思维，对于这种采用同步代码实现异步逻辑的方式，还需要一个转换的过程，因为这中间隐藏了一些容易让人迷惑的细节。</p>\n<p>那么本篇文章我们继续深入，看看 JavaScript 引擎是如何实现 async/await 的。如果上来直接介绍 async/await 的使用方式的话，那么你可能会有点懵，所以我们就从其最底层的技术点一步步往上讲解，从而带你彻底弄清楚 async 和 await 到底是怎么工作的。</p>\n<p>本文我们首先介绍生成器（Generator）是如何工作的，接着讲解 Generator 的底层实现机制——协程（Coroutine）；又因为 async/await 使用了 Generator 和 Promise 两种技术，所以紧接着我们就通过 Generator 和 Promise 来分析 async/await 到底是如何以同步的方式来编写异步代码的。</p>\n<h2 id="生成器-vs-协程"><a href="#%E7%94%9F%E6%88%90%E5%99%A8-vs-%E5%8D%8F%E7%A8%8B" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>生成器 VS 协程</h2>\n<p>我们先来看看什么是生成器函数？</p>\n<p>生成器函数是一个带星号函数，而且是可以暂停执行和恢复执行的。我们可以看下面这段代码：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="78207041694113430000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function* genDemo() {\n  console.log(\' 开始执行第一段 \');\n  yield \'generator 2\';\n\n  console.log(\' 开始执行第二段 \');\n  yield \'generator 2\';\n\n  console.log(\' 开始执行第三段 \');\n  yield \'generator 2\';\n\n  console.log(\' 执行结束 \');\n  return \'generator 2\';\n}\n\nconsole.log(\'main 0\');\nlet gen = genDemo();\nconsole.log(gen.next().value);\nconsole.log(\'main 1\');\nconsole.log(gen.next().value);\nconsole.log(\'main 2\');\nconsole.log(gen.next().value);\nconsole.log(\'main 3\');\nconsole.log(gen.next().value);\nconsole.log(\'main 4\');`, `78207041694113430000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                data-tooltip="复制"\n              >\n                <svg class="gatsby-code-button-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M16 1H2v16h2V3h12V1zm-1 4l6 6v12H6V5h9zm-1 7h5.5L14 6.5V12z"/></svg>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">genDemo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\' 开始执行第一段 \'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">yield</span> <span class="token string">\'generator 2\'</span><span class="token punctuation">;</span>\n\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\' 开始执行第二段 \'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">yield</span> <span class="token string">\'generator 2\'</span><span class="token punctuation">;</span>\n\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\' 开始执行第三段 \'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">yield</span> <span class="token string">\'generator 2\'</span><span class="token punctuation">;</span>\n\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\' 执行结束 \'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">return</span> <span class="token string">\'generator 2\'</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'main 0\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">let</span> gen <span class="token operator">=</span> <span class="token function">genDemo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>gen<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'main 1\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>gen<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'main 2\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>gen<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'main 3\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>gen<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'main 4\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>执行上面这段代码，观察输出结果，你会发现函数 genDemo 并不是一次执行完的，全局代码和 genDemo 函数交替执行。其实这就是生成器函数的特性，可以暂停执行，也可以恢复执行。下面我们就来看看生成器函数的具体使用方式：</p>\n<ul>\n<li>在生成器函数内部执行一段代码，如果遇到 yield 关键字，那么 JavaScript 引擎将返回关键字后面的内容给外部，并暂停该函数的执行。</li>\n<li>外部函数可以通过 next 方法恢复函数的执行</li>\n</ul>\n<p>关于函数的暂停和恢复，相信你一定很好奇这其中的原理，那么接下来我们就来简单介绍下 JavaScript 引擎 V8 是如何实现一个函数的暂停和恢复的，这也会有助于你理解后面要介绍的 async/await。</p>\n<p>要搞懂函数为何能暂停和恢复，那你首先要了解协程的概念。协程是一种比线程更加轻量级的存在。你可以把协程看成是跑在线程上的任务，一个线程上可以存在多个协程，但是在线程上同时只能执行一个协程，比如当前执行的是 A 协程，要启动 B 协程，那么 A 协程就需要将主线程的控制权交给 B 协程，这就体现在 A 协程暂停执行，B 协程恢复执行；同样，也可以从 B 协程中启动 A 协程。通常，如果从 A 协程启动 B 协程，我们就把 A 协程称为 B 协程的父协程。</p>\n<p>正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程。最重要的是，协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）。这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。</p>\n<p>为了让你更好地理解协程是怎么执行的，我结合上面那段代码的执行过程，画出了下面的“协程执行流程图”，你可以对照着代码来分析：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-07-09-33-10-f9e23b8a93102e501743b8445cce4c3d-205ae.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 53.648648648648646%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABTElEQVQoz6WSO04DMRCG9y4cB07ADXIHbgAIJPpUIKF0FHQIGkRExSsSBSKkQEDIbrJr7449Mx6H2c0KBQkQElP4+X/ze2wn839EsjyJsW5HOW2ej/cuU4tSL/4FlhgpBO3vxn51f7jee5xYXGQkDkQk9W4tC3VoH5NmOwZEACwKY02u8zfjUh0XBSGpc+l8aS16r2JktqUtK5AWro0psxV4ZGLNRZ7AWu8gSBAWV1auqtRcdcaANZYJ22PfT7B7nZ+NIOgaoqYUEfSoVhxYJDIF7xw28OmwXDt42r7IWvhwkK9s3XavpnNBcE510PhoAIDTejQLMzivR7p5zjdOXnqDaQsDiXH4kGHn+HWnn6o/OSfNnSjDSiJqLRyCjoXpy21/vlDnaLTbf//9bWOjXyDJTyJ19l7rRq3iT59kORTLsmw2m6VpGuP3P+UDbAl6la0gdsQAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 07 09 33 10"\n        title=""\n        src="/static/2021-07-07-09-33-10-f9e23b8a93102e501743b8445cce4c3d-fee1c.png"\n        srcset="/static/2021-07-07-09-33-10-f9e23b8a93102e501743b8445cce4c3d-a67b7.png 200w,\n/static/2021-07-07-09-33-10-f9e23b8a93102e501743b8445cce4c3d-0b187.png 400w,\n/static/2021-07-07-09-33-10-f9e23b8a93102e501743b8445cce4c3d-fee1c.png 800w,\n/static/2021-07-07-09-33-10-f9e23b8a93102e501743b8445cce4c3d-b1a91.png 1200w,\n/static/2021-07-07-09-33-10-f9e23b8a93102e501743b8445cce4c3d-205ae.png 1480w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从图中可以看出来协程的四点规则：</p>\n<ul>\n<li>通过调用生成器函数 genDemo 来创建一个协程 gen，创建之后，gen 协程并没有立即执行。</li>\n<li>要让 gen 协程执行，需要通过调用 gen.next。</li>\n<li>当协程正在执行的时候，可以通过 yield 关键字来暂停 gen 协程的执行，并返回主要信息给父协程。</li>\n<li>如果协程在执行期间，遇到了 return 关键字，那么 JavaScript 引擎会结束当前协程，并将 return 后面的内容返回给父协程。</li>\n</ul>\n<p>不过，对于上面这段代码，你可能又有这样疑问：父协程有自己的调用栈，gen 协程时也有自己的调用栈，当 gen 协程通过 yield 把控制权交给父协程时，V8 是如何切换到父协程的调用栈？当父协程通过 gen.next 恢复 gen 协程时，又是如何切换 gen 协程的调用栈？</p>\n<p>要搞清楚上面的问题，你需要关注以下两点内容。</p>\n<p>第一点：gen 协程和父协程是在主线程上交互执行的，并不是并发执行的，它们之前的切换是通过 yield 和 gen.next 来配合完成的。</p>\n<p>第二点：当在 gen 协程中调用了 yield 方法时，JavaScript 引擎会保存 gen 协程当前的调用栈信息，并恢复父协程的调用栈信息。同样，当在父协程中执行 gen.next 时，JavaScript 引擎会保存父协程的调用栈信息，并恢复 gen 协程的调用栈信息。</p>\n<p>为了直观理解父协程和 gen 协程是如何切换调用栈的，你可以参考下图</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-07-09-33-58-971ddbb92ba939af1476f008fd2421e0-ea453.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 88.32335329341318%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAIAAADUsmlHAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACbElEQVQ4y6VTW2sTQRTOv/AHSIv4YqE1oD6oD76If8CCQh+KiReqtKCiDyYq1TZpQCI21ggiFFqkVqitCFIopU0rFHpP1Nzaprltdje7O7M7OzM7zm6qraWaBw+HgTmH75xvzvnGxf7DXHsvlmVhE1HG0PoYmArCmTCMRagu13J1wBDCTCoJCGPjXhw8RMINJHKMyRkHTA8AW47VLqIoplIpwzDeRvo6rly+3eG93+kVittOY3pwZ2oxk1jcDUy588jMcmZoMv5u6tvodELRdB7iWZ7hJyIWoTvNXOVyWZUFp7bJCGREp6ZGMfpdHiOdBxkGzML7OxtQm1hT+mPg9bwandcG5sDwCqlqBiUUE8oIXsnp/bNqdE6JfgVvFowXs9p0GtX42rQffAGN3Wl3KNMSTDUF0udeiVmRD40R55mDC2qDb/14INkS2nSHsof9cf+nspO1bPC9sUKjf83dm3AHfjT1JM+/3BK0XfDoknL0afZkON/8ZO3Es40j3elHn4Vd8OCS2T5cuvlB6HhfvjZS9k3qCsT2cuwtkNiGefUj7hwHN0aKXRPQM2YOLeMd2pIkyWJl3ySAjnSTD9+CiCDT/KvCqtUqh9ujoXYryymJKmkjv2oU4np+FUGFOCRttxj3X5v6U2FcHoqiIgMKI9c3w2dyAxdyz0/j/GIdhdVExlkkvicpqPT1PG713PF0PbzU1p5PLtkvpPRf2uZ4WZa2tgtYKdz19Ta3+k+19Zy9eCubWKwP3vu7uMi3i0K+JBaKJf7PasH6YIyxoqqqoiAd6FA1dChKkqZp9f9zjR4fm2YbsB3YhhA6EPwTvWbTJh66KZgAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 07 09 33 58"\n        title=""\n        src="/static/2021-07-07-09-33-58-971ddbb92ba939af1476f008fd2421e0-fee1c.png"\n        srcset="/static/2021-07-07-09-33-58-971ddbb92ba939af1476f008fd2421e0-a67b7.png 200w,\n/static/2021-07-07-09-33-58-971ddbb92ba939af1476f008fd2421e0-0b187.png 400w,\n/static/2021-07-07-09-33-58-971ddbb92ba939af1476f008fd2421e0-fee1c.png 800w,\n/static/2021-07-07-09-33-58-971ddbb92ba939af1476f008fd2421e0-b1a91.png 1200w,\n/static/2021-07-07-09-33-58-971ddbb92ba939af1476f008fd2421e0-ea453.png 1336w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>到这里相信你已经弄清楚了协程是怎么工作的，其实在 JavaScript 中，生成器就是协程的一种实现方式，这样相信你也就理解什么是生成器了。那么接下来，我们使用生成器和 Promise 来改造开头的那段 Promise 代码。改造后的代码如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="5258009553325338000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`//foo 函数\nfunction* foo() {\n  let response1 = yield fetch(\'https://www.geekbang.org\');\n  console.log(\'response1\');\n  console.log(response1);\n  let response2 = yield fetch(\'https://www.geekbang.org/test\');\n  console.log(\'response2\');\n  console.log(response2);\n}\n\n// 执行 foo 函数的代码\nlet gen = foo();\nfunction getGenPromise(gen) {\n  return gen.next().value;\n}\ngetGenPromise(gen)\n  .then((response) => {\n    console.log(\'response1\');\n    console.log(response);\n    return getGenPromise(gen);\n  })\n  .then((response) => {\n    console.log(\'response2\');\n    console.log(response);\n  });`, `5258009553325338000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                data-tooltip="复制"\n              >\n                <svg class="gatsby-code-button-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M16 1H2v16h2V3h12V1zm-1 4l6 6v12H6V5h9zm-1 7h5.5L14 6.5V12z"/></svg>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">//foo 函数</span>\n<span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">let</span> response1 <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">\'https://www.geekbang.org\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'response1\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>response1<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">let</span> response2 <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">\'https://www.geekbang.org/test\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'response2\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>response2<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// 执行 foo 函数的代码</span>\n<span class="token keyword">let</span> gen <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">function</span> <span class="token function">getGenPromise</span><span class="token punctuation">(</span><span class="token parameter">gen</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> gen<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token function">getGenPromise</span><span class="token punctuation">(</span>gen<span class="token punctuation">)</span>\n  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">response</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'response1\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">return</span> <span class="token function">getGenPromise</span><span class="token punctuation">(</span>gen<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span>\n  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">response</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'response2\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>从图中可以看到，foo 函数是一个生成器函数，在 foo 函数里面实现了用同步代码形式来实现异步操作；但是在 foo 函数外部，我们还需要写一段执行 foo 函数的代码，如上述代码的后半部分所示，那下面我们就来分析下这段代码是如何工作的。</p>\n<ul>\n<li>首先执行的是 let gen = foo()，创建了 gen 协程。</li>\n<li>然后在父协程中通过执行 gen.next 把主线程的控制权交给 gen 协程。</li>\n<li>gen 协程获取到主线程的控制权后，就调用 fetch 函数创建了一个 Promise 对象 response1，然后通过 yield 暂停 gen 协程的执行，并将 response1 返回给父协程。</li>\n<li>父协程恢复执行后，调用 response1.then 方法等待请求结果。</li>\n<li>等通过 fetch 发起的请求完成之后，会调用 then 中的回调函数，then 中的回调函数拿到结果之后，通过调用 gen.next 放弃主线程的控制权，将控制权交 gen 协程继续执行下个请求。</li>\n</ul>\n<p>以上就是协程和 Promise 相互配合执行的一个大致流程。不过通常，我们把执行生成器的代码封装成一个函数，并把这个执行生成器代码的函数称为执行器（可参考著名的 co 框架），如下面这种方式：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="19234612030127374000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function* foo() {\n  let response1 = yield fetch(\'https://www.geekbang.org\');\n  console.log(\'response1\');\n  console.log(response1);\n  let response2 = yield fetch(\'https://www.geekbang.org/test\');\n  console.log(\'response2\');\n  console.log(response2);\n}\nco(foo());`, `19234612030127374000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                data-tooltip="复制"\n              >\n                <svg class="gatsby-code-button-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M16 1H2v16h2V3h12V1zm-1 4l6 6v12H6V5h9zm-1 7h5.5L14 6.5V12z"/></svg>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">let</span> response1 <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">\'https://www.geekbang.org\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'response1\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>response1<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">let</span> response2 <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">\'https://www.geekbang.org/test\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'response2\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>response2<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token function">co</span><span class="token punctuation">(</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>通过使用生成器配合执行器，就能实现使用同步的方式写出异步代码了，这样也大大加强了代码的可读性。</p>\n<h2 id="asyncawait"><a href="#asyncawait" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>async/await</h2>\n<p>虽然生成器已经能很好地满足我们的需求了，但是程序员的追求是无止境的，这不又在 ES7 中引入了 async/await，这种方式能够彻底告别执行器和生成器，实现更加直观简洁的代码。其实 async/await 技术背后的秘密就是 Promise 和生成器应用，往底层说就是微任务和协程应用。要搞清楚 async 和 await 的工作原理，我们就得对 async 和 await 分开分析。</p>\n<h3 id="async"><a href="#async" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>async</h3>\n<p>我们先来看看 async 到底是什么？根据 MDN 定义，async 是一个通过异步执行并隐式返回 Promise 作为结果的函数。</p>\n<p>对 async 函数的理解，这里需要重点关注两个词：异步执行和隐式返回 Promise。</p>\n<p>关于异步执行的原因，我们一会儿再分析。这里我们先来看看是如何隐式返回 Promise 的，你可以参考下面的代码：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="86395880845344670000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`async function foo() {\n  return 2;\n}\n\nconsole.log(foo()); // Promise {<resolved>: 2}`, `86395880845344670000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                data-tooltip="复制"\n              >\n                <svg class="gatsby-code-button-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M16 1H2v16h2V3h12V1zm-1 4l6 6v12H6V5h9zm-1 7h5.5L14 6.5V12z"/></svg>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token number">2</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Promise {&lt;resolved>: 2}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>执行这段代码，我们可以看到调用 async 声明的 foo 函数返回了一个 Promise 对象，状态是 resolved，返回结果如下所示：</p>\n<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">Promise {&lt;resolved&gt;: 2}</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<h3 id="await"><a href="#await" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>await</h3>\n<p>我们知道了 async 函数返回的是一个 Promise 对象，那下面我们再结合文中这段代码来看看 await 到底是什么。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="23704438849772868000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`async function foo() {\n  console.log(1);\n  let a = await 100;\n  console.log(a);\n  console.log(2);\n}\nconsole.log(0);\nfoo();\nconsole.log(3);`, `23704438849772868000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                data-tooltip="复制"\n              >\n                <svg class="gatsby-code-button-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M16 1H2v16h2V3h12V1zm-1 4l6 6v12H6V5h9zm-1 7h5.5L14 6.5V12z"/></svg>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token number">100</span><span class="token punctuation">;</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>观察上面这段代码，你能判断出打印出来的内容是什么吗？这得先来分析 async 结合 await 到底会发生什么。在详细介绍之前，我们先站在协程的视角来看看这段代码的整体执行流程图：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-07-09-37-14-71c0b4b2a21afa0107815d2005fccec4-a368f.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 56.89149560117303%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABhklEQVQoz42SSUvDQBTH+w31Lorgh/As3rx60VtPIgpuB0HxIHhwt+0kTVpBROwiaZI22+zzxpdaFaWCj19m/zPv/yYVOyXgL4SybIwy5bmK/UfAuDVgV8/V0r5Y3OObd+pbDIB7UHY4ljnQCFgMfILhseWxpMPlkwKVc7ti4/ZTLKQEUCxPBOc41WlHBUQNPPbm0p7D+3XWq5mAyM5D/OoImjJtpS6vqWAjGCVdfuTklAlcUmmXB66N/NYjWTm8Xzu+vyK19dMHHOxc3Gkaf1mpjDO1Z09m29UWyjpA3lehZ5N2vd2cqTbmt8hJzVvYIrNVsnzQUCz5FuOXZZnWpQdKGWWchs95t057ZPBKrpvOrUt6L+5N07l0nYZPslEwSjJWFBOxMRoAsJgc3UvJhx0Us7cm2sbkbeBC5NmRb4eIJ4thwbgUYvpTyaSfdupZt5FjtQJfRS0VtlTULgl9EOmPtH+HEVazCYaXgABFJxj9dXD6T8K5SLMcQXthFAfBAD4K+zPeAbGralM4bwnIAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 07 09 37 14"\n        title=""\n        src="/static/2021-07-07-09-37-14-71c0b4b2a21afa0107815d2005fccec4-fee1c.png"\n        srcset="/static/2021-07-07-09-37-14-71c0b4b2a21afa0107815d2005fccec4-a67b7.png 200w,\n/static/2021-07-07-09-37-14-71c0b4b2a21afa0107815d2005fccec4-0b187.png 400w,\n/static/2021-07-07-09-37-14-71c0b4b2a21afa0107815d2005fccec4-fee1c.png 800w,\n/static/2021-07-07-09-37-14-71c0b4b2a21afa0107815d2005fccec4-b1a91.png 1200w,\n/static/2021-07-07-09-37-14-71c0b4b2a21afa0107815d2005fccec4-a368f.png 1364w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>结合上图，我们来一起分析下 async/await 的执行流程。</p>\n<p>首先，执行 console.log(0)这个语句，打印出来 0。</p>\n<p>紧接着就是执行 foo 函数，由于 foo 函数是被 async 标记过的，所以当进入该函数的时候，JavaScript 引擎会保存当前的调用栈等信息，然后执行 foo 函数中的 console.log(1)语句，并打印出 1。</p>\n<p>接下来就执行到 foo 函数中的 await 100 这个语句了，这里是我们分析的重点，因为在执行 await 100 这个语句时，JavaScript 引擎在背后为我们默默做了太多的事情，那么下面我们就把这个语句拆开，来看看 JavaScript 到底都做了哪些事情。</p>\n<p>当执行到 await 100 时，会默认创建一个 Promise 对象，代码如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="16544445977221600000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`let promise_ = new Promise((resolve,reject){\n  resolve(100)\n})`, `16544445977221600000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                data-tooltip="复制"\n              >\n                <svg class="gatsby-code-button-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M16 1H2v16h2V3h12V1zm-1 4l6 6v12H6V5h9zm-1 7h5.5L14 6.5V12z"/></svg>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">let</span> promise_ <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span>reject<span class="token punctuation">)</span><span class="token punctuation">{</span>\n  <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span></span></pre></div>\n<p>在这个 promise_ 对象创建的过程中，我们可以看到在 executor 函数中调用了 resolve 函数，JavaScript 引擎会将该任务提交给微任务队列（上一篇文章中我们讲解过）。</p>\n<p>然后 JavaScript 引擎会暂停当前协程的执行，将主线程的控制权转交给父协程执行，同时会将 promise_ 对象返回给父协程。</p>\n<p>主线程的控制权已经交给父协程了，这时候父协程要做的一件事是调用 promise_.then 来监控 promise 状态的改变。</p>\n<p>接下来继续执行父协程的流程，这里我们执行 console.log(3)，并打印出来 3。随后父协程将执行结束，在结束之前，会进入微任务的检查点，然后执行微任务队列，微任务队列中有 resolve(100)的任务等待执行，执行到这里的时候，会触发 promise_.then 中的回调函数，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="70085011763158440000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`promise_.then((value) => {\n  // 回调函数被激活后\n  // 将主线程控制权交给 foo 协程，并将 value 值传给协程\n});`, `70085011763158440000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                data-tooltip="复制"\n              >\n                <svg class="gatsby-code-button-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M16 1H2v16h2V3h12V1zm-1 4l6 6v12H6V5h9zm-1 7h5.5L14 6.5V12z"/></svg>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js">promise_<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  <span class="token comment">// 回调函数被激活后</span>\n  <span class="token comment">// 将主线程控制权交给 foo 协程，并将 value 值传给协程</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>该回调函数被激活以后，会将主线程的控制权交给 foo 函数的协程，并同时将 value 值传给该协程。</p>\n<p>foo 协程激活之后，会把刚才的 value 值赋给了变量 a，然后 foo 协程继续执行后续语句，执行完成之后，将控制权归还给父协程。</p>\n<p>以上就是 await/async 的执行流程。正是因为 async 和 await 在背后为我们做了大量的工作，所以我们才能用同步的方式写出异步代码来</p>\n<h2 id="总结-5"><a href="#%E6%80%BB%E7%BB%93-5" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总结</h2>\n<ul>\n<li>Promise 的编程模型依然充斥着大量的 then 方法，虽然解决了回调地狱的问题，但是在语义方面依然存在缺陷，代码中充斥着大量的 then 函数，这就是 async/await 出现的原因。</li>\n<li>使用 async/await 可以实现用同步代码的风格来编写异步代码，这是因为 async/await 的基础技术使用了生成器和 Promise，生成器是协程的实现，利用生成器能实现生成器函数的暂停和恢复。</li>\n<li>另外，V8 引擎还为 async/await 做了大量的语法层面包装，所以了解隐藏在背后的代码有助于加深你对 async/await 的理解。</li>\n<li>async/await 无疑是异步编程领域非常大的一个革新，也是未来的一个主流的编程风格。其实，除了 JavaScript，Python、Dart、C# 等语言也都引入了 async/await，使用它不仅能让代码更加整洁美观，而且还能确保该函数始终都能返回 Promise</li>\n</ul>',
id:"/github/workspace/blog/浏览器工作原理与实践——页面循环系统/index.md absPath of file >>> MarkdownRemark",timeToRead:32,frontmatter:{date:"2021-07-05 15:32:26",path:"/browser-working-principle-cycle-system/",tags:"前端, 浏览器, 高级前端",title:"浏览器工作原理与实践——页面循环系统",draft:null}},{excerpt:"栈空间和堆空间：数据是如何存储的 对于前端开发者来说，JavaScript 的内存机制是一个不被经常提及的概念，因此很容易被忽视。特别是一些非计算机专业的同学，对内存机制可能没有非常清晰的认识，甚至有些同学根本就不知道 JavaScript 的内存机制是什么。 但是如果你想成为行业专家，并打造高性能前端应用，那么你就必须要搞清楚 JavaScript 的内存机制了。 其实，要搞清楚 JavaScript 的内存机制并不是一件很困难的事，在接下来的三篇文章（数据在内存中的存放、JavaScript…",html:'<h1 id="栈空间和堆空间：数据是如何存储的"><a href="#%E6%A0%88%E7%A9%BA%E9%97%B4%E5%92%8C%E5%A0%86%E7%A9%BA%E9%97%B4%EF%BC%9A%E6%95%B0%E6%8D%AE%E6%98%AF%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E7%9A%84" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>栈空间和堆空间：数据是如何存储的</h1>\n<p>对于前端开发者来说，JavaScript 的内存机制是一个不被经常提及的概念，因此很容易被忽视。特别是一些非计算机专业的同学，对内存机制可能没有非常清晰的认识，甚至有些同学根本就不知道 JavaScript 的内存机制是什么。</p>\n<p>但是如果你想成为行业专家，并打造高性能前端应用，那么你就必须要搞清楚 JavaScript 的内存机制了。</p>\n<p>其实，要搞清楚 JavaScript 的内存机制并不是一件很困难的事，在接下来的三篇文章（数据在内存中的存放、JavaScript 处理垃圾回收以及 V8 执行代码）中，我们将通过内存机制的介绍，循序渐进带你走进 JavaScript 内存的世界。</p>\n<p>今天我们讲述第一部分的内容——JavaScript 中的数据是如何存储在内存中的。虽然 JavaScript 并不需要直接去管理内存，但是在实际项目中为了能避开一些不必要的坑，你还是需要了解数据在内存中的存储方式的</p>\n<h2 id="让人疑惑的代码"><a href="#%E8%AE%A9%E4%BA%BA%E7%96%91%E6%83%91%E7%9A%84%E4%BB%A3%E7%A0%81" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>让人疑惑的代码</h2>\n<p>首先，我们先看下面这两段代码：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="61778144769029590000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function foo() {\n  var a = 1;\n  var b = a;\n  a = 2;\n  console.log(a);\n  console.log(b);\n}\nfoo();`, `61778144769029590000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                data-tooltip="复制"\n              >\n                <svg class="gatsby-code-button-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M16 1H2v16h2V3h12V1zm-1 4l6 6v12H6V5h9zm-1 7h5.5L14 6.5V12z"/></svg>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>\n  <span class="token keyword">var</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span>\n  a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="50055130001120030000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function foo() {\n  var a = { name: \'极客时间\' };\n  var b = a;\n  a.name = \'极客邦\';\n  console.log(a);\n  console.log(b);\n}\nfoo();`, `50055130001120030000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                data-tooltip="复制"\n              >\n                <svg class="gatsby-code-button-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M16 1H2v16h2V3h12V1zm-1 4l6 6v12H6V5h9zm-1 7h5.5L14 6.5V12z"/></svg>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">\'极客时间\'</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>\n  <span class="token keyword">var</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span>\n  a<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">\'极客邦\'</span><span class="token punctuation">;</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>若执行上述这两段代码，你知道它们输出的结果是什么吗？下面我们就来一个一个分析下。</p>\n<p>执行第一段代码，打印出来 a 的值是 2，b 的值是 1，这没什么难以理解的。</p>\n<p>接着，再执行第二段代码，你会发现，仅仅改变了 a 中 name 的属性值，但是最终 a 和 b 打印出来的值都是 <code class="language-text">{name: &quot;极客邦&quot;}</code>。这就和我们预期的不一致了，因为我们想改变的仅仅是 a 的内容，但 b 的内容也同时被改变了。</p>\n<p>要彻底弄清楚这个问题，我们就得先从“JavaScript 是什么类型的语言”讲起。</p>\n<h2 id="javascript-是什么类型的语言"><a href="#javascript-%E6%98%AF%E4%BB%80%E4%B9%88%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%AF%AD%E8%A8%80" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>JavaScript 是什么类型的语言</h2>\n<p>每种编程语言都具有内建的数据类型，但它们的数据类型常有不同之处，使用方式也很不一样，比如 C 语言在定义变量之前，就需要确定变量的类型，你可以看下面这段 C 代码：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="90491556440622610000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`int main()\n{\n   int a = 1;\n   char* b = &quot;极客时间&quot;;\n   bool c = true;\n   return 0;\n}`, `90491556440622610000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                data-tooltip="复制"\n              >\n                <svg class="gatsby-code-button-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M16 1H2v16h2V3h12V1zm-1 4l6 6v12H6V5h9zm-1 7h5.5L14 6.5V12z"/></svg>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="cpp"><pre style="counter-reset: linenumber NaN" class="language-cpp line-numbers"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n<span class="token punctuation">{</span>\n   <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>\n   <span class="token keyword">char</span><span class="token operator">*</span> b <span class="token operator">=</span> <span class="token string">"极客时间"</span><span class="token punctuation">;</span>\n   <span class="token keyword">bool</span> c <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n   <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>上述代码声明变量的特点是：在声明变量之前需要先定义变量类型，我们把这种在使用之前就需要确认其变量数据类型的称为静态语言。</p>\n<p>相反地，我们把在运行过程中需要检查数据类型的语言称为动态语言。比如我们所讲的 JavaScript 就是动态语言，因为在声明变量之前并不需要确认其数据类型。</p>\n<p>虽然 C 语言是静态，但是在 C 语言中，我们可以把其他类型数据赋予给一个声明好的变量，如：</p>\n<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">c = a</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>前面代码中，我们把 int 型的变量 a 赋值给了 bool 型的变量 c，这段代码也是可以编译执行的，因为在赋值过程中，C 编译器会把 int 型的变量悄悄转换为 bool 型的变量，我们通常把这种偷偷转换的操作称为隐式类型转换。而支持隐式类型转换的语言称为弱类型语言，不支持隐式类型转换的语言称为强类型语言。在这点上，C 和 JavaScript 都是弱类型语言。</p>\n<p>对于各种语言的类型，你可以参考下图</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-05-11-32-53-de9b1a6002d33cb8f31dff4fcf8163e4-74b93.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 85.39493293591654%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAIAAABSJhvpAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABf0lEQVQ4y5WTS04DMQyGewrWXITTIHEHlpyBK8CiIMGCRTccABZIILVIICRoKaWddh6ZPCaZ2A6ZTIXa0imtpZGi2J9/2/G0XLMhOYuOmgNaa29rIJI4YAC4I1ybBkoLcs3am2ADTpQb/MswBfMHAEiSWGjLDbIspeDaVhkRkzhmyuSGJOdEm5WDXwr+ORgopeo7UVJS9ex8FWmarIG9kxn0s8mNyzUyVWpLyjoFbiyoz6qzL14aLMCP0MmSpCWmMcDkMo0GiBnndb5ikclyyvXbcDLi+M4oK8DnVSGjh7Wt+KyGVyrJWWpL48vx+rwq24EpqKHp1u9KhJFW+fJeZ3h+OG4ffd+3BdWb5lRR+CmubNGSMgLMklTH/ejhKro7m/W7eTmPFEIswn+fqgoq2Cx/7oinC9u9lORiha55xRbgUHOZfLye7PeO90anB7mUkZqz/y5J6M8I3r3JHq/ly22sYMgRaPcfwyuFZcV6itvChOA//2DRNBpPJlLKJvgH2GDiSc51JmIAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 05 11 32 53"\n        title=""\n        src="/static/2021-07-05-11-32-53-de9b1a6002d33cb8f31dff4fcf8163e4-fee1c.png"\n        srcset="/static/2021-07-05-11-32-53-de9b1a6002d33cb8f31dff4fcf8163e4-a67b7.png 200w,\n/static/2021-07-05-11-32-53-de9b1a6002d33cb8f31dff4fcf8163e4-0b187.png 400w,\n/static/2021-07-05-11-32-53-de9b1a6002d33cb8f31dff4fcf8163e4-fee1c.png 800w,\n/static/2021-07-05-11-32-53-de9b1a6002d33cb8f31dff4fcf8163e4-b1a91.png 1200w,\n/static/2021-07-05-11-32-53-de9b1a6002d33cb8f31dff4fcf8163e4-74b93.png 1342w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<h2 id="javascript-的数据类型"><a href="#javascript-%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>JavaScript 的数据类型</h2>\n<p>现在我们知道了，JavaScript 是一种弱类型的、动态的语言。那这些特点意味着什么呢？</p>\n<ul>\n<li>弱类型，意味着你不需要告诉 JavaScript 引擎这个或那个变量是什么数据类型，JavaScript 引擎在运行代码的时候自己会计算出来。</li>\n<li>动态，意味着你可以使用同一个变量保存不同类型的数据</li>\n</ul>\n<p>那么接下来，我们再来看看 JavaScript 的数据类型，你可以看下面这段代码：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="78045402332303650000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`var bar;\nbar = 12;\nbar = \'极客时间\';\nbar = true;\nbar = null;\nbar = { name: \'极客时间\' };`, `78045402332303650000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                data-tooltip="复制"\n              >\n                <svg class="gatsby-code-button-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M16 1H2v16h2V3h12V1zm-1 4l6 6v12H6V5h9zm-1 7h5.5L14 6.5V12z"/></svg>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">var</span> bar<span class="token punctuation">;</span>\nbar <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">;</span>\nbar <span class="token operator">=</span> <span class="token string">\'极客时间\'</span><span class="token punctuation">;</span>\nbar <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\nbar <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\nbar <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">\'极客时间\'</span> <span class="token punctuation">}</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>从上述代码中你可以看出，我们声明了一个 bar 变量，然后可以使用各种类型的数据值赋予给该变量。</p>\n<p>在 JavaScript 中，如果你想要查看一个变量到底是什么类型，可以使用“typeof”运算符。具体使用方式如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="95953326919426820000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`var bar;\nconsole.log(typeof bar); // undefined\nbar = 12;\nconsole.log(typeof bar); // number\nbar = \'极客时间\';\nconsole.log(typeof bar); // string\nbar = true;\nconsole.log(typeof bar); // boolean\nbar = null;\nconsole.log(typeof bar); // object\nbar = { name: \'极客时间\' };\nconsole.log(typeof bar); // object`, `95953326919426820000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                data-tooltip="复制"\n              >\n                <svg class="gatsby-code-button-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M16 1H2v16h2V3h12V1zm-1 4l6 6v12H6V5h9zm-1 7h5.5L14 6.5V12z"/></svg>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">var</span> bar<span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> bar<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined</span>\nbar <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> bar<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// number</span>\nbar <span class="token operator">=</span> <span class="token string">\'极客时间\'</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> bar<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// string</span>\nbar <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> bar<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// boolean</span>\nbar <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> bar<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// object</span>\nbar <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">\'极客时间\'</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> bar<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// object</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>执行这段代码，你可以看到打印出来了不同的数据类型，有 undefined、number、boolean、object 等。那么接下来我们就来谈谈 JavaScript 到底有多少种数据类型。</p>\n<p>其实 JavaScript 中的数据类型一种有 8 种，它们分别是：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-05-11-34-28-f4de02d367abf9d7ef48b6f92606322c-ed3f4.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 55.74534161490683%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAB3UlEQVQoz0VRy24TQRD0VyMhwBEinDggEEJc4DMQ2FKSgyPFShQT2/uY9a5n57lPj3fdg2NfbHrWUZBKre7SVFd3T8/e/tiOPrWDMxi8toihi/D71Qn2+jNcvIdfL58ZfAY/X8D1l+Px2DPj783o4/ryfDV4sx6emUHfDPtw9e4EO/4Kow9w+faZgatzuOhvxt+cmCsuMmbAyFLLQqlS121t9xb21u4Atg08brC0e+hiR+5gs90cDyimnuZeqUku/HRxr9KZKeIqi06oi3jlSvKfyRemXDQ1d86FTthyuippmUUi9UQ6l8zTMtQi0CJ0kCFbznjqcYpxjkkmQ2i0E0tOOtbz52NvejOdjIh/S+OHYD5OogmjM1QqHkjuc+r6LuM/SXSfq+RJXGYLaCS+QLdMEadZznIdCeY5cWdY6KgqknWdFhofi93f6nA49DIV10VSZnEcTdAQY7KYEP+O0TlORJMHEtzhUNgokwQHRv26po2RzllworhnqtTZSsz9Ko/RFss6j3FnJHNFcGxMuhnFZs1bo7qvYoHAC1cUr4UTYm9cjKezNJliI3RGvusbtoY9grattK14OpjgsRSkKlIlcMkw14lghC49ztDNJYwGq4o3RmE8oS6ZWTnnf5oeOk1ATy/iAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 05 11 34 28"\n        title=""\n        src="/static/2021-07-05-11-34-28-f4de02d367abf9d7ef48b6f92606322c-fee1c.png"\n        srcset="/static/2021-07-05-11-34-28-f4de02d367abf9d7ef48b6f92606322c-a67b7.png 200w,\n/static/2021-07-05-11-34-28-f4de02d367abf9d7ef48b6f92606322c-0b187.png 400w,\n/static/2021-07-05-11-34-28-f4de02d367abf9d7ef48b6f92606322c-fee1c.png 800w,\n/static/2021-07-05-11-34-28-f4de02d367abf9d7ef48b6f92606322c-b1a91.png 1200w,\n/static/2021-07-05-11-34-28-f4de02d367abf9d7ef48b6f92606322c-ed3f4.png 1288w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>了解这些类型之后，还有三点需要你注意一下。</p>\n<p>第一点，使用 typeof 检测 Null 类型时，返回的是 Object。这是当初 JavaScript 语言的一个 Bug，一直保留至今，之所以一直没修改过来，主要是为了兼容老的代码。</p>\n<p>第二点，Object 类型比较特殊，它是由上述 7 种类型组成的一个包含了 key-value 对的数据类型。如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="40101479847135680000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`let myObj = {\n  name: \'极客时间\',\n  update: function() {....}\n}`, `40101479847135680000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                data-tooltip="复制"\n              >\n                <svg class="gatsby-code-button-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M16 1H2v16h2V3h12V1zm-1 4l6 6v12H6V5h9zm-1 7h5.5L14 6.5V12z"/></svg>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">let</span> myObj <span class="token operator">=</span> <span class="token punctuation">{</span>\n  name<span class="token punctuation">:</span> <span class="token string">\'极客时间\'</span><span class="token punctuation">,</span>\n  <span class="token function-variable function">update</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">.</span><span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>从中你可以看出来，Object 是由 key-value 组成的，其中的 vaule 可以是任何类型，包括函数，这也就意味着你可以通过 Object 来存储函数，Object 中的函数又称为方法，比如上述代码中的 update 方法。</p>\n<p>第三点，我们把前面的 7 种数据类型称为原始类型，把最后一个对象类型称为引用类型，之所以把它们区分为两种不同的类型，是因为它们在内存中存放的位置不一样。到底怎么个不一样法呢？接下来，我们就来讲解一下 JavaScript 的原始类型和引用类型到底是怎么储存的。</p>\n<h2 id="内存空间"><a href="#%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>内存空间</h2>\n<p>要理解 JavaScript 在运行过程中数据是如何存储的，你就得先搞清楚其存储空间的种类。下面是我画的 JavaScript 的内存模型，你可以参考下：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-05-11-35-12-736885d7c0436c33374eb14a3c7c9f69-4c847.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 618px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 200.32362459546925%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAoCAIAAABxU02MAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACJUlEQVRIx+2STU8TURSG7x9yU4EiJmL4EGpFEsHowgUxLnShRlZ2aAvtFIoffBja0slQqEiNSctURQJJQWKMJq7cGP+BO5k75047xp3nTtF0ZkDI1SXJk5Nz33nfnHtuhvz8oglDjCcnhCGQPeVGaYNsGyineaPYTV3kusNJYN7vINNi0wyZJl7TTZD28WbeFp1mV7gV1HaW6+A8DbI8EqiWb7JcJ8t1saVebjg47K8Wh6rrw2ZpyHr3uLYZMguDVmUUcp3WhmRtyaCebZzvuTaitsNCh7ncZ65cwoXNwgAugpU96+dvgfdvCLc68dsLN0PKZ6R8XEmf5BV7fvQ3msme1U1Lw8s1Kg4bYYtdwhBjOiwMoXLETSJKE5F9dA+ETkTcyBKNh+h4mPfJKG8SyIjXSeh4xIE8AqmpavG5MTPJFrNmIW88ktmSAplZ/OQyO8MTURqXQJmzdiqgphC2vGDMJGtvXpp5VcfroOHA8N5wiSZHbcbogxgPYJ0c8zoJyNI+xO9DPPQbCWL20WMj3+ZmhSED5e/CkJ5VKgw5v6oLcxz+j+GeEgebwNHDvXYmUNIHX+lX1igqQY2Lh4SD9rTrG0b2c214B+5uQ/g9u7pGEx/Ne2+hu8gNf5uME66tG7EP7FYFbmwad7bh8mv68JN5ewvOHRqu53EI1oua3l/mC3cXd4+6M254QeND/rxT/Xj8h/17uE/ThSFnXuwKQ1a+/hDmF2gO/Y3zkq/GAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 05 11 35 12"\n        title=""\n        src="/static/2021-07-05-11-35-12-736885d7c0436c33374eb14a3c7c9f69-4c847.png"\n        srcset="/static/2021-07-05-11-35-12-736885d7c0436c33374eb14a3c7c9f69-9882a.png 200w,\n/static/2021-07-05-11-35-12-736885d7c0436c33374eb14a3c7c9f69-ecdcc.png 400w,\n/static/2021-07-05-11-35-12-736885d7c0436c33374eb14a3c7c9f69-4c847.png 618w"\n        sizes="(max-width: 618px) 100vw, 618px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从图中可以看出， 在 JavaScript 的执行过程中， 主要有三种类型内存空间，分别是代码空间、栈空间和堆空间。</p>\n<p>其中的代码空间主要是存储可执行代码的，这个我们后面再做介绍，今天主要来说说栈空间和堆空间。</p>\n<h2 id="栈空间和堆空间"><a href="#%E6%A0%88%E7%A9%BA%E9%97%B4%E5%92%8C%E5%A0%86%E7%A9%BA%E9%97%B4" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>栈空间和堆空间</h2>\n<p>这里的栈空间就是我们之前反复提及的调用栈，是用来存储执行上下文的。为了搞清楚栈空间是如何存储数据的，我们还是先看下面这段代码：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="5953676983421441000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function foo() {\n  var a = \'极客时间\';\n  var b = a;\n  var c = { name: \'极客时间\' };\n  var d = c;\n}\nfoo();`, `5953676983421441000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                data-tooltip="复制"\n              >\n                <svg class="gatsby-code-button-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M16 1H2v16h2V3h12V1zm-1 4l6 6v12H6V5h9zm-1 7h5.5L14 6.5V12z"/></svg>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token string">\'极客时间\'</span><span class="token punctuation">;</span>\n  <span class="token keyword">var</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span>\n  <span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">\'极客时间\'</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>\n  <span class="token keyword">var</span> d <span class="token operator">=</span> c<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>前面文章我们已经讲解过了，当执行一段代码时，需要先编译，并创建执行上下文，然后再按照顺序执行代码。那么下面我们来看看，当执行到第 3 行代码时，其调用栈的状态，你可以参考下面这张调用栈状态图：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-05-13-36-42-768172f068757544caf5d7cdc266d812-b1a91.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 84.83333333333333%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAIAAABSJhvpAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACr0lEQVQ4y3WTW08TURDH+RDGd76CoA2Y+EVMjN/ERCJECliIDwoSHtpK0RcIGB6kINcWuYQWkLLbG91Lt3vfs/funnM8LVVbgpPJyZyz88vM/jPTh3sNQhgEYRCGrfP/AUKIJPd1k81mU9c05NnQs6BrQc9GvgOJt4LOI/Ks0LV0XSd8Dxz4nqAYm1Vnq2ITTxeN7wVpg1LTtJ6mtXTZSlfsjbKVZR3DAKTHvt6mm+esHklIkYQcScpPFrjB2eLAbGlwrjrwqTqcEJ+l1Edx9eU3xQRGB0Zta8Fh84pT32Wkz5dm/BzMHUkzu8z8qRq/sBLnYCqjvNpgP+zdjG5xim6iv3CnchhQjFjiOWzxvs5iVw5VxpdvoMFjDCiGOaAbGDvLeYFTAEZtmOgEAAghxDAs1OqFmqAqEl8XgiDwPKdcLlE05TvmRZndLcokf+WXxslGB2ZZNp/Pi5JE7gSmOZEErutBhIHt0BWmdMPbjltgxA58qbCy3oLJf5Oytm2TE8PguiYUmEbY9E03cJkT5UeMWhun1qLGzvTZ9pedskHg5Uv1X+UutcPrWr1YFzH0fYTDw/fm6IPqSH/ldb/39uHF/Iu9mkeyVq9UlsC4S210KxgrrZ/SZ3TliOaO9tcPlka2Fsc2F8d+fh1ZWY4v5eQCrydPxYYK7laGgV+TjIkDZXxfju5L0awxceJPttyLHvtTx04sI7/ZbiRzmgnuG5Ico0WSynBKG07pQwlx8CNF5uTxfDWywAwl5acpbSCpPV9VgGHchYlOFUGNHarTHVdiGanlWXk6q5CXmUN1MqMkchqZ7bsw2Rhg6Ngze93CvnUbIxdgF4QOME3z7lbdGlGOrFxAhoYIDlEAUTOEQTtA7a9/5vE+mPSjqirHcaQ3WZYFQSBxvV7ned73/e7M336AjgEMvgWjAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 05 13 36 42"\n        title=""\n        src="/static/2021-07-05-13-36-42-768172f068757544caf5d7cdc266d812-fee1c.png"\n        srcset="/static/2021-07-05-13-36-42-768172f068757544caf5d7cdc266d812-a67b7.png 200w,\n/static/2021-07-05-13-36-42-768172f068757544caf5d7cdc266d812-0b187.png 400w,\n/static/2021-07-05-13-36-42-768172f068757544caf5d7cdc266d812-fee1c.png 800w,\n/static/2021-07-05-13-36-42-768172f068757544caf5d7cdc266d812-b1a91.png 1200w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从图中可以看出来，当执行到第 3 行时，变量 a 和变量 b 的值都被保存在执行上下文中，而执行上下文又被压入到栈中，所以你也可以认为变量 a 和变量 b 的值都是存放在栈中的。</p>\n<p>接下来继续执行第 4 行代码，由于 JavaScript 引擎判断右边的值是一个引用类型，这时候处理的情况就不一样了，JavaScript 引擎并不是直接将该对象存放到变量环境中，而是将它分配到堆空间里面，分配后该对象会有一个在“堆”中的地址，然后再将该数据的地址写进 c 的变量值，最终分配好内存的示意图如下所示：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-05-13-36-59-da3fe5fbe645301d7ca272c4a9b64128-f0bde.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 56.77154582763338%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAB10lEQVQoz3WRz2vUQBTH93/x5J8gPQpeehIUvIiCRy8WFLx6Ubx4FxHcuqUt2GqR/hDRthd/dLut3U3bFFu3uj+SSTPJTJLJJjOZN04SSN2DXx7D8GY+3zfvTQ0AMpEqxYsQeUC+FyIFUKVAchBJvmY6UgVZma8pJTsD2jDYTNt/3bIbu+6cQettalo0xwoDtv6ENq6R+mTQuEpeXo536qWlhtVW110ynNUDZ6mNPh0H07v4xXf7yy9PH0mQeg03p7z5S+G3Z/HeTNR8nvS3Cxhy+HSIWOCrLGLoJBqa3eHQIrE58IvCeeVw56G3MZmEP/VzBcRC8urZ6qRnManE0XLv6cXe4wvG4qM+kQe/HZUwcYYkS4PmA+/jFYaaceRE5JQn9Bw+/GN3BsT8sdmcvrf96u7nD7Nf+4nOKD7KiC+TLGjd99YmIqcVUJvgLk+DCoYV07vxzrm9jG++x7dWgjtr9PpbZ/3Yr3qmW1N4dWJ01hKc8tgag/cHdL5DFvf9BQO/6eAFw5tr+0cWqabNvb3U3hAjLPhIcCazf3quPjP2kSpKlVilMiOEcF0sJVRIrbin9BgTLmgYpiLTe6nGpR1BgrbnvPIaq3x+E8B1XYSQV4hSqv6jv4osWckfUujXAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 05 13 36 59"\n        title=""\n        src="/static/2021-07-05-13-36-59-da3fe5fbe645301d7ca272c4a9b64128-fee1c.png"\n        srcset="/static/2021-07-05-13-36-59-da3fe5fbe645301d7ca272c4a9b64128-a67b7.png 200w,\n/static/2021-07-05-13-36-59-da3fe5fbe645301d7ca272c4a9b64128-0b187.png 400w,\n/static/2021-07-05-13-36-59-da3fe5fbe645301d7ca272c4a9b64128-fee1c.png 800w,\n/static/2021-07-05-13-36-59-da3fe5fbe645301d7ca272c4a9b64128-b1a91.png 1200w,\n/static/2021-07-05-13-36-59-da3fe5fbe645301d7ca272c4a9b64128-f0bde.png 1462w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从上图你可以清晰地观察到，对象类型是存放在堆空间的，在栈空间中只是保留了对象的引用地址，当 JavaScript 需要访问该数据的时候，是通过栈中的引用地址来访问的，相当于多了一道转手流程。</p>\n<p>好了，现在你应该知道了原始类型的数据值都是直接保存在“栈”中的，引用类型的值是存放在“堆”中的。不过你也许会好奇，为什么一定要分“堆”和“栈”两个存储空间呢？所有数据直接存放在“栈”中不就可以了吗？</p>\n<p>答案是不可以的。这是因为 JavaScript 引擎需要用栈来维护程序执行期间上下文的状态，如果栈空间大了话，所有的数据都存放在栈空间里面，那么会影响到上下文切换的效率，进而又影响到整个程序的执行效率。比如文中的 foo 函数执行结束了，JavaScript 引擎需要离开当前的执行上下文，只需要将指针下移到上个执行上下文的地址就可以了，foo 函数执行上下文栈区空间全部回收，具体过程你可以参考下图：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-05-13-37-18-08fb519b5e63747634c74613b337bd19-6b9f0.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 60.83086053412463%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABs0lEQVQoz6VSzW4TMRDOQ3HhEXgbJJ4FceAAZ1Cgl003ahSgIMgKRQ3bZFvRHBAUsl571hvba3u9/sFNhUihnPhkjzQafzPjmW8Q/gODfwWMMXmez+fzxWIRrZSSNs0sy6oKex+sdddk742JXqe1MqazVps+2vh0nKaj0Wg8HidJgjF2WqLLL70SwRmjpbNuEGm23HhcSSCmoYpgBcQ2FMry1esrTKfTyWRSA1lTe4LMEuxJZYtKOWsHsfDVCUFxBkfp1xfPIU3KgyE9P5NdB4QQSrlUwXYPjqq7T7/de1bdeXJ5//B7bHn35x1ZCsGKFV+dimLF8gX7EcOh73sDJGwb37LDM/rwA378ET/KICkgePd7YHEkojOUt1RIZR0Trd8lda3wnBvB+/NlP3ujs2OfvTWfC+v3pi3alm7ZlrdSdYwLGqvtyNfona/fHVcHwzodVS+HMHvvwk0yqjDUTbwIA9T1/uasc/X6ApZ5Xazg9BNZXzjvb+y5lbJEaLPZEADn3B+b18ZA0yBCMG1apW4RSdSG1nq/4X3EjL0x/lfe2xXGGEMIAUDUBuc8upTSv3v5CZczorFUmDZ+AAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 05 13 37 18"\n        title=""\n        src="/static/2021-07-05-13-37-18-08fb519b5e63747634c74613b337bd19-fee1c.png"\n        srcset="/static/2021-07-05-13-37-18-08fb519b5e63747634c74613b337bd19-a67b7.png 200w,\n/static/2021-07-05-13-37-18-08fb519b5e63747634c74613b337bd19-0b187.png 400w,\n/static/2021-07-05-13-37-18-08fb519b5e63747634c74613b337bd19-fee1c.png 800w,\n/static/2021-07-05-13-37-18-08fb519b5e63747634c74613b337bd19-b1a91.png 1200w,\n/static/2021-07-05-13-37-18-08fb519b5e63747634c74613b337bd19-6b9f0.png 1348w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>所以通常情况下，栈空间都不会设置太大，主要用来存放一些原始类型的小数据。而引用类型的数据占用的空间都比较大，所以这一类数据会被存放到堆中，堆空间很大，能存放很多大的数据，不过缺点是分配内存和回收内存都会占用一定的时间。</p>\n<p>解释了程序在执行过程中为什么需要堆和栈两种数据结构后，我们还是回到示例代码那里，看看它最后一步将变量 c 赋值给变量 d 是怎么执行的？</p>\n<p>在 JavaScript 中，赋值操作和其他语言有很大的不同，原始类型的赋值会完整复制变量值，而引用类型的赋值是复制引用地址。</p>\n<p>所以 <code class="language-text">d=c</code> 的操作就是把 c 的引用地址赋值给 d，你可以参考下图</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-05-13-37-35-27cda4d94677a23c74bbb5ba13eb9ec1-22802.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 59.25925925925925%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAB+klEQVQoz32Sz2sTQRzF+5/4H3gRxHoUpWervfagIoLgHyBeLBRBL15q6UE8CqI2mphoi1YkSQstoWotSZM0jXE3s9nZmZ2dnZmd7I9xNtm2KtLHO8wM38/Mg3kTSqlEK45TJ4fOtok6URN6gnGOfYGowJQjjyHKCQu0hRBHc8ODalAvyt23sl6QO6+HB5UU1g/XgTdfcefL+N5Kb+6zNffFubvmPChD4LI01igafTWLF8/gpfPk2SW8eJbm72Rws48MAAaDgWV2f3UahtHbbIGvXdSxiFJpeM2T9dvO+4u8Xw2oKdyW9PvJCFYtE1LqBWTgvZjtL031nl7e+7H9c8A7PUsJFvtUm1RvoY9TAdqOIh5KOJREX5nCTdPmQoTUhguT7funuo9O7+3UuijcN6CKZCxlzBgpX0erF3xr0yMA2e2Awyx2G+BKE2w0umu5Jx+eP1x9+bhQa3/a9w3kp38xsrt+0ylNMrvGmcNITwong78Z3kwOXl2G08voyhs8k/enc+hGCfbxIZwot3INFs9xe2soXclNDY9jJ4bjvau72qUGLjZwYRfm63il6WLKjr4qxN+lvRFKN4pkFIo4Go5fPhbHlmTkz5N/ehJFsW3DMAyzkoyDRYkK48Tzmc+FXo/9l5JYpeVLdHN0BY/h/0rPWZYFADihpL8B15yM3HlDkKoAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 05 13 37 35"\n        title=""\n        src="/static/2021-07-05-13-37-35-27cda4d94677a23c74bbb5ba13eb9ec1-fee1c.png"\n        srcset="/static/2021-07-05-13-37-35-27cda4d94677a23c74bbb5ba13eb9ec1-a67b7.png 200w,\n/static/2021-07-05-13-37-35-27cda4d94677a23c74bbb5ba13eb9ec1-0b187.png 400w,\n/static/2021-07-05-13-37-35-27cda4d94677a23c74bbb5ba13eb9ec1-fee1c.png 800w,\n/static/2021-07-05-13-37-35-27cda4d94677a23c74bbb5ba13eb9ec1-b1a91.png 1200w,\n/static/2021-07-05-13-37-35-27cda4d94677a23c74bbb5ba13eb9ec1-22802.png 1404w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从图中你可以看到，变量 c 和变量 d 都指向了同一个堆中的对象，所以这就很好地解释了文章开头的那个问题，通过 c 修改 name 的值，变量 d 的值也跟着改变，归根结底它们是同一个对象。</p>\n<h2 id="再谈闭包"><a href="#%E5%86%8D%E8%B0%88%E9%97%AD%E5%8C%85" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>再谈闭包</h2>\n<p>现在你知道了作用域内的原始类型数据会被存储到栈空间，引用类型会被存储到堆空间，基于这两点的认知，我们再深入一步，探讨下闭包的内存模型。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="87843819391593890000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function foo() {\n  var myName = \'极客时间\';\n  let test1 = 1;\n  const test2 = 2;\n  var innerBar = {\n    setName: function(newName) {\n      myName = newName;\n    },\n    getName: function() {\n      console.log(test1);\n      return myName;\n    }\n  };\n  return innerBar;\n}\nvar bar = foo();\nbar.setName(\'极客邦\');\nbar.getName();\nconsole.log(bar.getName());`, `87843819391593890000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                data-tooltip="复制"\n              >\n                <svg class="gatsby-code-button-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M16 1H2v16h2V3h12V1zm-1 4l6 6v12H6V5h9zm-1 7h5.5L14 6.5V12z"/></svg>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">var</span> myName <span class="token operator">=</span> <span class="token string">\'极客时间\'</span><span class="token punctuation">;</span>\n  <span class="token keyword">let</span> test1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>\n  <span class="token keyword">const</span> test2 <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>\n  <span class="token keyword">var</span> innerBar <span class="token operator">=</span> <span class="token punctuation">{</span>\n    <span class="token function-variable function">setName</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">newName</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      myName <span class="token operator">=</span> newName<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n    <span class="token function-variable function">getName</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>test1<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token keyword">return</span> myName<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span><span class="token punctuation">;</span>\n  <span class="token keyword">return</span> innerBar<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">var</span> bar <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nbar<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">\'极客邦\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nbar<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>bar<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>当执行这段代码的时候，你应该有过这样的分析：由于变量 myName、test1、test2 都是原始类型数据，所以在执行 foo 函数的时候，它们会被压入到调用栈中；当 foo 函数执行结束之后，调用栈中 foo 函数的执行上下文会被销毁，其内部变量 myName、test1、test2 也应该一同被销毁。</p>\n<p>要解释这个现象，我们就得站在内存模型的角度来分析这段代码的执行流程。</p>\n<ul>\n<li>当 JavaScript 引擎执行到 foo 函数时，首先会编译，并创建一个空执行上下文。</li>\n<li>在编译过程中，遇到内部函数 setName，JavaScript 引擎还要对内部函数做一次快速的词法扫描，发现该内部函数引用了 foo</li>\n<li>函数中的 myName 变量，由于是内部函数引用了外部函数的变量，所以 JavaScript 引擎判断这是一个闭包，于是在堆空间创建换一个“closure(foo)”的对象（这是一个内部对象，JavaScript 是无法访问的），用来保存 myName 变量。</li>\n<li>接着继续扫描到 getName 方法时，发现该函数内部还引用变量 test1，于是 JavaScript 引擎又将 test1 添加到“closure(foo)”对象中。这时候堆中的“closure(foo)”对象中就包含了 myName 和 test1 两个变量了。</li>\n<li>由于 test2 并没有被内部函数引用，所以 test2 依然保存在调用栈中</li>\n</ul>\n<p>通过上面的分析，我们可以画出执行到 foo 函数中 <code class="language-text">return innerBar</code> 语句时的调用栈状态，如下图所示：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-05-13-39-10-f46ac0461abfac3011858d9136484ef6-9131e.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 61.18980169971672%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAB+ElEQVQoz32Sz2/TMBTHe+bf4MiFExcQCHGaBIed+Ce4cAahIQ6cuCEktlUIGIKJCiqGaMcvqRMcWDXYQKUtrGyjaeK2Tu3EyXMSxzF2skogjT09P8n2+/g9631LSqnMmFTalfbMxHxrDg+1kl5xFI28sE/AJmC5TLtDwaaceEw/bFypxNqA9UVoLvLmPF+/yz/fl3FgYAAob7g3PtK5N/1rtd7NhnPl3fDyKnrbdfWtTFMdw0+33TvHJuUz9NEsfXiBPrmYBmMDEwY79jjycOARFgAH/vU33kb0yy42sMzh7QfuqxNBbylJghicmGMphYEnfriHXIAQwsBfu8VeXNr8UB2EaqtfVE4M/OOeWzvJNCwgClEE4ynM+I5lAxkF2PLmT/tzRzYr1wdMbf20lIhT5qlUhd8X3JfHcWsBu4iMez6xMpkaOORRo4vqLft1a1B/X1+tLVfWms/bRdu6a5FXLuPqUdopA/fi0IlhtF85ieBqg5x7Ss9X8MwzOlOF2RU4u4xXOlTfpvmfobc0qZ8Kfj1OU0g4ivm07SRJdsd+B7G2Tb/tjboO7SK/jdiQMJXP3UQRCEBSBHEcCRHrfrQ2Sn8PHZiH0UD9RxtZPnCEhoyxYrsPZ4WyCq3lWXpJmcncioNpE/8q7EDTf8EYe55HCBFCHJjzB95/kOu7c+UVAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 05 13 39 10"\n        title=""\n        src="/static/2021-07-05-13-39-10-f46ac0461abfac3011858d9136484ef6-fee1c.png"\n        srcset="/static/2021-07-05-13-39-10-f46ac0461abfac3011858d9136484ef6-a67b7.png 200w,\n/static/2021-07-05-13-39-10-f46ac0461abfac3011858d9136484ef6-0b187.png 400w,\n/static/2021-07-05-13-39-10-f46ac0461abfac3011858d9136484ef6-fee1c.png 800w,\n/static/2021-07-05-13-39-10-f46ac0461abfac3011858d9136484ef6-b1a91.png 1200w,\n/static/2021-07-05-13-39-10-f46ac0461abfac3011858d9136484ef6-9131e.png 1412w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从上图你可以清晰地看出，当执行到 foo 函数时，闭包就产生了；当 foo 函数执行结束之后，返回的 getName 和 setName 方法都引用 <code class="language-text">clourse(foo)</code> 对象，所以即使 foo 函数退出了，<code class="language-text">clourse(foo)</code> 依然被其内部的 getName 和 setName 方法引用。所以在下次调用 bar.setName 或者 bar.getName 时，创建的执行上下文中就包含了 <code class="language-text">clourse(foo)</code>。</p>\n<p>总的来说，产生闭包的核心有两步：第一步是需要预扫描内部函数；第二步是把内部函数引用的外部变量保存到堆中。</p>\n<h2 id="总结"><a href="#%E6%80%BB%E7%BB%93" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总结</h2>\n<p>好了，今天就讲到这里，下面我来简单总结下今天的要点。</p>\n<p>我们介绍了 JavaScript 中的 8 种数据类型，它们可以分为两大类——原始类型和引用类型。</p>\n<p>其中，原始类型的数据是存放在栈中，引用类型的数据是存放在堆中的。堆中的数据是通过引用和变量关联起来的。也就是说，JavaScript 的变量是没有数据类型的，值才有数据类型，变量可以随时持有任何类型的数据。</p>\n<p>然后我们分析了，在 JavaScript 中将一个原始类型的变量 a 赋值给 b，那么 a 和 b 会相互独立、互不影响；但是将引用类型的变量 a 赋值给变量 b，那会导致 a、b 两个变量都同时指向了堆中的同一块数据。</p>\n<p>最后，我们还站在内存模型的视角分析了闭包的产生过程。</p>\n<h2 id="思考时间"><a href="#%E6%80%9D%E8%80%83%E6%97%B6%E9%97%B4" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>思考时间</h2>\n<p>在实际的项目中，经常需要完整地拷贝一个对象，也就是说拷贝完成之后两个对象之间就不能互相影响。那该如何实现呢？</p>\n<p>结合下面这段代码，你可以分析下它是如何将对象 jack 拷贝给 jack2，然后在完成拷贝操作时两个 jack 还互不影响的呢。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="76100203943453230000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`let jack = {\n  name: \'jack.ma\',\n  age: 40,\n  like: {\n    dog: {\n      color: \'black\',\n      age: 3\n    },\n    cat: {\n      color: \'white\',\n      age: 2\n    }\n  }\n};\nfunction copy(src) {\n  let dest;\n  // 实现拷贝代码，将 src 的值完整地拷贝给 dest\n  // 在这里实现\n  return dest;\n}\nlet jack2 = copy(jack);\n\n// 比如修改 jack2 中的内容，不会影响到 jack 中的值\njack2.like.dog.color = \'green\';\nconsole.log(jack.like.dog.color); // 打印出来的应该是 &quot;black&quot;`, `76100203943453230000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                data-tooltip="复制"\n              >\n                <svg class="gatsby-code-button-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M16 1H2v16h2V3h12V1zm-1 4l6 6v12H6V5h9zm-1 7h5.5L14 6.5V12z"/></svg>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">let</span> jack <span class="token operator">=</span> <span class="token punctuation">{</span>\n  name<span class="token punctuation">:</span> <span class="token string">\'jack.ma\'</span><span class="token punctuation">,</span>\n  age<span class="token punctuation">:</span> <span class="token number">40</span><span class="token punctuation">,</span>\n  like<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n    dog<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n      color<span class="token punctuation">:</span> <span class="token string">\'black\'</span><span class="token punctuation">,</span>\n      age<span class="token punctuation">:</span> <span class="token number">3</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n    cat<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n      color<span class="token punctuation">:</span> <span class="token string">\'white\'</span><span class="token punctuation">,</span>\n      age<span class="token punctuation">:</span> <span class="token number">2</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token keyword">function</span> <span class="token function">copy</span><span class="token punctuation">(</span><span class="token parameter">src</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">let</span> dest<span class="token punctuation">;</span>\n  <span class="token comment">// 实现拷贝代码，将 src 的值完整地拷贝给 dest</span>\n  <span class="token comment">// 在这里实现</span>\n  <span class="token keyword">return</span> dest<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">let</span> jack2 <span class="token operator">=</span> <span class="token function">copy</span><span class="token punctuation">(</span>jack<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token comment">// 比如修改 jack2 中的内容，不会影响到 jack 中的值</span>\njack2<span class="token punctuation">.</span>like<span class="token punctuation">.</span>dog<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token string">\'green\'</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>jack<span class="token punctuation">.</span>like<span class="token punctuation">.</span>dog<span class="token punctuation">.</span>color<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 打印出来的应该是 "black"</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>关于 foo 函数执行上下文销毁过程：foo 函数执行结束之后，当前执行状态的指针下移到栈中的全局执行上下文的位置，foo 函数的执行上下文的那块数据就挪出来，这也就是 foo 函数执行上下文的销毁过程，这个文中有提到，你可以参考“调用栈中切换执行上下文状态“图。</p>\n<p>第二个问题：innerBar 返回后，含有 setName 和 getName 对象，这两个对象里面包含了堆中的 closure(foo) 的引用。虽然 foo 执行上下文销毁了，foo 函数中的对 closure(foo) 的引用也断开了，但是 setName 和 getName 里面又重新建立起来了对 closure(foo) 引用。</p>\n<p>你可以：</p>\n<ul>\n<li>打开开发者工具</li>\n<li>在控制台执行上述代码</li>\n<li>然后选择 Memory 标签，点击 take snapshot 获取 V8 的堆内存快照。</li>\n<li>然后 <code class="language-text">command+f(mac)</code> 或者 <code class="language-text">ctrl+f(win)</code>，搜索 setName，然后你就会发现 setName 对象下面包含了 raw<em>outer</em>scope<em>info</em>or<em>feedback</em>metadata，对闭包的引用数据就在这里面。</li>\n</ul>\n<h1 id="垃圾回收：垃圾数据如何自动回收"><a href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%9A%E5%9E%83%E5%9C%BE%E6%95%B0%E6%8D%AE%E5%A6%82%E4%BD%95%E8%87%AA%E5%8A%A8%E5%9B%9E%E6%94%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>垃圾回收：垃圾数据如何自动回收</h1>\n<p>有些数据被使用之后，可能就不再需要了，我们把这种数据称为垃圾数据。如果这些垃圾数据一直保存在内存中，那么内存会越用越多，所以我们需要对这些垃圾数据进行回收，以释放有限的内存空间</p>\n<h2 id="不同语言的垃圾回收策略"><a href="#%E4%B8%8D%E5%90%8C%E8%AF%AD%E8%A8%80%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>不同语言的垃圾回收策略</h2>\n<p>通常情况下，垃圾数据回收分为手动回收和自动回收两种策略。</p>\n<p>如 C/C++ 就是使用手动回收策略，何时分配内存、何时销毁内存都是由代码控制的，你可以参考下面这段 C 代码：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="3846738914845704000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// 在堆中分配内存\n// 在堆空间中分配 2048 字节的空间，并将分配后的引用地址保存到 p 中\nchar* p = (char*)malloc(2048);\n\n// 使用 p 指向的内存\n{\n  //....\n}\n\n// 使用结束后，销毁这段内存\nfree(p)；\np = NULL；`, `3846738914845704000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                data-tooltip="复制"\n              >\n                <svg class="gatsby-code-button-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M16 1H2v16h2V3h12V1zm-1 4l6 6v12H6V5h9zm-1 7h5.5L14 6.5V12z"/></svg>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="cpp"><pre style="counter-reset: linenumber NaN" class="language-cpp line-numbers"><code class="language-cpp"><span class="token comment">// 在堆中分配内存</span>\n<span class="token comment">// 在堆空间中分配 2048 字节的空间，并将分配后的引用地址保存到 p 中</span>\n<span class="token keyword">char</span><span class="token operator">*</span> p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">2048</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token comment">// 使用 p 指向的内存</span>\n<span class="token punctuation">{</span>\n  <span class="token comment">//....</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// 使用结束后，销毁这段内存</span>\n<span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span>；\np <span class="token operator">=</span> <span class="token constant">NULL</span>；</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>从上面这段 C 代码可以看出来，要使用堆中的一块空间，我们需要先调用 mallco 函数分配内存，然后再使用；当不再需要这块数据的时候，就要手动调用 free 函数来释放内存。如果这段数据已经不再需要了，但是又没有主动调用 free 函数来销毁，那么这种情况就被称为内存泄漏。</p>\n<p>另外一种使用的是自动垃圾回收的策略，如 JavaScript、Java、Python 等语言，产生的垃圾数据是由垃圾回收器来释放的，并不需要手动通过代码来释放。</p>\n<p>对于 JavaScript 而言，也正是这个“自动”释放资源的特性带来了很多困惑，也让一些 JavaScript 开发者误以为可以不关心内存管理，这是一个很大的误解。</p>\n<p>那么在本文，我们将围绕“JavaScript 的数据是如何回收的”这个话题来展开探讨。因为数据是存储在栈和堆两种内存空间中的，所以接下来我们就来分别介绍“栈中的垃圾数据”和“堆中的垃圾数据”是如何回收的。</p>\n<h2 id="调用栈中的数据是如何回收的"><a href="#%E8%B0%83%E7%94%A8%E6%A0%88%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%98%AF%E5%A6%82%E4%BD%95%E5%9B%9E%E6%94%B6%E7%9A%84" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>调用栈中的数据是如何回收的</h2>\n<p>首先是调用栈中的数据，我们还是通过一段示例代码的执行流程来分析其回收机制，具体如下：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="81415159095793470000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function foo() {\n  var a = 1;\n  var b = { name: \'极客邦\' };\n  function showName() {\n    var c = 1;\n    var d = { name: \'极客时间\' };\n  }\n  showName();\n}\nfoo();`, `81415159095793470000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                data-tooltip="复制"\n              >\n                <svg class="gatsby-code-button-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M16 1H2v16h2V3h12V1zm-1 4l6 6v12H6V5h9zm-1 7h5.5L14 6.5V12z"/></svg>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>\n  <span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">\'极客邦\'</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>\n  <span class="token keyword">function</span> <span class="token function">showName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>\n    <span class="token keyword">var</span> d <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">\'极客时间\'</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token function">showName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>当执行到第 6 行代码时，其调用栈和堆空间状态图如下所示：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-05-14-13-12-61833b6271a6466b1560d09e3c39099e-205ae.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 68.10810810810811%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAIAAACgpqunAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACdElEQVQoz22S30/TUBTH9/f4H/igD+qLr775YOIf4JsJia8+KLQlG6BPBAMDUdFIOn5FQjAKDBljQOlWmNbZru3W9de9XbvSn9euq2YYvzk5ybn3fs45956b8T0Podj8IfOiyA3DACWKPDswuMDgE9+3yHcGWxkFWO8YO3+s5Q+lvpVbixR4S5uaacdgfMJlt+CrO8bMbTBzC87eBdM3ffEoyRpmOKU7d9R5U2nPVrSFU/i6epktKrldqaFaA9gTt2Dhenf/sScdesKeJ+yGjjHoKSNpsAvUyAGIXux9HrX2pjiW4TWLb2kocOMjsLlTL9xji4TQagrCj6bAOo6dti1qkPrV/i606aWRs5kH5emHX0vlA84SFICSa5/TZy+nci+mJggcJwh8nCCaPN+vG0WZNrCzJYAV9edf5NGdDlY0sG8Q31NlmKY/v6hjeDabnSTG+yIIguO4FOYUc7Xa2a4r6zV1sw4+sc5cRc2X2w2lO4B1fr+ydJ/awhiGYqrlGl22ujC9s6BCoCuBraODHFx+BNZGGvVTXnN4SUVhPEIUyNv2xjW39jR+eBTqKAIo8v+MyjAvBOWn1LlYx5j3I2dLT0oUfdS0JM1EXn+etrTTJG9IpWe61tKVhqY0XLeXwmynO0+Z+VOQr17ma/7CeThfc5YZ2Lt0kd+vzFAnk9mxidw4jmNjY6Ox5/8+GCvD5ZpRYMCHY/HjSYuk1TjcrOs9J/1GoiiShdW19Q2SLJAkubKyoihKCscu+Qwh6Eg9M51+shWhqzIMAwAwvJJJ0Qj5QRQE4b/EkMJEV+DhwPd9TdNM04QQxl6WZV3X4ybjmv9N9xvm9+Bj8RurGwAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 05 14 13 12"\n        title=""\n        src="/static/2021-07-05-14-13-12-61833b6271a6466b1560d09e3c39099e-fee1c.png"\n        srcset="/static/2021-07-05-14-13-12-61833b6271a6466b1560d09e3c39099e-a67b7.png 200w,\n/static/2021-07-05-14-13-12-61833b6271a6466b1560d09e3c39099e-0b187.png 400w,\n/static/2021-07-05-14-13-12-61833b6271a6466b1560d09e3c39099e-fee1c.png 800w,\n/static/2021-07-05-14-13-12-61833b6271a6466b1560d09e3c39099e-b1a91.png 1200w,\n/static/2021-07-05-14-13-12-61833b6271a6466b1560d09e3c39099e-205ae.png 1480w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从图中可以看出，原始类型的数据被分配到栈中，引用类型的数据会被分配到堆中。当 foo 函数执行结束之后，foo 函数的执行上下文会从堆中被销毁掉，那么它是怎么被销毁的呢？下面我们就来分析一下。</p>\n<p>在上篇文章中，我们简单介绍过了，如果执行到 showName 函数时，那么 JavaScript 引擎会创建 showName 函数的执行上下文，并将 showName 函数的执行上下文压入到调用栈中，最终执行到 showName 函数时，其调用栈就如上图所示。与此同时，还有一个记录当前执行状态的指针（称为 ESP），指向调用栈中 showName 函数的执行上下文，表示当前正在执行 showName 函数。</p>\n<p>接着，当 showName 函数执行完成之后，函数执行流程就进入了 foo 函数，那这时就需要销毁 showName 函数的执行上下文了。ESP 这时候就帮上忙了，JavaScript 会将 ESP 下移到 foo 函数的执行上下文，这个下移操作就是销毁 showName 函数执行上下文的过程。</p>\n<p>你可能会有点懵，ESP 指针向下移动怎么就能把 showName 的执行上下文销毁了呢？具体你可以看下面这张移动 ESP 前后的对比图</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-05-14-13-27-61a4d68f73d41fb85c9268ac972f1816-5e571.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 62.41426611796982%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACVElEQVQoz2VSXU/TUBjez/M/kGjif/DGG29MMGJClGgwMAfsAgVUSGAwUAYRHHV0Wx377ifQbe3Wdm3P+nFOe46nQ8OFT56Lkzzv836eFCEkooAhQSGJEYkgiUJKjMI4jqmKKZIHJiT+x4hgRIUUjjHxwTFvv2Ls+bPB/Ln+hjFf/jQ+162ba6XVaiuKLCmD/e9chtUzpf4qq69WzHVuZE+CFEEImkaN719KQ05UK2252O0dNrVTwSqz5cLRUaN82RL7Fye/8m0j1xgdi+5aefipMlBML0UbCyBUtaE/AbC4YGceXK/NKDdSZxTygigJwqDXk3TL8wGRC+7GI/fjDM+dyk4sDt0UToYOz8TxYmn0oVBe3vu2dPBjkdF32w6CkIp0EYI6Omybh6Vqbiezt53eKTXzPDCcaWW6mxPRWamY2RrINqNsFy8wxgY3DCHCQUA8wAr6XNGcK45fMOHrGnl2Np4t3PZtPzH7IexpOnRN3PoS5J5oB88V9bapezbwk8JxLGiW7xhEb0yYtMcsd7pXshWKQ5CYaXuKbvE64Iubna9Pue1ZTlKvBr7nB0lfcSxrRrdvidWj+srjq/TDC+a0qsFbc2oOg2C3Zb9jraWK+77qp+voLeucSza9ebIRHP3ugfW6s9UEmy1/qwM32sFBx0YwTMwRQl0dlBSTlUclQaM3q6jOjQFwHJFp6fbAznesfEPbr6n5ej9X14uSGSGYmO+AoU+QHwUeJfkf9Eshj0CPhJPYc8g0718zxvdhEMLx2HZd15sCADCZeHfz36eaxv8BsrB/8eJEn6AAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 05 14 13 27"\n        title=""\n        src="/static/2021-07-05-14-13-27-61a4d68f73d41fb85c9268ac972f1816-fee1c.png"\n        srcset="/static/2021-07-05-14-13-27-61a4d68f73d41fb85c9268ac972f1816-a67b7.png 200w,\n/static/2021-07-05-14-13-27-61a4d68f73d41fb85c9268ac972f1816-0b187.png 400w,\n/static/2021-07-05-14-13-27-61a4d68f73d41fb85c9268ac972f1816-fee1c.png 800w,\n/static/2021-07-05-14-13-27-61a4d68f73d41fb85c9268ac972f1816-b1a91.png 1200w,\n/static/2021-07-05-14-13-27-61a4d68f73d41fb85c9268ac972f1816-5e571.png 1458w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从图中可以看出，当 showName 函数执行结束之后，ESP 向下移动到 foo 函数的执行上下文中，上面 showName 的执行上下文虽然保存在栈内存中，但是已经是无效内存了。比如当 foo 函数再次调用另外一个函数时，这块内容会被直接覆盖掉，用来存放另外一个函数的执行上下文。</p>\n<p>所以说，当一个函数执行结束之后，JavaScript 引擎会通过向下移动 ESP 来销毁该函数保存在栈中的执行上下文。</p>\n<h2 id="堆中的数据是如何回收的"><a href="#%E5%A0%86%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%98%AF%E5%A6%82%E4%BD%95%E5%9B%9E%E6%94%B6%E7%9A%84" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>堆中的数据是如何回收的</h2>\n<p>通过上面的讲解，我想现在你应该已经知道，当上面那段代码的 foo 函数执行结束之后，ESP 应该是指向全局执行上下文的，那这样的话，showName 函数和 foo 函数的执行上下文就处于无效状态了，不过保存在堆中的两个对象依然占用着空间，如下图所示</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-05-14-13-55-a9d092b8620c531f9704f0f11d718e85-6ea2c.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 83.11306901615274%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAIAAABSJhvpAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACFElEQVQ4y6WTT28SQRjG+TxGk8abF+PFb+BHMDFeDEYPeuMAJKCFsMSCQICmKi0kSCXgn8SjB1Ej2mhDUizCbtnl37A7M53Z2Z3FabdWiCYl8Tns7Eye37zPTOb1zP5DHnfgnCOEDo9FCDn9wRjbti0MdO8tbRYOm8/I5yfk6yb5tE53qyewcAif4zh8TmJqmialVBj08vXp2sVxfGX6aEVPXwaxc0bh2h9Y1Pk7mG1ZLgwbd/XaJdgMsuk+G31jo+8M/DgDtn7Dkw/3B6+vjndimBgYahhpGI+WhauVzUxyNZWMJRJryWQiHpdKxa1l4a3i89ADaTUi+QP+YDDo8/my2eyycKVciEcDjxNSOp3KpFOifqlUXBYeN+6p9SujLxEIRxB0IeghQz0TZi6MPnr1+nm8G+Uc2+aAm0POwLKVQePOYPsC2IlQMiXogKA+xcMj2KHEMak2gTLiisFkncmGpUBLhtwgjJlH8JvqRiHj38hK+Xwul8tk0snqi4pn5jg2ADOKnr7v3Xg59Na6t7bb3lrv9quDm3X13T6YcXZ82+Xww1gkKoVC4VA47PcH8vn1k9jiJYp4lklti2FkQB3YzBRTkxLxToVhMNC63Z+KIrfbe61WS5ZlTdM8Ljp/TrHa6XTcfnD3deYMomEmk8lCV83LtTqLO562yrw8/2xUcQRVVUU28VUURWTp9/tAXM2ifgGJ3J+m/MWuBAAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 05 14 13 55"\n        title=""\n        src="/static/2021-07-05-14-13-55-a9d092b8620c531f9704f0f11d718e85-fee1c.png"\n        srcset="/static/2021-07-05-14-13-55-a9d092b8620c531f9704f0f11d718e85-a67b7.png 200w,\n/static/2021-07-05-14-13-55-a9d092b8620c531f9704f0f11d718e85-0b187.png 400w,\n/static/2021-07-05-14-13-55-a9d092b8620c531f9704f0f11d718e85-fee1c.png 800w,\n/static/2021-07-05-14-13-55-a9d092b8620c531f9704f0f11d718e85-b1a91.png 1200w,\n/static/2021-07-05-14-13-55-a9d092b8620c531f9704f0f11d718e85-6ea2c.png 1362w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从图中可以看出，1003 和 1050 这两块内存依然被占用。要回收堆中的垃圾数据，就需要用到 JavaScript 中的垃圾回收器了。</p>\n<p>所以，接下来我们就来通过 Chrome 的 JavaScript 引擎 V8 来分析下堆中的垃圾数据是如何回收的。</p>\n<h2 id="代际假说和分代收集"><a href="#%E4%BB%A3%E9%99%85%E5%81%87%E8%AF%B4%E5%92%8C%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>代际假说和分代收集</h2>\n<p>不过在正式介绍 V8 是如何实现回收之前，你需要先学习下代际假说（The Generational Hypothesis）的内容，这是垃圾回收领域中一个重要的术语，后续垃圾回收的策略都是建立在该假说的基础之上的，所以很是重要。</p>\n<p>代际假说有以下两个特点：</p>\n<ul>\n<li>第一个是大部分对象在内存中存在的时间很短，简单来说，就是很多对象一经分配内存，很快就变得不可访问；</li>\n<li>第二个是不死的对象，会活得更久。</li>\n</ul>\n<p>其实这两个特点不仅仅适用于 JavaScript，同样适用于大多数的动态语言，如 Java、Python 等。</p>\n<p>有了代际假说的基础，我们就可以来探讨 V8 是如何实现垃圾回收的了。</p>\n<p>通常，垃圾回收算法有很多种，但是并没有哪一种能胜任所有的场景，你需要权衡各种场景，根据对象的生存周期的不同而使用不同的算法，以便达到最好的效果。</p>\n<p>所以，在 V8 中会把堆分为新生代和老生代两个区域，新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象。</p>\n<p>新生区通常只支持 1 ～ 8M 的容量，而老生区支持的容量就大很多了。对于这两块区域，V8 分别使用两个不同的垃圾回收器，以便更高效地实施垃圾回收。</p>\n<ul>\n<li>副垃圾回收器，主要负责新生代的垃圾回收。</li>\n<li>主垃圾回收器，主要负责老生代的垃圾回收。</li>\n</ul>\n<h2 id="垃圾回收器的工作流程"><a href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>垃圾回收器的工作流程</h2>\n<p>现在你知道了 V8 把堆分成两个区域——新生代和老生代，并分别使用两个不同的垃圾回收器。其实不论什么类型的垃圾回收器，它们都有一套共同的执行流程。</p>\n<p>第一步是标记空间中活动对象和非活动对象。所谓活动对象就是还在使用的对象，非活动对象就是可以进行垃圾回收的对象。</p>\n<p>第二步是回收非活动对象所占据的内存。其实就是在所有的标记完成之后，统一清理内存中所有被标记为可回收的对象。</p>\n<p>第三步是做内存整理。一般来说，频繁回收对象后，内存中就会存在大量不连续空间，我们把这些不连续的内存空间称为内存碎片。当内存中出现了大量的内存碎片之后，如果需要分配较大连续内存的时候，就有可能出现内存不足的情况。所以最后一步需要整理这些内存碎片，但这步其实是可选的，因为有的垃圾回收器不会产生内存碎片，比如接下来我们要介绍的副垃圾回收器。</p>\n<p>那么接下来，我们就按照这个流程来分析新生代垃圾回收器（副垃圾回收器）和老生代垃圾回收器（主垃圾回收器）是如何处理垃圾回收的。</p>\n<h2 id="副垃圾回收器"><a href="#%E5%89%AF%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>副垃圾回收器</h2>\n<p>副垃圾回收器主要负责新生区的垃圾回收。而通常情况下，大多数小的对象都会被分配到新生区，所以说这个区域虽然不大，但是垃圾回收还是比较频繁的。</p>\n<p>新生代中用 Scavenge 算法来处理。所谓 Scavenge 算法，是把新生代空间对半划分为两个区域，一半是对象区域，一半是空闲区域，如下图所示</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-05-14-15-22-e32f50e2eb152a5b001ac254262fa90b-574e5.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 59.45558739255014%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABGklEQVQoz41SaW+DMAzl///AqtuHIsa2klYQyH3ZqQl0PZH2ZCm25eczVb4DIuZ3wIJXf/Wneec+P/bd8fiaTgqx3+2UlO/JFNKPU/vz27Tf2rqEOcIqpJ97XjfNME5X/9pFtbzcgkroqYhPOqKJyFQSHlWYxaTsMOuUF3OwsPDXyjrmScjgHUBy1hqtVczwMOdNNwFDupGRsnbsZI0BgEkIzjl5YGN/msh3lefGutNZK0XGOI7D0P+fTKNiKrb3HhEonZxfpHVn3CavC3PAHcqA3EThgRSmgcam+jJk2tzkUVylt5DuK5eTrgLluNTC4VCTDJyTCeWb4GMrVd5GDMF5TyvcCngmU2jXdXVdt23LGPsqaAtCCE/BF3JCwHoMaWtPAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 05 14 15 22"\n        title=""\n        src="/static/2021-07-05-14-15-22-e32f50e2eb152a5b001ac254262fa90b-fee1c.png"\n        srcset="/static/2021-07-05-14-15-22-e32f50e2eb152a5b001ac254262fa90b-a67b7.png 200w,\n/static/2021-07-05-14-15-22-e32f50e2eb152a5b001ac254262fa90b-0b187.png 400w,\n/static/2021-07-05-14-15-22-e32f50e2eb152a5b001ac254262fa90b-fee1c.png 800w,\n/static/2021-07-05-14-15-22-e32f50e2eb152a5b001ac254262fa90b-b1a91.png 1200w,\n/static/2021-07-05-14-15-22-e32f50e2eb152a5b001ac254262fa90b-574e5.png 1396w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>新加入的对象都会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作。</p>\n<p>在垃圾回收过程中，首先要对对象区域中的垃圾做标记；标记完成之后，就进入垃圾清理阶段，副垃圾回收器会把这些存活的对象复制到空闲区域中，同时它还会把这些对象有序地排列起来，所以这个复制过程，也就相当于完成了内存整理操作，复制后空闲区域就没有内存碎片了。</p>\n<p>完成复制后，对象区域与空闲区域进行角色翻转，也就是原来的对象区域变成空闲区域，原来的空闲区域变成了对象区域。这样就完成了垃圾对象的回收操作，同时这种角色翻转的操作还能让新生代中的这两块区域无限重复使用下去。</p>\n<p>由于新生代中采用的 Scavenge 算法，所以每次执行清理操作时，都需要将存活的对象从对象区域复制到空闲区域。但复制操作需要时间成本，如果新生区空间设置得太大了，那么每次清理的时间就会过久，所以为了执行效率，一般新生区的空间会被设置得比较小。</p>\n<p>也正是因为新生区的空间不大，所以很容易被存活的对象装满整个区域。为了解决这个问题，JavaScript 引擎采用了对象晋升策略，也就是经过两次垃圾回收依然还存活的对象，会被移动到老生区中。</p>\n<h2 id="主垃圾回收器"><a href="#%E4%B8%BB%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>主垃圾回收器</h2>\n<p>主垃圾回收器主要负责老生区中的垃圾回收。除了新生区中晋升的对象，一些大的对象会直接被分配到老生区。因此老生区中的对象有两个特点，一个是对象占用空间大，另一个是对象存活时间长。</p>\n<p>由于老生区的对象比较大，若要在老生区中使用 Scavenge 算法进行垃圾回收，复制这些大的对象将会花费比较多的时间，从而导致回收执行效率不高，同时还会浪费一半的空间。因而，主垃圾回收器是采用标记 - 清除（Mark-Sweep）的算法进行垃圾回收的。下面我们来看看该算法是如何工作的。</p>\n<p>首先是标记过程阶段。标记阶段就是从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素称为活动对象，没有到达的元素就可以判断为垃圾数据。</p>\n<p>比如最开始的那段代码，当 showName 函数执行退出之后，这段代码的调用栈和堆空间如下图所示：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-05-14-15-47-89072468db6e7b2a97e7198cec310d4d-5fe3e.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 57.34265734265735%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAB3UlEQVQoz3VSy27TQBTtX/UrWCOx5A+gC5AQG0RhQUFR0qaIVqgESsVDKAixaClRUZo2sUlSK3Zj2iTYctrYDnb8mkfw2MNkAhQQPTqauSPdM+do7sxQjjRNY5JwEs5pnaQc9BzMTDeMUBJjmowpjWn6nTGd1MS2zINmUzlUw/YWrq+B/TwUVkAli9X3E/HkWhBFtrUuedkGzFTMzJ6VE5yM6K9KkXz8dae0vVut26U59/WsvzePDl+B5grqbXMxD+V6waYyqHSHpSNGp2qAZw27qDgHPfNE72mnpv38nnv7krVw3Xhwq3/nmv92YyqeqB0/6PVPExRSIWsXLqI3l5VWVfNJS7NoErOO0csF68aF4f25Yebm8O5Vv1j4FZvSEMC2YXeskVotKltL7Q8Pa4oqDdCJE7C3YGogz7ubs9ipEYoJcWISMtOfsZ0ALte93GdvsYEWJbLUorkGfKEECAKMcQRQ6d3jjfyV9SfLTwtrq4/yn3Y+njlHENd0TzTCyrG1+2UgaO6+5skm6Ha7giBIknTU0dROX2ZxJKnVkg2jfzaq3wC+G42+TSfPVl3Xy+WyKIoQQnYkhERR9O+ceTcn5eQ1w3g89n0/CAImS//Gf5z/BFMi9nmS5LyGH4XIT95I6xwYAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 05 14 15 47"\n        title=""\n        src="/static/2021-07-05-14-15-47-89072468db6e7b2a97e7198cec310d4d-fee1c.png"\n        srcset="/static/2021-07-05-14-15-47-89072468db6e7b2a97e7198cec310d4d-a67b7.png 200w,\n/static/2021-07-05-14-15-47-89072468db6e7b2a97e7198cec310d4d-0b187.png 400w,\n/static/2021-07-05-14-15-47-89072468db6e7b2a97e7198cec310d4d-fee1c.png 800w,\n/static/2021-07-05-14-15-47-89072468db6e7b2a97e7198cec310d4d-b1a91.png 1200w,\n/static/2021-07-05-14-15-47-89072468db6e7b2a97e7198cec310d4d-5fe3e.png 1430w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从上图你可以大致看到垃圾数据的标记过程，当 showName 函数执行结束之后，ESP 向下移动，指向了 foo 函数的执行上下文，这时候如果遍历调用栈，是不会找到引用 1003 地址的变量，也就意味着 1003 这块数据为垃圾数据，被标记为红色。由于 1050 这块数据被变量 b 引用了，所以这块数据会被标记为活动对象。这就是大致的标记过程。</p>\n<p>接下来就是垃圾的清除过程。它和副垃圾回收器的垃圾清除过程完全不同，你可以理解这个过程是清除掉红色标记数据的过程，可参考下图大致理解下其清除过程：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-05-14-16-00-e7097f5d5eb869f0198529da34626d3c-03014.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 60.6628242074928%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABkUlEQVQoz31R30vCUBT2D+y9lx4jeq//oQiiHuyhPRUFQRDiQzmXmCvXyFwSEqhjUyYquiZs7Yfeu107u3O5JPvYLvfce79zzved1CxGQEjg+wRjEsCWzBKAMKAgMaLzFPyfmSttZ5PYVvhuRrDvI4TgafQCYTyZTqPQp1cAjFBIhiTTquheMkWp9pLN9He33I93uPiyLNu2g7gLURTz+bzneRD6QYAxnldual3uqXyzvva8veGcnSCtDYf9Xk9VVdM0ZVlmWZbn+UqlgmhByIgW5EbzgWWnF6fD7HWpIavnjMEcQ/ORWkVROI6zTBNCQRBqtVqkhbZNfYJO3pT242uVKxRa6QMjvR+Rozqw1ut1vlTi7m4lSQIKmmsmYDAGMflc7k2S5t7Sb24YNU8ol++LReSHiSDvQnMSoUMwsLjsz6zCq27HZo5MXe9omus4v8jJAS4B+oBVV+Ti4Z45HvcHA+j0j8oryOFqe16rN3BcdzQaTiaT/8gBHSYI9pckJLCSDLkNw9B13aHyFo4k1H0DpKGjyMpxZJwAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 05 14 16 00"\n        title=""\n        src="/static/2021-07-05-14-16-00-e7097f5d5eb869f0198529da34626d3c-fee1c.png"\n        srcset="/static/2021-07-05-14-16-00-e7097f5d5eb869f0198529da34626d3c-a67b7.png 200w,\n/static/2021-07-05-14-16-00-e7097f5d5eb869f0198529da34626d3c-0b187.png 400w,\n/static/2021-07-05-14-16-00-e7097f5d5eb869f0198529da34626d3c-fee1c.png 800w,\n/static/2021-07-05-14-16-00-e7097f5d5eb869f0198529da34626d3c-b1a91.png 1200w,\n/static/2021-07-05-14-16-00-e7097f5d5eb869f0198529da34626d3c-03014.png 1388w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>上面的标记过程和清除过程就是标记 - 清除算法，不过对一块内存多次执行标记 - 清除算法后，会产生大量不连续的内存碎片。而碎片过多会导致大对象无法分配到足够的连续内存，于是又产生了另外一种算法——标记 - 整理（Mark-Compact），这个标记过程仍然与标记 - 清除算法里的是一样的，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。你可以参考下图</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-05-14-16-15-8b9ca980923f8eaba0c102b31f37df52-22802.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 49.71509971509971%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABE0lEQVQoz3VRy4qEMBD0/3/GdWdwFg8qIshoVg96FgRBRETRg49N4lYSd8Z5bBFD26nqVHe0TYJzzrAkuMQtv/0PDR+ldFkWyBBj//mDYiBj2/aHYZzO55OE8WlYlgWCECtenue6rtd1rcqt6zoMQ9d1wzimaRqGV0JIRATCKEqSBBwh7vveNE3HcYIgAFu5hRfk8du2LQo9GeYb322P4+j7flVViL8J+bpcwEZh1TACWKOMioDuAAGnD7bRj+d5cRwfxegZMeP3Waq53MWUsaIoXNeFVWTWw8BAwvmK6ymd5mmeZyGWpbWnZtRrvb6KcoFpZVnWNE1ZlnvPt+PjC7/FNImblfMH8asFzBlTxP7WC/ALx7A7GqZJCyYAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 05 14 16 15"\n        title=""\n        src="/static/2021-07-05-14-16-15-8b9ca980923f8eaba0c102b31f37df52-fee1c.png"\n        srcset="/static/2021-07-05-14-16-15-8b9ca980923f8eaba0c102b31f37df52-a67b7.png 200w,\n/static/2021-07-05-14-16-15-8b9ca980923f8eaba0c102b31f37df52-0b187.png 400w,\n/static/2021-07-05-14-16-15-8b9ca980923f8eaba0c102b31f37df52-fee1c.png 800w,\n/static/2021-07-05-14-16-15-8b9ca980923f8eaba0c102b31f37df52-b1a91.png 1200w,\n/static/2021-07-05-14-16-15-8b9ca980923f8eaba0c102b31f37df52-22802.png 1404w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<h2 id="全停顿"><a href="#%E5%85%A8%E5%81%9C%E9%A1%BF" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>全停顿</h2>\n<p>现在你知道了 V8 是使用副垃圾回收器和主垃圾回收器处理垃圾回收的，不过由于 JavaScript 是运行在主线程之上的，一旦执行垃圾回收算法，都需要将正在执行的 JavaScript 脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。我们把这种行为叫做全停顿（Stop-The-World）。</p>\n<p>比如堆中的数据有 1.5GB，V8 实现一次完整的垃圾回收需要 1 秒以上的时间，这也是由于垃圾回收而引起 JavaScript 线程暂停执行的时间，若是这样的时间花销，那么应用的性能和响应能力都会直线下降。主垃圾回收器执行一次完整的垃圾回收流程如下图所示：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-05-14-16-40-e971aec8ff9d9e307046a00b0e265563-4a030.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 40.78374455732946%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAIAAAB2/0i6AAAACXBIWXMAAA7DAAAOwwHHb6hkAAABGElEQVQY06WQsUvDQBTG+x85OTm4iUt1UheHunboIrgKUrsIxeJi7ebg5hIQFyeXKlnU1HCxaRASjtKkNr0Ec5e7e/FuUDtYHfzBHQ/e+977+ErFPyipBwASQBWvE+j68BCwd8dmyKLI4k4vQ5ZwnqZ918Rw78swBa34EiuE1P/hLV/oiHInNHc27e1VVFm721pBlfXHjeWram3pvFg8o5e2HhXwKcYYuwMP8uzCHNeMyYERPJ8cDVr1/nEDNesvrYbb3O+etveu411jfNOLsjT+tp2mKSFECuVdqKVC5kzIN0LwaORjHAyHjAvKOQDXXcEVxaztWVQElFLGWBRFnudN4zhnmp8Dm4faog79kfY8kiQJw/CXgQ8EMrmBWgskLgAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 05 14 16 40"\n        title=""\n        src="/static/2021-07-05-14-16-40-e971aec8ff9d9e307046a00b0e265563-fee1c.png"\n        srcset="/static/2021-07-05-14-16-40-e971aec8ff9d9e307046a00b0e265563-a67b7.png 200w,\n/static/2021-07-05-14-16-40-e971aec8ff9d9e307046a00b0e265563-0b187.png 400w,\n/static/2021-07-05-14-16-40-e971aec8ff9d9e307046a00b0e265563-fee1c.png 800w,\n/static/2021-07-05-14-16-40-e971aec8ff9d9e307046a00b0e265563-b1a91.png 1200w,\n/static/2021-07-05-14-16-40-e971aec8ff9d9e307046a00b0e265563-4a030.png 1378w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>在 V8 新生代的垃圾回收中，因其空间较小，且存活对象较少，所以全停顿的影响不大，但老生代就不一样了。如果在执行垃圾回收的过程中，占用主线程时间过久，就像上面图片展示的那样，花费了 200 毫秒，在这 200 毫秒内，主线程是不能做其他事情的。比如页面正在执行一个 JavaScript 动画，因为垃圾回收器在工作，就会导致这个动画在这 200 毫秒内无法执行的，这将会造成页面的卡顿现象。</p>\n<p>为了降低老生代的垃圾回收而造成的卡顿，V8 将标记过程分为一个个的子标记过程，同时让垃圾回收标记和 JavaScript 应用逻辑交替进行，直到标记阶段完成，我们把这个算法称为增量标记（Incremental Marking）算法。如下图所示：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-05-14-16-53-e6492934c0f0f4ec2d00fbd7e3ffd66d-39487.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 44.47476125511596%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAIAAAC9o5sfAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABEklEQVQoz5WRz0oDMRDG+2T6AOJF0FPVYz2ot/oMngTpSQUtta2lVER8hh704kX2JNoKW7ZrTLLZdrfZZCYmW6kHK9qPYfgI82P+pGDmCRHNP1T4+aSUYoxZQym1fmGYR9waf+DLLPsbns6ZKgwTEwoZDIYkNR/vdChUansjAGc64myswzGOJJq8/gvW4PK1p5dqWKwGp4dXK23TOGqtnpGbF2NE6JU2HkrFzXN/+RIr924XwBy2bXv9tyQid0/xWp3t1l+rx+2tjmhWWtsXvVsvkUH/sbzTPdjbrz2vN/lJlyaCfcOEECGEc6BdIOTZzQYAWmvrXKCeFkwmcv7BZsqUGsWxRRe49kxSSvtb2e8H/wRrNvpsX4BLjwAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 05 14 16 53"\n        title=""\n        src="/static/2021-07-05-14-16-53-e6492934c0f0f4ec2d00fbd7e3ffd66d-fee1c.png"\n        srcset="/static/2021-07-05-14-16-53-e6492934c0f0f4ec2d00fbd7e3ffd66d-a67b7.png 200w,\n/static/2021-07-05-14-16-53-e6492934c0f0f4ec2d00fbd7e3ffd66d-0b187.png 400w,\n/static/2021-07-05-14-16-53-e6492934c0f0f4ec2d00fbd7e3ffd66d-fee1c.png 800w,\n/static/2021-07-05-14-16-53-e6492934c0f0f4ec2d00fbd7e3ffd66d-b1a91.png 1200w,\n/static/2021-07-05-14-16-53-e6492934c0f0f4ec2d00fbd7e3ffd66d-39487.png 1466w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>使用增量标记算法，可以把一个完整的垃圾回收任务拆分为很多小的任务，这些小的任务执行时间比较短，可以穿插在其他的 JavaScript 任务中间执行，这样当执行上述动画效果时，就不会让用户因为垃圾回收任务而感受到页面的卡顿了。</p>\n<h2 id="总结-1"><a href="#%E6%80%BB%E7%BB%93-1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总结</h2>\n<p>首先我们介绍了不同语言的垃圾回收策略，然后又说明了栈中的数据是如何回收的，最后重点讲解了 JavaScript 中的垃圾回收器是如何工作的。</p>\n<p>从上面的分析你也能看出来，无论是垃圾回收的策略，还是处理全停顿的策略，往往都没有一个完美的解决方案，你需要花一些时间来做权衡，而这需要牺牲当前某几方面的指标来换取其他几个指标的提升。</p>\n<p>其实站在工程师的视角，我们经常需要在满足需求的前提下，权衡各个指标的得失，把系统设计得尽可能适应最核心的需求。</p>\n<p>生活中处理事情的原则也与之类似，古人很早就说过“两害相权取其轻，两利相权取其重”，所以与其患得患失，不如冷静地分析哪些才是核心诉求，然后果断决策牺牲哪些以使得利益最大化。</p>\n<h1 id="编译器和解析器：v8-如何执行一段-javascript-代码的"><a href="#%E7%BC%96%E8%AF%91%E5%99%A8%E5%92%8C%E8%A7%A3%E6%9E%90%E5%99%A8%EF%BC%9Av8-%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E4%B8%80%E6%AE%B5-javascript-%E4%BB%A3%E7%A0%81%E7%9A%84" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>编译器和解析器：V8 如何执行一段 JavaScript 代码的</h1>\n<p>前面我们已经花了很多篇幅来介绍 JavaScript 是如何工作的，了解这些内容能帮助你从底层理解 JavaScript 的工作机制，从而能帮助你更好地理解和应用 JavaScript。</p>\n<p>今天这篇文章我们就继续“向下”分析，站在 JavaScript 引擎 V8 的视角，来分析 JavaScript 代码是如何被执行的。</p>\n<p>前端工具和框架的自身更新速度非常快，而且还不断有新的出现。要想追赶上前端工具和框架的更新速度，你就需要抓住那些本质的知识，然后才能更加轻松地理解这些上层应用。比如我们接下来要介绍的 V8 执行机制，能帮助你从底层了解 JavaScript，也能帮助你深入理解语言转换器 Babel、语法检查工具 ESLint、前端框架 Vue 和 React 的一些底层实现机制。因此，了解 V8 的编译流程能让你对语言以及相关工具有更加充分的认识。</p>\n<p>要深入理解 V8 的工作原理，你需要搞清楚一些概念和原理，比如接下来我们要详细讲解的编译器（Compiler）、解释器（Interpreter）、抽象语法树（AST）、字节码（Bytecode）、即时编译器（JIT）等概念，都是你需要重点关注的。</p>\n<h2 id="编译器和解释器"><a href="#%E7%BC%96%E8%AF%91%E5%99%A8%E5%92%8C%E8%A7%A3%E9%87%8A%E5%99%A8" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>编译器和解释器</h2>\n<p>之所以存在编译器和解释器，是因为机器不能直接理解我们所写的代码，所以在执行程序之前，需要将我们所写的代码“翻译”成机器能读懂的机器语言。按语言的执行流程，可以把语言划分为编译型语言和解释型语言。</p>\n<p>编译型语言在程序执行之前，需要经过编译器的编译过程，并且编译之后会直接保留机器能读懂的二进制文件，这样每次运行程序时，都可以直接运行该二进制文件，而不需要再次重新编译了。比如 C/C++、GO 等都是编译型语言。</p>\n<p>而由解释型语言编写的程序，在每次运行时都需要通过解释器对程序进行动态解释和执行。比如 Python、JavaScript 等都属于解释型语言。</p>\n<p>那编译器和解释器是如何“翻译”代码的呢？具体流程你可以参考下图</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-05-14-17-59-b2dc07e44bcdda21710e54d53790c2bc-fc057.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 53.46260387811634%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABn0lEQVQoz2VSS2sUQRDe/yje/QEBr4LBf5CDRy96FAJJIGAOYhAJhARcTNSQiMRE17g7O9M7uzv9qEc/Ut27K4l+9AwfVd1V9VVVL6UUM0KKYYHM05L/JWIsR36ZFFfqee+ValSH1QwcACNcNzBQQtzcwLcKtHUE9pfKRme1tjC3aK2VOD1AHN4MNg7D2htq1GTWqsd7+GwfEkw/XNoHm/5kYEi3T97y+jukrjm4NM+PAiFI+p5kB3DXir43XmsD1pz8ofPKp+Qnhg+uWEPmn4f8ZciionPcmOCcC4vHWQFT9MQFKbL3hEieKUXKQIohn4Ux+GzLmuUT2cFDipivZTcKZy43IoaQgwbGyHgXq4Y19cff/P4HzeYd2e6iwten1M463XVbZ3x8pd1cXYzgbMSricRl2QB4M/j5oh+f7nOtWm/a3XN6uMkTjQju0Q6/7EsSt/2VXn0KZa6ptAmWmqUGY8E6lHhidYBTjaLNM08NGhB+v2JcjerukpQFKCvAIh4lkOgv2in8h2XD/oE46roej8fVaDSu62lBXJR7H7cw9nMkHYofLAAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 05 14 17 59"\n        title=""\n        src="/static/2021-07-05-14-17-59-b2dc07e44bcdda21710e54d53790c2bc-fee1c.png"\n        srcset="/static/2021-07-05-14-17-59-b2dc07e44bcdda21710e54d53790c2bc-a67b7.png 200w,\n/static/2021-07-05-14-17-59-b2dc07e44bcdda21710e54d53790c2bc-0b187.png 400w,\n/static/2021-07-05-14-17-59-b2dc07e44bcdda21710e54d53790c2bc-fee1c.png 800w,\n/static/2021-07-05-14-17-59-b2dc07e44bcdda21710e54d53790c2bc-b1a91.png 1200w,\n/static/2021-07-05-14-17-59-b2dc07e44bcdda21710e54d53790c2bc-fc057.png 1444w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从图中你可以看出这二者的执行流程，大致可阐述为如下：</p>\n<ul>\n<li>在编译型语言的编译过程中，编译器首先会依次对源代码进行词法分析、语法分析，生成抽象语法树（AST），然后是优化代码，最后再生成处理器能够理解的机器码。如果编译成功，将会生成一个可执行的文件。但如果编译过程发生了语法或者其他的错误，那么编译器就会抛出异常，最后的二进制文件也不会生成成功</li>\n<li>在解释型语言的解释过程中，同样解释器也会对源代码进行词法分析、语法分析，并生成抽象语法树（AST），不过它会再基于抽象语法树生成字节码，最后再根据字节码来执行程序、输出结果。</li>\n</ul>\n<h2 id="v8-是如何执行一段-javascript-代码的"><a href="#v8-%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E4%B8%80%E6%AE%B5-javascript-%E4%BB%A3%E7%A0%81%E7%9A%84" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>V8 是如何执行一段 JavaScript 代码的</h2>\n<p>通过上面的介绍，相信你已经了解编译器和解释器了。那接下来，我们就重点分析下 V8 是如何执行一段 JavaScript 代码的。你可以先来“一览全局”，参考下图：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-05-14-18-38-2ed8ee16a1f022fed83c2811bd01ea77-7a87e.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 61.07692307692307%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACMklEQVQoz22SS4/SUBTH+Ux+BxO/gVvd6M7EGBfOzseYmKjRhQs3JmZGRZnhJeUhA0NHRkIpDEJ5BfpgKC20ZSh99/ZxLahRx7n55Z67OL/8T25OCELo++eBPrQcXzY9A3jwouNv7lBQzLOxMfmms5jJVgP0SRXOKx+PiEvPp3eip+akIg1QicIkUhy9eHZy42rj1nW2hNmWs5EFAlJhf7zvUklnA6Sjsw5SrhxmC3m1+d5ovbNHmWECbW5t09tP+EePJaRiqGYoSFfng1f5wcsCIxAJ8fsna7D/ptS/h8z5RsTCX1fwys3ootVvCzmUCRfKxen9LEDyU1dR1vJqNrib4G5/XjL4HlvdFRu7T3PktT2VbmXhMJw8rl/ZsctNgkXxbrh4GG8/iC2Q3MRV1PXYltD1yKhLpwCVsqm0S8bb9XwRw30m5TJZtR8b1SI+h4rYcJJriUVCPmgu0I6haBtZ7Hlk3KXTgArIQCa5leIv73hMpwhPkUUrIp+89bkjERtxX9pcgeDybb7U/SMDMgHoDKDTNp2G41S5XvvwtauTWW+cFrpID0uYbFmqjaaBXOxwBwSP9n7JptABoxigkGDsn/hMAjIxm0xBOn5cxx6mWWqIK/hgkv0reaWtPwwYsi2z9oqzlQ3rB2+rc6DwrjpztbmnzYAm6NJKmy21+QZh6QAQunCBXA8almM7nmEB3bA1w3I9//+20O9t+wfHAbK8NHRdkVdni4UkikHO+UYIfwACYHTKWvHKHgAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 05 14 18 38"\n        title=""\n        src="/static/2021-07-05-14-18-38-2ed8ee16a1f022fed83c2811bd01ea77-fee1c.png"\n        srcset="/static/2021-07-05-14-18-38-2ed8ee16a1f022fed83c2811bd01ea77-a67b7.png 200w,\n/static/2021-07-05-14-18-38-2ed8ee16a1f022fed83c2811bd01ea77-0b187.png 400w,\n/static/2021-07-05-14-18-38-2ed8ee16a1f022fed83c2811bd01ea77-fee1c.png 800w,\n/static/2021-07-05-14-18-38-2ed8ee16a1f022fed83c2811bd01ea77-b1a91.png 1200w,\n/static/2021-07-05-14-18-38-2ed8ee16a1f022fed83c2811bd01ea77-7a87e.png 1300w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从图中可以清楚地看到，V8 在执行过程中既有解释器 Ignition，又有编译器 TurboFan，那么它们是如何配合去执行一段 JavaScript 代码的呢? 下面我们就按照上图来一一分解其执行流程。</p>\n<h3 id="生成抽象语法树（ast）和执行上下文"><a href="#%E7%94%9F%E6%88%90%E6%8A%BD%E8%B1%A1%E8%AF%AD%E6%B3%95%E6%A0%91%EF%BC%88ast%EF%BC%89%E5%92%8C%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>生成抽象语法树（AST）和执行上下文</h3>\n<p>将源代码转换为抽象语法树，并生成执行上下文，而执行上下文我们在前面的文章中已经介绍过很多了，主要是代码在执行过程中的环境信息。</p>\n<p>那么下面我们就得重点讲解下抽象语法树（下面表述中就直接用它的简称 AST 了），看看什么是 AST 以及 AST 的生成过程是怎样的。</p>\n<p>高级语言是开发者可以理解的语言，但是让编译器或者解释器来理解就非常困难了。对于编译器或者解释器来说，它们可以理解的就是 AST 了。所以无论你使用的是解释型语言还是编译型语言，在编译过程中，它们都会生成一个 AST。这和渲染引擎将 HTML 格式文件转换为计算机可以理解的 DOM 树的情况类似。</p>\n<p>你可以结合下面这段代码来直观地感受下什么是 AST：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="52966210411842220000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`var myName = \'极客时间\';\nfunction foo() {\n  return 23;\n}\nmyName = \'geektime\';\nfoo();`, `52966210411842220000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                data-tooltip="复制"\n              >\n                <svg class="gatsby-code-button-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M16 1H2v16h2V3h12V1zm-1 4l6 6v12H6V5h9zm-1 7h5.5L14 6.5V12z"/></svg>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">var</span> myName <span class="token operator">=</span> <span class="token string">\'极客时间\'</span><span class="token punctuation">;</span>\n<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token number">23</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\nmyName <span class="token operator">=</span> <span class="token string">\'geektime\'</span><span class="token punctuation">;</span>\n<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>这段代码经过 javascript-ast 站点处理后，生成的 AST 结构如下：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-05-14-19-46-44c46d8ae0c32eb24edf18b902ae31c3-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 143.95796847635728%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAdCAIAAAAl5NuSAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAC5UlEQVQ4y6WU/U+SURTH+ydbq1yguLbSSAgwLX+r6GUtZyoymJQb6BLNmdAKzRAiKMg2J2zIW0rES8oDCPjw3JcOXHJGgLTOD/d5dnc/95x7zvecM/Q/7Az78DxvMBh0Op12amp2drZTmBACn2Kx2NPTIxKJxSKxQqH4N89gGGNY7Xa7UqlUqVT9/f0bGxvH+6fApGbBYHC5Zlqt1uFwpFKp+O4uqlTgDlqLsTkMVqkZ/CCEJjUamUwmlclU99T7+Ty7vR0sCALAmBlCPCGl8A7Va6hphuomqfM9i7AdXHdCCLz1KBYWpsfKL6aP9E+QY7UdDCTw9RTQ6qEQtz0RGzTGH2piQ+v7C8f7TeDq6VB4bW3N6XRardbQTqjEFyKZzUQhGM/7s+Uf9WubZhvWFYtFIpEMyORS6TW3+2O9VOQk0jphLGwQ3OjoqFx+Qy6Xj4zc5jiuo2wzGEpls62azWaTyTg+/jQQCERjkXQmBXEggo6f3RwGJ0xYfr+/t7e3u7v7/Nkug3amQXDNYXYIDOLnclyeO/wQXX4VmrAnTKt7z3J8mqW9Ccx0SjD8ILiE0Kqrz+mVheiD5ejYYuTRwVGiEWbxWCxWsVh8ta/v4qXLr99WGwNhTE5tDGbJZNLr9brdbtcbfdL/knKfcMZNhTIWBIx4TBBulTBUs1rRMQ3fwb5zyHsBBQcw4sif8mgOw5vrjUEIpK4c2aMTGmrQ0bHH9J2tnbYZzPwjgYeSHu6G8ovavG0ut6QvbzpPgeth/26AcHZrMqwwfruviSjXM/MtG4OpD1RhNs/DJIExCMLCVMjkYtlS4qAYL/LcKTMM+gkG4NDw8KBK5fF4Op1hJ/0DoFaroeBdIpHkujSdzVY32zcGw+DZMBV8Pp/T5XLZbJ7nhvLXL3R7iyS+t0vY3zGQWJjevUnVt+jgFbo01ymMqlqqhDP5mUBhKVIyBkvuVKVBKC1hdihRqJhjvDVeXX0/hQb4Fwh4QJV0syU+AAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 05 14 19 46"\n        title=""\n        src="/static/2021-07-05-14-19-46-44c46d8ae0c32eb24edf18b902ae31c3-fee1c.png"\n        srcset="/static/2021-07-05-14-19-46-44c46d8ae0c32eb24edf18b902ae31c3-a67b7.png 200w,\n/static/2021-07-05-14-19-46-44c46d8ae0c32eb24edf18b902ae31c3-0b187.png 400w,\n/static/2021-07-05-14-19-46-44c46d8ae0c32eb24edf18b902ae31c3-fee1c.png 800w,\n/static/2021-07-05-14-19-46-44c46d8ae0c32eb24edf18b902ae31c3-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从图中可以看出，AST 的结构和代码的结构非常相似，其实你也可以把 AST 看成代码的结构化的表示，编译器或者解释器后续的工作都需要依赖于 AST，而不是源代码。</p>\n<p>AST 是非常重要的一种数据结构，在很多项目中有着广泛的应用。其中最著名的一个项目是 Babel。Babel 是一个被广泛使用的代码转码器，可以将 ES6 代码转为 ES5 代码，这意味着你可以现在就用 ES6 编写程序，而不用担心现有环境是否支持 ES6。Babel 的工作原理就是先将 ES6 源码转换为 AST，然后再将 ES6 语法的 AST 转换为 ES5 语法的 AST，最后利用 ES5 的 AST 生成 JavaScript 源代码。</p>\n<p>除了 Babel 外，还有 ESLint 也使用 AST。ESLint 是一个用来检查 JavaScript 编写规范的插件，其检测流程也是需要将源码转换为 AST，然后再利用 AST 来检查代码规范化的问题。</p>\n<p>现在你知道了什么是 AST 以及它的一些应用，那接下来我们再来看下 AST 是如何生成的。通常，生成 AST 需要经过两个阶段。</p>\n<p>第一阶段是分词（tokenize），又称为词法分析，其作用是将一行行的源码拆解成一个个 token。所谓 token，指的是语法上不可能再分的、最小的单个字符或字符串。你可以参考下图来更好地理解什么 token。</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-05-14-20-00-ccfce4dcfb994f03af63d60a1cd0b5d1-e3990.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 60.36484245439468%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABmElEQVQoz41Su0oDQRTN14ifYJHW0s5CELQTCysbtbYXhUiIKQVFS1HER8BGUQmahQ3ZRx5m3SS7STaPnexjdmYnzuzKGo0GL1PM45x7zr13YsOx8H1fkiSO4xRFGU6M2PgVIaRUKmUymYIghsdJZPoMEaJrFOe6Tq1aHHoWgQMK+ZNcaeorqeRyYu8uz9Mjxohisal10rPgeAEczROnH1jyWRLylYqRVaO9epBcSuw+iEJYM0NC07nZBCeL1sU6QXZY0C/KEHmPoiA0GkipuAXezmXtlycnz7myiFsi6hum3DDlel9QrWrLrndAWYM965PsYZwtSorRJlrd5jlXKjg85/A5m3sl0BoSPHhrWu+M5pmOZ9q9gkqwP9LtoFUEukZqR9veoLJBjX5k1oeoenov7V+CYj0aQSyaLWtVu1mei8szU93DNEN4MIAxnKP3ruNb59NrcuqKPX1TDuUxdmXqOYc7RmQnVMaup91y6tkzKGk/lccDY0ztUBBCiO7/98PYMH1ara7r3W4XAFCr1egmbAEJ0kXYDyj0obVDwqusAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 05 14 20 00"\n        title=""\n        src="/static/2021-07-05-14-20-00-ccfce4dcfb994f03af63d60a1cd0b5d1-fee1c.png"\n        srcset="/static/2021-07-05-14-20-00-ccfce4dcfb994f03af63d60a1cd0b5d1-a67b7.png 200w,\n/static/2021-07-05-14-20-00-ccfce4dcfb994f03af63d60a1cd0b5d1-0b187.png 400w,\n/static/2021-07-05-14-20-00-ccfce4dcfb994f03af63d60a1cd0b5d1-fee1c.png 800w,\n/static/2021-07-05-14-20-00-ccfce4dcfb994f03af63d60a1cd0b5d1-b1a91.png 1200w,\n/static/2021-07-05-14-20-00-ccfce4dcfb994f03af63d60a1cd0b5d1-e3990.png 1206w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从图中可以看出，通过 var myName = “极客时间”简单地定义了一个变量，其中关键字“var”、标识符“myName” 、赋值运算符“=”、字符串“极客时间”四个都是 token，而且它们代表的属性还不一样。</p>\n<p>第二阶段是解析（parse），又称为语法分析，其作用是将上一步生成的 token 数据，根据语法规则转为 AST。如果源码符合语法规则，这一步就会顺利完成。但如果源码存在语法错误，这一步就会终止，并抛出一个“语法错误”。</p>\n<p>这就是 AST 的生成过程，先分词，再解析。</p>\n<p>有了 AST 后，那接下来 V8 就会生成该段代码的执行上下文。至于执行上下文的具体内容，你可以参考前面几篇文章的讲解。</p>\n<h3 id="生成字节码"><a href="#%E7%94%9F%E6%88%90%E5%AD%97%E8%8A%82%E7%A0%81" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>生成字节码</h3>\n<p>有了 AST 和执行上下文后，那接下来的第二步，解释器 Ignition 就登场了，它会根据 AST 生成字节码，并解释执行字节码。</p>\n<p>其实一开始 V8 并没有字节码，而是直接将 AST 转换为机器码，由于执行机器码的效率是非常高效的，所以这种方式在发布后的一段时间内运行效果是非常好的。但是随着 Chrome 在手机上的广泛普及，特别是运行在 512M 内存的手机上，内存占用问题也暴露出来了，因为 V8 需要消耗大量的内存来存放转换后的机器码。为了解决内存占用问题，V8 团队大幅重构了引擎架构，引入字节码，并且抛弃了之前的编译器，最终花了将进四年的时间，实现了现在的这套架构。</p>\n<p>那什么是字节码呢？为什么引入字节码就能解决内存占用问题呢？</p>\n<p>字节码就是介于 AST 和机器码之间的一种代码。但是与特定类型的机器码无关，字节码需要通过解释器将其转换为机器码后才能执行。</p>\n<p>理解了什么是字节码，我们再来对比下高级代码、字节码和机器码，你可以参考下图</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-05-14-20-28-a51833171add1250d3cdc4af5ca00a04-3adf4.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 40.779610194902546%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAIAAAB2/0i6AAAACXBIWXMAAA7DAAAOwwHHb6hkAAAA0ElEQVQY06VQ0Y6DIBDs//9jY04EFBRlqQgUuJuqyeWuSdOk8wLLzOwOe/n+AJc3dTFFWmkN65a2dE+/5lrrC9vBLXZd6MY6NU42pvSw1HpOziU7f/NxC9EfvXzYDC3k3VE6F8iFayvkYKz1pdRz8jzPejSdULIfZPulh56IGJMtk6MxYK21vVRDr4VQoFAqpWKMDzMOY4zgfNS6lJJzTghWCmyMsRDCfQeUQoimaZAFj1CesXEDDdv/D/9dBzTo+2rbaDRNU7dD7uCcI+qz8gfZoNI9AIQfcwAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 05 14 20 28"\n        title=""\n        src="/static/2021-07-05-14-20-28-a51833171add1250d3cdc4af5ca00a04-fee1c.png"\n        srcset="/static/2021-07-05-14-20-28-a51833171add1250d3cdc4af5ca00a04-a67b7.png 200w,\n/static/2021-07-05-14-20-28-a51833171add1250d3cdc4af5ca00a04-0b187.png 400w,\n/static/2021-07-05-14-20-28-a51833171add1250d3cdc4af5ca00a04-fee1c.png 800w,\n/static/2021-07-05-14-20-28-a51833171add1250d3cdc4af5ca00a04-b1a91.png 1200w,\n/static/2021-07-05-14-20-28-a51833171add1250d3cdc4af5ca00a04-3adf4.png 1334w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从图中可以看出，机器码所占用的空间远远超过了字节码，所以使用字节码可以减少系统的内存使用。</p>\n<h3 id="执行代码"><a href="#%E6%89%A7%E8%A1%8C%E4%BB%A3%E7%A0%81" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>执行代码</h3>\n<p>生成字节码之后，接下来就要进入执行阶段了。</p>\n<p>通常，如果有一段第一次执行的字节码，解释器 Ignition 会逐条解释执行。在执行字节码的过程中，如果发现有热点代码（HotSpot），比如一段代码被重复执行多次，这种就称为热点代码，那么后台的编译器 TurboFan 就会把该段热点的字节码编译为高效的机器码，然后当再次执行这段被优化的代码时，只需要执行编译后的机器码就可以了，这样就大大提升了代码的执行效率。</p>\n<p>V8 的解释器和编译器的取名也很有意思。解释器 Ignition 是点火器的意思，编译器 TurboFan 是涡轮增压的意思，寓意着代码启动时通过点火器慢慢发动，一旦启动，涡轮增压介入，其执行效率随着执行时间越来越高效率，因为热点代码都被编译器 TurboFan 转换了机器码，直接执行机器码就省去了字节码“翻译”为机器码的过程。</p>\n<p>其实字节码配合解释器和编译器是最近一段时间很火的技术，比如 Java 和 Python 的虚拟机也都是基于这种技术实现的，我们把这种技术称为即时编译（JIT）。具体到 V8，就是指解释器 Ignition 在解释执行字节码的同时，收集代码信息，当它发现某一部分代码变热了之后，TurboFan 编译器便闪亮登场，把热点的字节码转换为机器码，并把转换后的机器码保存起来，以备下次使用。</p>\n<p>对于 JavaScript 工作引擎，除了 V8 使用了“字节码 +JIT”技术之外，苹果的 SquirrelFish Extreme 和 Mozilla 的 SpiderMonkey 也都使用了该技术。</p>\n<p>这么多语言的工作引擎都使用了“字节码 +JIT”技术，因此理解 JIT 这套工作机制还是很有必要的。你可以结合下图看看 JIT 的工作过程：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-05-14-20-54-8045c545088f5f05a98e2208382f5db2-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 108.66900175131349%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAWCAIAAABPIytRAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACTElEQVQ4y6WTS09TQRTHZ+VCXeHGlRt3Ji40fAuXJvoJdOUnIDFujImG8Igu1IUQsYHEmACiiY/EBlRQEKgRKKb0hX1R7mPu9La9987M37mdaik0tomzuDn3zPnNOfOfcwj+Y5GjLinD75aNyA4mk5jJIBA9wzr0dgzkCU48w+kpML9xaC+waES9zeP6JzHw1R9Ya3q6Z9ZhLMCKgW8lbyHtrJr4SWVPsE6yboCM49Qkzr4AGcOVaGurO7xaxvEJnHkewicncPVDb7AOsD3M7uJ1xp9NuMpYLsteBZONpYxKzcsbjn48zrl2doGTqRS1LMfH5SguzCFhc0ixFY9Xq9V/wep40zRt6vguXcx7fVOhbOPbAWqORR1K6aHkbXAQ+C4L6+SNoOkMhje1VOEvo7YQojOs3AXH286bpg9fNBXSiWpcphnWs0aSck+0w83nMdA/Jy+9E/2vsFBq9qlu1aU9nJvG+RlcfKmUb1xQ/oG1tbgHMmqRwV0ysv8m14zQW9GcIENFMlwgo6X5Am+DdW2Gh7EN93GMRhKiWG2OlxboV0Xei/l3ltlgzM+78u/kte4shajv533XaY1le+8EVeaaZXlAsxbMhdhJpU3bkeFtZZ2jLqDkqfFQP1UrZZVkOhMEQSeY82w2yxjTTXao58KGq1TK5bLomFkt13VNy1byLxX9G19waw13v+PaZ7zPhQB1WLFYVDk6wyqD7TDU6NCKQx7i2FP0RSR5gJsfXbiWYVGV/GBRnUfyh4WRDTyK4/5maKh3DgU9Mla/AbcF1nHyw70qAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 05 14 20 54"\n        title=""\n        src="/static/2021-07-05-14-20-54-8045c545088f5f05a98e2208382f5db2-fee1c.png"\n        srcset="/static/2021-07-05-14-20-54-8045c545088f5f05a98e2208382f5db2-a67b7.png 200w,\n/static/2021-07-05-14-20-54-8045c545088f5f05a98e2208382f5db2-0b187.png 400w,\n/static/2021-07-05-14-20-54-8045c545088f5f05a98e2208382f5db2-fee1c.png 800w,\n/static/2021-07-05-14-20-54-8045c545088f5f05a98e2208382f5db2-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<h2 id="javascript-的性能优化"><a href="#javascript-%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>JavaScript 的性能优化</h2>\n<p>到这里相信你现在已经了解 V8 是如何执行一段 JavaScript 代码的了。在过去几年中，JavaScript 的性能得到了大幅提升，这得益于 V8 团队对解释器和编译器的不断改进和优化。</p>\n<p>虽然在 V8 诞生之初，也出现过一系列针对 V8 而专门优化 JavaScript 性能的方案，比如隐藏类、内联缓存等概念都是那时候提出来的。不过随着 V8 的架构调整，你越来越不需要这些微优化策略了，相反，对于优化 JavaScript 执行效率，你应该将优化的中心聚焦在单次脚本的执行时间和脚本的网络下载上，主要关注以下三点内容</p>\n<ul>\n<li>提升单次脚本的执行速度，避免 JavaScript 的长任务霸占主线程，这样可以使得页面快速响应交互；</li>\n<li>避免大的内联脚本，因为在解析 HTML 的过程中，解析和编译也会占用主线程；</li>\n<li>减少 JavaScript 文件的容量，因为更小的文件会提升下载速度，并且占用更低的内存</li>\n</ul>\n<h2 id="总结-2"><a href="#%E6%80%BB%E7%BB%93-2" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总结</h2>\n<ul>\n<li>首先我们介绍了编译器和解释器的区别。</li>\n<li>紧接着又详细分析了 V8 是如何执行一段 JavaScript 代码的：V8 依据 JavaScript 代码生成 AST 和执行上下文，再基于 AST 生成字节码，然后通过解释器执行字节码，通过编译器来优化编译字节码。</li>\n<li>基于字节码和编译器，我们又介绍了 JIT 技术。</li>\n<li>最后我们延伸说明了下优化 JavaScript 性能的一些策略。</li>\n</ul>\n<p>之所以在本专栏里讲 V8 的执行流程，是因为我觉得编译器和解释器的相关概念和理论对于程序员来说至关重要，向上能让你充分理解一些前端应用的本质，向下能打开计算机编译原理的大门。通过这些知识的学习能让你将很多模糊的概念关联起来，使其变得更加清楚，从而拓宽视野，上升到更高的层次。</p>',
id:"/github/workspace/blog/浏览器工作原理与实践——V8工作原理/index.md absPath of file >>> MarkdownRemark",timeToRead:15,frontmatter:{date:"2021-07-05 11:30:26",path:"/browser-working-principle-v8/",tags:"前端, 浏览器, 高级前端",title:"浏览器工作原理与实践——V8工作原理",draft:null}},{excerpt:"Chrome 架构 在开始之前，我们一起看下，Chrome 打开一个页面需要启动多少进程？你可以点击 Chrome 浏览器右上角的“选项”菜单，选择“更多工具”子菜单，点击“任务管理器”，这将打开 Chrome 的任务管理器的窗口，如下图 和 Windows 任务管理器一样，Chrome 任务管理器也是用来展示运行中 Chrome 使用的进程信息的。从图中可以看到，Chrome 启动了 4 个进程，你也许会好奇，只是打开了…",html:'<h1 id="chrome-架构"><a href="#chrome-%E6%9E%B6%E6%9E%84" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Chrome 架构</h1>\n<p>在开始之前，我们一起看下，Chrome 打开一个页面需要启动多少进程？你可以点击 Chrome 浏览器右上角的“选项”菜单，选择“更多工具”子菜单，点击“任务管理器”，这将打开 Chrome 的任务管理器的窗口，如下图</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-01-16-58-08-24d148ec13da8eb39ea10a69aab6b6c8-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 59.982486865148864%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAB+UlEQVQoz4WQ3U4TURDH9yWMLWBtz36c/Tx7drsfLSDdLgVEAjTRmJCAd6WlGLoSL1Bky8KiItrt9hHUGwlemfgCvpiz5QYulOSXyZw58/9nZpg/v36nb1qHg17v9X4Q7O8FweG7ow8fz88/XUAShsdhPzoK+wcHb3vBq71eABHatrc7Py4vmcHFZ4weUksXsChiGWNJlBRF0VSVqBqxbReiYVoaoaIkm+UssZ3KxOSDMOwzSZIalVrNm9eIrhsmNcsQiU5FWdGpubrWtN1KdWbWrc4oKll8vDzn1Z8+ey7JShyfMelwmLPWao0n9bpPdIPoJmhUQkuI5wVxruYtLCxxHHbcKmL5YolVNd2fbzhOJYpOmGQ46u22m+tNy66AvVm2y5Zj2S6MJ2DJq/u+38BYhm4Qg52m0UZj0bKcKDplBkk6PW14nqeoOieIsLMwBnKWE2AKkIEGVoInx2NRVl23KsvqyWnMpOno3v08fLAsn8UbcJyAEFcqsdcJN65kbayQy03EZ+8zMZwODMH1Fhz+VwWmm5wqxPFYnM9P8QJGmWUGGsPeAN0G9CAZXzsdFYuIUlPT9DshhAKGUUaIzcYefEkKhaJpWtcf/wHEs4+8peWVldV1VaP944i5uvq5sbHZ6XRbrfadtNs7nZ1ud/fl5taLr9++/wVH6rYYMlmo1gAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 01 16 58 08"\n        title=""\n        src="/static/2021-07-01-16-58-08-24d148ec13da8eb39ea10a69aab6b6c8-fee1c.png"\n        srcset="/static/2021-07-01-16-58-08-24d148ec13da8eb39ea10a69aab6b6c8-a67b7.png 200w,\n/static/2021-07-01-16-58-08-24d148ec13da8eb39ea10a69aab6b6c8-0b187.png 400w,\n/static/2021-07-01-16-58-08-24d148ec13da8eb39ea10a69aab6b6c8-fee1c.png 800w,\n/static/2021-07-01-16-58-08-24d148ec13da8eb39ea10a69aab6b6c8-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>和 Windows 任务管理器一样，Chrome 任务管理器也是用来展示运行中 Chrome 使用的进程信息的。从图中可以看到，Chrome 启动了 4 个进程，你也许会好奇，只是打开了 1 个页面，为什么要启动这么多进程呢？</p>\n<p>在解答这个问题之前，我们需要了解一下进程的概念，不过由于好多人容易把进程和线程的概念混淆，从而影响后续其他概念的理解，所以这里我就将这两个概念以及它们之间的关系一并为你讲解下。</p>\n<h2 id="进程和线程"><a href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>进程和线程</h2>\n<p>不过，在介绍进程和线程之前，我需要先讲解下什么是并行处理，因为如果你理解了并行处理的概念，那么再理解进程和线程之间的关系就会变得轻松许多。</p>\n<h3 id="什么是并行处理"><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>什么是并行处理</h3>\n<p>计算机中的并行处理就是同一时刻处理多个任务，比如我们要计算下面这三个表达式的值，并显示出结果</p>\n<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">A = 1+2\nB = 20/5\nC = 7*8</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span></span></pre></div>\n<p>在编写代码的时候，我们可以把这个过程拆分为四个任务：</p>\n<ul>\n<li>任务 1 是计算 A=1+2；</li>\n<li>任务 2 是计算 B=20/5；</li>\n<li>任务 3 是计算 C=7*8；</li>\n<li>任务 4 是显示最后计算的结果</li>\n</ul>\n<p>正常情况下程序可以使用单线程来处理，也就是分四步按照顺序分别执行这四个任务。</p>\n<p>如果采用多线程，会怎么样呢？我们只需分“两步走”：第一步，使用三个线程同时执行前三个任务；第二步，再执行第四个显示任务。</p>\n<p>通过对比分析，你会发现用单线程执行需要四步，而使用多线程只需要两步。因此，使用并行处理能大大提升性能</p>\n<h3 id="线程-vs-进程"><a href="#%E7%BA%BF%E7%A8%8B-vs-%E8%BF%9B%E7%A8%8B" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>线程 VS 进程</h3>\n<p>多线程可以并行处理任务，但是线程是不能单独存在的，它是由进程来启动和管理的。那什么又是进程呢？</p>\n<p>一个进程就是一个程序的运行实例。详细解释就是，启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫进程。</p>\n<p>为了让你更好地理解上述计算过程，我画了下面这张对比图</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-01-17-00-46-687c7cb62d625aa36a786fa5988d5ff2-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 50.350262697022764%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABxElEQVQozyVSy4rUQBSNS3d+gxvXCuJWEPwKEcGNf6H+y9AiKPhixI2CIqgLRZmVzPRgku7pVKXer1RVkvKk+5JUHW7Vuffce6sqpSil/tW1kLJt2/V6zTmHc9zbNE1N03RdRwhZn58DD8Mwz/PhqNJKsZ4KxiQliuw4IT0h3nsHM4ZR6izMbJqG9f3i01owAGuMqZSU2IP3LWU14cZYqzUOcC8iixJzDCnnBQwOCVMIo1UpeNyqrHM5Ru7C7eP2yrP6xakocxJKp5S8Mfc+d/e/kFLy41/80TdWcvxJ3M3j3ZszMXmQrdNSCj9ce0erI7I6VbgqtPEh8J4+/S2f/IFnvPPh4uqri+TdCTEPv6tPtUxOV5CIGqSPN95uL622q7+iJC+1gb+nNKc0paGU+cHX/u5HtijytkxjGlCor/ADCBeuv26qo+b5mTrIzjkLAUERX5nnnXJbHZaaUwoxQReaUjnvI8g23HpPLr/kII+ac6VAllLGvWE2kAADOe8tHMjIjG4jxEmnfmwktaFMk9ZLwxjDdHrkx9gZ58DzNCEWZo5xLLKxIQPeiaKk3zRWK4x1iWgt/ODjzSAPVuCDH1FwBPAfWE0ipIeX/78AAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 01 17 00 46"\n        title=""\n        src="/static/2021-07-01-17-00-46-687c7cb62d625aa36a786fa5988d5ff2-fee1c.png"\n        srcset="/static/2021-07-01-17-00-46-687c7cb62d625aa36a786fa5988d5ff2-a67b7.png 200w,\n/static/2021-07-01-17-00-46-687c7cb62d625aa36a786fa5988d5ff2-0b187.png 400w,\n/static/2021-07-01-17-00-46-687c7cb62d625aa36a786fa5988d5ff2-fee1c.png 800w,\n/static/2021-07-01-17-00-46-687c7cb62d625aa36a786fa5988d5ff2-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从图中可以看到，线程是依附于进程的，而进程中使用多线程并行处理能提升运算效率。</p>\n<p>总结来说，进程和线程之间的关系有以下 4 个特点</p>\n<ol>\n<li>\n<p>进程中的任意一线程执行出错，都会导致整个进程的崩溃。</p>\n<p>我们可以模拟以下场景：</p>\n<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">A = 1+2\nB = 20/0\nC = 7*8</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span></span></pre></div>\n<p>我把上述三个表达式稍作修改，在计算 B 的值的时候，我把表达式的分母改成 0，当线程执行到 B = 20/0 时，由于分母为 0，线程会执行出错，这样就会导致整个进程的崩溃，当然另外两个线程执行的结果也没有了</p>\n</li>\n<li>\n<p>线程之间共享进程中的数据。</p>\n<p>如下图所示，线程之间可以对进程的公共数据进行读写操作。</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-01-18-39-03-ef151acdbd0c54e8f3aa8a46d03f6465-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 69.0893169877408%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAIAAACgpqunAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACHUlEQVQoz41TS6rUQBTNDkRwDc6cOHULDgUnLkFwI4IbcCCCqCMfDwRx4ESegg4c+aDblv4nnU+lfql/VeLJSyv9Zp5Uqkjdczn3l2y4jr7vsVPG5vM59qqqFovfy+UyL/LRep2cpb6XQgjGBGdGdUYppy2nlJSVoPRQ5FVRVIcDb6lVWncdFu4F5zHGDC++ASV48sE6e6AHF1wlKmVUnucgQKQRjdQScQXnOs4h5pzLUkpKSoQ7pCTbijHSCuKcJbzpFJe0SjH1MVFB4Kw6Jtsa0Ts7YlSWUjqjvGKDJkMM2miDZc0Q/GC5N6NVaeW974PFTTCd6sSkHK11Qx+CYVISG6LHk2JIwYUgBfFdPfjORY+YtfOcVUGTYISFM5SVsUO0L2fs1hm5c54zrVFXprpHn3a33+WvZhQ5owqtdvfeb2+82Z0tBQjwGnNuGVO0+bBsH37hj7/WwhjYuNL3P+5vvt0//9nA2UYPrSffyIPP5CKXICCxDIayLNFP3aGYyMEoq0Lyu7a8e77OXjdPf+yHwQunQ/DeGiQUrIkpHQuGAzVDs1FzY0yI4UpZvrgsn12K7/sxbIxDgJe1Ez/9c0bd2hPAMA4TKonGGpGsnuYJTEIICBA4OuOAZl3XMKxWq6IozBW01qvNZvZrATa6Ot1s1uvlasWFQIPQuWya5wmTQvqL6Sad4DjT0bZ1SSnLTv+H/wGYNpjtfts0zR8aWRcchjLahQAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 01 18 39 03"\n        title=""\n        src="/static/2021-07-01-18-39-03-ef151acdbd0c54e8f3aa8a46d03f6465-fee1c.png"\n        srcset="/static/2021-07-01-18-39-03-ef151acdbd0c54e8f3aa8a46d03f6465-a67b7.png 200w,\n/static/2021-07-01-18-39-03-ef151acdbd0c54e8f3aa8a46d03f6465-0b187.png 400w,\n/static/2021-07-01-18-39-03-ef151acdbd0c54e8f3aa8a46d03f6465-fee1c.png 800w,\n/static/2021-07-01-18-39-03-ef151acdbd0c54e8f3aa8a46d03f6465-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从上图可以看出，线程 1、线程 2、线程 3 分别把执行的结果写入 A、B、C 中，然后线程 2 继续从 A、B、C 中读取数据，用来显示执行结果。</p>\n</li>\n<li>\n<p>当一个进程关闭之后，操作系统会回收进程所占用的内存。</p>\n<p>当一个进程退出时，操作系统会回收该进程所申请的所有资源；即使其中任意线程因为操作不当导致内存泄漏，当进程退出时，这些内存也会被正确回收。</p>\n<p>比如之前的 IE 浏览器，支持很多插件，而这些插件很容易导致内存泄漏，这意味着只要浏览器开着，内存占用就有可能会越来越多，但是当关闭浏览器进程时，这些内存就都会被系统回收掉</p>\n</li>\n<li>\n<p>进程之间的内容相互隔离。</p>\n<p>进程隔离是为保护操作系统中进程互不干扰的技术，每一个进程只能访问自己占有的数据，也就避免出现进程 A 写入数据到进程 B 的情况。正是因为进程之间的数据是严格隔离的，所以一个进程如果崩溃了，或者挂起了，是不会影响到其他进程的。如果进程之间需要进行数据的通信，这时候就需要使用用于进程间通信（IPC）的机制了。</p>\n</li>\n</ol>\n<h2 id="单进程浏览器时代"><a href="#%E5%8D%95%E8%BF%9B%E7%A8%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E6%97%B6%E4%BB%A3" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>单进程浏览器时代</h2>\n<p>在了解了进程和线程之后，我们再来一起看下单进程浏览器的架构。顾名思义，单进程浏览器是指浏览器的所有功能模块都是运行在同一个进程里，这些模块包含了网络、插件、JavaScript 运行环境、渲染引擎和页面等。其实早在 2007 年之前，市面上浏览器都是单进程的。单进程浏览器的架构如下图所示</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-02-10-33-23-b0f62bc9971ee98ba6e5c476f2936afd-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 41.06830122591944%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAIAAAB2/0i6AAAACXBIWXMAAA7DAAAOwwHHb6hkAAABe0lEQVQY03WQO2ocQRCGJxY4MCjyBZzpBgYfwBdwrsgXcKo76ABGWgmBwcIvzAYyxpESG4G8Qjvsg5Xm1dsz3dOP6q6ex86o11orkn+KCrr5+H4q6P+l6zq/8zyP45gQkiQJADy8P5rA/yGiBmPQ1XXDOV/cRrRglFKltUE0xjZN81/YA8hp39raoZISaNKvKuewrV2nCiiZsXbT7n7+Zg2vViu09nAi3/7iV4X18v3Q7I8B0X2LYG8EVwz7pjIWRVmWN4syjkshvMPza7MBeDEsguPyaA7gqq1Tvv1JSIOvz2VwLA4myhfhUuVRlF9cFKM/LMsY5966hv1hXv3kT7/q9wursHo+FDtnugB881s/+aIHM+i7mgnJ05SHYz6b8izzJdq23ZhfDpfBgJ7MtXHV9gfy7CP15t1zFgyW765Zo3hyG5HphIQhGY1IOF6m6Qa2xvyY04PLZF5Ih3g2zb7PiLX2MmGfr9ObvKz99SxqIUBrUEpL6REP3gEh5689LMhejQAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 02 10 33 23"\n        title=""\n        src="/static/2021-07-02-10-33-23-b0f62bc9971ee98ba6e5c476f2936afd-fee1c.png"\n        srcset="/static/2021-07-02-10-33-23-b0f62bc9971ee98ba6e5c476f2936afd-a67b7.png 200w,\n/static/2021-07-02-10-33-23-b0f62bc9971ee98ba6e5c476f2936afd-0b187.png 400w,\n/static/2021-07-02-10-33-23-b0f62bc9971ee98ba6e5c476f2936afd-fee1c.png 800w,\n/static/2021-07-02-10-33-23-b0f62bc9971ee98ba6e5c476f2936afd-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>如此多的功能模块运行在一个进程里，是导致单进程浏览器不稳定、不流畅和不安全的一个主要因素。下面我就来一一分析下出现这些问题的原因</p>\n<h3 id="不稳定"><a href="#%E4%B8%8D%E7%A8%B3%E5%AE%9A" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>不稳定</h3>\n<p>早期浏览器需要借助于插件来实现诸如 Web 视频、Web 游戏等各种强大的功能，但是插件是最容易出问题的模块，并且还运行在浏览器进程之中，所以一个插件的意外崩溃会引起整个浏览器的崩溃。</p>\n<p>除了插件之外，渲染引擎模块也是不稳定的，通常一些复杂的 JavaScript 代码就有可能引起渲染引擎模块的崩溃。和插件一样，渲染引擎的崩溃也会导致整个浏览器的崩溃</p>\n<h3 id="不流畅"><a href="#%E4%B8%8D%E6%B5%81%E7%95%85" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>不流畅</h3>\n<p>从上面的“单进程浏览器架构示意图”可以看出，所有页面的渲染模块、JavaScript 执行环境以及插件都是运行在同一个线程中的，这就意味着同一时刻只能有一个模块可以执行。</p>\n<p>比如，下面这个无限循环的脚本：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="73341269111672890000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function freeze() {\n  while (1) {\n    console.log(\'freeze\');\n  }\n}\nfreeze();`, `73341269111672890000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                data-tooltip="复制"\n              >\n                <svg class="gatsby-code-button-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M16 1H2v16h2V3h12V1zm-1 4l6 6v12H6V5h9zm-1 7h5.5L14 6.5V12z"/></svg>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span> <span class="token function">freeze</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'freeze\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n<span class="token function">freeze</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>如果让这个脚本运行在一个单进程浏览器的页面里，你感觉会发生什么？</p>\n<p>因为这个脚本是无限循环的，所以当其执行时，它会独占整个线程，这样导致其他运行在该线程中的模块就没有机会被执行。因为浏览器中所有的页面都运行在该线程中，所以这些页面都没有机会去执行任务，这样就会导致整个浏览器失去响应，变卡顿。这块内容要继续往深的地方讲就到页面的事件循环系统了，具体相关内容会在后面的模块中为你深入讲解。</p>\n<p>除了上述脚本或者插件会让单进程浏览器变卡顿外，页面的内存泄漏也是单进程变慢的一个重要原因。通常浏览器的内核都是非常复杂的，运行一个复杂点的页面再关闭页面，会存在内存不能完全回收的情况，这样导致的问题是使用时间越长，内存占用越高，浏览器会变得越慢。</p>\n<h3 id="不安全"><a href="#%E4%B8%8D%E5%AE%89%E5%85%A8" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>不安全</h3>\n<p>这里依然可以从插件和页面脚本两个方面来解释该原因。</p>\n<p>插件可以使用 C/C++ 等代码编写，通过插件可以获取到操作系统的任意资源，当你在页面运行一个插件时也就意味着这个插件能完全操作你的电脑。如果是个恶意插件，那么它就可以释放病毒、窃取你的账号密码，引发安全性问题。</p>\n<p>至于页面脚本，它可以通过浏览器的漏洞来获取系统权限，这些脚本获取系统权限之后也可以对你的电脑做一些恶意的事情，同样也会引发安全问题。</p>\n<p>以上这些就是当时浏览器的特点，不稳定，不流畅，而且不安全。这是一段不堪回首的过去，也许你没有经历过，不过你可以想象一下这样的场景：当你正在用浏览器打开多个页面时，突然某个页面崩溃了或者失去响应，随之而来的是整个浏览器的崩溃或者无响应，然后你发现你给老板写的邮件页面也随之消失了，这时你的心情会不会和页面一样崩溃呢</p>\n<h2 id="多进程浏览器时代"><a href="#%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E6%97%B6%E4%BB%A3" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>多进程浏览器时代</h2>\n<p>好在现代浏览器已经解决了这些问题，是如何解决的呢？这就得聊聊我们这个“多进程浏览器时代”了</p>\n<h3 id="早期多进程架构"><a href="#%E6%97%A9%E6%9C%9F%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%9E%B6%E6%9E%84" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>早期多进程架构</h3>\n<p>你可以先看看下面这张图，这是 2008 年 Chrome 发布时的进程架构。</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-02-10-41-39-bd2a4bd820e0f87d8d65b603e1e31eca-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 63.48511383537654%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAIAAAAmMtkJAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABtklEQVQoz3VR30sbQRD27y99CKXQl7bgS+tjRCkVX5RWKKhgsMWYYvFuL/dz7y6X/b2zu+ncRWOl8WNYdmfmm292Zmf1Agi303J5W7GbimXCoif8l7OznRr83l03+v7n/fHk1Xn2lbDeFbaSwyM2bu/27haji/TD6c3ri/yILNEFAfl9ieEMLyuvwmHEds/vP59NP16Sk2TZK2xpOwQnpWFMdh1w7gH6ws55zmRTpzGRNV05yLkZ35bjGd2f0fG0/Ba3A9k7ZKZZRgjp2hbJznswWneLLE2TOCqLAgQ/i+joy9W78Y+3R5M3B5efJvN128FpxbtOMKaFCN4/9I1VjLFKoaHAHJV/zg+vooNf8/3r5DRqerL3XkqplJJCKK3xsuw6SmnTNG3bcs7VAAyA1T74Z38GACEEnnYA1qoojeKYJEmR5845CxYGYGkUeVjOhozK8A9EU7Oq4mWpsKhzG78xOAntfb8nfG4jo7rg4vdMJnHPs08RY62Ssl+HgwWuBuB52wCaM1VTkRBZFHixRttHaGOk4AE9Wud5Xtf108CUXE9Go2EeGj7WkTUwDXvBjj04Wvf4C6TU5K4TgcwjAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 02 10 41 39"\n        title=""\n        src="/static/2021-07-02-10-41-39-bd2a4bd820e0f87d8d65b603e1e31eca-fee1c.png"\n        srcset="/static/2021-07-02-10-41-39-bd2a4bd820e0f87d8d65b603e1e31eca-a67b7.png 200w,\n/static/2021-07-02-10-41-39-bd2a4bd820e0f87d8d65b603e1e31eca-0b187.png 400w,\n/static/2021-07-02-10-41-39-bd2a4bd820e0f87d8d65b603e1e31eca-fee1c.png 800w,\n/static/2021-07-02-10-41-39-bd2a4bd820e0f87d8d65b603e1e31eca-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从图中可以看出，Chrome 的页面是运行在单独的渲染进程中的，同时页面里的插件也是运行在单独的插件进程之中，而进程之间是通过 IPC 机制进行通信（如图中虚线部分）。</p>\n<p><strong>我们先看看如何解决不稳定的问题</strong>。由于进程是相互隔离的，所以当一个页面或者插件崩溃时，影响到的仅仅是当前的页面进程或者插件进程，并不会影响到浏览器和其他页面，这就完美地解决了页面或者插件的崩溃会导致整个浏览器崩溃，也就是不稳定的问题。</p>\n<p><strong>接下来再来看看不流畅的问题是如何解决的</strong>。同样，JavaScript 也是运行在渲染进程中的，所以即使 JavaScript 阻塞了渲染进程，影响到的也只是当前的渲染页面，而并不会影响浏览器和其他页面，因为其他页面的脚本是运行在它们自己的渲染进程中的。所以当我们再在 Chrome 中运行上面那个死循环的脚本时，没有响应的仅仅是当前的页面。</p>\n<p>对于内存泄漏的解决方法那就更简单了，因为当关闭一个页面时，整个渲染进程也会被关闭，之后该进程所占用的内存都会被系统回收，这样就轻松解决了浏览器页面的内存泄漏问题。</p>\n<p><strong>最后我们再来看看上面的两个安全问题是怎么解决的</strong>。采用多进程架构的额外好处是可以使用安全沙箱，你可以把沙箱看成是操作系统给进程上了一把锁，沙箱里面的程序可以运行，但是不能在你的硬盘上写入任何数据，也不能在敏感位置读取任何数据，例如你的文档和桌面。Chrome 把插件进程和渲染进程锁在沙箱里面，这样即使在渲染进程或者插件进程里面执行了恶意程序，恶意程序也无法突破沙箱去获取系统权限。</p>\n<p>好了，分析完早期的 Chrome 浏览器后，相信你已经了解了浏览器采用多进程架构的必要性</p>\n<h3 id="目前多进程架构"><a href="#%E7%9B%AE%E5%89%8D%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%9E%B6%E6%9E%84" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>目前多进程架构</h3>\n<p>不过 Chrome 的发展是滚滚向前的，相较之前，目前的架构又有了很多新的变化。我们先看看最新的 Chrome 进程架构，你可以参考下图</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-02-10-50-30-0c08515b5c453a3e0b919294d48b6226-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 43.25744308231174%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAIAAAC9o5sfAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABR0lEQVQoz5WRPUvDQBjHM4iDY8HNQXBxEro6FT+Fn8GPpNJRBFOQWnDQQXB1F7WYGpr00iYlbXK5e+65F5/GVii69M/xcHD/3/N2ntVai0qVZZXnyLkzxq1kldJCyKKAsrSI7o88C6DL+SgMB/2PjDH3Y7J2EaScTiZhEIzjyAH8AzuNGiQCGAVYcYPK2FrOaaVAVFoKulCDdUa7Brces+NOv+W/NbvxE5MOZcGXKnjlEM5eimYnOLl5PeqOesOKGLPK4O1cJd5FsNUOvcvh9YDToONsGsdxFEX5bE5w6yH3zr+22wOvzdrvBTH6Fz7sTfZux/vddLfD7ofcaZgX5bK0EASfPmcNnx3cpQ0/8T9nazAHRaeUqhSgjaHdq1qISJFml4j0uvAA7UC52kC2emGbaPFhWmdpypKEOtsMNojEg5SMMSnlN1pY8HNoYpOOAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 02 10 50 30"\n        title=""\n        src="/static/2021-07-02-10-50-30-0c08515b5c453a3e0b919294d48b6226-fee1c.png"\n        srcset="/static/2021-07-02-10-50-30-0c08515b5c453a3e0b919294d48b6226-a67b7.png 200w,\n/static/2021-07-02-10-50-30-0c08515b5c453a3e0b919294d48b6226-0b187.png 400w,\n/static/2021-07-02-10-50-30-0c08515b5c453a3e0b919294d48b6226-fee1c.png 800w,\n/static/2021-07-02-10-50-30-0c08515b5c453a3e0b919294d48b6226-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从图中可以看出，最新的 Chrome 浏览器包括：1 个浏览器（Browser）主进程、1 个 GPU 进程、1 个网络（NetWork）进程、多个渲染进程和多个插件进程</p>\n<p>下面我们来逐个分析下这几个进程的功能。</p>\n<ul>\n<li><strong>浏览器进程</strong>。主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。</li>\n<li><strong>渲染进程</strong>。核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。</li>\n<li><strong>GPU 进程</strong>。其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。</li>\n<li><strong>网络进程</strong>。主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。</li>\n<li><strong>插件进程</strong>。主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响</li>\n</ul>\n<p>讲到这里，现在你应该就可以回答文章开头提到的问题了：仅仅打开了 1 个页面，为什么有 4 个进程？因为打开 1 个页面至少需要 1 个网络进程、1 个浏览器进程、1 个 GPU 进程以及 1 个渲染进程，共 4 个；如果打开的页面有运行插件的话，还需要再加上 1 个插件进程。</p>\n<p>不过凡事都有两面性，虽然多进程模型提升了浏览器的稳定性、流畅性和安全性，但同样不可避免地带来了一些问题</p>\n<ul>\n<li><strong>更高的资源占用</strong>。因为每个进程都会包含公共基础结构的副本（如 JavaScript 运行环境），这就意味着浏览器会消耗更多的内存资源。</li>\n<li><strong>更复杂的体系架构</strong>。浏览器各模块之间耦合性高、扩展性差等问题，会导致现在的架构已经很难适应新的需求了</li>\n</ul>\n<p>对于上面这两个问题，Chrome 团队一直在寻求一种弹性方案，既可以解决资源占用高的问题，也可以解决复杂的体系架构的问题</p>\n<h3 id="未来面向服务的架构"><a href="#%E6%9C%AA%E6%9D%A5%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%9E%B6%E6%9E%84" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>未来面向服务的架构</h3>\n<p>为了解决这些问题，在 2016 年，Chrome 官方团队使用“面向服务的架构”（Services Oriented Architecture，简称 SOA）的思想设计了新的 Chrome 架构。也就是说 Chrome 整体架构会朝向现代操作系统所采用的“面向服务的架构” 方向发展，原来的各种模块会被重构成独立的服务（Service），每个服务（Service）都可以在独立的进程中运行，访问服务（Service）必须使用定义好的接口，通过 IPC 来通信，从而构建一个更内聚、松耦合、易于维护和扩展的系统，更好实现 Chrome 简单、稳定、高速、安全的目标。如果你对面向服务的架构感兴趣，你可以去网上搜索下资料，这里就不过多介绍了。</p>\n<p>Chrome 最终要把 UI、数据库、文件、设备、网络等模块重构为基础服务，类似操作系统底层服务，下面是 Chrome“面向服务的架构”的进程模型图</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-02-10-57-46-ffb91623e2df93bde2a7eec2ad8cdc48-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 50.96322241681261%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABSUlEQVQoz4VS7Y7lIAjt+z/lJJM72Zm22mu1FRDYg939PYY0ipwPoYu7mw5l6q3RdRmzz2XCyLRS+LrcYhFRPc9Wa+/9qVnMfYj0Wv+8vrbvb75vVVeAx3jnvK8rKFRB72etP+u6bns5q9oEkxpCzOfReR5ZNb3Lmo+Pz8+fPeEWyWD04B3uXW2YLRKOfBDdrSEcumHahKgcRy0FmydjQ2B71gywD/NFNMBXKXnbEDrfbLhjTttG9/2fDhnCQ8r7jXZIKPsCnxo6Hc87jwx6VI4BK5RSyjmLjADj3aDbdwQ2I1ABDkd0tZLTeRwmMj0qOn+kyOjMACvM/b4RMAX0P2VRxwCCNWUORyi1Vtu27TmFMjL4dAyFhQSJQY8yPPNsnc9Ozr2D7uk/AiKPDq54GJgu4tJuUCz+28LAXQRtj38jBiOw+fV6wftfQWJIpkhtoi4AAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 02 10 57 46"\n        title=""\n        src="/static/2021-07-02-10-57-46-ffb91623e2df93bde2a7eec2ad8cdc48-fee1c.png"\n        srcset="/static/2021-07-02-10-57-46-ffb91623e2df93bde2a7eec2ad8cdc48-a67b7.png 200w,\n/static/2021-07-02-10-57-46-ffb91623e2df93bde2a7eec2ad8cdc48-0b187.png 400w,\n/static/2021-07-02-10-57-46-ffb91623e2df93bde2a7eec2ad8cdc48-fee1c.png 800w,\n/static/2021-07-02-10-57-46-ffb91623e2df93bde2a7eec2ad8cdc48-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>目前 Chrome 正处在老的架构向服务化架构过渡阶段，这将是一个漫长的迭代过程。</p>\n<p>Chrome 正在逐步构建 Chrome 基础服务（Chrome Foundation Service），如果你认为 Chrome 是“便携式操作系统”，那么 Chrome 基础服务便可以被视为该操作系统的“基础”系统服务层。</p>\n<p>同时 Chrome 还提供灵活的弹性架构，在强大性能设备上会以多进程的方式运行基础服务，但是如果在资源受限的设备上（如下图），Chrome 会将很多服务整合到一个进程中，从而节省内存占用。</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-02-10-58-14-8d908e5e3d0fe15a69ea90f28746affc-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 55.166374781085814%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABrUlEQVQoz5VSy2pUQRCdnSt3omC+xg8Q/AQ3uvUBLgTxK8S9EBjURQJxF7IQxAQlcVSMiNe5M95Mz9x75z76/arutjIRZNSFHpqiD9Sp011Vg7SOaK0X0jDqpYwAwTtQygqxot55r1cAAEwerEsjCF4v5pPxt7auk/dRq2VZTsbjuiyDtZSxLMuKorDWhhAGvzlbKQRjGDA6tJCSUcoZU1JYrYX8CaVUjHFNjMW0MSmGlCBG7wG6ZlkVk6qY8q7xEGLwKUIK8Bdn5N6aUWN2pvzVQmHStBXbWbOVNe8rgbIvnd47ER+X2p2JjdJ907CuZV1HuUjO3HzLzj3Jr+y1KfntE3PpObk4nDz8wLH4vcP+/GZ+/eUiOgsopos5OTos3x1Vn4/nsxlY/TQXd/erR586fDxa3T5Y3tovHx/3KH5RyPsjOswFWHMqVpy3hPRk1vc95TxZdeeg2tj8em2XJLCvCd949v3yML+6O0f6YEQvbNU33lAwGv7stnMuwGlXsDd4996l6PHzZzQ6k7z2Shjs6685x5j+Abg2OPx+BdyTQfofoBiPkpIQgtP6ASH5Zb1BcUF5AAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 02 10 58 14"\n        title=""\n        src="/static/2021-07-02-10-58-14-8d908e5e3d0fe15a69ea90f28746affc-fee1c.png"\n        srcset="/static/2021-07-02-10-58-14-8d908e5e3d0fe15a69ea90f28746affc-a67b7.png 200w,\n/static/2021-07-02-10-58-14-8d908e5e3d0fe15a69ea90f28746affc-0b187.png 400w,\n/static/2021-07-02-10-58-14-8d908e5e3d0fe15a69ea90f28746affc-fee1c.png 800w,\n/static/2021-07-02-10-58-14-8d908e5e3d0fe15a69ea90f28746affc-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<h2 id="总结"><a href="#%E6%80%BB%E7%BB%93" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总结</h2>\n<p>本文主要是从 Chrome 进程架构的视角，分析了浏览器的进化史。</p>\n<p>最初的浏览器都是单进程的，它们不稳定、不流畅且不安全，之后出现了 Chrome，创造性地引入了多进程架构，并解决了这些遗留问题。随后 Chrome 试图应用到更多业务场景，如移动设备、VR、视频等，为了支持这些场景，Chrome 的架构体系变得越来越复杂，这种架构的复杂性倒逼 Chrome 开发团队必须进行架构的重构，最终 Chrome 团队选择了面向服务架构（SOA）形式，这也是 Chrome 团队现阶段的一个主要任务。</p>\n<p>鉴于目前架构的复杂性，要完整过渡到面向服务架构，估计还需要好几年时间才能完成。不过 Chrome 开发是一个渐进的过程，新的特性会一点点加入进来，这也意味着我们随时能看到 Chrome 新的变化。</p>\n<p>总体说来，Chrome 是以一个非常快速的速度在进化，越来越多的业务和应用都逐渐转至浏览器来开发，身为开发人员，我们不能坐视不管，而应该紧跟其步伐，收获这波技术红利</p>\n<h1 id="tcp-协议"><a href="#tcp-%E5%8D%8F%E8%AE%AE" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>TCP 协议</h1>\n<p>在衡量 Web 页面性能的时候有一个重要的指标叫“FP（First Paint）”，是指从页面加载到首次开始绘制的时长。这个指标直接影响了用户的跳出率，更快的页面响应意味着更多的 PV、更高的参与度，以及更高的转化率。那什么影响 FP 指标呢？其中一个重要的因素是网络加载速度</p>\n<p>要想优化 Web 页面的加载速度，你需要对网络有充分的了解。而理解网络的关键是要对网络协议有深刻的认识，不管你是使用 HTTP，还是使用 WebSocket，它们都是基于 TCP/IP 的，如果你对这些原理有足够了解，也就清楚如何去优化 Web 性能，或者能更轻松地定位 Web 问题了。此外，TCP/IP 的设计思想还有助于拓宽你的知识边界，从而在整体上提升你对项目的理解和解决问题的能力。</p>\n<p>好，接下来我们回到正题，开始今天的内容。在网络中，一个文件通常会被拆分为很多数据包来进行传输，而数据包在传输过程中又有很大概率丢失或者出错。那么如何保证页面文件能被完整地送达浏览器呢？</p>\n<p>这篇文章将站在数据包的视角，给出问题答案</p>\n<h2 id="一个数据包的旅程"><a href="#%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%8C%85%E7%9A%84%E6%97%85%E7%A8%8B" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>一个数据包的“旅程”</h2>\n<p>下面我将分别从“数据包如何送达主机”“主机如何将数据包转交给应用”和“数据是如何被完整地送达应用程序”这三个角度来为你讲述数据的传输过程</p>\n<p>互联网，实际上是一套理念和协议组成的体系架构。其中，协议是一套众所周知的规则和标准，如果各方都同意使用，那么它们之间的通信将变得毫无障碍</p>\n<p>互联网中的数据是通过数据包来传输的。如果发送的数据很大，那么该数据就会被拆分为很多小数据包来传输。比如你现在听的音频数据，是拆分成一个个小的数据包来传输的，并不是一个大的文件一次传输过来的</p>\n<h4 id="ip：把数据包送达目的主机"><a href="#ip%EF%BC%9A%E6%8A%8A%E6%95%B0%E6%8D%AE%E5%8C%85%E9%80%81%E8%BE%BE%E7%9B%AE%E7%9A%84%E4%B8%BB%E6%9C%BA" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>IP：把数据包送达目的主机</h4>\n<p>数据包要在互联网上进行传输，就要符合网际协议（Internet Protocol，简称 IP）标准。互联网上不同的在线设备都有唯一的地址，地址只是一个数字，这和大部分家庭收件地址类似，你只需要知道一个家庭的具体地址，就可以往这个地址发送包裹，这样物流系统就能把物品送到目的地</p>\n<p>计算机的地址就称为 IP 地址，访问任何网站实际上只是你的计算机向另外一台计算机请求信息。</p>\n<p>如果要想把一个数据包从主机 A 发送给主机 B，那么在传输之前，数据包上会被附加上主机 B 的 IP 地址信息，这样在传输过程中才能正确寻址。额外地，数据包上还会附加上主机 A 本身的 IP 地址，有了这些信息主机 B 才可以回复信息给主机 A。这些附加的信息会被装进一个叫 IP 头的数据结构里。IP 头是 IP 数据包开头的信息，包含 IP 版本、源 IP 地址、目标 IP 地址、生存时间等信息</p>\n<p>为了方便理解，我先把网络简单分为三层结构，如下图</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-02-11-17-17-5bcd4ef7a02968d2eb48bfe0f2c63841-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 61.55866900175131%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABpUlEQVQoz3VSW46cMBCci0TKiZNr5CsX2CtEWq20v5sZlhkGgx/4/YbUYJKsFKUFlmlc3VXVPm2/o9badZ1zbvtPTNM0jiM267q2zKnB8I1VSplzrnt8LNpOa62NMe1ky5ywCyEANs9UaR1TAh4ZrOseMUYykr7vGWellJQSMt77A4wUYNe+5zOtOYMWMsjf73el1LZuTLKZz8GHdTsIo8QBTmhXsmWkCB4ZjZzlUhp/dM4pB1Ap4SGhPTudBxi/rbVKq0UJZ11wNnvnrAG4NQHDRUtBiWHMMOoE14IDcnTGORutMALmEBtfRVQBVFIDo3PMyS8cfvKJdkQYqVMMf2kba9/ee8enL8/k07fLDxq26H+eL3AY8rB215vi9OvL9Pn77eketprK2sApwSI9EUiLzmvGoNh5PwwD6ME8WCAXCS7U+Nd3YnzcZwHNtUI9usOqHFzxriqJUfzRHPB7EW4cMKXCab28xeF6jApvqw0bVdDQCj77pCquFAb+mGXKw3Kz3iRUCj4610qfPl5Al52O2iaLjQn6fD0zzXzxyMiw/HthfwG7fbSqWvTU3AAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 02 11 17 17"\n        title=""\n        src="/static/2021-07-02-11-17-17-5bcd4ef7a02968d2eb48bfe0f2c63841-fee1c.png"\n        srcset="/static/2021-07-02-11-17-17-5bcd4ef7a02968d2eb48bfe0f2c63841-a67b7.png 200w,\n/static/2021-07-02-11-17-17-5bcd4ef7a02968d2eb48bfe0f2c63841-0b187.png 400w,\n/static/2021-07-02-11-17-17-5bcd4ef7a02968d2eb48bfe0f2c63841-fee1c.png 800w,\n/static/2021-07-02-11-17-17-5bcd4ef7a02968d2eb48bfe0f2c63841-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<blockquote>\n<p>下面我们一起来看下一个数据包从主机 A 到主机 B 的旅程：</p>\n</blockquote>\n<ul>\n<li>上层将含有“极客时间”的数据包交给网络层；</li>\n<li>网络层再将 IP 头附加到数据包上，组成新的 IP 数据包，并交给底层；</li>\n<li>底层通过物理网络将数据包传输给主机 B；</li>\n<li>数据包被传输到主机 B 的网络层，在这里主机 B 拆开数据包的 IP 头信息，并将拆开来的数据部分交给上层；</li>\n<li>最终，含有“极客时间”信息的数据包就到达了主机 B 的上层了</li>\n</ul>\n<h3 id="udp：把数据包送达应用程序"><a href="#udp%EF%BC%9A%E6%8A%8A%E6%95%B0%E6%8D%AE%E5%8C%85%E9%80%81%E8%BE%BE%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>UDP：把数据包送达应用程序</h3>\n<p>IP 是非常底层的协议，只负责把数据包传送到对方电脑，但是对方电脑并不知道把数据包交给哪个程序，是交给浏览器还是交给王者荣耀？因此，需要基于 IP 之上开发能和应用打交道的协议，最常见的是“用户数据包协议（User Datagram Protocol）”，简称 UDP。</p>\n<p>UDP 中一个最重要的信息是端口号，端口号其实就是一个数字，每个想访问网络的程序都需要绑定一个端口号。通过端口号 UDP 就能把指定的数据包发送给指定的程序了，所以 IP 通过 IP 地址信息把数据包发送给指定的电脑，而 UDP 通过端口号把数据包分发给正确的程序。和 IP 头一样，端口号会被装进 UDP 头里面，UDP 头再和原始数据包合并组成新的 UDP 数据包。UDP 头中除了目的端口，还有源端口号等信息</p>\n<p>为了支持 UDP 协议，我把前面的三层结构扩充为四层结构，在网络层和上层之间增加了传输层，如下图所示：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-02-11-18-52-dfda3b6ba81a1ee42cefbb375d72fe34-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 71.2784588441331%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAIAAACgpqunAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACCUlEQVQoz3VTu4oVQRCdzxIxEv0OA39C8AcMTA3MBUMRQTERDERBXUwMluvuOvd6Z3Ze/Zjp6ffD0z3uooFF04+pqlN1qmqqlFKMETshpOu69H9p25ZSem0PqUIIpohSSkrpriQWwcUW8d5rrWHmi2wGFY6u7+q6BupmDR2sl2VhjOFybI6Hw0EIscUMRfAde4W3UMJYU+J563xx91vk4AMVBAZF5WzRXadWxRClkYApTPIKIas3Vjlbp11w6Q9PxDQAcAW9wtmznnPKVvX8jD/5Tk+ZTdHPi+CcA4XNXIl5R9XT0/nZjg2zSCXNnDawCaPTOHRMPPw83HvXfOwN4nfDALbQHvuWjd2nZrn//vLBFzJOs6vP1TQhk+ycKfnMFQFzYs4qbba0wVJooS2KDCLQei2EZEzNPKZYwQKcSwFC2lbK+1YwQK9qVVpFOHubVwwuZM5p4zwtxFi9alfPBuuCm5avpXgJLZFWoXdE+Vr4g3D7BWkA9Ioz6A3Nrw97cvtVfefN8cbL/eNvI+na3Y8zTM6xaflw+eikv/ni/O7b9tbr5msvU3A+lCGBf54z56kJVHuiPSq/9WabKjR41nZczaRcPzL280IxCmJ5PLemB++VXvFATrjDB1OVmx8SXYkyMsPBWkk3cydlrvbfo79audpVOmWCoTNtusYGMDSrFT43IsV/f5Xf49Ahhtcri7AAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 02 11 18 52"\n        title=""\n        src="/static/2021-07-02-11-18-52-dfda3b6ba81a1ee42cefbb375d72fe34-fee1c.png"\n        srcset="/static/2021-07-02-11-18-52-dfda3b6ba81a1ee42cefbb375d72fe34-a67b7.png 200w,\n/static/2021-07-02-11-18-52-dfda3b6ba81a1ee42cefbb375d72fe34-0b187.png 400w,\n/static/2021-07-02-11-18-52-dfda3b6ba81a1ee42cefbb375d72fe34-fee1c.png 800w,\n/static/2021-07-02-11-18-52-dfda3b6ba81a1ee42cefbb375d72fe34-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>下面我们一起来看下一个数据包从主机 A 旅行到主机 B 的路线：</p>\n<ul>\n<li>上层将含有“极客时间”的数据包交给传输层；</li>\n<li>传输层会在数据包前面附加上 UDP 头，组成新的 UDP 数据包，再将新的 UDP 数据包交给网络层；</li>\n<li>网络层再将 IP 头附加到数据包上，组成新的 IP 数据包，并交给底层；</li>\n<li>数据包被传输到主机 B 的网络层，在这里主机 B 拆开 IP 头信息，并将拆开来的数据部分交给传输层；</li>\n<li>在传输层，数据包中的 UDP 头会被拆开，并根据 UDP 中所提供的端口号，把数据部分交给上层的应用程序；</li>\n<li>最终，含有“极客时间”信息的数据包就旅行到了主机 B 上层应用程序这里</li>\n</ul>\n<p>在使用 UDP 发送数据时，有各种因素会导致数据包出错，虽然 UDP 可以校验数据是否正确，但是对于错误的数据包，UDP 并不提供重发机制，只是丢弃当前的包，而且 UDP 在发送之后也无法知道是否能达到目的地。</p>\n<p>虽说 UDP 不能保证数据可靠性，但是传输速度却非常快，所以 UDP 会应用在一些关注速度、但不那么严格要求数据完整性的领域，如在线视频、互动游戏等</p>\n<h3 id="tcp：把数据完整地送达应用程序"><a href="#tcp%EF%BC%9A%E6%8A%8A%E6%95%B0%E6%8D%AE%E5%AE%8C%E6%95%B4%E5%9C%B0%E9%80%81%E8%BE%BE%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>TCP：把数据完整地送达应用程序</h3>\n<p>对于浏览器请求，或者邮件这类要求数据传输可靠性（reliability）的应用，如果使用 UDP 来传输会存在两个问题：</p>\n<ul>\n<li>数据包在传输过程中容易丢失；</li>\n<li>大文件会被拆分成很多小的数据包来传输，这些小的数据包会经过不同的路由，并在不同的时间到达接收端，而 UDP 协议并不知道如何组装这些数据包，从而把这些数据包还原成完整的文件</li>\n</ul>\n<p>基于这两个问题，我们引入 TCP 了。TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。相对于 UDP，TCP 有下面两个特点:</p>\n<ul>\n<li>对于数据包丢失的情况，TCP 提供重传机制；</li>\n<li>TCP 引入了数据包排序机制，用来保证把乱序的数据包组合成一个完整的文件。</li>\n</ul>\n<p>和 UDP 头一样，TCP 头除了包含了目标端口和本机端口号外，还提供了用于排序的序列号，以便接收端通过序号来重排数据包。</p>\n<p>下面看看 TCP 下的单个数据包的传输流程</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-02-13-44-25-a22307eda038250780c4d21ce4a0c211-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 69.87740805604203%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAIAAACgpqunAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACCUlEQVQoz2VSzW7UMBDeN+SKegTBo3DnDZBYIbW8AYcCooITKgcudFsK3U2y2cSxE8fj+Df9HHcrJMaWNfL8fTPfrOZ5jjHiFUIURRGPMh/lUa+q6nA4QAkh5M8VNFLU972Ucpomv4i1Fq/WGgr+h37IOsQtYoxB4CqGyAUvyxLxuQ4ETkjEGPPOF3WxK3cIfrRCQeoUDG3Uo7HGWasnQ5PBi+AMNfgwTuNkJ+c8GauNdemkiywJttQSP1DgjOxzDECVKyAL4TgbszU6GuVEhEqpMgDwge/rSnDx6kf35EP57rcCrqZtMT9kOTStZM33enz6qX55Ud81IpZ3E+cY2gpdkSallCY6L9SbjbxkJnqriIZhSMG8kZJvhX67Gd7fyk6SF5x4twwspp4TbO/n6FEzeIfOH3gKMcH2dukiITfgAi7ep56XgUnn3dKVzx4x+twzWCFDxpklb3bw0R+pSuy3eyG6RtLZTX963a+v+OdCajWCvESY6MZBXNbj+hc/vRnWV+LP6ObgQBZgR8Y6wdrrpn9+0Tz7cjg5r17/5FLw7S7R2zKGDs82/ORj9eJrC+u3vyxoBaITVcCW9zDx9LCSMPlMFbIHtJRgL6J6t70l1obcc15J7EOvpUGmtD0RgPf7fVxCueKcBGZk0nokM/zTbs//iPEGs8XVTg96AEnkKF1LPvj5P7kHeU4gpw/e15EAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 02 13 44 25"\n        title=""\n        src="/static/2021-07-02-13-44-25-a22307eda038250780c4d21ce4a0c211-fee1c.png"\n        srcset="/static/2021-07-02-13-44-25-a22307eda038250780c4d21ce4a0c211-a67b7.png 200w,\n/static/2021-07-02-13-44-25-a22307eda038250780c4d21ce4a0c211-0b187.png 400w,\n/static/2021-07-02-13-44-25-a22307eda038250780c4d21ce4a0c211-fee1c.png 800w,\n/static/2021-07-02-13-44-25-a22307eda038250780c4d21ce4a0c211-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>通过上图你应该可以了解一个数据包是如何通过 TCP 来传输的。TCP 单个数据包的传输流程和 UDP 流程差不多，不同的地方在于，通过 TCP 头的信息保证了一块大的数据传输的完整性。</p>\n<p>下面我们再看下完整的 TCP 连接过程，通过这个过程你可以明白 TCP 是如何保证重传机制和数据包的排序功能的。</p>\n<p>从下图可以看出，一个完整的 TCP 连接的生命周期包括了“建立连接”“传输数据”和“断开连接”三个阶段。</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-02-13-45-05-9debda7a276103e3391207cbaa5dbbae-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 35.72679509632224%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAIAAACHqfpvAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABG0lEQVQY05VPvU7DMBj0UAmJt2Bmgjdh4jl4AxZYeAKYKiREl6zMbCAhJIYsBVEaQRzsOI4/O47jOo1xA0lnTvJnfT+nu0Pe+67r1j38P4HCU0rFcZxlmZYSytIITkR18ZKfPdPzWJ4+ptEr65wFxgBAgTBKbslt22qtXaiCl5x7U70pt3OdoKvF5Iaiy+XRfRHOSkqEEBqEM2ZLDrZ9/7WNUQC+0cvG70YFmiaTGUVTfPygvF9bY0CqJsgOATfkWtdJknxjbGtNsswq+IDm8I7u384Pove92eLkqfAaQjqMMfn6tNb+6m3IoeGcV1VljMFpav5cBSerlYKQtjfXtc5JKYftoDwiJCeEjGtrVzTP66EN82CQMTYm/QFrzIGFa7OL5AAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 02 13 45 05"\n        title=""\n        src="/static/2021-07-02-13-45-05-9debda7a276103e3391207cbaa5dbbae-fee1c.png"\n        srcset="/static/2021-07-02-13-45-05-9debda7a276103e3391207cbaa5dbbae-a67b7.png 200w,\n/static/2021-07-02-13-45-05-9debda7a276103e3391207cbaa5dbbae-0b187.png 400w,\n/static/2021-07-02-13-45-05-9debda7a276103e3391207cbaa5dbbae-fee1c.png 800w,\n/static/2021-07-02-13-45-05-9debda7a276103e3391207cbaa5dbbae-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<ul>\n<li>首先，<strong>建立连接阶段</strong>。这个阶段是通过“三次握手”来建立客户端和服务器之间的连接。TCP 提供面向连接的通信传输。面向连接是指在数据通信开始之前先做好两端之间的准备工作。所谓三次握手，是指在建立一个 TCP 连接时，客户端和服务器总共要发送三个数据包以确认连接的建立。</li>\n<li>其次，<strong>传输数据阶段</strong>。在该阶段，接收端需要对每个数据包进行确认操作，也就是接收端在接收到数据包之后，需要发送确认数据包给发送端。所以当发送端发送了一个数据包之后，在规定时间内没有接收到接收端反馈的确认消息，则判断为数据包丢失，并触发发送端的重发机制。同样，一个大的文件在传输过程中会被拆分成很多小的数据包，这些数据包到达接收端后，接收端会按照 TCP 头中的序号为其排序，从而保证组成完整的数据。</li>\n<li>最后，<strong>断开连接阶段</strong>。数据传输完毕之后，就要终止连接了，涉及到最后一个阶段“四次挥手”来保证双方都能断开连接</li>\n</ul>\n<p>到这里你应该就明白了，TCP 为了保证数据传输的可靠性，牺牲了数据包的传输速度，因为“三次握手”和“数据包校验机制”等把传输过程中的数据包的数量提高了一倍。</p>\n<h2 id="总结-1"><a href="#%E6%80%BB%E7%BB%93-1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总结</h2>\n<ul>\n<li>互联网中的数据是通过数据包来传输的，数据包在传输过程中容易丢失或出错。</li>\n<li>IP 负责把数据包送达目的主机。</li>\n<li>UDP 负责把数据包送达具体应用。</li>\n<li>而 TCP 保证了数据完整地传输，它的连接可分为三个阶段：建立连接、传输数据和断开连接。</li>\n<li>其实了解 TCP 协议，是为了全方位了解 HTTP，包括其实际功能和局限性，之后才会更加深刻地理解为什么要推出 HTTP/2，以及为什么要推出 QUIC 协议，也就是未来的 HTTP/3。这是一个由浅入深、循序渐进的过程，我希望你能稳扎稳打，学好这每一步、每一个协议，后面“水到自然渠成”</li>\n</ul>\n<h1 id="http-请求流程"><a href="#http-%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>HTTP 请求流程</h1>\n<p>一个 TCP 连接过程包括了建立连接、传输数据和断开连接三个阶段。</p>\n<p>而 HTTP 协议，正是建立在 TCP 连接基础之上的。HTTP 是一种允许浏览器向服务器获取资源的协议，是 Web 的基础，通常由浏览器发起请求，用来获取不同类型的文件，例如 HTML 文件、CSS 文件、JavaScript 文件、图片、视频等。此外，HTTP 也是浏览器使用最广的协议，所以要想学好浏览器，就要先深入了解 HTTP。</p>\n<p>不知道你是否有过下面这些疑问：</p>\n<ol>\n<li>为什么通常在第一次访问一个站点时，打开速度很慢，当再次访问这个站点时，速度就很快了？</li>\n<li>当登录过一个网站之后，下次再访问该站点，就已经处于登录状态了，这是怎么做到的呢？</li>\n</ol>\n<p>这一切的秘密都隐藏在 HTTP 的请求过程中。所以，在今天这篇文章中，我将通过分析一个 HTTP 请求过程中每一步的状态来带你了解完整的 HTTP 请求过程，希望你看完这篇文章后，能够对 HTTP 协议有个全新的认识</p>\n<h2 id="浏览器端发起-http-请求流程"><a href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%AB%AF%E5%8F%91%E8%B5%B7-http-%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>浏览器端发起 HTTP 请求流程</h2>\n<p>如果你在浏览器地址栏里键入地址：<a href="http://baidu.com%EF%BC%8C%E9%82%A3%E4%B9%88%E6%8E%A5%E4%B8%8B%E6%9D%A5%EF%BC%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BC%9A%E5%AE%8C%E6%88%90%E5%93%AA%E4%BA%9B%E5%8A%A8%E4%BD%9C%E5%91%A2%EF%BC%9F%E4%B8%8B%E9%9D%A2%E6%88%91%E4%BB%AC%E5%B0%B1%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E8%AF%A6%E7%BB%86%E2%80%9C%E8%BF%BD%E8%B8%AA%E2%80%9D%E4%B8%8B" target="_blank" rel="nofollow noreferrer noopener">http://baidu.com，那么接下来，浏览器会完成哪些动作呢？下面我们就一步一步详细“追踪”下</a></p>\n<h3 id="构建请求"><a href="#%E6%9E%84%E5%BB%BA%E8%AF%B7%E6%B1%82" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>构建请求</h3>\n<p>首先，浏览器构建请求行信息（如下所示），构建好后，浏览器准备发起网络请求</p>\n<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">GET /index.html HTTP1.1</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<h3 id="查找缓存"><a href="#%E6%9F%A5%E6%89%BE%E7%BC%93%E5%AD%98" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>查找缓存</h3>\n<p>在真正发起网络请求之前，浏览器会先在浏览器缓存中查询是否有要请求的文件。其中，浏览器缓存是一种在本地保存资源副本，以供下次请求时直接使用的技术。</p>\n<p>当浏览器发现请求的资源已经在浏览器缓存中存有副本，它会拦截请求，返回该资源的副本，并直接结束请求，而不会再去源服务器重新下载。这样做的好处有：</p>\n<ul>\n<li>缓解服务器端压力，提升性能（获取资源的耗时更短了）；</li>\n<li>对于网站来说，缓存是实现快速资源加载的重要组成部分。</li>\n<li>当然，如果缓存查找失败，就会进入网络请求过程了。</li>\n</ul>\n<h3 id="准备-ip-地址和端口"><a href="#%E5%87%86%E5%A4%87-ip-%E5%9C%B0%E5%9D%80%E5%92%8C%E7%AB%AF%E5%8F%A3" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>准备 IP 地址和端口</h3>\n<p>不过，先不急，在了解网络请求之前，我们需要先看看 HTTP 和 TCP 的关系。因为浏览器使用 HTTP 协议作为应用层协议，用来封装请求的文本信息；并使用 TCP/IP 作传输层协议将它发到网络上，所以在 HTTP 工作开始之前，浏览器需要通过 TCP 与服务器建立连接。也就是说 HTTP 的内容是通过 TCP 的传输数据阶段来实现的，你可以结合下图更好地理解这二者的关系。</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-02-14-30-42-7b68c79b1d7fb59a33041ec119870e5c-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 49.91243432574431%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAB1ElEQVQoz21RTWsUMRieo2BBf4Y3/S16kAXrai1bRbx60IPF/yCClXpUcbEFKxQUQQ+22y0sflRY211mdqczmXzMV2YySSYzcWa2az345OFN8uZ9kjc8hm6g5iyrUVMXhcIYEoKb8/Iv52U1DH2CYsai0EpVk86ywrLIdBpU27KsM6qo47yylhuFUqY1efQtau+Ed/vBEXyb02cpXQ/RU85e0Oi5Yz8haC0K1zldmwTde31y/Ws4pvlMnP86PLqwTY1XyZmNaB8+kOSy4IvUb2ndzsUidFvQveqBVupf+Z3cP7tBjJfJLslP2mZCXvqUGF26sBUNvMcxuMbiFWAvaX0nF7chuAWcJQ8sp6Q9TlbPb/lGN9nzG3EupePBix9C4028sOn37VUtl1nYYXFHiRWRdjznZqXHqMOjGz/hw3Ob0Hgd7mJRizPGTMv6bOJ3h3h7hEyzFxx/CbxeQr9n7ICxA0p/ANBznB2M9sbT/kcTvx/7IZ/9ufJE5YHnoqmJbSuXCnoBITTLVG1R40maCgCCOBYJzXzX9o8nNI5OreJCsIwzzouydkNKyViKEATARcir1lLWfXLO/SDExE8Z+9fnU5TNc1UcjUaDwWA4HFZ36f/hD7gCD4uvreRIAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 02 14 30 42"\n        title=""\n        src="/static/2021-07-02-14-30-42-7b68c79b1d7fb59a33041ec119870e5c-fee1c.png"\n        srcset="/static/2021-07-02-14-30-42-7b68c79b1d7fb59a33041ec119870e5c-a67b7.png 200w,\n/static/2021-07-02-14-30-42-7b68c79b1d7fb59a33041ec119870e5c-0b187.png 400w,\n/static/2021-07-02-14-30-42-7b68c79b1d7fb59a33041ec119870e5c-fee1c.png 800w,\n/static/2021-07-02-14-30-42-7b68c79b1d7fb59a33041ec119870e5c-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>那接下来你可以思考这么“一连串”问题：</p>\n<ul>\n<li>HTTP 网络请求的第一步是做什么呢？结合上图看，是和服务器建立 TCP 连接。</li>\n<li>那建立连接的信息都有了吗？上一篇文章中，我们讲到建立 TCP 连接的第一步就是需要准备 IP 地址和端口号。</li>\n<li>那怎么获取 IP 地址和端口号呢？这得看看我们现在有什么，我们有一个 URL 地址，那么是否可以利用 URL 地址来获取 IP 和端口信息呢？</li>\n</ul>\n<p>在上一篇文章中，我们介绍过数据包都是通过 IP 地址传输给接收方的。由于 IP 地址是数字标识，比如极客时间网站的 IP 是 39.106.233.176, 难以记忆，但使用极客时间的域名（time.geekbang.org）就好记多了，所以基于这个需求又出现了一个服务，负责把域名和 IP 地址做一一映射关系。这套域名映射为 IP 的系统就叫做“域名系统”，简称 DNS（Domain Name System）。</p>\n<p>所以，这样一路推导下来，你会发现在第一步浏览器会请求 DNS 返回域名对应的 IP。当然浏览器还提供了 DNS 数据缓存服务，如果某个域名已经解析过了，那么浏览器会缓存解析的结果，以供下次查询时直接使用，这样也会减少一次网络请求。</p>\n<blockquote>\n<ul>\n<li>递归：客户端只发一次请求，要求对方给出最终结果。</li>\n<li>迭代：客户端发出一次请求，对方如果没有授权回答，它就会返回一个能解答这个查询的其它名称服务器列表，客户端会再向返回的列表中发出请求，直到找到最终负责所查域名的名称服务器，从它得到最终结果。</li>\n<li>授权回答：向 dns 服务器查询一个域名，刚好这个域名是本服务器负责，返回的结果就是授权回答。</li>\n</ul>\n</blockquote>\n<ul>\n<li>客户端——本地 dns 服务端：这部分属于递归查询。</li>\n<li>本地 dns 服务端——外网：这部分属于迭代查询。</li>\n<li>递归查询时，返回的结果只有两种：查询成功或查询失败。</li>\n<li>迭代查询，又称作重指引,返回的是最佳的查询点或者主机地址。</li>\n<li>在本地有两种缓存，浏览器缓存和操作系统(OS)缓存，优先访问浏览器缓存。</li>\n</ul>\n<p>拿到 IP 之后，接下来就需要获取端口号了。通常情况下，如果 URL 没有特别指明端口号，那么 HTTP 协议默认是 80 端口。</p>\n<h3 id="等待-tcp-队列"><a href="#%E7%AD%89%E5%BE%85-tcp-%E9%98%9F%E5%88%97" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>等待 TCP 队列</h3>\n<p>现在已经把端口和 IP 地址都准备好了，那么下一步是不是可以建立 TCP 连接了呢？</p>\n<p>答案依然是“不行”。Chrome 有个机制，同一个域名同时最多只能建立 6 个 TCP 连接，如果在同一个域名下同时有 10 个请求发生，那么其中 4 个请求会进入排队等待状态，直至进行中的请求完成。</p>\n<p>当然，如果当前请求数量少于 6，会直接进入下一步，建立 TCP 连接。</p>\n<h3 id="建立-tcp-连接"><a href="#%E5%BB%BA%E7%AB%8B-tcp-%E8%BF%9E%E6%8E%A5" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>建立 TCP 连接</h3>\n<p>排队等待结束之后，终于可以快乐地和服务器握手了，在 HTTP 工作开始之前，浏览器通过 TCP 与服务器建立连接。而 TCP 的工作方式，我在上一篇文章中已经做过详细介绍了，如果有必要，你可以自行回顾下，这里我就不再重复讲述了。</p>\n<h3 id="发送-http-请求"><a href="#%E5%8F%91%E9%80%81-http-%E8%AF%B7%E6%B1%82" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>发送 HTTP 请求</h3>\n<p>一旦建立了 TCP 连接，浏览器就可以和服务器进行通信了。而 HTTP 中的数据正是在这个通信过程中传输的。</p>\n<p>你可以结合下图来理解，浏览器是如何发送请求信息给服务器的。</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-02-14-32-10-3c3808ca8b8b038e69000ae8d201f4f5-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 57.4430823117338%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAB+0lEQVQoz02Q3Y7SQBTH+xw+hfFdjDd6qVe+g8l64QNoNNxsoonRxAv1zgtjAgFWWGAp/aC0pbCUyi79pO18lHZmPFSWOHMyOfPxO///HElwmMdRp4cd48ekPqyz06P/hgTHa1SeO+SthYch/e6S1yZu3ZL3DmrMScPG31xccV6XO1W7g0FNjotn/eRRO/7i7V+q+cN20nDo0xF63Imf9NMXGqJClGDnjgPkXy2JMh7shR3k8uxadjZjyx3b69H8z9D2JqtAW8euv9uliGSZKOib0ebB5+nXZQ5kxbhUcpYx4frJQNZ7Y71zOemOFGPpXd+E7jbZ+HGU5ASRAiFYf7j52dC/8Iuy/ojEOQdLfpReKNPezOlqprz04BYLAW73oFAbhgB5WvtGFUfVwbgkOIfrIEq7stpRzZ7h9HRLma/CDOe0yBEhtAAEekYRanvZOy0cR7Ti7KgM8C3AE6Olmk3FbE2MrmIMtJlsmMrMNJ3FNohu/LDIslc979658sHKjn8WtW2AW2Otqdk/r/SWZv+60rqquQihSwJzQRgEj3MSVoe2Y8ZzcHJSDsPdUNaGuvVb1keG059ML2Xdcla2vdhFMQX3aYaTRA3w2WD70YyhVsWYJOqWYEx3cRrFWRhBHJIoiJM4BarApCSwYrEvOl56/9P0eXMNcMnYXwugWNovkYlQAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 02 14 32 10"\n        title=""\n        src="/static/2021-07-02-14-32-10-3c3808ca8b8b038e69000ae8d201f4f5-fee1c.png"\n        srcset="/static/2021-07-02-14-32-10-3c3808ca8b8b038e69000ae8d201f4f5-a67b7.png 200w,\n/static/2021-07-02-14-32-10-3c3808ca8b8b038e69000ae8d201f4f5-0b187.png 400w,\n/static/2021-07-02-14-32-10-3c3808ca8b8b038e69000ae8d201f4f5-fee1c.png 800w,\n/static/2021-07-02-14-32-10-3c3808ca8b8b038e69000ae8d201f4f5-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>首先浏览器会向服务器发送请求行，它包括了请求方法、请求 URI（Uniform Resource Identifier）和 HTTP 版本协议。</p>\n<p>发送请求行，就是告诉服务器浏览器需要什么资源，最常用的请求方法是 Get。比如，直接在浏览器地址栏键入极客时间的域名（time.geekbang.org），这就是告诉服务器要 Get 它的首页资源。</p>\n<p>另外一个常用的请求方法是 POST，它用于发送一些数据给服务器，比如登录一个网站，就需要通过 POST 方法把用户信息发送给服务器。如果使用 POST 方法，那么浏览器还要准备数据给服务器，这里准备的数据是通过请求体来发送。</p>\n<p>在浏览器发送请求行命令之后，还要以请求头形式发送其他一些信息，把浏览器的一些基础信息告诉服务器。比如包含了浏览器所使用的操作系统、浏览器内核等信息，以及当前请求的域名信息、浏览器端的 Cookie 信息，等等</p>\n<h2 id="服务器端处理-http-请求流程"><a href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%A4%84%E7%90%86-http-%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>服务器端处理 HTTP 请求流程</h2>\n<p>历经千辛万苦，HTTP 的请求信息终于被送达了服务器。接下来，服务器会根据浏览器的请求信息来准备相应的内容</p>\n<h3 id="返回请求"><a href="#%E8%BF%94%E5%9B%9E%E8%AF%B7%E6%B1%82" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>返回请求</h3>\n<p>一旦服务器处理结束，便可以返回数据给浏览器了。你可以通过工具软件 curl 来查看返回请求数据，具体使用方法是在命令行中输入以下命令：</p>\n<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">curl -i https://time.geekbang.org/</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>注意这里加上了 -i 是为了返回响应行、响应头和响应体的数据，返回的结果如下图所示，你可以结合这些数据来理解服务器是如何响应浏览器的。</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-02-14-33-16-988b7460f818f1f1b7cc6d1a675b62dd-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 57.00525394045533%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABzUlEQVQoz3VSu44UMRDcnyEl5z+I+AIISBDiE0gJSC5CSAQkhEQXcgTcaoVuD7S3e8e8djzv8XieHtvjtumZEwcS0CpZpZarq7vtFRijASQA1yC0lhoUgDbG2H+HWXAbK+Rvnf7hGXu8rp9t2ItN9WTNDrW0f1z6TxG7UmBOE/Hyir/a0te75mRbnOxqr8U0WLTHFgDpHBaADvKjy9Y5n9PGrDiYerKZMHsvuvpxPFwHxDuWZdVRyikdq2pqW4RsGtN3FxF78P778y8Z+k5gVjjeMEGj4MYnF9fO3ic7x987bpykQz8MA781x72Mozh28qxUXytVK8wYnNnC0l4Wxzeu5/mB43ohIV3fY6taa6UUnoBWUpz7+b0320enHvrhXn+L8zR1gyAMiev7YRSjc0iiOEm8IEiyrKobVjdxM56nw2U5NtP8IndiKAkhrpsEAXGcJPDrLK2zjKVJHh7bIhdt2zPWyUlbK8EO07KwO3EeRREhjFI5jlpKJUYkCiHEzIWQfRfT9sOh+By3el7/Ip5/BD5DnsdFMeGfWQCYm+vOpbWxCrmSm2N5/923p58IqibzS4yXu4rRvJg4/xuKc8n50PdUaDrZStl2afsnTdJpKRbSYLIAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 02 14 33 16"\n        title=""\n        src="/static/2021-07-02-14-33-16-988b7460f818f1f1b7cc6d1a675b62dd-fee1c.png"\n        srcset="/static/2021-07-02-14-33-16-988b7460f818f1f1b7cc6d1a675b62dd-a67b7.png 200w,\n/static/2021-07-02-14-33-16-988b7460f818f1f1b7cc6d1a675b62dd-0b187.png 400w,\n/static/2021-07-02-14-33-16-988b7460f818f1f1b7cc6d1a675b62dd-fee1c.png 800w,\n/static/2021-07-02-14-33-16-988b7460f818f1f1b7cc6d1a675b62dd-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>首先服务器会返回响应行，包括协议版本和状态码。</p>\n<p>但并不是所有的请求都可以被服务器处理的，那么一些无法处理或者处理出错的信息，怎么办呢？服务器会通过请求行的状态码来告诉浏览器它的处理结果，比如：</p>\n<ul>\n<li>最常用的状态码是 200，表示处理成功；</li>\n<li>如果没有找到页面，则会返回 404</li>\n</ul>\n<p>状态码类型很多，这里我就不过多介绍了，网上有很多资料，你可以自行查询和学习。</p>\n<p>随后，正如浏览器会随同请求发送请求头一样，服务器也会随同响应向浏览器发送响应头。响应头包含了服务器自身的一些信息，比如服务器生成返回数据的时间、返回的数据类型（JSON、HTML、流媒体等类型），以及服务器要在客户端保存的 Cookie 等信息。</p>\n<p>发送完响应头后，服务器就可以继续发送响应体的数据，通常，响应体就包含了 HTML 的实际内容。</p>\n<p>以上这些就是服务器响应浏览器的具体过程</p>\n<h3 id="断开连接"><a href="#%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>断开连接</h3>\n<p>通常情况下，一旦服务器向客户端返回了请求数据，它就要关闭 TCP 连接。不过如果浏览器或者服务器在其头信息中加入了：</p>\n<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">Connection:Keep-Alive</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>那么 TCP 连接在发送后将仍然保持打开状态，这样浏览器就可以继续通过同一个 TCP 连接发送请求。保持 TCP 连接可以省去下次请求时需要建立连接的时间，提升资源加载速度。比如，一个 Web 页面中内嵌的图片就都来自同一个 Web 站点，如果初始化了一个持久连接，你就可以复用该连接，以请求其他资源，而不需要重新再建立新的 TCP 连接。</p>\n<h3 id="重定向"><a href="#%E9%87%8D%E5%AE%9A%E5%90%91" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>重定向</h3>\n<p>到这里似乎请求流程快结束了，不过还有一种情况你需要了解下，比如当你在浏览器中打开 geekbang.org 后，你会发现最终打开的页面地址是 <a href="https://www.geekbang.org%E3%80%82" target="_blank" rel="nofollow noreferrer noopener">https://www.geekbang.org。</a></p>\n<p>这两个 URL 之所以不一样，是因为涉及到了一个重定向操作。跟前面一样，你依然可以使用 curl 来查看下请求 geekbang.org 会返回什么内容？</p>\n<p>在控制台输入如下命令：</p>\n<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">curl -I geekbang.org</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>注意这里输入的参数是 -I，和 -i 不一样，-I 表示只需要获取响应头和响应行数据，而不需要获取响应体的数据，最终返回的数据如下图所示：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-02-14-34-31-69e505f1be7d2fd4b613ea7a458e0885-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 49.38704028021015%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABu0lEQVQoz32RPW/UMBjHs/AN+EKMDExs7cTOzFqkSggJBGIoEqq6wAhLRbcuqKI6hKjuUO7ydnbeLlzsXHOX+HKJX842SSr1hYHHkvXX4+dnP//Hhr4dql3/i/ZU3aowrpXs09/R5rW5fGfmB+P80F69/Z0d2OQ9qD/5m0NQOSW/rrwDiz51ZOUPjv1Hn8ePT+Duiffwy2TnW7b7Y/3sonz6szhD9F+41VLprVJroTDTIRHDEP8KsJnkF9FiANMBSAc+Hvp/knQh9I01Q9+1KbXOKuYFiRcmIJ47MLJhbPszG0S2B2dBuCFEMiY5v4Ll6bx5YZZvLPJqtDhyi7JhEEyjOArDEPbhui5CaZZlGONlnndv1HXbsKGUenK+MvbP7708M/ZO73/040oAMB3btut5luNMIUwx7t3d9Cgp7eBSqK8J3R8Ve6PV8+Hyg1XElyQNwtiykA8RmM4ByGexLApFiFqXirPuoiu4H5KCtTaJdiudUpVXDQJgAUELp56LA3/uOshxZtYkmYxRHLdGlhh1ntu5N1tFuCq4LLmstkpIxZqaM8rqTSeaut0F56xpOKWCNrRab1n3Z38BvcEfk8FQqrIAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 02 14 34 31"\n        title=""\n        src="/static/2021-07-02-14-34-31-69e505f1be7d2fd4b613ea7a458e0885-fee1c.png"\n        srcset="/static/2021-07-02-14-34-31-69e505f1be7d2fd4b613ea7a458e0885-a67b7.png 200w,\n/static/2021-07-02-14-34-31-69e505f1be7d2fd4b613ea7a458e0885-0b187.png 400w,\n/static/2021-07-02-14-34-31-69e505f1be7d2fd4b613ea7a458e0885-fee1c.png 800w,\n/static/2021-07-02-14-34-31-69e505f1be7d2fd4b613ea7a458e0885-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从图中你可以看到，响应行返回的状态码是 301，状态 301 就是告诉浏览器，我需要重定向到另外一个网址，而需要重定向的网址正是包含在响应头的 Location 字段中，接下来，浏览器获取 Location 字段中的地址，并使用该地址重新导航，这就是一个完整重定向的执行流程。这也就解释了为什么输入的是 geekbang.org，最终打开的却是 <a href="https://www.geekbang.org" target="_blank" rel="nofollow noreferrer noopener">https://www.geekbang.org</a> 了。</p>\n<p>不过也不要认为这种跳转是必然的。如果你打开 <a href="https://12306.cn" target="_blank" rel="nofollow noreferrer noopener">https://12306.cn</a>，你会发现这个站点是打不开的。这是因为12306的服务器并没有处理跳转，所以必须要手动输入完整的 <a href="https://www.12306.com" target="_blank" rel="nofollow noreferrer noopener">https://www.12306.com</a> 才能打开页面。</p>\n<h2 id="问题解答"><a href="#%E9%97%AE%E9%A2%98%E8%A7%A3%E7%AD%94" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>问题解答</h2>\n<p>说了这么多，相信你现在已经了解了 HTTP 的请求流程，那现在我们再回过头来看看文章开头提出的问题。</p>\n<h3 id="为什么很多站点第二次打开速度会很快？"><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BE%88%E5%A4%9A%E7%AB%99%E7%82%B9%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%89%93%E5%BC%80%E9%80%9F%E5%BA%A6%E4%BC%9A%E5%BE%88%E5%BF%AB%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>为什么很多站点第二次打开速度会很快？</h3>\n<p>如果第二次页面打开很快，主要原因是第一次加载页面过程中，缓存了一些耗时的数据。</p>\n<p>那么，哪些数据会被缓存呢？从上面介绍的核心请求路径可以发现，DNS 缓存和页面资源缓存这两块数据是会被浏览器缓存的。其中，DNS 缓存比较简单，它主要就是在浏览器本地把对应的 IP 和域名关联起来，这里就不做过多分析了。</p>\n<p>我们重点看下浏览器资源缓存，下面是缓存处理的过程：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-02-14-37-15-61f31fbab75310c0f7be777f4b9becac-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 114.79859894921192%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAXCAIAAACEf/j0AAAACXBIWXMAAA7DAAAOwwHHb6hkAAADgUlEQVQ4y2VUy47sNBC9Env+gX9hwS+wYMcn8DEsEAskdAUbJCSQ0JWu0GhmmBnNq5/ppDvPThznYTuOEzvpxAnV3cP09KWkWEmljl0551TejePYtm1RFGVZjm+i6zqlVN/3r5lhGCBTHaJpGsi8gyvL85vbu9lsprU+FsGaJMl8PqeUvmZ2u51lWZeXl9fX19Pp9AV8fH2s+OTw8X8BZ0KnR8gePKftbzbz/ADFOIzjEKEsJ4QyHPi1a6s0kVEoUVS5jkowZayu6xP4u4vos++NLU5wmkVJGmHMRdUPA+c8RrFpWqa1NgxjGwR1VSGEzsC/2vzbv0PL9RJabHGGCWOi5lW1RbEfxW6I1v7WQzjnQkiVppmU8gQ+xu3D08Xt/T+Pk9vHiRdGtuejNH+aLx8M6+p5djdbOltk+0FGqDpQ/QKGDoEBRIuIlmIYhR7LTtd6pGWdCplvIx4iXgje9qrXZVVLpc7ATT+0wygB2XQVKxShLeelqMpmJ3KiKGtUAwWgx6fg412nB1BZD2Mvm16ITggwA1RDcgdGglXvxYSkegtOlA5F63qe7biOH5i2E6VZRhksvGmdCHtJjgtBZQMbAdVn4K/+DL78w684g0/GhOZFUatm36FqAi6fn5+t5YJmaUQ4d9wySeALTuBvPkZffwjKgslOy52GtVYt7J+W1YrUM3e7xnnIKiNmJMnLLDtjG9gCYlbrDai69gJ3G4HOrBQp417dX5D+97j/CzVL3olxFNC2fNP20dWG7Xy8urmfLacrK0DYD6O84Fy2Ico3rAnakXZDdyRMnrE9AJPQZFhUhdxJwqooqnFclqKta3p3Qzw/ZGUE/uAl2OyFMJiqXg9I9kS2dhAarj9bOzPLtrcRDAdKUiabueMtvfDB3Fw9TizXD2DfV3ti0Xz+o/nDqugqjlmJaZFCt7UEwanamSibPT2YKwM22jBJGg3DcwKnVfvFL95PJtM1P5hkT0A/jJ0esZCLtFzHqU1Lm4hLK/RyjpLkNBhw1XuFuuXKNDbOZLlamOs4IzjN40IYRfsBqZ8X+P2Tc+MlZhClhHb//ZtObE8N4+r+cbq2J8bKR9jxfKpaSorw6mZzeesuLNKPYB19oOoE3k+VHgvZsqYHHqFC6bEb9sI0hFTzab0yKmMJCu3A+Xo4A8NDd8CrfqwPDgPbwJy81h3HQx+OfRv/AjZeCGwYRGz2AAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 02 14 37 15"\n        title=""\n        src="/static/2021-07-02-14-37-15-61f31fbab75310c0f7be777f4b9becac-fee1c.png"\n        srcset="/static/2021-07-02-14-37-15-61f31fbab75310c0f7be777f4b9becac-a67b7.png 200w,\n/static/2021-07-02-14-37-15-61f31fbab75310c0f7be777f4b9becac-0b187.png 400w,\n/static/2021-07-02-14-37-15-61f31fbab75310c0f7be777f4b9becac-fee1c.png 800w,\n/static/2021-07-02-14-37-15-61f31fbab75310c0f7be777f4b9becac-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>首先，我们看下服务器是通过什么方式让浏览器缓存数据的？</p>\n<p>从上图的第一次请求可以看出，当服务器返回 HTTP 响应头给浏览器时，浏览器是通过响应头中的 Cache-Control 字段来设置是否缓存该资源。通常，我们还需要为这个资源设置一个缓存过期时长，而这个时长是通过 Cache-Control 中的 Max-age 参数来设置的，比如上图设置的缓存过期时间是 2000 秒。</p>\n<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">Cache-Control:Max-age=2000</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>这也就意味着，在该缓存资源还未过期的情况下, 如果再次请求该资源，会直接返回缓存中的资源给浏览器。</p>\n<p>但如果缓存过期了，浏览器则会继续发起网络请求，并且在 HTTP 请求头中带上：</p>\n<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">If-None-Match:&quot;4f80f-13c-3a1xb12a&quot;</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>服务器收到请求头后，会根据 If-None-Match 的值来判断请求的资源是否有更新。</p>\n<ul>\n<li>如果没有更新，就返回 304 状态码，相当于服务器告诉浏览器：“这个缓存可以继续使用，这次就不重复发送数据给你了。”</li>\n<li>如果资源有更新，服务器就直接返回最新资源给浏览器。</li>\n</ul>\n<p>简要来说，很多网站第二次访问能够秒开，是因为这些网站把很多资源都缓存在了本地，浏览器缓存直接使用本地副本来回应请求，而不会产生真实的网络请求，从而节省了时间。同时，DNS 数据也被浏览器缓存了，这又省去了 DNS 查询环节</p>\n<h3 id="登录状态是如何保持的？"><a href="#%E7%99%BB%E5%BD%95%E7%8A%B6%E6%80%81%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E6%8C%81%E7%9A%84%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>登录状态是如何保持的？</h3>\n<ul>\n<li>\n<p>通过上面的介绍，你已经了解了缓存是如何工作的。下面我们再一起看下登录状态是如何保持的。</p>\n</li>\n<li>\n<p>用户打开登录页面，在登录框里填入用户名和密码，点击确定按钮。点击按钮会触发页面脚本生成用户登录信息，然后调用 POST 方法提交用户登录信息给服务器。</p>\n</li>\n<li>\n<p>服务器接收到浏览器提交的信息之后，查询后台，验证用户登录信息是否正确，如果正确的话，会生成一段表示用户身份的字符串，并把该字符串写到响应头的 Set-Cookie 字段里，如下所示，然后把响应头发送给浏览器</p>\n<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">Set-Cookie: UID=3431uad;</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n</li>\n<li>\n<p>浏览器在接收到服务器的响应头后，开始解析响应头，如果遇到响应头里含有 Set-Cookie 字段的情况，浏览器就会把这个字段信息保存到本地。比如把 UID=3431uad 保持到本地。</p>\n</li>\n<li>\n<p>当用户再次访问时，浏览器会发起 HTTP 请求，但在发起请求之前，浏览器会读取之前保存的 Cookie 数据，并把数据写进请求头里的 Cookie 字段里（如下所示），然后浏览器再将请求头发送给服务器。</p>\n<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">Cookie: UID=3431uad;</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n</li>\n<li>\n<p>服务器在收到 HTTP 请求头数据之后，就会查找请求头里面的“Cookie”字段信息，当查找到包含 UID=3431uad 的信息时，服务器查询后台，并判断该用户是已登录状态，然后生成含有该用户信息的页面数据，并把生成的数据发送给浏览器。</p>\n</li>\n<li>\n<p>浏览器在接收到该含有当前用户的页面数据后，就可以正确展示用户登录的状态信息了</p>\n</li>\n</ul>\n<p>好了，通过这个流程你可以知道浏览器页面状态是通过使用 Cookie 来实现的。Cookie 流程可以参考下图：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-02-14-40-22-4af82d22add944617ac7cc3ca154385a-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 81.61120840630473%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAIAAACZeshMAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAB/ElEQVQoz31T23LbIBD1/39Lf6F96eS1k6ljJ5Yjy5axQNwkhISRhKCL1KRO23jnDLMLHDi7C6sw2+SDewP4f9kU/qwuWGx1yxwBkwc47ycfDUbwYWaYvHV+/HjuCsKZEKwLwxRcvCRuMcbsdknXmTDPjCEuSTOeuCmVle0QyaZ3Dxv27RF/33LMqxyXBeMYQBnCpCAl4bygHJVsnx2eTvLLA/r6SH6kMpIH54UecG2pHs8lbexwnVW0dtjuElbVcGc3TtYHRDlTGsIx5hL8kjNYzC8EzOXpgg/ociZlmqPsfMlQkRyOJ0xOBSFcSN1Nc5pLUX8XDOoBs4iUhxyBwpxQwJlQ8BHon2XDibVugeUm79+rPfNjiApyxkSotqwUbOTakKqJfqVk06ICK90uMsMtOcwx5WJwsYsA3ffpBTdXO73Vv1aN0vo/5CVmQnS2p5WidYOYXCevWVFiWRNZmX5sdNPcIZeME8q3u/36JXlK0pcs3yTp9vXw83l3wSRHl6Zt32X+Q6aUyao2V6ENVV2pOtoY8GVrVGf2aabb9nPZc87QSUgUum1c6FyADvfzqoqqPydzwe0wwiO9Om9G3/auGybwrYt9lbW6ezNjtu+XT6Kvdr15FrWCJz3M5Kqu9Z2Ccc6Px6MQoqQMigediyNjAMY5IcRae/urfgES7pe98fK3TwAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 02 14 40 22"\n        title=""\n        src="/static/2021-07-02-14-40-22-4af82d22add944617ac7cc3ca154385a-fee1c.png"\n        srcset="/static/2021-07-02-14-40-22-4af82d22add944617ac7cc3ca154385a-a67b7.png 200w,\n/static/2021-07-02-14-40-22-4af82d22add944617ac7cc3ca154385a-0b187.png 400w,\n/static/2021-07-02-14-40-22-4af82d22add944617ac7cc3ca154385a-fee1c.png 800w,\n/static/2021-07-02-14-40-22-4af82d22add944617ac7cc3ca154385a-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>简单地说，如果服务器端发送的响应头内有 Set-Cookie 的字段，那么浏览器就会将该字段的内容保持到本地。当下次客户端再往该服务器发送请求时，客户端会自动在请求头中加入 Cookie 值后再发送出去。服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到该用户的状态信息。</p>\n<h2 id="总结-2"><a href="#%E6%80%BB%E7%BB%93-2" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总结</h2>\n<p>本篇文章的内容比较多、比较碎，但是非常重要，所以我先来总结下今天的主要内容。</p>\n<p>为了便于你理解，我画了下面这张详细的“HTTP 请求示意图”，用来展现浏览器中的 HTTP 请求所经历的各个阶段。</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-02-14-40-45-86a71443bb66a1e30057d7f6a1be6e9f-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 37.04028021015762%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAIAAACHqfpvAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABeklEQVQY04WQPUvDUBSGg4s/w8HRXf+Co+Ci2IoVnMXBwUWUFvwDujm4FVsQFRQtrV9owaFSLf1umqS1TW4Tb5MmN01uknuMuLl4lvfwvufhcA4H/xWxbUEQRFFyXfon4n6FAchICeccx+H5tkks3w8cxw0BYtmahr/wcDx2KaWhQz3f833GGPfD/dCse3BNX3neg+mUOHVpXvFJGO2M9IRtJqhzMEBxJO+rg33f3F14qi29EIAghL2AjS0W6FuXLFd+Z8HE2YhLwal4BMaijtdMYxVgHSmRgRJRURS8yEyuOncfhAs5wI+V8ua81pK2b+/O9rY+45Npi0t6Sf4Q3GUDx2wzBsHGQI4q/egQx8BemcmUZ3Ph/T5n691aLXverjeeS8XiQ7bxcFIQj98+y0JB69xgNa9peUnIYPyKlJeOlMNaPv1Rv6j0WOBzI5PwvNRttiqNarstoq6io56pypZhSaJMCDUMUio1wz+FTbPZsQgdKn1DRYzBN4lJZz58Un6rAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 02 14 40 45"\n        title=""\n        src="/static/2021-07-02-14-40-45-86a71443bb66a1e30057d7f6a1be6e9f-fee1c.png"\n        srcset="/static/2021-07-02-14-40-45-86a71443bb66a1e30057d7f6a1be6e9f-a67b7.png 200w,\n/static/2021-07-02-14-40-45-86a71443bb66a1e30057d7f6a1be6e9f-0b187.png 400w,\n/static/2021-07-02-14-40-45-86a71443bb66a1e30057d7f6a1be6e9f-fee1c.png 800w,\n/static/2021-07-02-14-40-45-86a71443bb66a1e30057d7f6a1be6e9f-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从图中可以看到，浏览器中的 HTTP 请求从发起到结束一共经历了如下八个阶段：构建请求、查找缓存、准备 IP 和端口、等待 TCP 队列、建立 TCP 连接、发起 HTTP 请求、服务器处理请求、服务器返回请求和断开连接。</p>\n<p>然后我还通过 HTTP 请求路径解答了两个经常会碰到的问题，一个涉及到了 Cache 流程，另外一个涉及到如何使用 Cookie 来进行状态管理。</p>\n<p>通过今天系统的讲解，想必你已经了解了一个 HTTP 完整的工作流程，相信这些知识点之于你以后的学习或工作会很有帮助。</p>\n<h1 id="渲染流程（上）"><a href="#%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>渲染流程（上）</h1>\n<p>在上一篇文章中我们介绍了导航相关的流程，那导航被提交后又会怎么样呢？就进入了渲染阶段。这个阶段很重要，了解其相关流程能让你“看透”页面是如何工作的，有了这些知识，你可以解决一系列相关的问题，比如能熟练使用开发者工具，因为能够理解开发者工具里面大部分项目的含义，能优化页面卡顿问题，使用 JavaScript 优化动画流程，通过优化样式表来防止强制同步布局，等等。</p>\n<p>既然它的功能这么强大，那么今天，我们就来好好聊聊渲染流程。</p>\n<p>通常，我们编写好 HTML、CSS、JavaScript 等文件，经过浏览器就会显示出漂亮的页面（如下图所示），但是你知道它们是如何转化成页面的吗？这背后的原理，估计很多人都答不上来。</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-02-16-05-52-f9ed713c2bf23d27e50dcf589b7ed991-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 39.492119089316986%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAIAAAB2/0i6AAAACXBIWXMAAA7DAAAOwwHHb6hkAAABCklEQVQY022R626DIABGff9X2SNs2b/d0qyb84IWq7ZORZw60yLgQAe167bWE0IC5PtyAGO8YNCMh3FESqnXFxg/gd8tRlmNcYFw07RxGEXxFpflWf+/8F8oZWsI0UeVZoUHPNuyVdNJSggppJrFMdzLIWyFUHpCQ7ouyzMAg1fTDdbb+4fnKEykRuwJTTZu7N9U9acq0uGayUXR73rJKCWEYGVZVh7wbcv1YXR9++g4K845paoUr8ACLK9yhFWZDu/6QeXJl5zc2rZdvph13QQBTLM0DGPTtKYj5bUnHel415H5OzPG757eHACT901ZpnmOEULjHMb0dmf/QIi6gTIVnPGDMB3mvuob8QvKF8uYFxQAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 02 16 05 52"\n        title=""\n        src="/static/2021-07-02-16-05-52-f9ed713c2bf23d27e50dcf589b7ed991-fee1c.png"\n        srcset="/static/2021-07-02-16-05-52-f9ed713c2bf23d27e50dcf589b7ed991-a67b7.png 200w,\n/static/2021-07-02-16-05-52-f9ed713c2bf23d27e50dcf589b7ed991-0b187.png 400w,\n/static/2021-07-02-16-05-52-f9ed713c2bf23d27e50dcf589b7ed991-fee1c.png 800w,\n/static/2021-07-02-16-05-52-f9ed713c2bf23d27e50dcf589b7ed991-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从图中可以看出，左边输入的是 HTML、CSS、JavaScript 数据，这些数据经过中间渲染模块的处理，最终输出为屏幕上的像素。</p>\n<p>这中间的渲染模块就是我们今天要讨论的主题。为了能更好地理解下文，你可以先结合下图快速抓住 HTML、CSS 和 JavaScript 的含义：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-02-16-05-58-6a940bf92dcacab8dcc2cc452b23d026-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 61.646234676007005%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABTklEQVQoz51S207DMAzd/38RbzzxEwyGRtssbSDNpbk4iVPcbmPTYBLiKKkax8c+trOZV9Q6/wMb2vsJH5r82GX6l0JEMRT5aXs+KkUWxLnvyzB8CDFIKRnLzuGFHErVUEVASp9TclpP46ilNMZ4751zfa+c84Lixuh9SaleyDcoiJlWpjgphECEUoAMpeAvstsJn3iRcYlHWylFSehLtKOTMbNzwA6MFBUx+ClfyCPUnUGXT2StSfKi+ZvMegsZ37tWj6Ph3Np4V/YNEEA3+woRlErWgHM5/iDfGxbGUBibg0et6mSr9zVfyaZqD+fu10q3flqRV6e6jKM47yHnAECdRJoVwKVhz7qc8iByzpumaduWopAFALquI8PLdtt0XdYadq9o7Z9qXnKvD9C7CUJYznj1SOjquuB6xpGDEGPbAGOJs/C2S/yQhv7o+AWZubvkbXXPigAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 02 16 05 58"\n        title=""\n        src="/static/2021-07-02-16-05-58-6a940bf92dcacab8dcc2cc452b23d026-fee1c.png"\n        srcset="/static/2021-07-02-16-05-58-6a940bf92dcacab8dcc2cc452b23d026-a67b7.png 200w,\n/static/2021-07-02-16-05-58-6a940bf92dcacab8dcc2cc452b23d026-0b187.png 400w,\n/static/2021-07-02-16-05-58-6a940bf92dcacab8dcc2cc452b23d026-fee1c.png 800w,\n/static/2021-07-02-16-05-58-6a940bf92dcacab8dcc2cc452b23d026-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从上图可以看出，HTML 的内容是由标记和文本组成。标记也称为标签，每个标签都有它自己的语意，浏览器会根据标签的语意来正确展示 HTML 内容。比如上面的 <code class="language-text">&lt;p&gt;</code> 标签是告诉浏览器在这里的内容需要创建一个新段落，中间的文本就是段落中需要显示的内容</p>\n<p>如果需要改变 HTML 的字体颜色、大小等信息，就需要用到 CSS。CSS 又称为层叠样式表，是由选择器和属性组成，比如图中的 p 选择器，它会把 HTML 里面 <code class="language-text">&lt;p&gt;</code> 标签的内容选择出来，然后再把选择器的属性值应用到 <code class="language-text">&lt;p&gt;</code> 标签内容上。选择器里面有个 color 属性，它的值是 red，这是告诉渲染引擎把 <code class="language-text">&lt;p&gt;</code> 标签的内容显示为红色</p>\n<p>至于 JavaScript（简称为 JS），使用它可以使网页的内容“动”起来，比如上图中，可以通过 JavaScript 来修改 CSS 样式值，从而达到修改文本颜色的目的。</p>\n<p>搞清楚 HTML、CSS 和 JavaScript 的含义后，那么接下来我们就正式开始分析渲染模块了。</p>\n<p>由于渲染机制过于复杂，所以渲染模块在执行过程中会被划分为很多子阶段，输入的 HTML 经过这些子阶段，最后输出像素。我们把这样的一个处理流程叫做渲染流水线，其大致流程如下图所示：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-02-16-06-13-89b78e89bcac2f6bb9219e8b4c79262f-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 21.36602451838879%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAIAAAABPYjBAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAAxklEQVQI111PzQqCQBj0dYJepEeQnqM36REiiA5BBEnUIegUQQehCFL7MTV12z/NXXfVXKgOzmWY75sZGK1qoFRQVBQEY5Hn/6OUsuHV1KuqRKEEYyyECGISIwwRdv0gfMFaAkQwQgCAujGrTYzX3d8wk+X2yYUsLD9qjeze+tIeW/29py/v+tzprtzOzK7eFBMSPIG5m5zMFeO/cCpKNxGZLCGhg0O4ucbDY7T3oGEDw4oXzmt6jlmaEEppknoPJ/BvnKs5H8Iz3DFqFoEBAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 02 16 06 13"\n        title=""\n        src="/static/2021-07-02-16-06-13-89b78e89bcac2f6bb9219e8b4c79262f-fee1c.png"\n        srcset="/static/2021-07-02-16-06-13-89b78e89bcac2f6bb9219e8b4c79262f-a67b7.png 200w,\n/static/2021-07-02-16-06-13-89b78e89bcac2f6bb9219e8b4c79262f-0b187.png 400w,\n/static/2021-07-02-16-06-13-89b78e89bcac2f6bb9219e8b4c79262f-fee1c.png 800w,\n/static/2021-07-02-16-06-13-89b78e89bcac2f6bb9219e8b4c79262f-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>按照渲染的时间顺序，流水线可分为如下几个子阶段：<strong>构建 DOM 树、样式计算、布局阶段、分层、绘制、分块、光栅化和合成</strong>。内容比较多，我会用两篇文章来为你详细讲解这各个子阶段。接下来，在介绍每个阶段的过程中，你应该重点关注以下三点内容</p>\n<ul>\n<li>开始每个子阶段都有其输入的内容；</li>\n<li>然后每个子阶段有其处理过程；</li>\n<li>最终每个子阶段会生成输出内容。</li>\n</ul>\n<p>理解了这三部分内容，能让你更加清晰地理解每个子阶段。</p>\n<h2 id="构建-dom-树"><a href="#%E6%9E%84%E5%BB%BA-dom-%E6%A0%91" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>构建 DOM 树</h2>\n<p>为什么要构建 DOM 树呢？这是因为浏览器无法直接理解和使用 HTML，所以需要将 HTML 转换为浏览器能够理解的结构——DOM 树。</p>\n<p>这里我们还需要简单介绍下什么是树结构，为了更直观地理解，你可以参考下面我画的几个树结构：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-02-16-08-36-42700865796c08a6398a35d5c4b39f2b-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 75.21891418563924%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAIAAABr+ngCAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABPElEQVQoz42Sy06DQBSGef8XcuXKhXHhwsRrUjXUtqQtBSxzYc5tHJgKlVDbEzKZ+XO+nMtP4n9DunOl2JH409GwRzkkJ8cwE6alUdZ5meCjNKtwqyE+kyhZ8oWBQGcKgUg3rnQ8wjT6KuQINUAvBfkeXlUqLXS4zJWErjXwW24HuEtaaV7u25ohoXKtlIQCsxLS0s4r+1UTxzyFuYGNob5sjLqBuu3ooLXwQktmZK1wbX1c1sZK4Xz4ejieWytLE3aDQjQszKJ8fLdvWqScb4ZeO0yOuueqcPd38Z5Ekdgr8oLgbm/EGulEmVo4GyP13o+sOuXNrpFM82j4E/DYYS4N5BrikOfgv8Y+7yBO/bCFI+P9RW3rBpnJOYfEl1buIzCv+2D+9N/+L9wxxeMTZcupdVwA4/UVfr5Pwj/+r3VzCmDATQAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 02 16 08 36"\n        title=""\n        src="/static/2021-07-02-16-08-36-42700865796c08a6398a35d5c4b39f2b-fee1c.png"\n        srcset="/static/2021-07-02-16-08-36-42700865796c08a6398a35d5c4b39f2b-a67b7.png 200w,\n/static/2021-07-02-16-08-36-42700865796c08a6398a35d5c4b39f2b-0b187.png 400w,\n/static/2021-07-02-16-08-36-42700865796c08a6398a35d5c4b39f2b-fee1c.png 800w,\n/static/2021-07-02-16-08-36-42700865796c08a6398a35d5c4b39f2b-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从图中可以看出，树这种结构非常像我们现实生活中的“树”，其中每个点我们称为节点，相连的节点称为父子节点。树结构在浏览器中的应用还是比较多的，比如下面我们要介绍的渲染流程，就在频繁地使用树结构。</p>\n<p>接下来咱们还是言归正传，来看看 DOM 树的构建过程，你可以参考下图</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-02-16-08-49-4cefa68e354f6a9eef45bfa391736ac8-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 48.59894921190894%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABSklEQVQoz32R2U7DMBBF+/9PfABfgcQrm3gAFZVCF7WCkC5pms3x7niJE2wCVYIEI9my594zM5ZH7d/RNH5f5/x8fJgeyFem6RtGbglptK47rS93R8Dk2fUyo+qUGcAY8ygrEcFMCl1rbzJcw7A1dJlV420+O+L7IFV182s0D1NWZZApJZXSSptKqlpxnUxbuHrcFE870Fh5MTuUlLmythnCUqpjweIUQsxEpRDCprbO1ipyuS5fYnwb5M72vM8nEegP72HXKgGuvfbM8MEhlFdB8f62el0spjGaR/kipSfVw0xoKlQP84q1vlAQZzeTGUHwY7e/m4fhEYRJefKM/vkptxAE0ebDGGNtjYqUEcQpHrzZBeecUtp1c+HcZVkKIborIQQh9KM2D3uyBby19TfMGHOOPlwURQe7JITQ1dJadwMHUZLkQGv1CfvcQGddNcHkAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 02 16 08 49"\n        title=""\n        src="/static/2021-07-02-16-08-49-4cefa68e354f6a9eef45bfa391736ac8-fee1c.png"\n        srcset="/static/2021-07-02-16-08-49-4cefa68e354f6a9eef45bfa391736ac8-a67b7.png 200w,\n/static/2021-07-02-16-08-49-4cefa68e354f6a9eef45bfa391736ac8-0b187.png 400w,\n/static/2021-07-02-16-08-49-4cefa68e354f6a9eef45bfa391736ac8-fee1c.png 800w,\n/static/2021-07-02-16-08-49-4cefa68e354f6a9eef45bfa391736ac8-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从图中可以看出，构建 DOM 树的输入内容是一个非常简单的 HTML 文件，然后经由 HTML 解析器解析，最终输出树状结构的 DOM。</p>\n<p>为了更加直观地理解 DOM 树，你可以打开 Chrome 的“开发者工具”，选择“Console”标签来打开控制台，然后在控制台里面输入“document”后回车，这样你就能看到一个完整的 DOM 树结构，如下图所示：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-02-16-09-05-2067a2b87ed56790b581b29b437b690e-78894.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 85.24904214559388%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAIAAABSJhvpAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACCUlEQVQ4y41T/W+bMBDl//9rJu3XdVKlbd2qtouaRUlHS/iyjbENGAzGH8CckDZZl247PVnm4N17uju89ZO6Xsq7lbpdqS93qhFdmqYQIkJIEARZliUAL9ePCcRxHLtXlFKXdyfG2LtayHcfxMVVd3ndvf8oi6pNkggAgBBijNV1XVa8KCuckyRJiqLgnGut1T686fdQSqNsJxJFkSsvhGiewxV6OefwMEc/4dpHm7ItHZkLtXrMkzh0fKfc/DW8m6fPXx8uP20uaJ07suwVyvIwCJx2EsfOf1VVTu4sjrbH/VlLuwoZgCBKASvLpu0cRHcenolDef/dynYmG14Sfx0sbtLNfZslikCV70GekR8znvI38vbbqNSsb3Cq6grGib9YV4RMg52MnuweRh/uxn08ahC87ramaLTGuaipaIrWmL7vdd1Z0VtlrNF91xvRaqFGCUNvGsdpGI5kAkdXfpoYYGADelFJKSHtEOvaru/buhaKMsG4lmD7hzKBkzXGWrRFDWt2jXTVD9186e3uUaP4DHlWdhyc4oe1H7nFogXHXCs9D2UcZnL0JtmNYuuHECG3jI4x2GFv4d/Kxl0EF5xybbSSapb6T9u7sTkpHGP3M8AQtqWY/R4wDm/YptmszGAF/Gw4Wb7Xytmp8j6l0qfdnuSI/Nh0aTKUxBa5LbBlJ6CZLWnvL38BTV/IFJc6LtoAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 02 16 09 05"\n        title=""\n        src="/static/2021-07-02-16-09-05-2067a2b87ed56790b581b29b437b690e-fee1c.png"\n        srcset="/static/2021-07-02-16-09-05-2067a2b87ed56790b581b29b437b690e-a67b7.png 200w,\n/static/2021-07-02-16-09-05-2067a2b87ed56790b581b29b437b690e-0b187.png 400w,\n/static/2021-07-02-16-09-05-2067a2b87ed56790b581b29b437b690e-fee1c.png 800w,\n/static/2021-07-02-16-09-05-2067a2b87ed56790b581b29b437b690e-78894.png 1044w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>图中的 document 就是 DOM 结构，你可以看到，DOM 和 HTML 内容几乎是一样的，但是和 HTML 不同的是，DOM 是保存在内存中树状结构，可以通过 JavaScript 来查询或修改其内容。</p>\n<p>那下面就来看看如何通过 JavaScript 来修改 DOM 的内容，在控制台中输入：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="73521670510394710000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`document.getElementsByTagName(\'p\')[0].innerText = \'black\';`, `73521670510394710000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                data-tooltip="复制"\n              >\n                <svg class="gatsby-code-button-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M16 1H2v16h2V3h12V1zm-1 4l6 6v12H6V5h9zm-1 7h5.5L14 6.5V12z"/></svg>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js">document<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span><span class="token string">\'p\'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>innerText <span class="token operator">=</span> <span class="token string">\'black\'</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>这行代码的作用是把第一个 <code class="language-text">&lt;p&gt;</code> 标签的内容修改为 black，具体执行结果你可以参考下图：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-02-16-09-41-51e72617b9c746f8ec1a1d3f6cf66ed3-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 62.34676007005253%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABh0lEQVQoz4WSWW+cMBSF8/9/VdTHPkVtGjGTAQMeNi94Axu8EQ+kmkylKp8u5nKl43Nk/LR9EvaKqYs73vsYQwgu7i//F+duk0PzlB4/z/kvdH4huu28NQPChJBhGDAdq2vfD2gY+nGHc57my7LcxWFdKVxI7R2jzrCm7QEASa+U4kLedtp7s6O1ttbexSlGLcGZZdIQu5iypbCuEMJCiKRR0w2plEwolYbmwTkEIGFGL5Omq56Lqi/zSwNrRsgkRCrF+ST40UjOF63v4huw3ShLIVY1dn+y7vU3Op/7LOtOpybLeJHjokJ5LmCt3k+mbbY98KfYgdxjHDcf14lTCgFIpxJicGoybWl7aEdmGXNSOEr8pB6dD6KL3ri4dVcsmUq/ziK8VsDC2pbANlc3DOnTEXJ3jsviEfJC+BFb3KUcChTw5yu7lF6p7f/sYq3X4iJ/PJvsbe3aYKdgFAbXNgdmFIfJv/UQO12jdIYhHGNnA+u4Notb/TfOXzdLVzGtms/zOG3f8QHUorEigoV4zAAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 02 16 09 41"\n        title=""\n        src="/static/2021-07-02-16-09-41-51e72617b9c746f8ec1a1d3f6cf66ed3-fee1c.png"\n        srcset="/static/2021-07-02-16-09-41-51e72617b9c746f8ec1a1d3f6cf66ed3-a67b7.png 200w,\n/static/2021-07-02-16-09-41-51e72617b9c746f8ec1a1d3f6cf66ed3-0b187.png 400w,\n/static/2021-07-02-16-09-41-51e72617b9c746f8ec1a1d3f6cf66ed3-fee1c.png 800w,\n/static/2021-07-02-16-09-41-51e72617b9c746f8ec1a1d3f6cf66ed3-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从图中可以看出，在执行了一段修改第一个 <code class="language-text">&lt;p&gt;</code> 标签的 JavaScript 代码后，DOM 的第一个 p 节点的内容成功被修改，同时页面中的内容也被修改了</p>\n<p>好了，现在我们已经生成 DOM 树了，但是 DOM 节点的样式我们依然不知道，要让 DOM 节点拥有正确的样式，这就需要样式计算了</p>\n<h2 id="样式计算"><a href="#%E6%A0%B7%E5%BC%8F%E8%AE%A1%E7%AE%97" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>样式计算</h2>\n<p>样式计算的目的是为了计算出 DOM 节点中每个元素的具体样式，这个阶段大体可分为三步来完成</p>\n<h3 id="把-css-转换为浏览器能够理解的结构"><a href="#%E6%8A%8A-css-%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%B5%8F%E8%A7%88%E5%99%A8%E8%83%BD%E5%A4%9F%E7%90%86%E8%A7%A3%E7%9A%84%E7%BB%93%E6%9E%84" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>把 CSS 转换为浏览器能够理解的结构</h3>\n<p>那 CSS 样式的来源主要有哪些呢？你可以先参考下图：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-02-16-12-02-e0fe4b6f2cb6fe5338ba6e72a381bf91-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 51.225919439579684%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAB4klEQVQoz32S3U/aUBjGvdkytuESqBRMbEHari0CK/ZD0TikRUCIWfz3gIRFjTCzjBv9FxTXIslIIHxeDLeMjoSPXiwG7A4dy2JM9kve8948z3nenPcs6Lre66nXsnJzU1JKJQVUaV6fZeXyqthTfwLN/V+m0yk4dYMFUJlMhnhNRWJxSZKiUliUpIgYju3tBTkfCps/5bNT7XuxWKxUKoqilMvlZrP557qZOZVKkSQZTyRFUQzv7oZCoe2trYgU4dj1V4sv87lToOn3+6PRaDAYDIfD8Xj8IBnHcZKiUNcqwIUgdhh2u93Cum8ZMn/MvdfvRo1Go9PpgMxWqwX8/5JnY+OYP8B6GYamKSfqXEEQmqLZwBvIYj7Ln+j3v2q1GrC1DUD+g2QMw2ivn/CsEW7MiSJ2uwPHCa/P//yF+TSXB5rJZKI/YmZOp9MYQQa3d3iO43lBEDY2eHYnyLHMms2yeJY71vW7drvz7fb2q0G329U0bW7OZrM2+zLD8u8ODw+SyeT+/kEiKjAUH/B4CKTw4Wii/ZBluV6vfzGoVquqqs7N4LVNJtMK6nK6VmGHA7JardCSBVqywY4nT58dHZ/8b+xCofBWlOKJBFgV2LFkAFosGg1ubl5cnAMN+BuPzb8BngdqTouR4pMAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 02 16 12 02"\n        title=""\n        src="/static/2021-07-02-16-12-02-e0fe4b6f2cb6fe5338ba6e72a381bf91-fee1c.png"\n        srcset="/static/2021-07-02-16-12-02-e0fe4b6f2cb6fe5338ba6e72a381bf91-a67b7.png 200w,\n/static/2021-07-02-16-12-02-e0fe4b6f2cb6fe5338ba6e72a381bf91-0b187.png 400w,\n/static/2021-07-02-16-12-02-e0fe4b6f2cb6fe5338ba6e72a381bf91-fee1c.png 800w,\n/static/2021-07-02-16-12-02-e0fe4b6f2cb6fe5338ba6e72a381bf91-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从图中可以看出，CSS 样式来源主要有三种：</p>\n<ul>\n<li>通过 link 引用的外部 CSS 文件</li>\n<li><code class="language-text">&lt;style&gt;</code> 标记内的 CSS</li>\n<li>元素的 style 属性内嵌的 CSS</li>\n</ul>\n<p>和 HTML 文件一样，浏览器也是无法直接理解这些纯文本的 CSS 样式，所以当渲染引擎接收到 CSS 文本时，会执行一个转换操作，将 CSS 文本转换为浏览器可以理解的结构——styleSheets。</p>\n<p>为了加深理解，你可以在 Chrome 控制台中查看其结构，只需要在控制台中输入 document.styleSheets，然后就看到如下图所示的结构</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-02-16-12-40-791585362c47e31660a48d55a09dac3a-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 51.48861646234676%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABfElEQVQoz4VS27KjIBD0//8vu+ckGowgF+UiNwUSdMekzta+bdeUtgzN9Aw21lqEHiNlQgjnvHN227Z1Xe2y5JTWGIHAZ9o2IDGELSUgwftScpO2RKkQ87wYgzEex9F7zzmfGeV44ILraRKE0Ecv6agJ9iM2nEnGVu+aWqvksm/7YSDGLADworV2zlFKlVI+BDjr40tLGSCcVVrHGJvjOIxY+CCUtjln8Ayrp8+UP3g+nymlUgoQyKZ8EugCUqdYEU2vXHHlrQfZXivs3lI5/odTbCfH+2lmcwwRGgbnIA4hGKOhFPg3xvwl5yyt/ew5xcvsZiYkHyENS/sb9R37cez/kPP1IbWeleteJVMjGtH9DlOBg6GlWsor51fJr5ROktLz3TS0ClF+cFaONk58YowRQhBCjPNAsLldl661/R2e+vvL4kF2Lft14T3CbfvoOvgxGhialoZggt8AMVy1xsPctgohPTzm7jbdvlV/n35fFLijdGjb6+XCGfsD3vwz8Zv1rq8AAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 02 16 12 40"\n        title=""\n        src="/static/2021-07-02-16-12-40-791585362c47e31660a48d55a09dac3a-fee1c.png"\n        srcset="/static/2021-07-02-16-12-40-791585362c47e31660a48d55a09dac3a-a67b7.png 200w,\n/static/2021-07-02-16-12-40-791585362c47e31660a48d55a09dac3a-0b187.png 400w,\n/static/2021-07-02-16-12-40-791585362c47e31660a48d55a09dac3a-fee1c.png 800w,\n/static/2021-07-02-16-12-40-791585362c47e31660a48d55a09dac3a-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从图中可以看出，这个样式表包含了很多种样式，已经把那三种来源的样式都包含进去了。当然样式表的具体结构不是我们今天讨论的重点，你只需要知道渲染引擎会把获取到的 CSS 文本全部转换为 styleSheets 结构中的数据，并且该结构同时具备了查询和修改功能，这会为后面的样式操作提供基础</p>\n<h3 id="转换样式表中的属性值，使其标准化"><a href="#%E8%BD%AC%E6%8D%A2%E6%A0%B7%E5%BC%8F%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%B1%9E%E6%80%A7%E5%80%BC%EF%BC%8C%E4%BD%BF%E5%85%B6%E6%A0%87%E5%87%86%E5%8C%96" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>转换样式表中的属性值，使其标准化</h3>\n<p>现在我们已经把现有的 CSS 文本转化为浏览器可以理解的结构了，那么接下来就要对其进行属性值的标准化操作。</p>\n<p>要理解什么是属性值标准化，你可以看下面这样一段 CSS 文本</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="13492427896447578000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`body {\n  font-size: 2em;\n}\np {\n  color: blue;\n}\nspan {\n  display: none;\n}\ndiv {\n  font-weight: bold;\n}\ndiv p {\n  color: green;\n}\ndiv {\n  color: red;\n}`, `13492427896447578000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                data-tooltip="复制"\n              >\n                <svg class="gatsby-code-button-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M16 1H2v16h2V3h12V1zm-1 4l6 6v12H6V5h9zm-1 7h5.5L14 6.5V12z"/></svg>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="css"><pre style="counter-reset: linenumber NaN" class="language-css line-numbers"><code class="language-css"><span class="token selector">body</span> <span class="token punctuation">{</span>\n  <span class="token property">font-size</span><span class="token punctuation">:</span> 2em<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token selector">p</span> <span class="token punctuation">{</span>\n  <span class="token property">color</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token selector">span</span> <span class="token punctuation">{</span>\n  <span class="token property">display</span><span class="token punctuation">:</span> none<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token selector">div</span> <span class="token punctuation">{</span>\n  <span class="token property">font-weight</span><span class="token punctuation">:</span> bold<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token selector">div p</span> <span class="token punctuation">{</span>\n  <span class="token property">color</span><span class="token punctuation">:</span> green<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token selector">div</span> <span class="token punctuation">{</span>\n  <span class="token property">color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>可以看到上面的 CSS 文本中有很多属性值，如 2em、blue、bold，这些类型数值不容易被渲染引擎理解，所以需要将所有值转换为渲染引擎容易理解的、标准化的计算值，这个过程就是属性值标准化。</p>\n<p>那标准化后的属性值是什么样子的？</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-02-16-13-34-8841a135870c814b592e642ff3947b8f-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 30.297723292469353%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAIAAABM9SnKAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABDUlEQVQY0zWP63LCIBBGff/Xsp3WqZ3RqdVqTQgYbgmQREmwDZdu1DKHH/DtYZdZuq0xpSE8cGE6xonoU7rG5G4MNyD1cYrAmsHux0BbWzb21PSkscR0tDnb0bsQiW4zoTKhc6EwrQqhoZK1FqKHzJzfQMIYIjkXTBmZS/VB+K6U7/uc05IVSCBUZZnTGuqx6sT1X0bWrwve1pIUOTodhcR5Zb6UPajL2zceukar+szKX1zEc5euPTIWw/fuMh/8iuoNrZdELktxqLtP2cLbekwrauB+TdU2o7uCb0/1npuNbKufe+cYnY+oDwvtn3UAXtR4vPhhDM4HPMSF8U/Kz3WcmzDX/lV7mBQUkP8AhUBPsP+pwwMAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 02 16 13 34"\n        title=""\n        src="/static/2021-07-02-16-13-34-8841a135870c814b592e642ff3947b8f-fee1c.png"\n        srcset="/static/2021-07-02-16-13-34-8841a135870c814b592e642ff3947b8f-a67b7.png 200w,\n/static/2021-07-02-16-13-34-8841a135870c814b592e642ff3947b8f-0b187.png 400w,\n/static/2021-07-02-16-13-34-8841a135870c814b592e642ff3947b8f-fee1c.png 800w,\n/static/2021-07-02-16-13-34-8841a135870c814b592e642ff3947b8f-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从图中可以看到，2em 被解析成了 32px，red 被解析成了 rgb(255,0,0)，bold 被解析成了 700……</p>\n<h3 id="计算出-dom-树中每个节点的具体样式"><a href="#%E8%AE%A1%E7%AE%97%E5%87%BA-dom-%E6%A0%91%E4%B8%AD%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E5%85%B7%E4%BD%93%E6%A0%B7%E5%BC%8F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>计算出 DOM 树中每个节点的具体样式</h3>\n<p>现在样式的属性已被标准化了，接下来就需要计算 DOM 树中每个节点的样式属性了，如何计算呢？</p>\n<p>这就涉及到 CSS 的继承规则和层叠规则了。</p>\n<p>首先是 CSS 继承。CSS 继承就是每个 DOM 节点都包含有父节点的样式。这么说可能有点抽象，我们可以结合具体例子，看下面这样一张样式表是如何应用到 DOM 节点上的。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="59857768491963760000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`body {\n  font-size: 20px;\n}\np {\n  color: blue;\n}\nspan {\n  display: none;\n}\ndiv {\n  font-weight: bold;\n  color: red;\n}\ndiv p {\n  color: green;\n}`, `59857768491963760000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                data-tooltip="复制"\n              >\n                <svg class="gatsby-code-button-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M16 1H2v16h2V3h12V1zm-1 4l6 6v12H6V5h9zm-1 7h5.5L14 6.5V12z"/></svg>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="css"><pre style="counter-reset: linenumber NaN" class="language-css line-numbers"><code class="language-css"><span class="token selector">body</span> <span class="token punctuation">{</span>\n  <span class="token property">font-size</span><span class="token punctuation">:</span> 20px<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token selector">p</span> <span class="token punctuation">{</span>\n  <span class="token property">color</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token selector">span</span> <span class="token punctuation">{</span>\n  <span class="token property">display</span><span class="token punctuation">:</span> none<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token selector">div</span> <span class="token punctuation">{</span>\n  <span class="token property">font-weight</span><span class="token punctuation">:</span> bold<span class="token punctuation">;</span>\n  <span class="token property">color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token selector">div p</span> <span class="token punctuation">{</span>\n  <span class="token property">color</span><span class="token punctuation">:</span> green<span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>这张样式表最终应用到 DOM 节点的效果如下图所示：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-02-16-14-28-f41716c265ae029adde20d8757c7c165-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 76.70753064798599%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAIAAABr+ngCAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACAklEQVQoz4VTy26bQBT1qh/Qb8oiatUP6Lar/EP/oNt+QxZN1XblqE1XUdVVF7YUimOMMVAIZng/DDMwY3LGkzgPWeqRQMMM53LuuYfRcADbut+m3dCLrXzYAQshxH6tMMLVdV1ZltUOWZ5XZXF8ao7e/zk3koFFf2cz01wCrutqmpbnuap4R07TFLuGYVgru0zjKg5+LcnZVRRkeE+wtsnzAhxZOss45/vvS3LbtlEcxxEpQ+v3kvzUlrK2vLqx5l5aaRJ6nn8DBEGwWq3CMOz7/o6swOXr7O14ffTZlysu2zw6td590bzF1US7nkwmpmmqEuj0gbxX0tGma6t749iWFYPgQ+kNNdkUWdM0gnMohfhH5N29ZuLCTMb6TcXELGZvvv6zSEbFcPLDe/XN/25TKebB7Huy2prH9OVH88UH/dKjTtq8PnNWeUd7fnIRHX+yz5f1YfK+RJKlUbnppAECjUsvOLzhAw2F4PAJ3WLgz8lVJYfdpG5bFxgJo1T0Uqdt2wvMGWO0ncVi4XmecuuRbCHWO8DKvCgIiTZ1PYhOkREBFRIkghDynAxggNPpdKbrlmXBz3ZTDXwjZ8ZYuwMWkE0pVVY/IaMeDnAcRZHjuGQdpMRDHpIkAfPQL/DUMDVqCNN1HULmcwMqkIq6rv9PVkBjYPq+jzwh0ggGUn2QfAuXeEuqlewHzAAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 02 16 14 28"\n        title=""\n        src="/static/2021-07-02-16-14-28-f41716c265ae029adde20d8757c7c165-fee1c.png"\n        srcset="/static/2021-07-02-16-14-28-f41716c265ae029adde20d8757c7c165-a67b7.png 200w,\n/static/2021-07-02-16-14-28-f41716c265ae029adde20d8757c7c165-0b187.png 400w,\n/static/2021-07-02-16-14-28-f41716c265ae029adde20d8757c7c165-fee1c.png 800w,\n/static/2021-07-02-16-14-28-f41716c265ae029adde20d8757c7c165-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从图中可以看出，所有子节点都继承了父节点样式。比如 body 节点的 font-size 属性是 20，那 body 节点下面的所有节点的 font-size 都等于 20。</p>\n<p>为了加深你对 CSS 继承的理解，你可以打开 Chrome 的“开发者工具”，选择第一个“element”标签，再选择“style”子标签，你会看到如下界面</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-02-16-14-40-9531707a82e91ea0e7e015bea3cbc620-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 91.3309982486865%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAIAAADUsmlHAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACdElEQVQ4y22TyW4UMRCG82ScEA+DIl6AEzdOXLiEC+IN8gI5wAEpAimblKAMUZZJT7e73e19adtlNzXZSGam5Ivd/dtVX/21NT1EuVtTCKN3xhhpjU5eB6uNVngSw5himF7G1sreMTrMK07pFOSnQ75fiSnK0ak06uTElOOquEAA02Y3ZEOCYbQatDQTpP0WFgamklOCBDkFi3+uiUsu0Zbkp6CiU92C0ZZpZTOEFIIf7yMGpwqMa2mjOsgcFGTwtJJXM9B1sQRTBbz0fiVXop4ybBKPArxAWrS57eYX3XzG2mvd3SpGOWds6EnTWGs2AisPu+zl0CjBgrdT8Z9P9GEjJ4idNGLojOJY/0baSz3myduFUYprgdsjNtnR/qr4xyM3eYHfSlqrOY8KPCvRWNlZQbX2TCDYNEHIjjsj5QjWOXx5A21sEhhSPLOi1bSRN3NW11oIh4xV53ntjTbGajmEUflgE75fylra0YrqSpydidPT6nzGtck5RYyUlq0ODnNB3FBWgS0PcrRtfd2RVnPhQlbVcb37drG7bdtzZYOWzNcn7OJH//c7muqpVQCmyaYxvOY98Up5JRCrufx5sfN69uVNpH+0QySu+frqYHvr+N2W/r3z7OWy7H70ipK5aDs9cOc9lIIOSzgSGSxKnXUn38jeh27vfSQHj/bMCSzNloLrSXWFU6G4HFGWIgIbZQeQpNII7J52yOWZt1HsWfYsOdbcXlLS8kE49HSIXvaGEY2ojceaY9Ax4bXmP+3lVNkuux4dOpAb2aO47buG9cRx4iW1cjASG0lT9JAzPDp8dZ6XxePQPq07FsD7sLgp2KqX8Q+E9QRmNn6f9QAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 02 16 14 40"\n        title=""\n        src="/static/2021-07-02-16-14-40-9531707a82e91ea0e7e015bea3cbc620-fee1c.png"\n        srcset="/static/2021-07-02-16-14-40-9531707a82e91ea0e7e015bea3cbc620-a67b7.png 200w,\n/static/2021-07-02-16-14-40-9531707a82e91ea0e7e015bea3cbc620-0b187.png 400w,\n/static/2021-07-02-16-14-40-9531707a82e91ea0e7e015bea3cbc620-fee1c.png 800w,\n/static/2021-07-02-16-14-40-9531707a82e91ea0e7e015bea3cbc620-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>这个界面展示的信息很丰富，大致可描述为如下</p>\n<ul>\n<li>首先，可以选择要查看的元素的样式（位于图中的区域 2 中），在图中的第 1 个区域中点击对应的元素元素，就可以了下面的区域查看该元素的样式了。比如这里我们选择的元素是 <code class="language-text">&lt;p&gt;</code> 标签，位于 html.body.div.这个路径下面</li>\n<li>其次，可以从样式来源（位于图中的区域 3 中）中查看样式的具体来源信息，看看是来源于样式文件，还是来源于 UserAgent 样式表。这里需要特别提下 UserAgent 样式，它是浏览器提供的一组默认样式，如果你不提供任何样式，默认使用的就是 UserAgent 样式。</li>\n<li>最后，可以通过区域 2 和区域 3 来查看样式继承的具体过程。</li>\n</ul>\n<p>以上就是 CSS 继承的一些特性，样式计算过程中，会根据 DOM 节点的继承关系来合理计算节点样式。</p>\n<p>样式计算过程中的第二个规则是样式层叠（即 CSS 选择器优先级）。层叠是 CSS 的一个基本特征，它是一个定义了如何合并来自多个源的属性值的算法。它在 CSS 处于核心地位，CSS 的全称“层叠样式表”正是强调了这一点。关于层叠的具体规则这里就不做过多介绍了，网上资料也非常多，你可以自行搜索学习</p>\n<p>总之，样式计算阶段的目的是为了计算出 DOM 节点中每个元素的具体样式，在计算过程中需要遵守 CSS 的继承和层叠两个规则。这个阶段最终输出的内容是每个 DOM 节点的样式，并被保存在 ComputedStyle 的结构内。</p>\n<p>如果你想了解每个 DOM 元素最终的计算样式，可以打开 Chrome 的“开发者工具”，选择第一个“element”标签，然后再选择“Computed”子标签，如下图所示：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-02-16-15-44-cc5179ac54d5735966256e9c98c20ca1-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 75.04378283712785%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAIAAABr+ngCAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACO0lEQVQoz32STW/UMBCG999zBSQqDlS0QqgCcefQAxdaUWjZ0lZVN2yy2cROHMeJncSJvxO8y6oFoTJ6LY1sPzP2a89QjsqSgBwHYVJThvKMUooQwhiv12sAUghBFIVpmkIA4jjGRREEC79ECJl1tCPrcnRuHMdBOm1HZ+00TX3flz4qGsYAE0ZZ63Pa8Iq1qKxRgX2P2TSNKK6SZYbyMiMDYVL03Grla/kSmzFNzhp0d1pcf2qCE748HcLPqkF+fjbwIVvkRtvp73DO7VCfawHODi6Onyy/PIU/XoCzZxzebmBrXVM1eZInaUorxqvez+zgadfbKVlcH73/uPf8aP/t8Zubsz2JFhvYj7qoMgCHod92GR86/wlfvZvPX518PTw5Pwi/vxS/YcI1hAwUNCcdpgK3ggpXCzcoew9bLavLD2z+Gp/v15eH5Nt+n29h6SacszQtclQzKnpthRm9pLd93J3Cm6d5rZpyYKXuatNVo1EbWA2yDJFR+sGrLdNn6ya60yRXJVQY6grpqlAVYnDVZWkL4i4JZ0YZLfT9q9zDbRyQq8s2TbSUWw1GSc7b+dUFRqhpO5bGs+nf2MIcrGi0pFE4UGb8sY2x1goh1wkwxvgdhpJH4R6uWLRsIfTiBdLa40YKASAUQhg3ygo/CvsrVbc3LFiwnwFbLiTv3Gj7nkdRrLUyo1P1f2CwwsGyhoj6r5yhhrZcGtr2qwR2veyUbQv0KOy9lQho4h3G2ssnW4kikyVSBCuc/wL43Euj4RSMGwAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 02 16 15 44"\n        title=""\n        src="/static/2021-07-02-16-15-44-cc5179ac54d5735966256e9c98c20ca1-fee1c.png"\n        srcset="/static/2021-07-02-16-15-44-cc5179ac54d5735966256e9c98c20ca1-a67b7.png 200w,\n/static/2021-07-02-16-15-44-cc5179ac54d5735966256e9c98c20ca1-0b187.png 400w,\n/static/2021-07-02-16-15-44-cc5179ac54d5735966256e9c98c20ca1-fee1c.png 800w,\n/static/2021-07-02-16-15-44-cc5179ac54d5735966256e9c98c20ca1-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>上图红色方框中显示了 html.body.div.p 标签的 ComputedStyle 的值。你想要查看哪个元素，点击左边对应的标签就可以了</p>\n<h2 id="布局阶段"><a href="#%E5%B8%83%E5%B1%80%E9%98%B6%E6%AE%B5" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>布局阶段</h2>\n<p>现在，我们有 DOM 树和 DOM 树中元素的样式，但这还不足以显示页面，因为我们还不知道 DOM 元素的几何位置信息。那么接下来就需要计算出 DOM 树中可见元素的几何位置，我们把这个计算过程叫做布局。</p>\n<p>Chrome 在布局阶段需要完成两个任务：创建布局树和布局计算</p>\n<h3 id="创建布局树"><a href="#%E5%88%9B%E5%BB%BA%E5%B8%83%E5%B1%80%E6%A0%91" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>创建布局树</h3>\n<p>你可能注意到了 DOM 树还含有很多不可见的元素，比如 head 标签，还有使用了 display:none 属性的元素。所以在显示之前，我们还要额外地构建一棵只包含可见元素布局树。</p>\n<p>我们结合下图来看看布局树的构造过程：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-02-16-16-13-ad77522d9035a03d3d0ba10af3f479dd-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 86.1646234676007%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAIAAABSJhvpAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACf0lEQVQ4y22SyW7bMBCG86h9hvYBivbSQ9AHCHrJobmkKboEaGEgjYM4abMndeotsS1Z1E5qJSlLomh1LLlJanggCEMOv+Hwn1krK5vNykSWqSz/LedW+3JWcjHLCymLAjallA+htdqx4+x5Q1s/thbbdYrqD9SLPfNSJZIS28W2bed5voAfjr5sot1BAE6aCzjhYhz4XkSTxjDkaa4G/HCIY2yblgVRzjncP4f7JN04s4wo3bxxr+wEKnVclxAP4DiIWooPZ+4JP7hzFaQrE2SaJqV0AbdtttXGQspPHedQ8cMkh3fWz9Fj8frQOrXSrTbR4vzZLtJpUQuxKPv9bfhtQHa6RIuyTIiNU13kWUXPHNfb7xiEJhnnQRSbyPB8P0mSWrM5HE6Ltxfx9f2k8WVn63zSJtl2x4+mYiaFNlGJiVgcSUYxxhrS4PN9/xH2w/jdx++9+xGn0YcfJ6fd8U33jifTeXlS+kGgKIo2HgMMy7qRj2pzxq7PT1zXAd9CKrYN28HhYE/GOuwwSkFeEBlMCPGklRVcZyKE9Hq9qofz9Kjxiqo/wcGuOxqNhsPhYDBI03QFDPUAFoYhNDBJeFKUXvNNqh5NRUlpHAQBhODah4KXhyTLMpCRcZ4yCvlav2+7Bn76wqWx/Q+G3G5lNAhLMd28tL72/Xo8JWOOrhumaRhGHMfLcFEURmW6YRQ0cpjY7scXKGiN/TLnMsvDKMLzsSOMsRU3i8ogC/yvrq/uFO1zP1g/1ockKaVwbRtmFmSHwVwBQ+sh5jgOwbh50Bx32r/+DI80phh2FnkeIRC1LWtF2XWrEIwPQp5jgzRTxs5a+3k6VScqQtqScrX9Bak3uY1GwpNFAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 02 16 16 13"\n        title=""\n        src="/static/2021-07-02-16-16-13-ad77522d9035a03d3d0ba10af3f479dd-fee1c.png"\n        srcset="/static/2021-07-02-16-16-13-ad77522d9035a03d3d0ba10af3f479dd-a67b7.png 200w,\n/static/2021-07-02-16-16-13-ad77522d9035a03d3d0ba10af3f479dd-0b187.png 400w,\n/static/2021-07-02-16-16-13-ad77522d9035a03d3d0ba10af3f479dd-fee1c.png 800w,\n/static/2021-07-02-16-16-13-ad77522d9035a03d3d0ba10af3f479dd-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从上图可以看出，DOM 树中所有不可见的节点都没有包含到布局树中。</p>\n<p>为了构建布局树，浏览器大体上完成了下面这些工作</p>\n<p>遍历 DOM 树中的所有可见节点，并把这些节点加到布局中；而不可见的节点会被布局树忽略掉，如 head 标签下面的全部内容，再比如 body.p.span 这个元素，因为它的属性包含 dispaly:none，所以这个元素也没有被包进布局树</p>\n<h3 id="布局计算"><a href="#%E5%B8%83%E5%B1%80%E8%AE%A1%E7%AE%97" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>布局计算</h3>\n<p>现在我们有了一棵完整的布局树。那么接下来，就要计算布局树节点的坐标位置了。布局的计算过程非常复杂，我们这里先跳过不讲，等到后面章节中我再做详细的介绍。</p>\n<p>在执行布局操作的时候，会把布局运算的结果重新写回布局树中，所以布局树既是输入内容也是输出内容，这是布局阶段一个不合理的地方，因为在布局阶段并没有清晰地将输入内容和输出内容区分开来。针对这个问题，Chrome 团队正在重构布局代码，下一代布局系统叫 LayoutNG，试图更清晰地分离输入和输出，从而让新设计的布局算法更加简单。</p>\n<h2 id="总结-3"><a href="#%E6%80%BB%E7%BB%93-3" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总结</h2>\n<p>好了，今天正文就到这里，我画了下面这张比较完整的渲染流水线，你可以结合这张图来回顾下今天的内容。</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-02-16-16-48-d4a99bbcee5f2b5ebe9f227ed61e45f5-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 26.70753064798599%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAIAAADKYVtkAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABAElEQVQY002OvU7DMBRG8xCMvAc8BzMTKzsPws4GAwxlCRJSkYq6UIEoFBEiUkITJ24g2I7r2HF+HJtQiuhZ7tX33SNdy6yhtRZL/pO/pZRSCK6UWr+3fkdT113dlAWGIIWRUWVbFaoqu0ppU1QKL2QIYkqz5od2JWttZKs/cCar6i7Clz66AfjkCV75X8PX0H7PoHc7d66JN+AYyFpRSmIwlVIuZWNwLsaPk0awvf5s8yzcsafWobN1Huz3vY3j+M0+QL3d5GhbuD0q1Mx3X+5P0/Rz9TZieQCTjOXPCRkG6CFCFz4eRcSZ40FIcexSMCH+iKGIi4KxBSEZ57wTvwFi8Q6DqtcibQAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 02 16 16 48"\n        title=""\n        src="/static/2021-07-02-16-16-48-d4a99bbcee5f2b5ebe9f227ed61e45f5-fee1c.png"\n        srcset="/static/2021-07-02-16-16-48-d4a99bbcee5f2b5ebe9f227ed61e45f5-a67b7.png 200w,\n/static/2021-07-02-16-16-48-d4a99bbcee5f2b5ebe9f227ed61e45f5-0b187.png 400w,\n/static/2021-07-02-16-16-48-d4a99bbcee5f2b5ebe9f227ed61e45f5-fee1c.png 800w,\n/static/2021-07-02-16-16-48-d4a99bbcee5f2b5ebe9f227ed61e45f5-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从图中可以看出，本节内容我们介绍了渲染流程的前三个阶段：DOM 生成、样式计算和布局。要点可大致总结为如下：</p>\n<ul>\n<li>浏览器不能直接理解 HTML 数据，所以第一步需要将其转换为浏览器能够理解的 DOM 树结构；</li>\n<li>生成 DOM 树后，还需要根据 CSS 样式表，来计算出 DOM 树所有节点的样式；</li>\n<li>最后计算 DOM 元素的布局信息，使其都保存在布局树中。</li>\n</ul>\n<h1 id="渲染流程（下）"><a href="#%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B%EF%BC%88%E4%B8%8B%EF%BC%89" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>渲染流程（下）</h1>\n<p>在上篇文章中，我们介绍了渲染流水线中的 DOM 生成、样式计算和布局三个阶段，那今天我们接着讲解渲染流水线后面的阶段。</p>\n<p>这里还是先简单回顾下上节前三个阶段的主要内容：在 HTML 页面内容被提交给渲染引擎之后，渲染引擎首先将 HTML 解析为浏览器可以理解的 DOM；然后根据 CSS 样式表，计算出 DOM 树所有节点的样式；接着又计算每个元素的几何坐标位置，并将这些信息保存在布局树中</p>\n<h2 id="分层"><a href="#%E5%88%86%E5%B1%82" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>分层</h2>\n<p>现在我们有了布局树，而且每个元素的具体位置信息都计算出来了，那么接下来是不是就要开始着手绘制页面了？</p>\n<p>答案依然是否定的。</p>\n<p>因为页面中有很多复杂的效果，如一些复杂的 3D 变换、页面滚动，或者使用 z-indexing 做 z 轴排序等，为了更加方便地实现这些效果，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树（LayerTree）。如果你熟悉 PS，相信你会很容易理解图层的概念，正是这些图层叠加在一起构成了最终的页面图像。</p>\n<p>要想直观地理解什么是图层，你可以打开 Chrome 的“开发者工具-更多工具”，选择“Layers”标签，就可以看到可视化页面的分层情况，如下图所示</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-02-16-19-07-5b6eab53e4d0fc218cd4e6927b2a7603-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 94.13309982486864%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAATCAIAAAAf7rriAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACh0lEQVQ4y5VTS29SQRS+/4ekJKKFQl03/g9j3PRBbdK4F4toS5NW+w8aN8aNMeERWnWlxkYhBBo3dSFvuK953LkP8LszQKmJC7/czJ0zc7453zlzRpv8D1zX9X1/bmqeRPBv+BLwwQiy4zjXZF3XDV23F0Ak5qZhYF8fjUYYTdPknOOgKXkcBOOFONjo9/udTgd85TEeqy8ETMQHfybbYZ7gvqQphUIIaAMZP9MwOGPYBVOJRwDsQn9I5sRio7Zj64qDU+FXrdYuLr79brXevHv//Ue122lf/rxst9qWacIHnspNw8G9brvf7Q6HQywxxnBkpVLJ5p5D/KePH16fnlbKhULx7dcvn39dXQ0GfVU2QGOcG4bZ6yHT/mAwQHkgGNt72WdPnu692M/n9vNH+YOT45dHh4cHuezxqxPbsqiEBj/8er0emBhBRvBQea12/8HD9Y301vbOzu7j7Z3ddPrR5mZ6fWOr0WiotDX4YaZuGxVzPS9UJQSMSeBNZIUXofyRdkhW1UcNw+UABMkJ/LH8KCW43vk9zSfTq1JLsnsEsQxGLNSfWga1LWkSShmjTNYSM4awGJHpNLIKHsZHAxDLocRhtkMt4XDBKLdNbhuuEhpmFsy7VZtrUOI5vIklOHUYEZy4DnM5FczGiis42slzhSID12T1CrBHEYoSZpv4oJwzorKQGdme68wKN9b+enFICRWR/ThBZfALe38SzrGCuS/fWSAbVlu8A4z1er1ULJ6fn5VKxUKxWC6X0G2l0IAFs3wmgQnMG7IxNpvNe2trd1dXl+/cXlpaisViyWTylgRMjKlUCiuJRCIajd6QrfiZTCYSicAjHo8vx+MrEuCszID1pMQfp7zrJyfY/70AAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 02 16 19 07"\n        title=""\n        src="/static/2021-07-02-16-19-07-5b6eab53e4d0fc218cd4e6927b2a7603-fee1c.png"\n        srcset="/static/2021-07-02-16-19-07-5b6eab53e4d0fc218cd4e6927b2a7603-a67b7.png 200w,\n/static/2021-07-02-16-19-07-5b6eab53e4d0fc218cd4e6927b2a7603-0b187.png 400w,\n/static/2021-07-02-16-19-07-5b6eab53e4d0fc218cd4e6927b2a7603-fee1c.png 800w,\n/static/2021-07-02-16-19-07-5b6eab53e4d0fc218cd4e6927b2a7603-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从上图可以看出，渲染引擎给页面分了很多图层，这些图层按照一定顺序叠加在一起，就形成了最终的页面，你可以参考下图</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-02-16-19-23-31433d4b6eb787869027519d7532ea44-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 76.00700525394046%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAIAAABr+ngCAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACWklEQVQoz3VSS2sTURQeUFwp4kLdqIWK0ELEShfBUDUqakUXIkqLzzRpYoot2Gp9hWma2lIQNS78GXZVXElBUElT24UKQsBMpplJM5mZxDxn7jRN6pe5bUyVfgzDufc8vu+ec5gM952L8ZIkaZpWLBar1erq5jAMQ9f1QqFQLpfjcYGRk0vJZDKVSimyIsuyqqppE2oD0utQTCA4k8lEIhGmpK2htBFgWDYBA4r+8UKCIIjM/9qo8nw+H4vFotFoLperXzYGKKpKkzc4qI8QAm3QDObG5HqALCu15ArRysXsCilVKhXoXDEBG38ajfbAhkEDcKwxKyqDg6GXSDFPtNpLKHAJ5vVu6PjqMI8aComiyJAaDN0o68QgDUCJzQZGpfE8zxBjWc/KeuInSYuUEOUhTxREHzviY/3PWD/rD4wGxn0jAXb0+f2hR++mplAC7WTAkMv+lhKClEygwzhiEvCFw+EtO/bs2t/aZLFZbBesZ68Os5OTr96eutTdfasHARgE3myk0xl+Mc7zi1gS+lT45ua+NrcesXdePn3x2u2+hwNPx+MJCfcfPn7pGxiCwXEcQ3XSP/YO+1BPbmpusR0/Y7V33vQMPh57+evHt9X80vT0e3f/4N9k6CyYoJtEk+fnF3bvO9Rx/kqX58G9JxPDY68/zczEFz5PvAg67vbXZCMZTYJaLCq6h2JYYOiAb3Y2zGzbfqCl7aCl/aj1RPsx+2HrybaOc1t37u26fmPtzWAGIXaQkoOZzikUCjmdTpfL5exxut1ur9fb63J53L2OO45g8A2mDbI/ApfzmGn3K60AAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 02 16 19 23"\n        title=""\n        src="/static/2021-07-02-16-19-23-31433d4b6eb787869027519d7532ea44-fee1c.png"\n        srcset="/static/2021-07-02-16-19-23-31433d4b6eb787869027519d7532ea44-a67b7.png 200w,\n/static/2021-07-02-16-19-23-31433d4b6eb787869027519d7532ea44-0b187.png 400w,\n/static/2021-07-02-16-19-23-31433d4b6eb787869027519d7532ea44-fee1c.png 800w,\n/static/2021-07-02-16-19-23-31433d4b6eb787869027519d7532ea44-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>现在你知道了浏览器的页面实际上被分成了很多图层，这些图层叠加后合成了最终的页面。下面我们再来看看这些图层和布局树节点之间的关系，如文中图所示：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-02-16-19-40-789dd716354757d4cc55c2ea69397fd2-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 59.01926444833625%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABpUlEQVQoz4WSzU7bQBDHIy59AV6Je699AU4cEOIJeukTVOKCBIqQEIeqlSpVEBHxIQ4o5JCqBUIj8oEw8dqOvbteez/Gu0zi1JEQiL9kezU7v935z7jm/gsAoijKssy9IWvtZDLBHFyUkVq1R8KwddXu3v2DAl6FlVKdTqfdbud5/hKWSQAicZJZLV+F8yx7Go8TShljc7isgEvYv4e9O7nbVd1YO1cYKCphncYYxrnkXMQx0hhcwLnSX67452Z/7SQ5echcoaXSlaSULE3HhAQPo8TzeJrOYXz+BOrTIVttBJsXVGnqrLGgjdFoEi/EOil2aTQkvm8AUiEKgIXnv7H7+IutfAtWfvJbwp5i9kglzxUgakAIweNJGgaI4UTQsE8I1jKHuzc3hz8OLA++D8yHrWj562hpW+xcC+dMJrWZqfxwzon3GA8HURhiJ6Zwv98/PTtPWeJlrv472O949Ws2pGY225c9x8vB6IXnadLsrQu7eextHI3WG15ubBV/S7Xy1ylPwvFctlok5r3BwPf9cusduEoyWjcbR4zS+14PvbwLPwMDc6Y+uC/7VAAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 02 16 19 40"\n        title=""\n        src="/static/2021-07-02-16-19-40-789dd716354757d4cc55c2ea69397fd2-fee1c.png"\n        srcset="/static/2021-07-02-16-19-40-789dd716354757d4cc55c2ea69397fd2-a67b7.png 200w,\n/static/2021-07-02-16-19-40-789dd716354757d4cc55c2ea69397fd2-0b187.png 400w,\n/static/2021-07-02-16-19-40-789dd716354757d4cc55c2ea69397fd2-fee1c.png 800w,\n/static/2021-07-02-16-19-40-789dd716354757d4cc55c2ea69397fd2-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>通常情况下，并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层。如上图中的 span 标签没有专属图层，那么它们就从属于它们的父节点图层。但不管怎样，最终每一个节点都会直接或者间接地从属于一个层。</p>\n<p>那么需要满足什么条件，渲染引擎才会为特定的节点创建新的层呢？通常满足下面两点中任意一点的元素就可以被提升为单独的一个图层。</p>\n<p>第一点，拥有层叠上下文属性的元素会被提升为单独的一层。</p>\n<p>页面是个二维平面，但是层叠上下文能够让 HTML 元素具有三维概念，这些 HTML 元素按照自身属性的优先级分布在垂直于这个二维平面的 z 轴上。你可以结合下图来直观感受下：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-02-16-19-52-1b184bd368aca2f479b6127e610206b6-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 52.62697022767075%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABZ0lEQVQoz5WSy0sCQRzH/ZOiW53qGEQY6aFLBEFZB+15CUMrIqgklIwORV6KuhTdDPEBgYb22J3Xaj4WDavd9WCXdjc3tzEsgtTqw/f0m/kwM3zHoGmaqr6+VVS9ItejvWiqQoctqFaruq4bREniEIiw6aW4sHItrl4JC3HJn+LTKYIxaQjHcYqi1OQnUcoixh0tdG0+2lyZCW9+aIP37yXyCKK7JEEI/4D6sizXZOFD9sTuT6bCcvd6rsddNHqzvV5mcJs9DuJsCkP0i7x1WTiavXhod/g6XJaRwNzY+bzpdNrDOmMCgM1PFkUJAvYGc/xagG9b3O309E0mTNaYaTzav8OPhkssxKSZLEkSC0ASIw6TpP3AN3xoXEZmJ2u23w7sFyyhEmgtAwDoBHIknSFnbM4aEmfCAo0tKDgiRYCaX5vKEMJaA59r3PeQxnV9vVlkGAYhBP8M3VyXad3lcvn5n9B/SeV3TSkhZIoRX2gAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 02 16 19 52"\n        title=""\n        src="/static/2021-07-02-16-19-52-1b184bd368aca2f479b6127e610206b6-fee1c.png"\n        srcset="/static/2021-07-02-16-19-52-1b184bd368aca2f479b6127e610206b6-a67b7.png 200w,\n/static/2021-07-02-16-19-52-1b184bd368aca2f479b6127e610206b6-0b187.png 400w,\n/static/2021-07-02-16-19-52-1b184bd368aca2f479b6127e610206b6-fee1c.png 800w,\n/static/2021-07-02-16-19-52-1b184bd368aca2f479b6127e610206b6-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从图中可以看出，明确定位属性的元素、定义透明属性的元素、使用 CSS 滤镜的元素等，都拥有层叠上下文属性。</p>\n<p>第二点，需要剪裁（clip）的地方也会被创建为图层。</p>\n<p>不过首先你需要了解什么是剪裁，结合下面的 HTML 代码：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="4315177304008499700"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`<style>\n  div {\n    width: 200;\n    height: 200;\n    overflow: auto;\n    background: gray;\n  }\n</style>\n<body>\n  <div>\n    <p>\n      所以元素有了层叠上下文的属性或者需要被剪裁，那么就会被提升成为单独一层，你可以参看下图：\n    </p>\n    <p>\n      从上图我们可以看到，document层上有A和B层，而B层之上又有两个图层。这些图层组织在一起也是一颗树状结构。\n    </p>\n    <p>\n      图层树是基于布局树来创建的，为了找出哪些元素需要在哪些层中，渲染引擎会遍历布局树来创建层树（Update LayerTree）。\n    </p>\n  </div>\n</body>`, `4315177304008499700`)"\n            >\n              <div\n                class="gatsby-code-button"\n                data-tooltip="复制"\n              >\n                <svg class="gatsby-code-button-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M16 1H2v16h2V3h12V1zm-1 4l6 6v12H6V5h9zm-1 7h5.5L14 6.5V12z"/></svg>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">\n  <span class="token selector">div</span> <span class="token punctuation">{</span>\n    <span class="token property">width</span><span class="token punctuation">:</span> 200<span class="token punctuation">;</span>\n    <span class="token property">height</span><span class="token punctuation">:</span> 200<span class="token punctuation">;</span>\n    <span class="token property">overflow</span><span class="token punctuation">:</span> auto<span class="token punctuation">;</span>\n    <span class="token property">background</span><span class="token punctuation">:</span> gray<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>\n      所以元素有了层叠上下文的属性或者需要被剪裁，那么就会被提升成为单独一层，你可以参看下图：\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>\n      从上图我们可以看到，document层上有A和B层，而B层之上又有两个图层。这些图层组织在一起也是一颗树状结构。\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>\n      图层树是基于布局树来创建的，为了找出哪些元素需要在哪些层中，渲染引擎会遍历布局树来创建层树（Update LayerTree）。\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>在这里我们把 div 的大小限定为 200*200 像素，而 div 里面的文字内容比较多，文字所显示的区域肯定会超出 200*200 的面积，这时候就产生了剪裁，渲染引擎会把裁剪文字内容的一部分用于显示在 div 区域，下图是运行时的执行结果</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-02-16-20-36-8dcd5a1dc365e9c77df5fd51b4ebf21e-e52c1.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 664px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 70.18072289156628%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAIAAACgpqunAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABkUlEQVQoz6WSO48BURiG/TiFahESNq4xZhF3ywxD3BKlRE8kGsS1EgmS3UKB2h+Q+BvMPjmq3ZjdYt9i8s2Z83zvd945ptPpNBqNlsvlfD6fTqfj8Xg2m00mE+rVakXNp8vlouv6/X7Xv8vU6XQsFovb7bbZbC9CVqvV4XDY7fZUKvUqtN/v2Xq73X7CvV7P5/PJsuz3+5PJZCwWSyQSkiQFAoF8Ph+JRBRFOR6Pz+Fut+tyucLhsMfjwZ/C6/XmcrlSqVSpVDRNUxX1cDg8h4fDIVZsBcC5WCxmMplqtdpqtRqNRrPZhDeEF4tFoVCA4UkLCgzfhWq1GjCLhvBgMAiFQhySsXm+CTE/r5y2Xq//AZMWM8fjcdKCZ2xZSBKihSFM2viwNZ1OP+INBoMw9ML8EYch3O/3SRuAnGEehpgzBbGzqKrqb2NzDTg2PL+a3dFoFICTw9Mrm80awu1222w2Y4K/0+nkVpXLZTLXhEge2PCGnc/n9Xq92+02m812u6X4FPoQomDler0+v9v6P/QF9o1HLIXkyEcAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 02 16 20 36"\n        title=""\n        src="/static/2021-07-02-16-20-36-8dcd5a1dc365e9c77df5fd51b4ebf21e-e52c1.png"\n        srcset="/static/2021-07-02-16-20-36-8dcd5a1dc365e9c77df5fd51b4ebf21e-57381.png 200w,\n/static/2021-07-02-16-20-36-8dcd5a1dc365e9c77df5fd51b4ebf21e-40546.png 400w,\n/static/2021-07-02-16-20-36-8dcd5a1dc365e9c77df5fd51b4ebf21e-e52c1.png 664w"\n        sizes="(max-width: 664px) 100vw, 664px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>出现这种裁剪情况的时候，渲染引擎会为文字部分单独创建一个层，如果出现滚动条，滚动条也会被提升为单独的层。你可以参考下图：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-02-16-20-47-403ddb282ae513e46ba23ecea178fce5-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 35.288966725043785%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAIAAACHqfpvAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAAyklEQVQY032Qvw5EQBDGPahGoxahlGglXsC7KBANLQXRXWLdrd3TkLictTeWc+ISv2Iy2dnvmz9Sje43hFHTQFKjB6WECgghTwFuKW7JaxyjKNJ13bIs27bLsuScS+8JYNMaGeN85l9mASRQgxjHsaIomqYZhpHn+SJey9ewxZSHYSjLsqqqYJFl2SYGYLxhGK7FSZKYpum6ruM4VVVtYqilaep5XhAEfd8fBz5ZnB5/Y3dd5/t+URTHha+X2sT7J3G56XizveG/0QdUtIHGAH/uIwAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 02 16 20 47"\n        title=""\n        src="/static/2021-07-02-16-20-47-403ddb282ae513e46ba23ecea178fce5-fee1c.png"\n        srcset="/static/2021-07-02-16-20-47-403ddb282ae513e46ba23ecea178fce5-a67b7.png 200w,\n/static/2021-07-02-16-20-47-403ddb282ae513e46ba23ecea178fce5-0b187.png 400w,\n/static/2021-07-02-16-20-47-403ddb282ae513e46ba23ecea178fce5-fee1c.png 800w,\n/static/2021-07-02-16-20-47-403ddb282ae513e46ba23ecea178fce5-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>所以说，元素有了层叠上下文的属性或者需要被剪裁，满足这任意一点，就会被提升成为单独一层。</p>\n<h2 id="图层绘制"><a href="#%E5%9B%BE%E5%B1%82%E7%BB%98%E5%88%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>图层绘制</h2>\n<p>在完成图层树的构建之后，渲染引擎会对图层树中的每个图层进行绘制，那么接下来我们看看渲染引擎是怎么实现图层绘制的？</p>\n<p>试想一下，如果给你一张纸，让你先把纸的背景涂成蓝色，然后在中间位置画一个红色的圆，最后再在圆上画个绿色三角形。你会怎么操作呢？</p>\n<p>通常，你会把你的绘制操作分解为三步：</p>\n<ul>\n<li>制蓝色背景；</li>\n<li>在中间绘制一个红色的圆；</li>\n<li>再在圆上绘制绿色三角形</li>\n</ul>\n<p>渲染引擎实现图层的绘制与之类似，会把一个图层的绘制拆分成很多小的绘制指令，然后再把这些指令按照顺序组成一个待绘制列表，如下图所示：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-02-16-21-21-5bf50c6a0589859e0e21d716ffa7e99f-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 52.80210157618214%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABWElEQVQoz21Sy07DQAzs//8H4ggXpB4BobYSqBz6VBGBNM9mkzSvzeblXaZZqWob5mCtbM/YGWekBiAiy7JM0zQMI89zZKSU6j+MdK3rOnAQ8W7bdrvdrtfrxWIRRZGWA3QbcEXmnGdZFoZhURRJkugohKjrGvFwOKCapiliHMeIyF+Rm6ZxXRcF27bR4XleEAS+70MFeehCAg9IVFV1S8YE0EDmBceGmlyWJVodx2GMiR6wAMlbMiTxeSBjZzSBeRLqRSMWVDxvBG9FmR0Ha2tLELEw3JIXQDIj5XfKF+QVFArYRleGnYH5UNW2n9xvG8brh2U6+YwnTvsRqSeL9oXsD3RB1kOwOW6rL7zbfSUh+8nK6Zuh7mbdkaNhc6RNcuqkIRme4byr1Wo+n09nM5GnTqXu9/K7VstE/uby0aR3NiAPof+pqJJji15cevbkqy/HtjQv1v4DYTZ1QqC9FIIAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 02 16 21 21"\n        title=""\n        src="/static/2021-07-02-16-21-21-5bf50c6a0589859e0e21d716ffa7e99f-fee1c.png"\n        srcset="/static/2021-07-02-16-21-21-5bf50c6a0589859e0e21d716ffa7e99f-a67b7.png 200w,\n/static/2021-07-02-16-21-21-5bf50c6a0589859e0e21d716ffa7e99f-0b187.png 400w,\n/static/2021-07-02-16-21-21-5bf50c6a0589859e0e21d716ffa7e99f-fee1c.png 800w,\n/static/2021-07-02-16-21-21-5bf50c6a0589859e0e21d716ffa7e99f-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从图中可以看出，绘制列表中的指令其实非常简单，就是让其执行一个简单的绘制操作，比如绘制粉色矩形或者黑色的线等。而绘制一个元素通常需要好几条绘制指令，因为每个元素的背景、前景、边框都需要单独的指令去绘制。所以在图层绘制阶段，输出的内容就是这些待绘制列表。</p>\n<p>你也可以打开“开发者工具”的“Layers”标签，选择“document”层，来实际体验下绘制列表，如下图所示：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-02-16-21-35-fe1bafa462e925267eb2f89be13b57cf-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 44.833625218914186%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAIAAAC9o5sfAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABMklEQVQoz3WR20rDQBCG8/4v4KUFvdFeCb6BggqlULU5lGLS1uwh2WyS3Z1NmqRZt0eL2I9/h5mBb27WwYSEYYgxwTT9RpRQaitjjHOe7chzzjKeMm6XdpQ7ioIDgENp8jl1U5ZuetNtttja92ZP27ZKSXNGf8T2jtZaCGGr+Y+maZQQ5gJHGcCYjTHd9rR9x7RdV69rc7Y5ZSuD1qAkycrnIH2ZF6NI0GVW4UyhDC5EY54vYo5zB6yt5BcVV090MCpuxhBNksaPwUP6QioP5e4qwcVBjhIxeE0e3fLBW6+myTpAEGC9z4zUC6ZPY4ArH8sFVTUc5DAR16/p8F3eT+TyI25m+EzG1Zz+kUVIJChH2f+SIqLl7Ru9G/PhmEeTVeUj4SF5ivvbKx+BH5cRFUr+AHjg9WbzO6BtAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 02 16 21 35"\n        title=""\n        src="/static/2021-07-02-16-21-35-fe1bafa462e925267eb2f89be13b57cf-fee1c.png"\n        srcset="/static/2021-07-02-16-21-35-fe1bafa462e925267eb2f89be13b57cf-a67b7.png 200w,\n/static/2021-07-02-16-21-35-fe1bafa462e925267eb2f89be13b57cf-0b187.png 400w,\n/static/2021-07-02-16-21-35-fe1bafa462e925267eb2f89be13b57cf-fee1c.png 800w,\n/static/2021-07-02-16-21-35-fe1bafa462e925267eb2f89be13b57cf-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>在该图中，区域 1 就是 document 的绘制列表，拖动区域 2 中的进度条可以重现列表的绘制过程。</p>\n<h2 id="栅格化（raster）操作"><a href="#%E6%A0%85%E6%A0%BC%E5%8C%96%EF%BC%88raster%EF%BC%89%E6%93%8D%E4%BD%9C" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>栅格化（raster）操作</h2>\n<p>绘制列表只是用来记录绘制顺序和绘制指令的列表，而实际上绘制操作是由渲染引擎中的合成线程来完成的。你可以结合下图来看下渲染主线程和合成线程之间的关系：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-02-16-21-55-1ba3be4d39252859208fc5006de0b4ff-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 40.63047285464098%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAIAAAB2/0i6AAAACXBIWXMAAA7DAAAOwwHHb6hkAAABKElEQVQY001QS04DMQztSVkgVUicgwUHYAEHYMGWA0B7hgJSRx1YISqVzid2HOfn4BmmnxdLcWw/+zmzUkrOOY5IKR6hfh6RBkypo6NxJc706vveWouWrCUmy4TeWYfwuanqag1gNI52PKiFFgC7rhvI2lbfIoUJUnQQxPhsQu44fv3s6u9tiEHFDSaxZO+ZYnCIOE3WNl1vxNPHtr94gfkCLl/hamnmC7xemurXJu+QVAyx7YnIOTqRVbZGJGtbDz7hwVqkXQfsuRT5H54ipzR8EABMZPVCUG0iOZYTxJieTfO04ZtVuV3lh7WMK+gHy4ncNE3btspXPXyGEFP27rnGuzd3/06PlYonP6Ymsojoyvv9XtcwMMCMODiQGEswxYOwwbMCJf8Bp8vHQd6RUHkAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 02 16 21 55"\n        title=""\n        src="/static/2021-07-02-16-21-55-1ba3be4d39252859208fc5006de0b4ff-fee1c.png"\n        srcset="/static/2021-07-02-16-21-55-1ba3be4d39252859208fc5006de0b4ff-a67b7.png 200w,\n/static/2021-07-02-16-21-55-1ba3be4d39252859208fc5006de0b4ff-0b187.png 400w,\n/static/2021-07-02-16-21-55-1ba3be4d39252859208fc5006de0b4ff-fee1c.png 800w,\n/static/2021-07-02-16-21-55-1ba3be4d39252859208fc5006de0b4ff-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>如上图所示，当图层的绘制列表准备好之后，主线程会把该绘制列表提交（commit）给合成线程，那么接下来合成线程是怎么工作的呢？</p>\n<p>那我们得先来看看什么是视口，你可以参看下图：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-02-16-22-05-dd52dfb403bb0cf35e50ed7b7324ddb7-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 95.5341506129597%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAATCAIAAAAf7rriAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACdUlEQVQ4y41TWU9TQRTu3zG+GeOLDyYmGt7VkOiTMcENSLS+wQOJaDUYNUoEhESBsERTiJFaWUwUpS1tkbYUsC12A21pb2+X27vM7kwviSba1pM5uZM557vnm+/MsbCaUUoJJpQyBIChGZQwSgiCiDU0CyGUf8Ke/KP20EBnaPzW5qQ1NHbZO3bB9eF+qPbfBmAsgp75XPuJQO9Z34vO8Mgl//D5z7bDjldtLgEmtAnYuyRbWzZ6z/hGroVH2vwD55b7jszbr7tr4GaVVxfyN06tdZ1e7W8NDLW67x1feHB0fqbDe0Cb+9/rN/hdtuPYctdJV0/HZo81aGv59PSQ480VQRsjTOvc22IGnP5qty3R25e8+zxzZ2jv4ePkk9ux6fG0KTdIp2A2A/d2QTQKMxm4m+Z7ipCFx6JFfPOLMpdWR8PS65gyG9enY8pMQun2Vddklkl9z7rdRjBgbG8Z37ZAfMeIRkAqycUQ4A0JTWxVGYNauUQJYIwgVWFYXYirSynVv/KxkIiTbBaXSkTTUG4fyzKpKoI295CEXm7qHJOvaDqmkDG5ahAM7RF11BVlSK/XKwGOFdHUdoXpklbI6YUsUYuk1h/H1+TKzr7QDJN/q819YgdfXFRG1wv9ntygVxr05YfXy5PhytVF+VlEJNV7JgIclKnzB5uNafao8jZhvN8jzl3sTOO5FPJLgkIj2gfGpYIqvyFjvEFYLAyaDIbJComJYjqAklzKF2TNMHhFzQCYNgObI/nnaVElZZ1gBCmlzcHc+CvkhWQV/yzBssGHm0EIadPKZkJFJ/kqLulEg+aMMwDAf1U2k4jo34HV2osbC/YLweUYIDQ5i4UAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 02 16 22 05"\n        title=""\n        src="/static/2021-07-02-16-22-05-dd52dfb403bb0cf35e50ed7b7324ddb7-fee1c.png"\n        srcset="/static/2021-07-02-16-22-05-dd52dfb403bb0cf35e50ed7b7324ddb7-a67b7.png 200w,\n/static/2021-07-02-16-22-05-dd52dfb403bb0cf35e50ed7b7324ddb7-0b187.png 400w,\n/static/2021-07-02-16-22-05-dd52dfb403bb0cf35e50ed7b7324ddb7-fee1c.png 800w,\n/static/2021-07-02-16-22-05-dd52dfb403bb0cf35e50ed7b7324ddb7-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>通常一个页面可能很大，但是用户只能看到其中的一部分，我们把用户可以看到的这个部分叫做视口（viewport）。</p>\n<p>在有些情况下，有的图层可以很大，比如有的页面你使用滚动条要滚动好久才能滚动到底部，但是通过视口，用户只能看到页面的很小一部分，所以在这种情况下，要绘制出所有图层内容的话，就会产生太大的开销，而且也没有必要。</p>\n<p>基于这个原因，合成线程会将图层划分为图块（tile），这些图块的大小通常是 256x256 或者 512x512，如下图所示：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-02-16-22-17-00298b4e3274165a99e51b835b4ed22e-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 87.12784588441332%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAIAAABSJhvpAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACP0lEQVQ4y4WTz2sTQRTH+xcJejbgQRBE0ZuIBxEFT+JBKIj01Gt/ICgoKggelF5KC1JFsBLTiw3V2NqkCk3TmqZJdmd3fuzs/Hjz4mxCJJGkPoZhZ+Z99n3fmzcTnb45h37+lq/dPVucvvz12a3i02urs2fyj06vhL8Cf4Rdh0Gb+Af+vlafPL8xf6P4enJ94d7qk0ufHueWwkrDswjuP/BmYe/+xbXpC4WXN/PPryzP5VZenFsi5XpHC4jjsXBPVeFt5frJj3dyhanbXx5c/TB14v3MqcX90oE/AkL6rjgA+0U2ss+fpd03M5sLDyuLCzvLr0rv5n58ni82d+sZHEcjItvDuqntISWGUsUOESnjQUe3OuYoSRm6UCZhlldEfG5AQnuwj0nShR3a3we2VkWZAIAUgTYQUg2grBYhNVanCc8Eex84aujyttpY9/xQzpkwcKloahkxSrRsO9VWSjpDpchgRyO0xgmRzan0aQ7BvuAsrjcau416tbFfpmHVKKGTFqftLjy+2j0zKQuCuNkiLA49Q7kSnBqdZeh8wXql7Rd8EM7WzlLOAhq1lWhC2gKrnIk6VqDSjtFjIndhEyEIJVkc1CipOlBoY4ibjhBMU38vqPVY2Wh5r10QUtCC6k7Gp8yHdSTQ21v+UsbLNhEYbqyiLIxok0rV1SL7v7Z/22sE7EWyhAVcxixQsoVowRBIQmTccaZ3KijlyMjdTRDOMLAJmtgZ4iDxkZ0SyLnvML1V6vXWaPh4Qzf0Kv8AtNC6+UR6mCwAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 02 16 22 17"\n        title=""\n        src="/static/2021-07-02-16-22-17-00298b4e3274165a99e51b835b4ed22e-fee1c.png"\n        srcset="/static/2021-07-02-16-22-17-00298b4e3274165a99e51b835b4ed22e-a67b7.png 200w,\n/static/2021-07-02-16-22-17-00298b4e3274165a99e51b835b4ed22e-0b187.png 400w,\n/static/2021-07-02-16-22-17-00298b4e3274165a99e51b835b4ed22e-fee1c.png 800w,\n/static/2021-07-02-16-22-17-00298b4e3274165a99e51b835b4ed22e-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>然后合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图。而图块是栅格化执行的最小单位。渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的，运行方式如下图所示：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-02-16-22-27-d76346656d5c88592fc50be9d77a7789-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 59.28196147110333%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABlklEQVQoz21Ry24UMRDc/0QC5aNy5JRwAYkvIBEXpJw4IJZlhYhQok1CZjzjZ/ttU2NPtCBSsnvc3dPt6vKm1ppzTv8BsdrwXBLZjNQGH2OMc9ZiO+ed9YuFQ7+ur3/s90qpxetwjpqVUpZSNmgDFydrZArkUqGYsUxItw/Dz5sDmtVawKDWVJPzloKnXrLcjN5ciOJp98BffFAnl/LlhYQ9uVSvLuTVQWdvlbFLhRFkNEgBx2IwLzmDHqM0UZztsgZl72elidZrS4rexRhBdvm/F+OE0MItx/oXlJSWjx9v7Om+nn4vVyNiMReMUNebsYUQ4zhCJKMVUeNETRcfanSfD/Jsp15/4Z8ONq16uSPtpraDs74ZxIOemEXJe8bf7sS7LXu/feRCggvnvLc+qg0mpfHx3qthkBNj41gt/Wbi7Ot8vp3ffJO3TIIaRw+M82wxKHDGIOF0d1edjSG0F7K1xJzgRXTvc/1T3AE3hNCHRsJorQxJtVhMh7DWuh9WweDoJ/QEiE0TqLOhYWwYnjDPM6ih8A8/EazNMZjYswAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 02 16 22 27"\n        title=""\n        src="/static/2021-07-02-16-22-27-d76346656d5c88592fc50be9d77a7789-fee1c.png"\n        srcset="/static/2021-07-02-16-22-27-d76346656d5c88592fc50be9d77a7789-a67b7.png 200w,\n/static/2021-07-02-16-22-27-d76346656d5c88592fc50be9d77a7789-0b187.png 400w,\n/static/2021-07-02-16-22-27-d76346656d5c88592fc50be9d77a7789-fee1c.png 800w,\n/static/2021-07-02-16-22-27-d76346656d5c88592fc50be9d77a7789-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>通常，栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫快速栅格化，或者 GPU 栅格化，生成的位图被保存在 GPU 内存中。</p>\n<p>相信你还记得，GPU 操作是运行在 GPU 进程中，如果栅格化操作使用了 GPU，那么最终生成位图的操作是在 GPU 中完成的，这就涉及到了跨进程操作。具体形式你可以参考下图：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-02-16-22-41-4688f12be6d789345beb01f329614300-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 75.04378283712785%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAIAAABr+ngCAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAB6ElEQVQoz4VSWW5UMRCcmyJxAyROwAUAIZYgcQwOgMIPX4kCgQlfMJoweZvf4rXbG2W/YVUQJavVXqqr3PYmpWQrnHPGWmXK0IjK9EL0YjTG2N/gHCEgAXETQsB2jTpFztnXEVJww9er7ss2sAsFvgzPOOYZfOu938QYQUa9TPKzUM8++VdX/GLrX27p0fny5GzqTK2VImL2hpyJ3hJRIUN9miYxTjnQxUE+PDfP36unFxrx5NKdfNB7oRLjTvDqjFbIiPhIXpURUwzV9k8kXnoeG+1I+iw5EeQDQwx7KHFUnud5WRaQmZzj4NiTDxiGmI16fCbvntKdN+71jnPEMoTiL9sgwzkzow1UAS9KKY3maL0T5vJafPwmhMQcq7o6r2T0EZzisvrBKqqAgwfLVm9bde90vv92fvBubhdN1ki8oTF/k2EGUUlphn5oG3Fzk5wdxvG66fpx7sQ0TpOUUsCBlBC4RVlXV6ULfZ+tDd5rJT1R9AU4DNqqjKSQcT1scEW5DzP6N0s54Yd13W6363t8NjEMA6Zt26L0sdtQA4f+xFoeb4C64KBW0zRd15Uuoh0Kl5Ple+Z/YOXDF05DBOKogmT96ohH5VuBPRyCCATXRgDI9/v94XD4PxneVpOIpkL9AFbwOt8BvtJaZq0cBo8AAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 02 16 22 41"\n        title=""\n        src="/static/2021-07-02-16-22-41-4688f12be6d789345beb01f329614300-fee1c.png"\n        srcset="/static/2021-07-02-16-22-41-4688f12be6d789345beb01f329614300-a67b7.png 200w,\n/static/2021-07-02-16-22-41-4688f12be6d789345beb01f329614300-0b187.png 400w,\n/static/2021-07-02-16-22-41-4688f12be6d789345beb01f329614300-fee1c.png 800w,\n/static/2021-07-02-16-22-41-4688f12be6d789345beb01f329614300-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从图中可以看出，渲染进程把生成图块的指令发送给 GPU，然后在 GPU 中执行生成图块的位图，并保存在 GPU 的内存中。</p>\n<h2 id="合成和显示"><a href="#%E5%90%88%E6%88%90%E5%92%8C%E6%98%BE%E7%A4%BA" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>合成和显示</h2>\n<p>一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。</p>\n<p>浏览器进程里面有一个叫 viz 的组件，用来接收合成线程发过来的 DrawQuad 命令，然后根据 DrawQuad 命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。</p>\n<p>到这里，经过这一系列的阶段，编写好的 HTML、CSS、JavaScript 等文件，经过浏览器就会显示出漂亮的页面了。</p>\n<h2 id="渲染流水线大总结"><a href="#%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%A4%A7%E6%80%BB%E7%BB%93" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>渲染流水线大总结</h2>\n<p>好了，我们现在已经分析完了整个渲染流程，从 HTML 到 DOM、样式计算、布局、图层、绘制、光栅化、合成和显示。下面我用一张图来总结下这整个渲染流程：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-02-16-23-25-12e192c0842585e51fb9e749122078c7-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 65.23642732049036%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAIAAAAmMtkJAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABr0lEQVQoz5WSyU7cQBCGeUEeJeLEIS+QIxoh5Q0SCYlrDignQoKEUNjCgBgGxDgeZoy7safb3dV7d8qxFcIilPwqeVN9rvqreimlpJQSQgCAkMCF7II1oiCUECrk38IswBsiCC5575EMwWsFMbiUfEp4Dc7K4upsPrmy1gbvfocP3hqjlYKmaR5grU3U/KRggx9q/RTeD9XgmL/bq75MVYrOWuMdhvVGGNUgi8VbOITAFgvGefL2vBQfRrBxCZvjNj6OYP9WpGiiN6kNGywYrZU2Deb3MGPoBF9S23av6G2UlVBmxNN1k8Y84UMufIohxojN9nBd11VVoRkhcW6qCy7AabU/ZSvf+OrXanWXvdnhg8NagUTDWK/33BmIj4VfrEMcanI3yye0mHnnYvBtfyH0lTGPcy4eq9sJpZRQOpsX+fT2ZpLVFWX3hC8q7LT3/LxmJ+dcWZZZlhFCjDH4r5wstg+GFzc5SIH76+EXhTB21I0DSdzu26O4/BnWzrFvo617DX4iPFJzrkd3smwMHjG0/e9wO788ux4efCqLeef0PyqjLscXJ9+3sp/ZH/gXwfHmTslGNTkAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 02 16 23 25"\n        title=""\n        src="/static/2021-07-02-16-23-25-12e192c0842585e51fb9e749122078c7-fee1c.png"\n        srcset="/static/2021-07-02-16-23-25-12e192c0842585e51fb9e749122078c7-a67b7.png 200w,\n/static/2021-07-02-16-23-25-12e192c0842585e51fb9e749122078c7-0b187.png 400w,\n/static/2021-07-02-16-23-25-12e192c0842585e51fb9e749122078c7-fee1c.png 800w,\n/static/2021-07-02-16-23-25-12e192c0842585e51fb9e749122078c7-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>结合上图，一个完整的渲染流程大致可总结为如下</p>\n<ul>\n<li>渲染进程将 HTML 内容转换为能够读懂的 DOM 树结构。</li>\n<li>渲染引擎将 CSS 样式表转化为浏览器可以理解的 styleSheets，计算出 DOM 节点的样式。</li>\n<li>创建布局树，并计算元素的布局信息。</li>\n<li>对布局树进行分层，并生成分层树。</li>\n<li>为每个图层生成绘制列表，并将其提交到合成线程。</li>\n<li>合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。</li>\n<li>合成线程发送绘制图块命令 DrawQuad 给浏览器进程。</li>\n<li>浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上</li>\n</ul>\n<h2 id="相关概念"><a href="#%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>相关概念</h2>\n<p>有了上面介绍渲染流水线的基础，我们再来看看三个和渲染流水线相关的概念——“重排”“重绘”和“合成”。理解了这三个概念对于你后续 Web 的性能优化会有很大帮助。</p>\n<h3 id="更新了元素的几何属性（重排）"><a href="#%E6%9B%B4%E6%96%B0%E4%BA%86%E5%85%83%E7%B4%A0%E7%9A%84%E5%87%A0%E4%BD%95%E5%B1%9E%E6%80%A7%EF%BC%88%E9%87%8D%E6%8E%92%EF%BC%89" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>更新了元素的几何属性（重排）</h3>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-02-16-24-14-7d1130489df189dc3836e35c56e87c90-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 27.845884413309985%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAIAAABM9SnKAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABE0lEQVQY041QTUvDQBDNP67oQSKCKIgnKVovYvsHxP9QsEatsVG0VaGe0o8kxDTZzG6y2e7uuIni2WEOb+bNG+aNhSa00rLSkqMSBuO/w9KISq05TRgJS7riJS2rNRfS9E2WlTTlbwrJuDCUbKhabLQGC15APEeaiDQQsS+zUMtSqQrzAEmg0oVIZpiHKvEVRGYnyqIWOz5sDMi2Q1r9ZOuW2Xd5awCbN3DmrfrTpX0Pu0PYc2F/VNgPxc6QHriGzS/fvxCl5S3hyM06L6ztkUMn7DyR9jMce3D1kY/8+HycdyfQfU1P3Oj0Meq9QW9MLiZwPctqcXN8/STFMjqfasEaR/LHTgO0EowtPiHym+E/Cr8BEGRINvQRRAsAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 02 16 24 14"\n        title=""\n        src="/static/2021-07-02-16-24-14-7d1130489df189dc3836e35c56e87c90-fee1c.png"\n        srcset="/static/2021-07-02-16-24-14-7d1130489df189dc3836e35c56e87c90-a67b7.png 200w,\n/static/2021-07-02-16-24-14-7d1130489df189dc3836e35c56e87c90-0b187.png 400w,\n/static/2021-07-02-16-24-14-7d1130489df189dc3836e35c56e87c90-fee1c.png 800w,\n/static/2021-07-02-16-24-14-7d1130489df189dc3836e35c56e87c90-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从上图可以看出，如果你通过 JavaScript 或者 CSS 修改元素的几何位置属性，例如改变元素的宽度、高度等，那么浏览器会触发重新布局，解析之后的一系列子阶段，这个过程就叫重排。无疑，重排需要更新完整的渲染流水线，所以开销也是最大的</p>\n<h3 id="更新元素的绘制属性（重绘）"><a href="#%E6%9B%B4%E6%96%B0%E5%85%83%E7%B4%A0%E7%9A%84%E7%BB%98%E5%88%B6%E5%B1%9E%E6%80%A7%EF%BC%88%E9%87%8D%E7%BB%98%EF%BC%89" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>更新元素的绘制属性（重绘）</h3>\n<p>接下来，我们再来看看重绘，比如通过 JavaScript 更改某些元素的背景颜色，渲染流水线会怎样调整呢？你可以参考下图：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-02-16-24-33-72a4f59fadf2078de83b2b9f20c01e72-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 25.04378283712785%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAIAAADKYVtkAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAA+ElEQVQY04WPwUrDQBiE85Kee/CgoD6ATyGefQnBYilFkNYqiNBQg7SraJZYSZNsks1ukmb333+7VvHqMJeB+WDGs3+CjdkU0DDTcdQNItr/5AFAyXkjKi2LtkxEmbFsnbOsluKn0dWVkhxaWZdM1bwTvOUFGviGDSKojqb8keZ3b2ufhK+EkOUyeI9e4ipmuR+lzvMVm9F4FmXzz+wpTD6S3Fr0YLfukoi9Ie+N1fno+WZwNRr0z4b+6YO8Xnztj+XRVB5MxPG9PJzIk6ns3cqLwMHa+/1rQCllAMIwpJQaY1zUSrtV1iiLOo1XZBG0NXddhM6ictQWzZgSDgm2Gb0AAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 02 16 24 33"\n        title=""\n        src="/static/2021-07-02-16-24-33-72a4f59fadf2078de83b2b9f20c01e72-fee1c.png"\n        srcset="/static/2021-07-02-16-24-33-72a4f59fadf2078de83b2b9f20c01e72-a67b7.png 200w,\n/static/2021-07-02-16-24-33-72a4f59fadf2078de83b2b9f20c01e72-0b187.png 400w,\n/static/2021-07-02-16-24-33-72a4f59fadf2078de83b2b9f20c01e72-fee1c.png 800w,\n/static/2021-07-02-16-24-33-72a4f59fadf2078de83b2b9f20c01e72-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从图中可以看出，如果修改了元素的背景颜色，那么布局阶段将不会被执行，因为并没有引起几何位置的变换，所以就直接进入了绘制阶段，然后执行之后的一系列子阶段，这个过程就叫重绘。相较于重排操作，重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些。</p>\n<h3 id="直接合成阶段"><a href="#%E7%9B%B4%E6%8E%A5%E5%90%88%E6%88%90%E9%98%B6%E6%AE%B5" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>直接合成阶段</h3>\n<p>那如果你更改一个既不要布局也不要绘制的属性，会发生什么变化呢？渲染引擎将跳过布局和绘制，只执行后续的合成操作，我们把这个过程叫做合成。具体流程参考下图</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-02-16-25-05-b0fa53f2f6f52a78c60b47c9e89274a7-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 23.64273204903678%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAIAAADKYVtkAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAA8ElEQVQY03WQy07DMBRE870sukBQJL6GH+iCBQbSsChqVVVISLRAQClREZRHE8d2bMex4weulS1HczejGWl0IxewRhlJjKSmRU5R2zW9H/QfEcaYUqqbWqBfWn6plnNai4ZxzrXWPiEFa0klCOKolIw0CHaC92WllFTqJscgw6OH7TJ9TZ896Wq5+njfPO7q+A2O10WyLsdBSVZcZvDlB+3L/lSnh5PdwaQe3JIRSOIrcB3HFwDc3y3OnuDhDJ/MyfGsOppWwzk5XZDBFJ9n0DkT9fOtX2g72eZ5zhjbGwGf8LJWF9/bz01uTBeeYILcH/8HEXg+ILrkAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 02 16 25 05"\n        title=""\n        src="/static/2021-07-02-16-25-05-b0fa53f2f6f52a78c60b47c9e89274a7-fee1c.png"\n        srcset="/static/2021-07-02-16-25-05-b0fa53f2f6f52a78c60b47c9e89274a7-a67b7.png 200w,\n/static/2021-07-02-16-25-05-b0fa53f2f6f52a78c60b47c9e89274a7-0b187.png 400w,\n/static/2021-07-02-16-25-05-b0fa53f2f6f52a78c60b47c9e89274a7-fee1c.png 800w,\n/static/2021-07-02-16-25-05-b0fa53f2f6f52a78c60b47c9e89274a7-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>在上图中，我们使用了 CSS 的 transform 来实现动画效果，这可以避开重排和重绘阶段，直接在非主线程上执行合成动画操作。这样的效率是最高的，因为是在非主线程上合成，并没有占用主线程的资源，另外也避开了布局和绘制两个子阶段，所以相对于重绘和重排，合成能大大提升绘制效率。</p>\n<p>至于如何用这些概念去优化页面，我们会在后面相关章节做详细讲解的，这里你只需要先结合“渲染流水线”弄明白这三个概念及原理就行</p>\n<h2 id="总结-4"><a href="#%E6%80%BB%E7%BB%93-4" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总结</h2>\n<p>通过本文的分析，你应该可以看到，Chrome 的渲染流水线还是相当复杂晦涩，且难以理解，不过 Chrome 团队在不断添加新功能的同时，也在不断地重构一些子阶段，目的就是让整体渲染架构变得更加简单和高效，正所谓大道至简。</p>\n<h2 id="思考时间"><a href="#%E6%80%9D%E8%80%83%E6%97%B6%E9%97%B4" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>思考时间</h2>\n<p>在优化 Web 性能的方法中，减少重绘、重排是一种很好的优化方式，那么结合文中的分析，你能总结出来为什么减少重绘、重排能优化 Web 性能吗？那又有那些具体的实践方法能减少重绘、重排呢？</p>\n<ul>\n<li>触发 repaint reflow 的操作尽量放在一起，比如改变 dom 高度和设置 margin 分开写，可能会出发两次重排</li>\n<li>通过虚拟 dom 层计算出操作总得差异，一起提交给浏览器。之前还用过 createdocumentfragment 来汇总 append 的 dom,来减少触发重排重绘次数。</li>\n</ul>',
id:"/github/workspace/blog/浏览器工作原理与实践——宏观视角上的浏览器/index.md absPath of file >>> MarkdownRemark",timeToRead:26,frontmatter:{date:"2021-07-01 14:44:27",path:"/browser-working-principle-macro-view/",tags:"前端, JS, 高级前端",title:"浏览器工作原理与实践——宏观视角上的浏览器",draft:null}},{excerpt:"背景 在浏览器中，我们可以同时打开多个 Tab 页，每个 Tab 页可以粗略理解为一个“独立”的运行环境，即使是全局对象也不会在多个 Tab 间共享。然而有些时候，我们希望能在这些“独立”的 Tab…",html:'<h1 id="背景"><a href="#%E8%83%8C%E6%99%AF" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>背景</h1>\n<p>在浏览器中，我们可以同时打开多个 Tab 页，每个 Tab 页可以粗略理解为一个“独立”的运行环境，即使是全局对象也不会在多个 Tab 间共享。然而有些时候，我们希望能在这些“独立”的 Tab 页面之间同步页面的数据、信息或状态。</p>\n<p>正如下面这个例子：我在列表页点击“收藏”后，对应的详情页按钮会自动更新为“已收藏”状态；类似的，在详情页点击“收藏”后，列表页中按钮也会更新。</p>\n<p><img src="/static/cross-page-message-95ffa84567dab8bfd85806efe647b5a3.gif"></p>\n<h1 id="同源页面间的跨页面通信"><a href="#%E5%90%8C%E6%BA%90%E9%A1%B5%E9%9D%A2%E9%97%B4%E7%9A%84%E8%B7%A8%E9%A1%B5%E9%9D%A2%E9%80%9A%E4%BF%A1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>同源页面间的跨页面通信</h1>\n<p>浏览器的同源策略在下述的一些跨页面通信方法中依然存在限制。因此我们先来看看，在满足同源策略的情况下，都有哪些技术可以用来实现跨页面通信。</p>\n<h2 id="broadcast-channel"><a href="#broadcast-channel" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>BroadCast Channel</h2>\n<p>BroadCast Channel 可以帮我们创建一个用于广播的通信频道，当所有页面都监听同一频道的消息时，其中某一个页面通过它发送的消息就会被其他所有页面收到，它的 API 和用法都非常简单。</p>\n<p>下面的方式就可以创建一个标识为 AlienZHOU 的频道：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="21253631585804820000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`const bc = new BroadcastChannel(\'AlienZHOU\');`, `21253631585804820000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                data-tooltip="复制"\n              >\n                <svg class="gatsby-code-button-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M16 1H2v16h2V3h12V1zm-1 4l6 6v12H6V5h9zm-1 7h5.5L14 6.5V12z"/></svg>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">const</span> bc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BroadcastChannel</span><span class="token punctuation">(</span><span class="token string">\'AlienZHOU\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>各个页面可以通过 onmessage 来监听被广播的消息：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="78892267054084830000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`bc.onmessage = function(e) {\n  const data = e.data;\n  const text = \'[receive] \' + data.msg + \' —— tab \' + data.from;\n  console.log(\'[BroadcastChannel] receive message:\', text);\n};`, `78892267054084830000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                data-tooltip="复制"\n              >\n                <svg class="gatsby-code-button-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M16 1H2v16h2V3h12V1zm-1 4l6 6v12H6V5h9zm-1 7h5.5L14 6.5V12z"/></svg>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js">bc<span class="token punctuation">.</span><span class="token function-variable function">onmessage</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> data <span class="token operator">=</span> e<span class="token punctuation">.</span>data<span class="token punctuation">;</span>\n  <span class="token keyword">const</span> text <span class="token operator">=</span> <span class="token string">\'[receive] \'</span> <span class="token operator">+</span> data<span class="token punctuation">.</span>msg <span class="token operator">+</span> <span class="token string">\' —— tab \'</span> <span class="token operator">+</span> data<span class="token punctuation">.</span>from<span class="token punctuation">;</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'[BroadcastChannel] receive message:\'</span><span class="token punctuation">,</span> text<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>要发送消息时只需要调用实例上的 postMessage 方法即可：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="21701569784422190000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`bc.postMessage(mydata);`, `21701569784422190000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                data-tooltip="复制"\n              >\n                <svg class="gatsby-code-button-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M16 1H2v16h2V3h12V1zm-1 4l6 6v12H6V5h9zm-1 7h5.5L14 6.5V12z"/></svg>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js">bc<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span>mydata<span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<h2 id="service-worker"><a href="#service-worker" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Service Worker</h2>\n<p>Service Worker 是一个可以长期运行在后台的 Worker，能够实现与页面的双向通信。多页面共享间的 Service Worker 可以共享，将 Service Worker 作为消息的处理中心（中央站）即可实现广播效果。</p>\n<p>首先，需要在页面注册 Service Worker：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="53555934164083640000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`/* 页面逻辑 */\nnavigator.serviceWorker.register(\'../util.sw.js\').then(function() {\n  console.log(\'Service Worker 注册成功\');\n});`, `53555934164083640000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                data-tooltip="复制"\n              >\n                <svg class="gatsby-code-button-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M16 1H2v16h2V3h12V1zm-1 4l6 6v12H6V5h9zm-1 7h5.5L14 6.5V12z"/></svg>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">/* 页面逻辑 */</span>\nnavigator<span class="token punctuation">.</span>serviceWorker<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span><span class="token string">\'../util.sw.js\'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'Service Worker 注册成功\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>其中../util.sw.js 是对应的 Service Worker 脚本。Service Worker 本身并不自动具备“广播通信”的功能，需要我们添加些代码，将其改造成消息中转站：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="11756923179235045000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`/* ../util.sw.js Service Worker 逻辑 */\nself.addEventListener(\'message\', function(e) {\n  console.log(\'service worker receive message\', e.data);\n  e.waitUntil(\n    self.clients.matchAll().then(function(clients) {\n      if (!clients || clients.length === 0) {\n        return;\n      }\n      clients.forEach(function(client) {\n        client.postMessage(e.data);\n      });\n    })\n  );\n});`, `11756923179235045000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                data-tooltip="复制"\n              >\n                <svg class="gatsby-code-button-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M16 1H2v16h2V3h12V1zm-1 4l6 6v12H6V5h9zm-1 7h5.5L14 6.5V12z"/></svg>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">/* ../util.sw.js Service Worker 逻辑 */</span>\nself<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">\'message\'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'service worker receive message\'</span><span class="token punctuation">,</span> e<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  e<span class="token punctuation">.</span><span class="token function">waitUntil</span><span class="token punctuation">(</span>\n    self<span class="token punctuation">.</span>clients<span class="token punctuation">.</span><span class="token function">matchAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">clients</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>clients <span class="token operator">||</span> clients<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">return</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n      clients<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">client</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        client<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span>\n  <span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>我们在 Service Worker 中监听了 message 事件，获取页面（从 Service Worker 的角度叫 client）发送的信息。然后通过 self.clients.matchAll() 获取当前注册了该 Service Worker 的所有页面，通过调用每个 client（即页面）的 postMessage 方法，向页面发送消息。这样就把从一处（某个 Tab 页面）收到的消息通知给了其他页面。</p>\n<p>处理完 Service Worker，我们需要在页面监听 Service Worker 发送来的消息：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="18483134005059076000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`/* 页面逻辑 */\nnavigator.serviceWorker.addEventListener(\'message\', function(e) {\n  const data = e.data;\n  const text = \'[receive] \' + data.msg + \' —— tab \' + data.from;\n  console.log(\'[Service Worker] receive message:\', text);\n});`, `18483134005059076000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                data-tooltip="复制"\n              >\n                <svg class="gatsby-code-button-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M16 1H2v16h2V3h12V1zm-1 4l6 6v12H6V5h9zm-1 7h5.5L14 6.5V12z"/></svg>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">/* 页面逻辑 */</span>\nnavigator<span class="token punctuation">.</span>serviceWorker<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">\'message\'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> data <span class="token operator">=</span> e<span class="token punctuation">.</span>data<span class="token punctuation">;</span>\n  <span class="token keyword">const</span> text <span class="token operator">=</span> <span class="token string">\'[receive] \'</span> <span class="token operator">+</span> data<span class="token punctuation">.</span>msg <span class="token operator">+</span> <span class="token string">\' —— tab \'</span> <span class="token operator">+</span> data<span class="token punctuation">.</span>from<span class="token punctuation">;</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'[Service Worker] receive message:\'</span><span class="token punctuation">,</span> text<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>最后，当需要同步消息时，可以调用 Service Worker 的 postMessage 方法：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="85128506786804900000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`/* 页面逻辑 */\nnavigator.serviceWorker.controller.postMessage(mydata);`, `85128506786804900000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                data-tooltip="复制"\n              >\n                <svg class="gatsby-code-button-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M16 1H2v16h2V3h12V1zm-1 4l6 6v12H6V5h9zm-1 7h5.5L14 6.5V12z"/></svg>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">/* 页面逻辑 */</span>\nnavigator<span class="token punctuation">.</span>serviceWorker<span class="token punctuation">.</span>controller<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span>mydata<span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span></span></pre></div>\n<h2 id="localstorage"><a href="#localstorage" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>LocalStorage</h2>\n<p>LocalStorage 作为前端最常用的本地存储，大家应该已经非常熟悉了；但 StorageEvent 这个与它相关的事件有些同学可能会比较陌生。</p>\n<p>当 LocalStorage 变化时，会触发 storage 事件。利用这个特性，我们可以在发送消息时，把消息写入到某个 LocalStorage 中；然后在各个页面内，通过监听 storage 事件即可收到通知。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="20465261399187630000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`window.addEventListener(\'storage\', function(e) {\n  if (e.key === \'ctc-msg\') {\n    const data = JSON.parse(e.newValue);\n    const text = \'[receive] \' + data.msg + \' —— tab \' + data.from;\n    console.log(\'[Storage I] receive message:\', text);\n  }\n});`, `20465261399187630000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                data-tooltip="复制"\n              >\n                <svg class="gatsby-code-button-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M16 1H2v16h2V3h12V1zm-1 4l6 6v12H6V5h9zm-1 7h5.5L14 6.5V12z"/></svg>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js">window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">\'storage\'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>key <span class="token operator">===</span> <span class="token string">\'ctc-msg\'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>newValue<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">const</span> text <span class="token operator">=</span> <span class="token string">\'[receive] \'</span> <span class="token operator">+</span> data<span class="token punctuation">.</span>msg <span class="token operator">+</span> <span class="token string">\' —— tab \'</span> <span class="token operator">+</span> data<span class="token punctuation">.</span>from<span class="token punctuation">;</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'[Storage I] receive message:\'</span><span class="token punctuation">,</span> text<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>在各个页面添加如上的代码，即可监听到 LocalStorage 的变化。当某个页面需要发送消息时，只需要使用我们熟悉的 setItem 方法即可：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="78466170555658450000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`mydata.st = +new Date();\nwindow.localStorage.setItem(\'ctc-msg\', JSON.stringify(mydata));`, `78466170555658450000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                data-tooltip="复制"\n              >\n                <svg class="gatsby-code-button-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M16 1H2v16h2V3h12V1zm-1 4l6 6v12H6V5h9zm-1 7h5.5L14 6.5V12z"/></svg>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js">mydata<span class="token punctuation">.</span>st <span class="token operator">=</span> <span class="token operator">+</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nwindow<span class="token punctuation">.</span>localStorage<span class="token punctuation">.</span><span class="token function">setItem</span><span class="token punctuation">(</span><span class="token string">\'ctc-msg\'</span><span class="token punctuation">,</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>mydata<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span></span></pre></div>\n<p>注意这里有一个细节：我们在 mydata 上添加了一个取当前毫秒时间戳的 .st 属性。这是因为 storage 事件只有在值真正改变时才会触发。举个例子：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="44777588786488010000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`window.localStorage.setItem(\'test\', \'123\');\nwindow.localStorage.setItem(\'test\', \'123\');`, `44777588786488010000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                data-tooltip="复制"\n              >\n                <svg class="gatsby-code-button-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M16 1H2v16h2V3h12V1zm-1 4l6 6v12H6V5h9zm-1 7h5.5L14 6.5V12z"/></svg>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js">window<span class="token punctuation">.</span>localStorage<span class="token punctuation">.</span><span class="token function">setItem</span><span class="token punctuation">(</span><span class="token string">\'test\'</span><span class="token punctuation">,</span> <span class="token string">\'123\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nwindow<span class="token punctuation">.</span>localStorage<span class="token punctuation">.</span><span class="token function">setItem</span><span class="token punctuation">(</span><span class="token string">\'test\'</span><span class="token punctuation">,</span> <span class="token string">\'123\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span></span></pre></div>\n<p>由于第二次的值 123 与第一次的值相同，所以以上的代码只会在第一次 setItem 时触发 storage 事件。因此我们通过设置 st 来保证每次调用时一定会触发 storage 事件。</p>\n<h2 id="阶段性总结-1"><a href="#%E9%98%B6%E6%AE%B5%E6%80%A7%E6%80%BB%E7%BB%93-1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>阶段性总结-1</h2>\n<p>上面我们看到了三种实现跨页面通信的方式，不论是建立广播频道的 Broadcast Channel，还是使用 Service Worker 的消息中转站，抑或是有一些 tricky 的 storage 事件，其都是“广播模式”：一个页面将消息通知给一个“中央站”，再由“中央站”通知给各个页面</p>\n<p>下面我们会看到另外两种跨页面通信方式，我把它称为“共享存储+轮询模式”。</p>\n<h2 id="shared-worker"><a href="#shared-worker" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Shared Worker</h2>\n<p>Shared Worker 是 Worker 家族的另一个成员。普通的 Worker 之间是独立运行、数据互不相通；而多个 Tab 注册的 Shared Worker 则可以实现数据共享。</p>\n<p>Shared Worker 在实现跨页面通信时的问题在于，它无法主动通知所有页面，因此我们会使用轮询的方式，来拉取最新的数据。思路如下：</p>\n<p>让 Shared Worker 支持两种消息。一种是 post，Shared Worker 收到后会将该数据保存下来；另一种是 get，Shared Worker 收到该消息后会将保存的数据通过 postMessage 传给注册它的页面。也就是让页面通过 get 来主动获取（同步）最新消息。具体实现如下：</p>\n<p>首先，我们会在页面中启动一个 Shared Worker，启动方式非常简单：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="21251635729030525000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// 构造函数的第二个参数是 Shared Worker 名称，也可以留空\nconst sharedWorker = new SharedWorker(\'../util.shared.js\', \'ctc\');`, `21251635729030525000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                data-tooltip="复制"\n              >\n                <svg class="gatsby-code-button-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M16 1H2v16h2V3h12V1zm-1 4l6 6v12H6V5h9zm-1 7h5.5L14 6.5V12z"/></svg>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">// 构造函数的第二个参数是 Shared Worker 名称，也可以留空</span>\n<span class="token keyword">const</span> sharedWorker <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SharedWorker</span><span class="token punctuation">(</span><span class="token string">\'../util.shared.js\'</span><span class="token punctuation">,</span> <span class="token string">\'ctc\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span></span></pre></div>\n<p>然后，在该 Shared Worker 中支持 get 与 post 形式的消息：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="78899090364992600000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`/* ../util.shared.js: Shared Worker 代码 */\nlet data = null;\nself.addEventListener(\'connect\', function(e) {\n  const port = e.ports[0];\n  port.addEventListener(\'message\', function(event) {\n    if (event.data.get) {\n      // get 指令则返回存储的消息数据\n      data && port.postMessage(data);\n    } else {\n      // 非 get 指令则存储该消息数据\n      data = event.data;\n    }\n  });\n  port.start();\n});`, `78899090364992600000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                data-tooltip="复制"\n              >\n                <svg class="gatsby-code-button-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M16 1H2v16h2V3h12V1zm-1 4l6 6v12H6V5h9zm-1 7h5.5L14 6.5V12z"/></svg>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">/* ../util.shared.js: Shared Worker 代码 */</span>\n<span class="token keyword">let</span> data <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\nself<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">\'connect\'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> port <span class="token operator">=</span> e<span class="token punctuation">.</span>ports<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n  port<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">\'message\'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>event<span class="token punctuation">.</span>data<span class="token punctuation">.</span>get<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token comment">// get 指令则返回存储的消息数据</span>\n      data <span class="token operator">&amp;&amp;</span> port<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n      <span class="token comment">// 非 get 指令则存储该消息数据</span>\n      data <span class="token operator">=</span> event<span class="token punctuation">.</span>data<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  port<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>之后，页面定时发送 get 指令的消息给 Shared Worker，轮询最新的消息数据，并在页面监听返回信息：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="71511628172697160000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// 定时轮询，发送 get 指令的消息\nsetInterval(function() {\n  sharedWorker.port.postMessage({ get: true });\n}, 1000);\n\n// 监听 get 消息的返回数据\nsharedWorker.port.addEventListener(\n  \'message\',\n  (e) => {\n    const data = e.data;\n    const text = \'[receive] \' + data.msg + \' —— tab \' + data.from;\n    console.log(\'[Shared Worker] receive message:\', text);\n  },\n  false\n);\nsharedWorker.port.start();`, `71511628172697160000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                data-tooltip="复制"\n              >\n                <svg class="gatsby-code-button-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M16 1H2v16h2V3h12V1zm-1 4l6 6v12H6V5h9zm-1 7h5.5L14 6.5V12z"/></svg>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">// 定时轮询，发送 get 指令的消息</span>\n<span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  sharedWorker<span class="token punctuation">.</span>port<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token keyword">get</span><span class="token punctuation">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token comment">// 监听 get 消息的返回数据</span>\nsharedWorker<span class="token punctuation">.</span>port<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span>\n  <span class="token string">\'message\'</span><span class="token punctuation">,</span>\n  <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n    <span class="token keyword">const</span> data <span class="token operator">=</span> e<span class="token punctuation">.</span>data<span class="token punctuation">;</span>\n    <span class="token keyword">const</span> text <span class="token operator">=</span> <span class="token string">\'[receive] \'</span> <span class="token operator">+</span> data<span class="token punctuation">.</span>msg <span class="token operator">+</span> <span class="token string">\' —— tab \'</span> <span class="token operator">+</span> data<span class="token punctuation">.</span>from<span class="token punctuation">;</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'[Shared Worker] receive message:\'</span><span class="token punctuation">,</span> text<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token boolean">false</span>\n<span class="token punctuation">)</span><span class="token punctuation">;</span>\nsharedWorker<span class="token punctuation">.</span>port<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>最后，当要跨页面通信时，只需给 Shared Worker postMessage 即可：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="43750709395498074000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`sharedWorker.port.postMessage(mydata);`, `43750709395498074000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                data-tooltip="复制"\n              >\n                <svg class="gatsby-code-button-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M16 1H2v16h2V3h12V1zm-1 4l6 6v12H6V5h9zm-1 7h5.5L14 6.5V12z"/></svg>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js">sharedWorker<span class="token punctuation">.</span>port<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span>mydata<span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<blockquote>\n<p>注意，如果使用 addEventListener 来添加 Shared Worker 的消息监听，需要显式调用 MessagePort.start 方法，即上文中的 sharedWorker.port.start()；如果使用 onmessage 绑定监听则不需要。</p>\n</blockquote>\n<h2 id="indexeddb"><a href="#indexeddb" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>IndexedDB</h2>\n<p>除了可以利用 Shared Worker 来共享存储数据，还可以使用其他一些“全局性”（支持跨页面）的存储方案。例如 IndexedDB 或 cookie。</p>\n<blockquote>\n<p>鉴于大家对 cookie 已经很熟悉，加之作为“互联网最早期的存储方案之一”，cookie 已经在实际应用中承受了远多于其设计之初的责任，我们下面会使用 IndexedDB 来实现。</p>\n</blockquote>\n<p>其思路很简单：与 Shared Worker 方案类似，消息发送方将消息存至 IndexedDB 中；接收方（例如所有页面）则通过轮询去获取最新的信息。在这之前，我们先简单封装几个 IndexedDB 的工具方法。</p>\n<p>打开数据库连接</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="52539846879206540000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function openStore() {\n  const storeName = \'ctc_aleinzhou\';\n  return new Promise(function(resolve, reject) {\n    if (!(\'indexedDB\' in window)) {\n      return reject(&quot;don\'t support indexedDB&quot;);\n    }\n    const request = indexedDB.open(\'CTC_DB\', 1);\n    request.onerror = reject;\n    request.onsuccess = (e) => resolve(e.target.result);\n    request.onupgradeneeded = function(e) {\n      const db = e.srcElement.result;\n      if (e.oldVersion === 0 && !db.objectStoreNames.contains(storeName)) {\n        const store = db.createObjectStore(storeName, { keyPath: \'tag\' });\n        store.createIndex(storeName + \'Index\', \'tag\', { unique: false });\n      }\n    };\n  });\n}`, `52539846879206540000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                data-tooltip="复制"\n              >\n                <svg class="gatsby-code-button-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M16 1H2v16h2V3h12V1zm-1 4l6 6v12H6V5h9zm-1 7h5.5L14 6.5V12z"/></svg>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span> <span class="token function">openStore</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> storeName <span class="token operator">=</span> <span class="token string">\'ctc_aleinzhou\'</span><span class="token punctuation">;</span>\n  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span><span class="token string">\'indexedDB\'</span> <span class="token keyword">in</span> window<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">return</span> <span class="token function">reject</span><span class="token punctuation">(</span><span class="token string">"don\'t support indexedDB"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n    <span class="token keyword">const</span> request <span class="token operator">=</span> indexedDB<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">\'CTC_DB\'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    request<span class="token punctuation">.</span>onerror <span class="token operator">=</span> reject<span class="token punctuation">;</span>\n    request<span class="token punctuation">.</span><span class="token function-variable function">onsuccess</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">resolve</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>target<span class="token punctuation">.</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    request<span class="token punctuation">.</span><span class="token function-variable function">onupgradeneeded</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">const</span> db <span class="token operator">=</span> e<span class="token punctuation">.</span>srcElement<span class="token punctuation">.</span>result<span class="token punctuation">;</span>\n      <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>oldVersion <span class="token operator">===</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>db<span class="token punctuation">.</span>objectStoreNames<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>storeName<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">const</span> store <span class="token operator">=</span> db<span class="token punctuation">.</span><span class="token function">createObjectStore</span><span class="token punctuation">(</span>storeName<span class="token punctuation">,</span> <span class="token punctuation">{</span> keyPath<span class="token punctuation">:</span> <span class="token string">\'tag\'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        store<span class="token punctuation">.</span><span class="token function">createIndex</span><span class="token punctuation">(</span>storeName <span class="token operator">+</span> <span class="token string">\'Index\'</span><span class="token punctuation">,</span> <span class="token string">\'tag\'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> unique<span class="token punctuation">:</span> <span class="token boolean">false</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>存储数据</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="68380705607620460000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function saveData(db, data) {\n  return new Promise(function(resolve, reject) {\n    const STORE_NAME = \'ctc_aleinzhou\';\n    const tx = db.transaction(STORE_NAME, \'readwrite\');\n    const store = tx.objectStore(STORE_NAME);\n    const request = store.put({ tag: \'ctc_data\', data });\n    request.onsuccess = () => resolve(db);\n    request.onerror = reject;\n  });\n}`, `68380705607620460000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                data-tooltip="复制"\n              >\n                <svg class="gatsby-code-button-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M16 1H2v16h2V3h12V1zm-1 4l6 6v12H6V5h9zm-1 7h5.5L14 6.5V12z"/></svg>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span> <span class="token function">saveData</span><span class="token punctuation">(</span><span class="token parameter">db<span class="token punctuation">,</span> data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">const</span> <span class="token constant">STORE_NAME</span> <span class="token operator">=</span> <span class="token string">\'ctc_aleinzhou\'</span><span class="token punctuation">;</span>\n    <span class="token keyword">const</span> tx <span class="token operator">=</span> db<span class="token punctuation">.</span><span class="token function">transaction</span><span class="token punctuation">(</span><span class="token constant">STORE_NAME</span><span class="token punctuation">,</span> <span class="token string">\'readwrite\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">const</span> store <span class="token operator">=</span> tx<span class="token punctuation">.</span><span class="token function">objectStore</span><span class="token punctuation">(</span><span class="token constant">STORE_NAME</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">const</span> request <span class="token operator">=</span> store<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token punctuation">{</span> tag<span class="token punctuation">:</span> <span class="token string">\'ctc_data\'</span><span class="token punctuation">,</span> data <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    request<span class="token punctuation">.</span><span class="token function-variable function">onsuccess</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">resolve</span><span class="token punctuation">(</span>db<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    request<span class="token punctuation">.</span>onerror <span class="token operator">=</span> reject<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>查询/读取数据</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="18488621638619087000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function query(db) {\n  const STORE_NAME = \'ctc_aleinzhou\';\n  return new Promise(function(resolve, reject) {\n    try {\n      const tx = db.transaction(STORE_NAME, \'readonly\');\n      const store = tx.objectStore(STORE_NAME);\n      const dbRequest = store.get(\'ctc_data\');\n      dbRequest.onsuccess = (e) => resolve(e.target.result);\n      dbRequest.onerror = reject;\n    } catch (err) {\n      reject(err);\n    }\n  });\n}`, `18488621638619087000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                data-tooltip="复制"\n              >\n                <svg class="gatsby-code-button-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M16 1H2v16h2V3h12V1zm-1 4l6 6v12H6V5h9zm-1 7h5.5L14 6.5V12z"/></svg>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span> <span class="token function">query</span><span class="token punctuation">(</span><span class="token parameter">db</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> <span class="token constant">STORE_NAME</span> <span class="token operator">=</span> <span class="token string">\'ctc_aleinzhou\'</span><span class="token punctuation">;</span>\n  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">try</span> <span class="token punctuation">{</span>\n      <span class="token keyword">const</span> tx <span class="token operator">=</span> db<span class="token punctuation">.</span><span class="token function">transaction</span><span class="token punctuation">(</span><span class="token constant">STORE_NAME</span><span class="token punctuation">,</span> <span class="token string">\'readonly\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token keyword">const</span> store <span class="token operator">=</span> tx<span class="token punctuation">.</span><span class="token function">objectStore</span><span class="token punctuation">(</span><span class="token constant">STORE_NAME</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token keyword">const</span> dbRequest <span class="token operator">=</span> store<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">\'ctc_data\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      dbRequest<span class="token punctuation">.</span><span class="token function-variable function">onsuccess</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">resolve</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>target<span class="token punctuation">.</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      dbRequest<span class="token punctuation">.</span>onerror <span class="token operator">=</span> reject<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token function">reject</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>剩下的工作就非常简单了。首先打开数据连接，并初始化数据：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="16334017525729872000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`openStore().then((db) => saveData(db, null));`, `16334017525729872000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                data-tooltip="复制"\n              >\n                <svg class="gatsby-code-button-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M16 1H2v16h2V3h12V1zm-1 4l6 6v12H6V5h9zm-1 7h5.5L14 6.5V12z"/></svg>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token function">openStore</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">db</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">saveData</span><span class="token punctuation">(</span>db<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>对于消息读取，可以在连接与初始化后轮询：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="92913054771211960000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`openStore()\n  .then((db) => saveData(db, null))\n  .then(function(db) {\n    setInterval(function() {\n      query(db).then(function(res) {\n        if (!res || !res.data) {\n          return;\n        }\n        const data = res.data;\n        const text = \'[receive] \' + data.msg + \' —— tab \' + data.from;\n        console.log(\'[Storage I] receive message:\', text);\n      });\n    }, 1000);\n  });`, `92913054771211960000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                data-tooltip="复制"\n              >\n                <svg class="gatsby-code-button-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M16 1H2v16h2V3h12V1zm-1 4l6 6v12H6V5h9zm-1 7h5.5L14 6.5V12z"/></svg>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token function">openStore</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">db</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">saveData</span><span class="token punctuation">(</span>db<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">db</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token function">query</span><span class="token punctuation">(</span>db<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">res</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>res <span class="token operator">||</span> <span class="token operator">!</span>res<span class="token punctuation">.</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n          <span class="token keyword">return</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n        <span class="token keyword">const</span> data <span class="token operator">=</span> res<span class="token punctuation">.</span>data<span class="token punctuation">;</span>\n        <span class="token keyword">const</span> text <span class="token operator">=</span> <span class="token string">\'[receive] \'</span> <span class="token operator">+</span> data<span class="token punctuation">.</span>msg <span class="token operator">+</span> <span class="token string">\' —— tab \'</span> <span class="token operator">+</span> data<span class="token punctuation">.</span>from<span class="token punctuation">;</span>\n        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'[Storage I] receive message:\'</span><span class="token punctuation">,</span> text<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>最后，要发送消息时，只需向 IndexedDB 存储数据即可：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="70683514408235860000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`openStore()\n  .then((db) => saveData(db, null))\n  .then(function(db) {\n    // …… 省略上面的轮询代码\n    // 触发 saveData 的方法可以放在用户操作的事件监听内\n    saveData(db, mydata);\n  });`, `70683514408235860000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                data-tooltip="复制"\n              >\n                <svg class="gatsby-code-button-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M16 1H2v16h2V3h12V1zm-1 4l6 6v12H6V5h9zm-1 7h5.5L14 6.5V12z"/></svg>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token function">openStore</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">db</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">saveData</span><span class="token punctuation">(</span>db<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">db</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// …… 省略上面的轮询代码</span>\n    <span class="token comment">// 触发 saveData 的方法可以放在用户操作的事件监听内</span>\n    <span class="token function">saveData</span><span class="token punctuation">(</span>db<span class="token punctuation">,</span> mydata<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h2 id="阶段性总结-2"><a href="#%E9%98%B6%E6%AE%B5%E6%80%A7%E6%80%BB%E7%BB%93-2" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>阶段性总结-2</h2>\n<p>在“广播模式”外，我们又了解了“共享存储+长轮询”这种模式。也许你会认为长轮询没有监听模式优雅，但实际上，有些时候使用“共享存储”的形式时，不一定要搭配长轮询。</p>\n<p>例如，在多 Tab 场景下，我们可能会离开 Tab A 到另一个 Tab B 中操作；过了一会我们从 Tab B 切换回 Tab A 时，希望将之前在 Tab B 中的操作的信息同步回来。这时候，其实只用在 Tab A 中监听 visibilitychange 这样的事件，来做一次信息同步即可。</p>\n<p>下面，我会再介绍一种通信方式，我把它称为“口口相传”模式。</p>\n<h2 id="windowopen--windowopener"><a href="#windowopen--windowopener" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>window.open + window.opener</h2>\n<p>当我们使用 window.open 打开页面时，方法会返回一个被打开页面 window 的引用。而在未显示指定 noopener 时，被打开的页面可以通过 window.opener 获取到打开它的页面的引用 —— 通过这种方式我们就将这些页面建立起了联系（一种树形结构）。</p>\n<p>首先，我们把 window.open 打开的页面的 window 对象收集起来：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="10604121117278843000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`let childWins = [];\ndocument.getElementById(\'btn\').addEventListener(\'click\', function() {\n  const win = window.open(\'./some/sample\');\n  childWins.push(win);\n});`, `10604121117278843000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                data-tooltip="复制"\n              >\n                <svg class="gatsby-code-button-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M16 1H2v16h2V3h12V1zm-1 4l6 6v12H6V5h9zm-1 7h5.5L14 6.5V12z"/></svg>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">let</span> childWins <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\ndocument<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">\'btn\'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">\'click\'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> win <span class="token operator">=</span> window<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">\'./some/sample\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  childWins<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>win<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>然后，当我们需要发送消息的时候，作为消息的发起方，一个页面需要同时通知它打开的页面与打开它的页面：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="18111566015198943000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// 向下传递消息，打开的窗口传递消息给它打开的页面\nchildWins = childWins.filter((w) => !w.closed);\nif (childWins.length > 0) {\n  mydata.fromOpenner = false;\n  childWins.forEach((w) => w.postMessage(mydata));\n}\n\n// 向上传递消息，打开的窗口传递消息给打开它的页面\nif (window.opener && !window.opener.closed) {\n  mydata.fromOpenner = true;\n  window.opener.postMessage(mydata);\n}`, `18111566015198943000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                data-tooltip="复制"\n              >\n                <svg class="gatsby-code-button-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M16 1H2v16h2V3h12V1zm-1 4l6 6v12H6V5h9zm-1 7h5.5L14 6.5V12z"/></svg>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">// 向下传递消息，打开的窗口传递消息给它打开的页面</span>\nchildWins <span class="token operator">=</span> childWins<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">w</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token operator">!</span>w<span class="token punctuation">.</span>closed<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">if</span> <span class="token punctuation">(</span>childWins<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  mydata<span class="token punctuation">.</span>fromOpenner <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>\n  childWins<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">w</span><span class="token punctuation">)</span> <span class="token operator">=></span> w<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span>mydata<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// 向上传递消息，打开的窗口传递消息给打开它的页面</span>\n<span class="token keyword">if</span> <span class="token punctuation">(</span>window<span class="token punctuation">.</span>opener <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>window<span class="token punctuation">.</span>opener<span class="token punctuation">.</span>closed<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  mydata<span class="token punctuation">.</span>fromOpenner <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n  window<span class="token punctuation">.</span>opener<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span>mydata<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>注意，我这里先用 .closed 属性过滤掉已经被关闭的 Tab 窗口。这样，作为消息发送方的任务就完成了。下面看看，作为消息接收方，它需要做什么。</p>\n<p>此时，一个收到消息的页面就不能那么自私了，除了展示收到的消息，它还需要将消息再传递给它所“知道的人”（打开与被它打开的页面）:</p>\n<blockquote>\n<p>需要注意的是，我这里通过判断消息来源，避免将消息回传给发送方，防止消息在两者间死循环的传递。（该方案会有些其他小问题，实际中可以进一步优化）</p>\n</blockquote>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="41947958217923570000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`window.addEventListener(\'message\', function(e) {\n  const data = e.data;\n  const text = \'[receive] \' + data.msg + \' —— tab \' + data.from;\n  console.log(\'[Cross-document Messaging] receive message:\', text);\n  // 向上传递消息，避免消息回传\n  if (window.opener && !window.opener.closed && data.fromOpenner) {\n    window.opener.postMessage(data);\n  }\n  // 过滤掉已经关闭的窗口\n  childWins = childWins.filter((w) => !w.closed);\n  // 避免消息回传\n  if (childWins && !data.fromOpenner) {\n    // 向下传递消息\n    childWins.forEach((w) => w.postMessage(data));\n  }\n});`, `41947958217923570000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                data-tooltip="复制"\n              >\n                <svg class="gatsby-code-button-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M16 1H2v16h2V3h12V1zm-1 4l6 6v12H6V5h9zm-1 7h5.5L14 6.5V12z"/></svg>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js">window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">\'message\'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> data <span class="token operator">=</span> e<span class="token punctuation">.</span>data<span class="token punctuation">;</span>\n  <span class="token keyword">const</span> text <span class="token operator">=</span> <span class="token string">\'[receive] \'</span> <span class="token operator">+</span> data<span class="token punctuation">.</span>msg <span class="token operator">+</span> <span class="token string">\' —— tab \'</span> <span class="token operator">+</span> data<span class="token punctuation">.</span>from<span class="token punctuation">;</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'[Cross-document Messaging] receive message:\'</span><span class="token punctuation">,</span> text<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token comment">// 向上传递消息，避免消息回传</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>window<span class="token punctuation">.</span>opener <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>window<span class="token punctuation">.</span>opener<span class="token punctuation">.</span>closed <span class="token operator">&amp;&amp;</span> data<span class="token punctuation">.</span>fromOpenner<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    window<span class="token punctuation">.</span>opener<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token comment">// 过滤掉已经关闭的窗口</span>\n  childWins <span class="token operator">=</span> childWins<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">w</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token operator">!</span>w<span class="token punctuation">.</span>closed<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token comment">// 避免消息回传</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>childWins <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>data<span class="token punctuation">.</span>fromOpenner<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 向下传递消息</span>\n    childWins<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">w</span><span class="token punctuation">)</span> <span class="token operator">=></span> w<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>这样，每个节点（页面）都肩负起了传递消息的责任，也就是我说的“口口相传”，而消息就在这个树状结构中流转了起来。</p>\n<h2 id="阶段性总结-3"><a href="#%E9%98%B6%E6%AE%B5%E6%80%A7%E6%80%BB%E7%BB%93-3" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>阶段性总结-3</h2>\n<p>显然，“口口相传”的模式存在一个问题：如果页面不是通过在另一个页面内的 window.open 打开的（例如直接在地址栏输入，或从其他网站链接过来），这个联系就被打破了。</p>\n<p>除了上面这六个常见方法，其实还有一种（第七种）做法是通过 WebSocket 这类的“服务器推”技术来进行同步。这好比将我们的“中央站”从前端移到了后端，比如说 Polling/COMET/SSE/WebSocket。</p>\n<h1 id="非同源页面之间的通信"><a href="#%E9%9D%9E%E5%90%8C%E6%BA%90%E9%A1%B5%E9%9D%A2%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>非同源页面之间的通信</h1>\n<p>上面我们介绍了七种前端跨页面通信的方法，但它们大都受到同源策略的限制。然而有时候，我们有两个不同域名的产品线，也希望它们下面的所有页面之间能无障碍地通信。那该怎么办呢？</p>\n<p>要实现该功能，可以使用一个用户不可见的 iframe 作为“桥”。由于 iframe 与父页面间可以通过指定 origin 来忽略同源限制，因此可以在每个页面中嵌入一个 iframe （例如：<a href="http://sample.com/bridge.html%EF%BC%89%EF%BC%8C%E8%80%8C%E8%BF%99%E4%BA%9B" target="_blank" rel="nofollow noreferrer noopener">http://sample.com/bridge.html），而这些</a> iframe 由于使用的是一个 url，因此属于同源页面，其通信方式可以复用上面第一部分提到的各种方式。</p>\n<p>页面与 iframe 通信非常简单，首先需要在页面中监听 iframe 发来的消息，做相应的业务处理：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="95700790375725560000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`/* 业务页面代码 */\nwindow.addEventListener(\'message\', function(e) {\n  // …… do something\n});`, `95700790375725560000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                data-tooltip="复制"\n              >\n                <svg class="gatsby-code-button-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M16 1H2v16h2V3h12V1zm-1 4l6 6v12H6V5h9zm-1 7h5.5L14 6.5V12z"/></svg>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">/* 业务页面代码 */</span>\nwindow<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">\'message\'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// …… do something</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>然后，当页面要与其他的同源或非同源页面通信时，会先给 iframe 发送消息：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="7529014667803758000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`/* 业务页面代码 */\nwindow.frames[0].window.postMessage(mydata, \'*\');`, `7529014667803758000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                data-tooltip="复制"\n              >\n                <svg class="gatsby-code-button-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M16 1H2v16h2V3h12V1zm-1 4l6 6v12H6V5h9zm-1 7h5.5L14 6.5V12z"/></svg>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">/* 业务页面代码 */</span>\nwindow<span class="token punctuation">.</span>frames<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>window<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span>mydata<span class="token punctuation">,</span> <span class="token string">\'*\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span></span></pre></div>\n<p>其中为了简便此处将 postMessage 的第二个参数设为了 *，你也可以设为 iframe 的 URL。iframe 收到消息后，会使用某种跨页面消息通信技术在所有 iframe 间同步消息，例如下面使用的 Broadcast Channel：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="72337670137680355000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`/* iframe 内代码 */\nconst bc = new BroadcastChannel(\'AlienZHOU\');\n// 收到来自页面的消息后，在 iframe 间进行广播\nwindow.addEventListener(\'message\', function(e) {\n  bc.postMessage(e.data);\n});`, `72337670137680355000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                data-tooltip="复制"\n              >\n                <svg class="gatsby-code-button-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M16 1H2v16h2V3h12V1zm-1 4l6 6v12H6V5h9zm-1 7h5.5L14 6.5V12z"/></svg>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">/* iframe 内代码 */</span>\n<span class="token keyword">const</span> bc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BroadcastChannel</span><span class="token punctuation">(</span><span class="token string">\'AlienZHOU\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token comment">// 收到来自页面的消息后，在 iframe 间进行广播</span>\nwindow<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">\'message\'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  bc<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>其他 iframe 收到通知后，则会将该消息同步给所属的页面：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="49673436583158880000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`/* iframe 内代码 */\n// 对于收到的（iframe）广播消息，通知给所属的业务页面\nbc.onmessage = function(e) {\n  window.parent.postMessage(e.data, \'*\');\n};`, `49673436583158880000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                data-tooltip="复制"\n              >\n                <svg class="gatsby-code-button-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M16 1H2v16h2V3h12V1zm-1 4l6 6v12H6V5h9zm-1 7h5.5L14 6.5V12z"/></svg>\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">/* iframe 内代码 */</span>\n<span class="token comment">// 对于收到的（iframe）广播消息，通知给所属的业务页面</span>\nbc<span class="token punctuation">.</span><span class="token function-variable function">onmessage</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  window<span class="token punctuation">.</span>parent<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>data<span class="token punctuation">,</span> <span class="token string">\'*\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>下图就是使用 iframe 作为“桥”的非同源页面间通信模式图。</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-06-30-11-37-20-bcab03162a3d07b9021b67604ee7a0ec-d6910.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 568px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 48.767605633802816%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACCklEQVQoz2PYf+DPkqU39u7/lZRU39CwbPeeb8uW396z97uDXRADKwO3Fh+HMienOhebLAcXB+elhYteb9p8b8XKDzt26KmoMGzf+XXK1GNbtr7PzOxoaV23fuPLqTNO7tj11dU5koGFgVODm1WejU2ZnVWajYeT6+qixXeXLjk3cybQCEM1NYZDR/4vXXoXSKaltTY3r92z9++KlY+AXCfHMAZmBmZZFgYJBgZJBiYxZh4u7huLFn3euvXZqtU/d+021tBguHv3586d5x49/puZWT9hwspr19/v3Xvp/sO/9vb+vKJcLVNaq9qqu2Z0OgU6MzMwXN+16/GZM7eOHP5y9aqjhQXD69evt2zZ8ObN84KChhkzljx+fH/bto3v3n2wtfWUUZJ6++bt8SPH3756U9FYycDAcPnUybOXL+/av//lo8cO5uYMDx4+27fvwL17DzMzKiZPWXL7zr39Bw7eufvU3t5XUl781NnTu/fsPnH6ZHphBlDzid27r1y6dPTI4QdXLjtbWTEcOvxty5ZHhw5/jY4uKS+ffvDQ502bH2ze8sjOxp+Bg0HNXl3NTk3dSVNYVYSdlfXonNnv9ux5vn37s23b7ExNGQQFxfn5RQUExLi5+YCIn18MyBUUFGNn52RkYmRgZIAgRmZGFmZmEaC0gIAomOTi5GTAD5iZmCGIkZGRgboAAP0M5FJj0X+RAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 06 30 11 37 20"\n        title=""\n        src="/static/2021-06-30-11-37-20-bcab03162a3d07b9021b67604ee7a0ec-d6910.png"\n        srcset="/static/2021-06-30-11-37-20-bcab03162a3d07b9021b67604ee7a0ec-487ad.png 200w,\n/static/2021-06-30-11-37-20-bcab03162a3d07b9021b67604ee7a0ec-1cefb.png 400w,\n/static/2021-06-30-11-37-20-bcab03162a3d07b9021b67604ee7a0ec-d6910.png 568w"\n        sizes="(max-width: 568px) 100vw, 568px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>其中“同源跨域通信方案”可以使用文章第一部分提到的某种技术。</p>\n<h1 id="总结"><a href="#%E6%80%BB%E7%BB%93" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总结</h1>\n<p>对于同源页面，常见的方式包括：</p>\n<ul>\n<li>广播模式：Broadcast Channe / Service Worker / LocalStorage + StorageEvent</li>\n<li>共享存储模式：Shared Worker / IndexedDB / cookie</li>\n<li>口口相传模式：window.open + window.opener</li>\n<li>基于服务端：Websocket / Comet / SSE 等</li>\n</ul>\n<p>而对于非同源页面，则可以通过嵌入同源 iframe 作为“桥”，将非同源页面通信转换为同源页面通信。</p>',
id:"/github/workspace/blog/浏览器跨页面通信/index.md absPath of file >>> MarkdownRemark",timeToRead:7,frontmatter:{date:"2021-06-30 11:17:28",path:"/browser-cross-page-message/",tags:"前端, 浏览器, 高级前端",title:"浏览器跨页面通信",draft:null}}],length:20,tag:"高级前端",pagesSum:4,page:1}}}});