webpackJsonp([0xe199a1f74c70],{1403:function(n,a){n.exports={data:{site:{siteMetadata:{title:"女王控的博客",description:'前端工程师，黑猫女王控，欢迎勾搭，技术相关<a href="https://github.com/towavephone" target="_blank">@towavephone</a>，QQ闲聊<a href="tencent://AddContact/?fromId=45&fromSubId=1&subcmd=all&uin=634407147&website=www.oicqzone.com">@towave</a>，bili关注<a href="https://space.bilibili.com/11507708#/" target="_blank">@towave</a>',siteUrl:"https://blog.towavephone.com"}}},pathContext:{posts:[{excerpt:"React 生命周期很多人都了解，但通常我们所了解的都是  单个组件  的生命周期，但针对  Hooks 组件、多个关联组件 （父子组件和兄弟组件） 的生命周期又是怎么样的喃？你有思考和了解过吗，接下来我们将完整的了解 React 生命周期。 关于  组件  ，我们这里指的是   以及   ，但是否包括 Hooks 组件呢？ Hooks 组件 函数组件  的本质是函数，没有 state 的概念的，因此 不存在生命周期 一说，仅仅是一个  render 函数 而已。 但是引入  Hooks…",html:'<p>React 生命周期很多人都了解，但通常我们所了解的都是 <strong>单个组件</strong> 的生命周期，但针对 <strong>Hooks 组件、多个关联组件</strong>（父子组件和兄弟组件） 的生命周期又是怎么样的喃？你有思考和了解过吗，接下来我们将完整的了解 React 生命周期。</p>\n<p>关于 <strong>组件</strong> ，我们这里指的是 <code class="language-text">React.Component</code> 以及 <code class="language-text">React.PureComponent</code> ，但是否包括 Hooks 组件呢？</p>\n<h1 id="hooks-组件"><a href="#hooks-%E7%BB%84%E4%BB%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Hooks 组件</h1>\n<p><strong>函数组件</strong> 的本质是函数，没有 state 的概念的，因此<strong>不存在生命周期</strong>一说，仅仅是一个 <strong>render 函数</strong>而已。</p>\n<p>但是引入 <strong>Hooks</strong> 之后就变得不同了，它能让组件在不使用 class 的情况下使用 state 以及其他的 React 特性，相比与 class 的生命周期概念来说，它更接近于实现状态同步，而不是响应生命周期事件。但我们可以利用 <code class="language-text">useState</code>、 <code class="language-text">useEffect()</code> 和 <code class="language-text">useLayoutEffect()</code> 来模拟实现生命周期。</p>\n<p>即：<strong>Hooks 组件更接近于实现状态同步，而不是响应生命周期事件</strong>。</p>\n<p>下面，是具体的 生命周期 与 Hooks 的<strong>对应关系</strong>：</p>\n<ul>\n<li>\n<p><code class="language-text">constructor</code>：函数组件不需要构造函数，我们可以通过调用 <strong><code class="language-text">useState</code> 来初始化 state</strong>。如果计算的代价比较昂贵，也可以传一个函数给 <code class="language-text">useState</code>。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="76998927352201630000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`const [num, UpdateNum] = useState(0);`, `76998927352201630000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">const</span> <span class="token punctuation">[</span>num<span class="token punctuation">,</span> UpdateNum<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n</li>\n<li>\n<p><code class="language-text">getDerivedStateFromProps</code>：一般情况下，我们不需要使用它，我们可以在<strong>渲染过程中更新 state</strong>，以达到实现 <code class="language-text">getDerivedStateFromProps</code> 的目的。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="53055553390095580000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function ScrollView({ row }) {\nlet [isScrollingDown, setIsScrollingDown] = useState(false);\nlet [prevRow, setPrevRow] = useState(null);\n\nif (row !== prevRow) {\n  // Row 自上次渲染以来发生过改变。更新 isScrollingDown。\n  setIsScrollingDown(prevRow !== null && row > prevRow);\n  setPrevRow(row);\n}\n\nreturn \\`Scrolling down: \\${isScrollingDown}\\`;\n}`, `53055553390095580000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span> <span class="token function">ScrollView</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> row <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n<span class="token keyword">let</span> <span class="token punctuation">[</span>isScrollingDown<span class="token punctuation">,</span> setIsScrollingDown<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">let</span> <span class="token punctuation">[</span>prevRow<span class="token punctuation">,</span> setPrevRow<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token keyword">if</span> <span class="token punctuation">(</span>row <span class="token operator">!==</span> prevRow<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// Row 自上次渲染以来发生过改变。更新 isScrollingDown。</span>\n  <span class="token function">setIsScrollingDown</span><span class="token punctuation">(</span>prevRow <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> row <span class="token operator">></span> prevRow<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token function">setPrevRow</span><span class="token punctuation">(</span>row<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">return</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Scrolling down: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>isScrollingDown<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>React 会立即退出第一次渲染并用更新后的 state 重新运行组件以避免耗费太多性能。</p>\n</li>\n<li>\n<p><code class="language-text">shouldComponentUpdate</code>：可以用 <strong><code class="language-text">React.memo</code></strong> 包裹一个组件来对它的 <code class="language-text">props</code> 进行浅比较</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="70014299857322590000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`const Button = React.memo((props) => {\n// 具体的组件\n});`, `70014299857322590000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">const</span> Button <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">memo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n<span class="token comment">// 具体的组件</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span></span></pre></div>\n<p>注意：<strong><code class="language-text">React.memo</code> 等效于 <code class="language-text">PureComponent</code></strong>，它只浅比较 props。这里也可以使用 <code class="language-text">useMemo</code> 优化每一个节点。</p>\n</li>\n<li>\n<p><code class="language-text">render</code>：这是函数组件体本身。</p>\n</li>\n<li>\n<p><code class="language-text">componentDidMount</code>, <code class="language-text">componentDidUpdate</code>： <code class="language-text">useLayoutEffect</code> 与它们两的调用阶段是一样的。但是，我们推荐你<strong>一开始先用 useEffect</strong>，只有当它出问题的时候再尝试使用 <code class="language-text">useLayoutEffect</code>。<code class="language-text">useEffect</code> 可以表达所有这些的组合。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="87816557337105370000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// componentDidMount\nuseEffect(() => {\n// 需要在 componentDidMount 执行的内容\n}, []);\n\nuseEffect(() => {\n// 在 componentDidMount，以及 count 更改时 componentDidUpdate 执行的内容\ndocument.title = \\`You clicked \\${count} times\\`;\nreturn () => {\n  // 需要在 count 更改时 componentDidUpdate（先于 document.title = ... 执行，遵守先清理后更新）\n  // 以及 componentWillUnmount 执行的内容\n}; // 当函数中 Cleanup 函数会按照在代码中定义的顺序先后执行，与函数本身的特性无关\n}, [count]); // 仅在 count 更改时更新`, `87816557337105370000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">// componentDidMount</span>\n<span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n<span class="token comment">// 需要在 componentDidMount 执行的内容</span>\n<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n<span class="token comment">// 在 componentDidMount，以及 count 更改时 componentDidUpdate 执行的内容</span>\ndocument<span class="token punctuation">.</span>title <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">You clicked </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>count<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> times</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>\n<span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  <span class="token comment">// 需要在 count 更改时 componentDidUpdate（先于 document.title = ... 执行，遵守先清理后更新）</span>\n  <span class="token comment">// 以及 componentWillUnmount 执行的内容</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 当函数中 Cleanup 函数会按照在代码中定义的顺序先后执行，与函数本身的特性无关</span>\n<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>count<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 仅在 count 更改时更新</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p><strong>请记得 React 会等待浏览器完成画面渲染之后才会延迟调用 <code class="language-text">useEffect</code>，因此会使得额外操作很方便</strong></p>\n</li>\n<li>\n<p><code class="language-text">componentWillUnmount</code>：相当于 <code class="language-text">useEffect</code> 里面返回的 <code class="language-text">cleanup</code> 函数</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="87769639973709320000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// componentDidMount/componentWillUnmount\nuseEffect(() => {\n// 需要在 componentDidMount 执行的内容\nreturn function cleanup() {\n  // 需要在 componentWillUnmount 执行的内容\n};\n}, []);`, `87769639973709320000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">// componentDidMount/componentWillUnmount</span>\n<span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n<span class="token comment">// 需要在 componentDidMount 执行的内容</span>\n<span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token function">cleanup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 需要在 componentWillUnmount 执行的内容</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n</li>\n<li>\n<p><code class="language-text">componentDidCatch</code> and <code class="language-text">getDerivedStateFromError</code>：目前<strong>还没有</strong>这些方法的 Hook 等价写法，但很快会加上。</p>\n</li>\n</ul>\n<p>为方便记忆，大致汇总成表格如下。</p>\n<table>\n<thead>\n<tr>\n<th>class 组件</th>\n<th>Hooks 组件</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>constructor</td>\n<td>useState</td>\n</tr>\n<tr>\n<td>getDerivedStateFromProps</td>\n<td>useState 里面 update 函数</td>\n</tr>\n<tr>\n<td>shouldComponentUpdate</td>\n<td>useMemo</td>\n</tr>\n<tr>\n<td>render</td>\n<td>函数本身</td>\n</tr>\n<tr>\n<td>componentDidMount</td>\n<td>useEffect</td>\n</tr>\n<tr>\n<td>componentDidUpdate</td>\n<td>useEffect</td>\n</tr>\n<tr>\n<td>componentWillUnmount</td>\n<td>useEffect 里面返回的函数</td>\n</tr>\n<tr>\n<td>componentDidCatch</td>\n<td>无</td>\n</tr>\n<tr>\n<td>getDerivedStateFromError</td>\n<td>无</td>\n</tr>\n</tbody>\n</table>\n<h1 id="单个组件的生命周期"><a href="#%E5%8D%95%E4%B8%AA%E7%BB%84%E4%BB%B6%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>单个组件的生命周期</h1>\n<h2 id="生命周期"><a href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>生命周期</h2>\n<h3 id="v163-之前"><a href="#v163-%E4%B9%8B%E5%89%8D" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>V16.3 之前</h3>\n<p>我们可以将生命周期分为三个阶段：</p>\n<ul>\n<li>挂载阶段</li>\n<li>组件更新阶段</li>\n<li>卸载阶段</li>\n</ul>\n<p>分开来讲：</p>\n<ol>\n<li>\n<p>挂载阶段</p>\n<ul>\n<li><code class="language-text">constructor</code>：避免将 props 的值复制给 state</li>\n<li><code class="language-text">componentWillMount</code></li>\n<li><code class="language-text">render</code>：react 最重要的步骤，创建虚拟 dom，进行 diff 算法，更新 dom 树都在此进行</li>\n<li><code class="language-text">componentDidMount</code></li>\n</ul>\n</li>\n<li>\n<p>组件更新阶段</p>\n<ul>\n<li><code class="language-text">componentWillReceiveProps</code></li>\n<li><code class="language-text">shouldComponentUpdate</code></li>\n<li><code class="language-text">componentWillUpdate</code></li>\n<li><code class="language-text">render</code></li>\n<li><code class="language-text">componentDidUpdate</code></li>\n</ul>\n</li>\n<li>\n<p>卸载阶段</p>\n<ul>\n<li><code class="language-text">componentWillUnMount</code></li>\n</ul>\n</li>\n</ol>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2019-09-19-15-39-27-eab55b0696e08d1c4eb1c06e80f91656-64b63.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 46.2%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAIAAAC9o5sfAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABMUlEQVQoz31RXW/DIAzs//9je16nqVXapkkWGkJKvgsGDMxptq4P207Iss53WLY3MUYDC3zwBK01IoYY6FFpZShSvpJUJcY5R8yGSCll0zTEGmOEEFRbpCEAZaDrutZLAvEOpRRp5nm+m9FCvYN6j1a3l/FybJqi84jHyb5U02tnQcOU7Nu3rWalj0EUskxqnkuPfuns4OZAoXei5+klrSRDjyOv+S6RaaaGiR1Yuc3anFM3C07fwIClGTbxGzQzH7pU8LKTzmPP2HV/7t4Pep4rIQrGunFYF/HAszmI3mZ85q1BH2QznBLGcnED9dGzo8ha1dEifjc/FyiX6nqW52pkM5ii1odyug42xr/NYYlxvQpv9S5vT9Vg7NflfAj/dPaPj0nk0INB4/BJHu6aH3wCvBUH6w2zt08AAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2019 09 19 15 39 27"\n        title=""\n        src="/static/2019-09-19-15-39-27-eab55b0696e08d1c4eb1c06e80f91656-fee1c.png"\n        srcset="/static/2019-09-19-15-39-27-eab55b0696e08d1c4eb1c06e80f91656-a67b7.png 200w,\n/static/2019-09-19-15-39-27-eab55b0696e08d1c4eb1c06e80f91656-0b187.png 400w,\n/static/2019-09-19-15-39-27-eab55b0696e08d1c4eb1c06e80f91656-fee1c.png 800w,\n/static/2019-09-19-15-39-27-eab55b0696e08d1c4eb1c06e80f91656-b1a91.png 1200w,\n/static/2019-09-19-15-39-27-eab55b0696e08d1c4eb1c06e80f91656-95179.png 1600w,\n/static/2019-09-19-15-39-27-eab55b0696e08d1c4eb1c06e80f91656-64b63.png 2000w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>这种生命周期会存在一个问题，那就是当更新复杂组件的最上层组件时，调用栈会很长，如果在进行复杂的操作时，就可能长时间阻塞主线程，带来不好的用户体验，<strong>Fiber</strong> 就是为了解决该问题而生。</p>\n<h3 id="v163-之后"><a href="#v163-%E4%B9%8B%E5%90%8E" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>V16.3 之后</h3>\n<p><strong>Fiber 本质上是一个虚拟的堆栈帧，新的调度器会按照优先级自由调度这些帧，从而将之前的同步渲染改成了异步渲染，在不影响体验的情况下去分段计算更新。</strong></p>\n<p>对于异步渲染，分为两阶段：</p>\n<ul>\n<li>\n<p><code class="language-text">reconciliation</code>：</p>\n<ul>\n<li><code class="language-text">componentWillMount</code></li>\n<li><code class="language-text">componentWillReceiveProps</code></li>\n<li><code class="language-text">shouldConmponentUpdate</code></li>\n<li><code class="language-text">componentWillUpdate</code></li>\n</ul>\n</li>\n<li>\n<p><code class="language-text">commit</code></p>\n<ul>\n<li><code class="language-text">componentDidMount</code></li>\n<li><code class="language-text">componentDidUpdate</code></li>\n</ul>\n</li>\n</ul>\n<p>其中，<code class="language-text">reconciliation</code> 阶段是可以被打断的，所以 <code class="language-text">reconcilation</code> 阶段执行的函数就会出现多次调用的情况，显然，这是不合理的。</p>\n<p>所以 V16.3 引入了新的 API 来解决这个问题：</p>\n<ol>\n<li>\n<p><code class="language-text">static getDerivedStateFromProps</code>： 该函数在<strong>挂载阶段和组件更新阶段</strong>都会执行，即<strong>每次获取新的<code class="language-text">props</code> 或 <code class="language-text">state</code> 之后都会被执行</strong>，<strong>在挂载阶段用来代替<code class="language-text">componentWillMount</code></strong>；在组件更新阶段配合 <code class="language-text">componentDidUpdate</code>，可以覆盖 <code class="language-text">componentWillReceiveProps</code> 的所有用法。</p>\n<p>同时它是一个静态函数，所以函数体内不能访问 <code class="language-text">this</code>，会根据 <code class="language-text">nextProps</code> 和 <code class="language-text">prevState</code> 计算出预期的状态改变，返回结果会被送给 <code class="language-text">setState</code><strong>，</strong>返回 <code class="language-text">null</code> 则说明不需要更新 <code class="language-text">state</code>，并且这个返回是<strong>必须的</strong>。</p>\n</li>\n<li>\n<p><code class="language-text">getSnapshotBeforeUpdate</code>: 该函数会在 <strong><code class="language-text">render</code> 之后， DOM 更新前</strong>被调用，用于读取最新的 DOM 数据。</p>\n<p>返回一个值，<strong>作为 <code class="language-text">componentDidUpdate</code> 的第三个参数</strong>；配合 <code class="language-text">componentDidUpdate</code>, 可以覆盖<code class="language-text">componentWillUpdate</code> 的所有用法。</p>\n</li>\n</ol>\n<p>注意：V16.3 中只用在组件挂载或组件 <code class="language-text">props</code> 更新过程才会调用，即如果是因为自身 setState 引发或者 forceUpdate 引发，而不是由父组件引发的话，那么<code class="language-text">static getDerivedStateFromProps</code>也不会被调用，在 V16.4 中更正为都调用。</p>\n<p>即更新后的生命周期为：</p>\n<ol>\n<li>\n<p>挂载阶段</p>\n<ul>\n<li><code class="language-text">constructor</code></li>\n<li><code class="language-text">static getDerivedStateFromProps</code></li>\n<li><code class="language-text">render</code></li>\n<li><code class="language-text">componentDidMount</code></li>\n</ul>\n</li>\n<li>\n<p>更新阶段</p>\n<ul>\n<li><code class="language-text">static getDerivedStateFromProps</code></li>\n<li><code class="language-text">shouldComponentUpdate</code></li>\n<li><code class="language-text">render</code></li>\n<li><code class="language-text">getSnapshotBeforeUpdate</code></li>\n<li><code class="language-text">componentDidUpdate</code></li>\n</ul>\n</li>\n<li>\n<p>卸载阶段</p>\n<ul>\n<li><code class="language-text">componentWillUnmount</code></li>\n</ul>\n</li>\n</ol>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2019-09-19-15-42-52-c13f7d524b09e92ec31990247d36fa3c-60fa0.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 65.97845601436265%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAIAAAAmMtkJAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAB1ElEQVQoz11SibKqMAzl///OGRUVAVkLbaH7xuaNF0fvexkmCTk5zekSPf+1bdv2ZF6eZBCE4K7rCIS+36Ht1/ae6C/tA4P3IXAupJTWOcHYSIj3/oPuzV8yYONAT6ejFNwYbYwJIcDYy+VirQVUaw0JpfRwOHDOIY/ei22btr4jPMkqMiqptJIvgyaMe60UJEIIICilMMbg3+RdtdA+rfkxaQqkhLLQTShVSmNMhJAtQowxIJg/FoGetm0lLKt9iW2FbU3dtaCnFMVZl1ZjhU1N3KMzeFQ7F8bCFl5k0BbHMUJo3xX8QhV82Q7XrLuX5Jr3XBpQDrYP/JI/B6aNG7mG62HCwFd2HCbfkiZvOGEGD4Jzaf8jw5FCBD0A1URXWDfUtNQ8Gpo3tB8torodTEUUGeQuG3S9yRCqqur7PkxTCJO1DrxzfvW9FSlpjqg4UHSeVO40dT4474DmoMP7aFmW32sM62yec7949JyJk6VhueH5pOvF1BsUQzt7vq7fV7Su62tymqaE0HkyfMxxdxPsoUXDhmKgGcF30ieCFda0zoowBaE4GTB4yKN5nkEDeO3MrUzi7JJUd1DCLG9ZC/kZKuUdMaSsYmqMs9MlP98eZ6n5Dzwc3073oxEkAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2019 09 19 15 42 52"\n        title=""\n        src="/static/2019-09-19-15-42-52-c13f7d524b09e92ec31990247d36fa3c-fee1c.png"\n        srcset="/static/2019-09-19-15-42-52-c13f7d524b09e92ec31990247d36fa3c-a67b7.png 200w,\n/static/2019-09-19-15-42-52-c13f7d524b09e92ec31990247d36fa3c-0b187.png 400w,\n/static/2019-09-19-15-42-52-c13f7d524b09e92ec31990247d36fa3c-fee1c.png 800w,\n/static/2019-09-19-15-42-52-c13f7d524b09e92ec31990247d36fa3c-b1a91.png 1200w,\n/static/2019-09-19-15-42-52-c13f7d524b09e92ec31990247d36fa3c-95179.png 1600w,\n/static/2019-09-19-15-42-52-c13f7d524b09e92ec31990247d36fa3c-60fa0.png 2228w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<h3 id="生命周期，误区"><a href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%8C%E8%AF%AF%E5%8C%BA" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>生命周期，误区</h3>\n<p><strong>误解一：</strong><code class="language-text">getDerivedStateFromProps</code> 和 <code class="language-text">componentWillReceiveProps</code> 只会在 <code class="language-text">props</code> <strong>改变</strong> 时才会调用</p>\n<p>实际上，<strong>只要父级重新渲染，<code class="language-text">getDerivedStateFromProps</code> 和 <code class="language-text">componentWillReceiveProps</code> 都会重新调用，不管 <code class="language-text">props</code> 有没有变化</strong>。所以，在这两个方法内直接将 props 赋值到 state 是不安全的。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="72732758639652720000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// 子组件\nclass PhoneInput extends Component {\n  state = { phone: this.props.phone };\n\n  handleChange = (e) => {\n    this.setState({ phone: e.target.value });\n  };\n\n  render() {\n    const { phone } = this.state;\n    return <input onChange={this.handleChange} value={phone} />;\n  }\n\n  componentWillReceiveProps(nextProps) {\n    // 不要这样做。\n    // 这会覆盖掉之前所有的组件内 state 更新！\n    this.setState({ phone: nextProps.phone });\n  }\n}\n\n// 父组件\nclass App extends Component {\n  constructor() {\n    super();\n    this.state = {\n      count: 0\n    };\n  }\n\n  componentDidMount() {\n    // 使用了 setInterval，\n    // 每秒钟都会更新一下 state.count\n    // 这将导致 App 每秒钟重新渲染一次\n    this.interval = setInterval(\n      () =>\n        this.setState((prevState) => ({\n          count: prevState.count + 1\n        })),\n      1000\n    );\n  }\n\n  componentWillUnmount() {\n    clearInterval(this.interval);\n  }\n\n  render() {\n    return (\n      <>\n        <p>Start editing to see some magic happen :)</p>\n        <PhoneInput phone=\'call me!\' />\n        <p>\n          This component will re-render every second. Each time it renders, the text you type will be reset. This\n          illustrates a derived state anti-pattern.\n        </p>\n      </>\n    );\n  }\n}`, `72732758639652720000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">// 子组件</span>\n<span class="token keyword">class</span> <span class="token class-name">PhoneInput</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>\n  state <span class="token operator">=</span> <span class="token punctuation">{</span> phone<span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>phone <span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n  <span class="token function-variable function">handleChange</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span> phone<span class="token punctuation">:</span> e<span class="token punctuation">.</span>target<span class="token punctuation">.</span>value <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">const</span> <span class="token punctuation">{</span> phone <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">;</span>\n    <span class="token keyword">return</span> <span class="token operator">&lt;</span>input onChange<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>handleChange<span class="token punctuation">}</span> value<span class="token operator">=</span><span class="token punctuation">{</span>phone<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token function">componentWillReceiveProps</span><span class="token punctuation">(</span><span class="token parameter">nextProps</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 不要这样做。</span>\n    <span class="token comment">// 这会覆盖掉之前所有的组件内 state 更新！</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span> phone<span class="token punctuation">:</span> nextProps<span class="token punctuation">.</span>phone <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// 父组件</span>\n<span class="token keyword">class</span> <span class="token class-name">App</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>\n  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span>\n      count<span class="token punctuation">:</span> <span class="token number">0</span>\n    <span class="token punctuation">}</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 使用了 setInterval，</span>\n    <span class="token comment">// 每秒钟都会更新一下 state.count</span>\n    <span class="token comment">// 这将导致 App 每秒钟重新渲染一次</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>interval <span class="token operator">=</span> <span class="token function">setInterval</span><span class="token punctuation">(</span>\n      <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span>\n        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">prevState</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span>\n          count<span class="token punctuation">:</span> prevState<span class="token punctuation">.</span>count <span class="token operator">+</span> <span class="token number">1</span>\n        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n      <span class="token number">1000</span>\n    <span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token function">componentWillUnmount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token function">clearInterval</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>interval<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token punctuation">(</span>\n      <span class="token operator">&lt;</span><span class="token operator">></span>\n        <span class="token operator">&lt;</span>p<span class="token operator">></span>Start editing to see some magic happen <span class="token punctuation">:</span><span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">></span>\n        <span class="token operator">&lt;</span>PhoneInput phone<span class="token operator">=</span><span class="token string">\'call me!\'</span> <span class="token operator">/</span><span class="token operator">></span>\n        <span class="token operator">&lt;</span>p<span class="token operator">></span>\n          This component will re<span class="token operator">-</span>render every second<span class="token punctuation">.</span> Each time it renders<span class="token punctuation">,</span> the text you type will be reset<span class="token punctuation">.</span> This\n          illustrates a derived state anti<span class="token operator">-</span>pattern<span class="token punctuation">.</span>\n        <span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">></span>\n      <span class="token operator">&lt;</span><span class="token operator">/</span><span class="token operator">></span>\n    <span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p><a href="https://stackblitz.com/edit/react-yammav" target="_blank" rel="nofollow noreferrer noopener">实例可点击这里查看</a></p>\n<p>当然，我们可以在 父组件 App 中 <code class="language-text">shouldComponentUpdate</code> 比较 props 的 email 是不是修改再决定要不要重新渲染，但是如果子组件接受多个 props（较为复杂），就很难处理，而且 <code class="language-text">shouldComponentUpdate</code> 主要是用来性能提升的，不推荐开发者操作 <code class="language-text">shouldComponetUpdate</code>（可以使用 <code class="language-text">React.PureComponet</code>）。</p>\n<p>我们也可以使用 <strong>在 props 变化后修改 state</strong>。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="67523567389041770000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`class PhoneInput extends Component {\n  state = {\n    phone: this.props.phone\n  };\n\n  componentWillReceiveProps(nextProps) {\n    // 只要 props.phone 改变，就改变 state\n    if (nextProps.phone !== this.props.phone) {\n      this.setState({\n        phone: nextProps.phone\n      });\n    }\n  }\n\n  // ...\n}`, `67523567389041770000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">PhoneInput</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>\n  state <span class="token operator">=</span> <span class="token punctuation">{</span>\n    phone<span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>phone\n  <span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n  <span class="token function">componentWillReceiveProps</span><span class="token punctuation">(</span><span class="token parameter">nextProps</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 只要 props.phone 改变，就改变 state</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>nextProps<span class="token punctuation">.</span>phone <span class="token operator">!==</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>phone<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n        phone<span class="token punctuation">:</span> nextProps<span class="token punctuation">.</span>phone\n      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token comment">// ...</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>但这种也会导致一个问题，当 props 较为复杂时，props 与 state 的关系不好控制，可能导致问题</p>\n<p>解决方案一：<strong>完全可控的组件</strong></p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="63160966213018345000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function PhoneInput(props) {\n  return <input onChange={props.onChange} value={props.phone} />;\n}`, `63160966213018345000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span> <span class="token function">PhoneInput</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token operator">&lt;</span>input onChange<span class="token operator">=</span><span class="token punctuation">{</span>props<span class="token punctuation">.</span>onChange<span class="token punctuation">}</span> value<span class="token operator">=</span><span class="token punctuation">{</span>props<span class="token punctuation">.</span>phone<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span></span></pre></div>\n<p><strong>完全由 props 控制，不派生 state</strong></p>\n<p>解决方案二：<strong>有 key 的非可控组件</strong></p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="11656640900655213000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`class PhoneInput extends Component {\n  state = { phone: this.props.defaultPhone };\n\n  handleChange = (event) => {\n    this.setState({ phone: event.target.value });\n  };\n\n  render() {\n    return <input onChange={this.handleChange} value={this.state.phone} />;\n  }\n}\n\n<PhoneInput defaultPhone={this.props.user.phone} key={this.props.user.id} />;`, `11656640900655213000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">PhoneInput</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>\n  state <span class="token operator">=</span> <span class="token punctuation">{</span> phone<span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>defaultPhone <span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n  <span class="token function-variable function">handleChange</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span> phone<span class="token punctuation">:</span> event<span class="token punctuation">.</span>target<span class="token punctuation">.</span>value <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token operator">&lt;</span>input onChange<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>handleChange<span class="token punctuation">}</span> value<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>phone<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token operator">&lt;</span>PhoneInput defaultPhone<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>user<span class="token punctuation">.</span>phone<span class="token punctuation">}</span> key<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>user<span class="token punctuation">.</span>id<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>当 <code class="language-text">key</code> 变化时， React 会<strong>创建一个新的而不是更新一个既有的组件</strong></p>\n<p><strong>误解二</strong>：将 props 的值直接复制给 state</p>\n<p><strong>应避免将 props 的值复制给 state</strong></p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="68655607325617725000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`constructor(props) {\n super(props);\n // 千万不要这样做\n // 直接用 props，保证单一数据源\n this.state = { phone: props.phone };\n}`, `68655607325617725000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>\n <span class="token comment">// 千万不要这样做</span>\n <span class="token comment">// 直接用 props，保证单一数据源</span>\n <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span> phone<span class="token punctuation">:</span> props<span class="token punctuation">.</span>phone <span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h1 id="多个组件的执行顺序"><a href="#%E5%A4%9A%E4%B8%AA%E7%BB%84%E4%BB%B6%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>多个组件的执行顺序</h1>\n<h2 id="父子组件"><a href="#%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>父子组件</h2>\n<ul>\n<li>\n<p><strong>挂载阶段</strong></p>\n<p>分 <strong>两个</strong> 阶段：</p>\n<ul>\n<li>第 <strong>一</strong> 阶段，由父组件开始执行到自身的 <code class="language-text">render</code>，解析其下有哪些子组件需要渲染，并对其中 <strong>同步的子组件</strong> 进行创建，按 <strong>递归顺序</strong> 挨个执行各个子组件至 <code class="language-text">render</code>，生成到父子组件对应的 Virtual DOM 树，并 commit 到 DOM。</li>\n<li>第 <strong>二</strong> 阶段，此时 DOM 节点已经生成完毕，组件挂载完成，开始后续流程。先依次触发同步子组件各自的 <code class="language-text">componentDidMount</code>，最后触发父组件的。</li>\n</ul>\n<p><strong>注意</strong>：如果父组件中包含异步子组件，则会在父组件挂载完成后被创建。</p>\n<p>所以执行顺序是：</p>\n<p>父组件 getDerivedStateFromProps —> 同步子组件 getDerivedStateFromProps —> 同步子组件 componentDidMount —> 父组件 componentDidMount —> 异步子组件 getDerivedStateFromProps —> 异步子组件 componentDidMount</p>\n</li>\n<li>\n<p><strong>更新阶段</strong></p>\n<p><strong>React 的设计遵循单向数据流模型</strong> ，也就是说，数据均是由父组件流向子组件。</p>\n<ul>\n<li>\n<p>第 <strong>一</strong> 阶段，由父组件开始，执行</p>\n</li>\n<li>\n<p><code class="language-text">static getDerivedStateFromProps</code></p>\n</li>\n<li>\n<p><code class="language-text">shouldComponentUpdate</code></p>\n</li>\n</ul>\n<p>更新到自身的 <code class="language-text">render</code>，解析其下有哪些子组件需要渲染，并对 <strong>子组件</strong> 进行创建，按 <strong>递归顺序</strong> 挨个执行各个子组件至 <code class="language-text">render</code>，生成到父子组件对应的 Virtual DOM 树，并与已有的 Virtual DOM 树 比较，计算出 <strong>Virtual DOM 真正变化的部分</strong> ，并只针对该部分进行的原生 DOM 操作。</p>\n<ul>\n<li>\n<p>第 <strong>二</strong> 阶段，此时 DOM 节点已经生成完毕，组件挂载完成，开始后续流程。先依次触发同步子组件以下函数，最后触发父组件的。</p>\n</li>\n<li>\n<p><code class="language-text">getSnapshotBeforeUpdate()</code></p>\n</li>\n<li>\n<p><code class="language-text">componentDidUpdate()</code></p>\n</li>\n</ul>\n<p>React 会按照上面的顺序依次执行这些函数，每个函数都是各个子组件的先执行，然后才是父组件的执行。</p>\n<p>所以执行顺序是：</p>\n<p>父组件 getDerivedStateFromProps —> 父组件 shouldComponentUpdate —> 子组件 getDerivedStateFromProps —> 子组件 shouldComponentUpdate —> 子组件 getSnapshotBeforeUpdate —> 父组件 getSnapshotBeforeUpdate —> 子组件 componentDidUpdate —> 父组件 componentDidUpdate</p>\n</li>\n<li>\n<p><strong>卸载阶段</strong></p>\n<p><code class="language-text">componentWillUnmount()</code>，顺序为 <strong>父组件的先执行，子组件按照在 JSX 中定义的顺序依次执行各自的方法</strong>。</p>\n<p><strong>注意</strong> ：如果卸载旧组件的同时伴随有新组件的创建，新组件会先被创建并执行完 <code class="language-text">render</code>，然后卸载不需要的旧组件，最后新组件执行挂载完成的回调。</p>\n</li>\n</ul>\n<h2 id="兄弟组件"><a href="#%E5%85%84%E5%BC%9F%E7%BB%84%E4%BB%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>兄弟组件</h2>\n<ul>\n<li>\n<p><strong>挂载阶段</strong></p>\n<p>若是同步路由，它们的创建顺序和其在共同父组件中定义的先后顺序是 <strong>一致</strong> 的。</p>\n<p>若是异步路由，它们的创建顺序和 js 加载完成的顺序一致。</p>\n</li>\n<li>\n<p><strong>更新阶段、卸载阶段</strong></p>\n<p>兄弟节点之间的通信主要是经过父组件（Redux 和 Context 也是通过改变父组件传递下来的 <code class="language-text">props</code> 实现的），<strong>满足 React 的设计遵循单向数据流模型</strong>， <strong>因此任何两个组件之间的通信，本质上都可以归结为父子组件更新的情况</strong> 。</p>\n<p>所以，兄弟组件更新、卸载阶段，请参考 <strong>父子组件</strong>。</p>\n</li>\n</ul>',
id:"/github/workspace/blog/React生命周期入门学习/index.md absPath of file >>> MarkdownRemark",timeToRead:9,frontmatter:{date:"2019-09-19 15:29:20",path:"/react-lifecycle-practice-learn/",tags:"前端, React, 生命周期",title:"React生命周期入门学习",draft:null}}],length:1,tag:"生命周期",pagesSum:1,page:1}}}});