webpackJsonp([88544223563419],{1191:function(n,a){n.exports={data:{site:{siteMetadata:{description:'前端工程师，黑猫女王控，欢迎勾搭，技术相关<a href="https://github.com/towavephone" target="_blank">@towavephone</a>，QQ闲聊<a href="tencent://AddContact/?fromId=45&fromSubId=1&subcmd=all&uin=634407147&website=www.oicqzone.com">@towave</a>，bili关注<a href="https://space.bilibili.com/11507708#/" target="_blank">@towave</a>',siteUrl:"https://blog.towavephone.com"}}},pathContext:{posts:[{excerpt:"组件 纯组件  ，和   类似，都是定义一个组件类。不同是   没有实现  ，而   通过   和   的 浅比较 实现了。 在下一节中将会详细介绍。 函数组件 定义 React 组件的 最简单 方式就是定义一个函数组件，它接受单一的 props 并返回一个 React 元素。 在 函数组件 中，它的输入输出全部由 props 决定，且不会产生任何副作用，这说明  函数组件 也是 无状态组件 。 在函数组件中，无法修改 props，无法使用 state…",html:'<h1 id="组件"><a href="#%E7%BB%84%E4%BB%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>组件</h1>\n<h2 id="纯组件"><a href="#%E7%BA%AF%E7%BB%84%E4%BB%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>纯组件</h2>\n<p><code class="language-text">React.PureComponent</code> ，和 <code class="language-text">React.Component</code> 类似，都是定义一个组件类。不同是 <code class="language-text">React.Component</code> 没有实现 <code class="language-text">shouldComponentUpdate()</code>，而 <code class="language-text">React.PureComponent</code> 通过 <code class="language-text">props</code> 和 <code class="language-text">state</code> 的<strong>浅比较</strong>实现了。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="22035142809946472000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// React.PureComponent 纯组件\nclass Counter extends React.PureComponent {\n  constructor(props) {\n    super(props);\n    this.state = { count: 0 };\n  }\n  render() {\n    return (\n      <button onClick={() => this.setState((state) => ({ count: state.count + 1 }))}>Count: {this.state.count}</button>\n    );\n  }\n}`, `22035142809946472000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">// React.PureComponent 纯组件</span>\n<span class="token keyword">class</span> <span class="token class-name">Counter</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>PureComponent</span> <span class="token punctuation">{</span>\n  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span> count<span class="token punctuation">:</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token punctuation">(</span>\n      <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">state</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span> count<span class="token punctuation">:</span> state<span class="token punctuation">.</span>count <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">></span>Count<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>count<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span>\n    <span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>在下一节中将会详细介绍。</p>\n<h2 id="函数组件"><a href="#%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>函数组件</h2>\n<p>定义 React 组件的<strong>最简单</strong>方式就是定义一个函数组件，它接受单一的 props 并返回一个 React 元素。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="5996852947568354000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// 函数组件\nfunction Counter(props) {\n  return <div>Counter: {props.count}</div>;\n}\n// 类组件\nclass Counter extends React.Component {\n  render() {\n    return <div>Counter: {this.props.count}</div>;\n  }\n}`, `5996852947568354000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">// 函数组件</span>\n<span class="token keyword">function</span> <span class="token function">Counter</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token operator">&lt;</span>div<span class="token operator">></span>Counter<span class="token punctuation">:</span> <span class="token punctuation">{</span>props<span class="token punctuation">.</span>count<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token comment">// 类组件</span>\n<span class="token keyword">class</span> <span class="token class-name">Counter</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>\n  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token operator">&lt;</span>div<span class="token operator">></span>Counter<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>count<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<ul>\n<li>在 函数组件 中，它的输入输出全部由 props 决定，且不会产生任何副作用，这说明 <strong>函数组件 也是 无状态组件</strong>。</li>\n<li>在函数组件中，无法修改 props，无法使用 state 及组件的生命周期，说明 <strong>函数组件 也是 展示组件</strong>。</li>\n<li>函数组件 的功能只是接收 props，渲染页面，它不执行与 UI 无关的逻辑处理，它只是一个<strong>纯函数</strong>。</li>\n<li>函数组件，相对于类组件来说，更加简洁。无论是复用性还是性能，都<strong>优于类组件</strong>。</li>\n</ul>\n<h2 id="受控组件与非受控组件"><a href="#%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6%E4%B8%8E%E9%9D%9E%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>受控组件与非受控组件</h2>\n<p><strong>受控和非受控主要是取决于组件是否受父级传入的 props 控制</strong></p>\n<p>用 props 传入数据的话，组件可以被认为是<strong>受控</strong>（因为组件被父级传入的 props 控制）。</p>\n<p>数据只保存在组件内部的 state 的话，是<strong>非受控</strong>组件（因为外部没办法直接控制 state）。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="85575841119979980000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`export default class AnForm extends React.Component {\n  state = {\n    name: \'\'\n  };\n  handleSubmitClick = () => {\n    console.log(\'非受控组件: \', this._name.value);\n    console.log(\'受控组件: \', this.state.name);\n  };\n  handleChange = (e) => {\n    this.setState({\n      name: e.target.value\n    });\n  };\n\n  render() {\n    return (\n      <form onSubmit={this.handleSubmitClick}>\n        <label>\n          非受控组件:\n          <input type=\'text\' defaultValue=\'default\' ref={(input) => (this._name = input)} />\n        </label>\n        <label>\n          受控组件:\n          <input type=\'text\' value={this.state.name} onChange={this.handleChange} />\n        </label>\n        <input type=\'submit\' value=\'Submit\' />\n      </form>\n    );\n  }\n}`, `85575841119979980000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">class</span> <span class="token class-name">AnForm</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>\n  state <span class="token operator">=</span> <span class="token punctuation">{</span>\n    name<span class="token punctuation">:</span> <span class="token string">\'\'</span>\n  <span class="token punctuation">}</span><span class="token punctuation">;</span>\n  <span class="token function-variable function">handleSubmitClick</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'非受控组件: \'</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_name<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'受控组件: \'</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">;</span>\n  <span class="token function-variable function">handleChange</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n      name<span class="token punctuation">:</span> e<span class="token punctuation">.</span>target<span class="token punctuation">.</span>value\n    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token punctuation">(</span>\n      <span class="token operator">&lt;</span>form onSubmit<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>handleSubmitClick<span class="token punctuation">}</span><span class="token operator">></span>\n        <span class="token operator">&lt;</span>label<span class="token operator">></span>\n          非受控组件<span class="token punctuation">:</span>\n          <span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">\'text\'</span> defaultValue<span class="token operator">=</span><span class="token string">\'default\'</span> ref<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token parameter">input</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>_name <span class="token operator">=</span> input<span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span>\n        <span class="token operator">&lt;</span><span class="token operator">/</span>label<span class="token operator">></span>\n        <span class="token operator">&lt;</span>label<span class="token operator">></span>\n          受控组件<span class="token punctuation">:</span>\n          <span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">\'text\'</span> value<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>name<span class="token punctuation">}</span> onChange<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>handleChange<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span>\n        <span class="token operator">&lt;</span><span class="token operator">/</span>label<span class="token operator">></span>\n        <span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">\'submit\'</span> value<span class="token operator">=</span><span class="token string">\'Submit\'</span> <span class="token operator">/</span><span class="token operator">></span>\n      <span class="token operator">&lt;</span><span class="token operator">/</span>form<span class="token operator">></span>\n    <span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h3 id="受控组件"><a href="#%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>受控组件</h3>\n<p>与 html 不同的是，在 React 中，<code class="language-text">&lt;input&gt;</code>或<code class="language-text">&lt;select&gt;</code>、<code class="language-text">&lt;textarea&gt;</code>等这类组件，不会主动维持自身状态，并根据用户输入进行更新。它们都要绑定一个<code class="language-text">onChange</code>事件；每当状态发生变化时，都要写入组件的 state 中，在 React 中被称为<strong>受控组件</strong>。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="95186830658498890000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`export default class AnForm extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { value: \'\' };\n    this.handleChange = this.handleChange.bind(this);\n  }\n  handleChange(event) {\n    this.setState({ value: event.target.value });\n  }\n  render() {\n    return <input type=\'text\' value={this.state.value} onChange={this.handleChange} />;\n  }\n}`, `95186830658498890000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">class</span> <span class="token class-name">AnForm</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>\n  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span> value<span class="token punctuation">:</span> <span class="token string">\'\'</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>handleChange <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">handleChange</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token function">handleChange</span><span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span> value<span class="token punctuation">:</span> event<span class="token punctuation">.</span>target<span class="token punctuation">.</span>value <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">\'text\'</span> value<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>value<span class="token punctuation">}</span> onChange<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>handleChange<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<ul>\n<li>\n<p><strong>onChange &#x26; value 模式</strong>（单选按钮和复选按钮对应的是 checked props）</p>\n</li>\n<li>\n<p>react 通过这种方式<strong>消除了组件的局部状态，</strong>使得应用的整个<strong>状态可控</strong>。</p>\n</li>\n<li>\n<p>注意 <code class="language-text">&lt;input type=&quot;file&quot; /&gt;</code>，它是一个<strong>非受控组件</strong>。</p>\n</li>\n<li>\n<p>可以使用计算属性名将多个相似的操作组合成一个。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="57804292214286600000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`this.setState({\n[name]: value\n});`, `57804292214286600000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n<span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token punctuation">:</span> value\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span></span></pre></div>\n</li>\n</ul>\n<h3 id="非受控组件"><a href="#%E9%9D%9E%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>非受控组件</h3>\n<p>非受控组件不再将数据保存在 state，而使用 refs，将真实数据保存在 DOM 中。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="78631833895699320000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`export default class AnForm extends Component {\n  handleSubmitClick = () => {\n    const name = this._name.value;\n  };\n\n  render() {\n    return (\n      <div>\n        <input type=\'text\' ref={(input) => (this._name = input)} />\n        <button onClick={this.handleSubmitClick}>Sign up</button>\n      </div>\n    );\n  }\n}`, `78631833895699320000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">class</span> <span class="token class-name">AnForm</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>\n  <span class="token function-variable function">handleSubmitClick</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n    <span class="token keyword">const</span> name <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_name<span class="token punctuation">.</span>value<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token punctuation">(</span>\n      <span class="token operator">&lt;</span>div<span class="token operator">></span>\n        <span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">\'text\'</span> ref<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token parameter">input</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>_name <span class="token operator">=</span> input<span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span>\n        <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>handleSubmitClick<span class="token punctuation">}</span><span class="token operator">></span>Sign up<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span>\n      <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>\n    <span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<ul>\n<li>\n<p><strong>非受控组件是最简单快速</strong>的实现方式，项目中出现极简的表单时，使用它，但<strong>受控组件才是是最权威的</strong>。</p>\n</li>\n<li>\n<p>通常指定一个 <strong>defaultValue/defaultChecked</strong> 默认值来控制初始状态，不使用 value。</p>\n</li>\n<li>\n<p>非受控组件相比于受控组件，更容易同时集成 React 和非 React 代码。</p>\n</li>\n<li>\n<p>使用场景</p>\n<p>| 特征 | 非受控组件 | 受控组件 |\n| --- | --- | --- |\n| one-time value retrieval (e.g. on submit) | ✅ | ✅ |\n| <a href="https://goshakkk.name/submit-time-validation-react/" target="_blank" rel="nofollow noreferrer noopener">validating on submit</a> | ✅ | ✅ |\n| <a href="https://goshakkk.name/instant-form-fields-validation-react/" target="_blank" rel="nofollow noreferrer noopener">instant field validation</a> | ❌ | ✅ |\n| <a href="https://goshakkk.name/form-recipe-disable-submit-button-react/" target="_blank" rel="nofollow noreferrer noopener">conditionally disabling submit button</a> | ❌ | ✅ |\n| enforcing input format | ❌ | ✅ |\n| several inputs for one piece of data | ❌ | ✅ |\n| <a href="https://goshakkk.name/array-form-inputs/" target="_blank" rel="nofollow noreferrer noopener">dynamic inputs</a> | ❌ | ✅ |</p>\n</li>\n</ul>\n<h2 id="有状态组件与无状态组件"><a href="#%E6%9C%89%E7%8A%B6%E6%80%81%E7%BB%84%E4%BB%B6%E4%B8%8E%E6%97%A0%E7%8A%B6%E6%80%81%E7%BB%84%E4%BB%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>有状态组件与无状态组件</h2>\n<h3 id="有状态组件"><a href="#%E6%9C%89%E7%8A%B6%E6%80%81%E7%BB%84%E4%BB%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>有状态组件</h3>\n<p>通过 state 管理状态</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="92620840961120780000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`export default class Counter extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { clicks: 0 };\n    this.handleClick = this.handleClick.bind(this);\n  }\n  handleClick() {\n    this.setState((state) => ({ clicks: state.clicks + 1 }));\n  }\n  render() {\n    return <Button onClick={this.handleClick} text={\\`You\'ve clicked me \\${this.state.clicks} times!\\`} />;\n  }\n}`, `92620840961120780000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">class</span> <span class="token class-name">Counter</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>\n  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span> clicks<span class="token punctuation">:</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>handleClick <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">handleClick</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token function">handleClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">state</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span> clicks<span class="token punctuation">:</span> state<span class="token punctuation">.</span>clicks <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token operator">&lt;</span>Button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>handleClick<span class="token punctuation">}</span> text<span class="token operator">=</span><span class="token punctuation">{</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">You\'ve clicked me </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>clicks<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> times!</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h3 id="无状态组件"><a href="#%E6%97%A0%E7%8A%B6%E6%80%81%E7%BB%84%E4%BB%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>无状态组件</h3>\n<p>输入输出数据完全由 props 决定，而且不会产生任何副作用。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="35366258450903820000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`const Button = (props) => <button onClick={props.onClick}>{props.text}</button>;`, `35366258450903820000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">const</span> <span class="token function-variable function">Button</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span>props<span class="token punctuation">.</span>onClick<span class="token punctuation">}</span><span class="token operator">></span><span class="token punctuation">{</span>props<span class="token punctuation">.</span>text<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<ul>\n<li>无状态组件一般会搭配高阶组件（简称：HOC）一起使用，高阶组件用来托管 state，Redux 框架就是通过 store 管理数据源和所有状态，其中所有负责展示的组件都使用无状态函数式的写法。</li>\n<li>一个简单的 无状态(stateless) 按钮组件，仅依赖于 props(属性) ，这也称为<strong>函数式组件</strong>。</li>\n</ul>\n<h2 id="展示组件与容器组件"><a href="#%E5%B1%95%E7%A4%BA%E7%BB%84%E4%BB%B6%E4%B8%8E%E5%AE%B9%E5%99%A8%E7%BB%84%E4%BB%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>展示组件与容器组件</h2>\n<h3 id="展示组件"><a href="#%E5%B1%95%E7%A4%BA%E7%BB%84%E4%BB%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>展示组件</h3>\n<p>展示组件指不关心数据是怎么加载和变动的，只关注于页面展示效果的组件。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="2948148724506438700"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`class TodoList extends React.Component {\n  constructor(props) {\n    super(props);\n  }\n  render() {\n    const { todos } = this.props;\n    return (\n      <div>\n        <ul>\n          {todos.map((item, index) => {\n            return <li key={item.id}>{item.name}</li>;\n          })}\n        </ul>\n      </div>\n    );\n  }\n}`, `2948148724506438700`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">TodoList</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>\n  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">const</span> <span class="token punctuation">{</span> todos <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">;</span>\n    <span class="token keyword">return</span> <span class="token punctuation">(</span>\n      <span class="token operator">&lt;</span>div<span class="token operator">></span>\n        <span class="token operator">&lt;</span>ul<span class="token operator">></span>\n          <span class="token punctuation">{</span>todos<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">item<span class="token punctuation">,</span> index</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n            <span class="token keyword">return</span> <span class="token operator">&lt;</span>li key<span class="token operator">=</span><span class="token punctuation">{</span>item<span class="token punctuation">.</span>id<span class="token punctuation">}</span><span class="token operator">></span><span class="token punctuation">{</span>item<span class="token punctuation">.</span>name<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">></span><span class="token punctuation">;</span>\n          <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span>\n        <span class="token operator">&lt;</span><span class="token operator">/</span>ul<span class="token operator">></span>\n      <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>\n    <span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<ul>\n<li>只能通过 <strong>props</strong> 的方式<strong>接收数据和进行回调</strong>(callback)操作。</li>\n<li><strong>很少拥有自己的状态</strong>，即使有也是用于展示 UI 状态的。</li>\n<li>通常允许通过 <strong>this.props.children</strong> 方式来包含其他组件。</li>\n<li><strong>内部可以包含展示组件和容器组件</strong>，通常会包含一些自己的 DOM 标记和样式(style)</li>\n<li>对应用程序的其他部分没有依赖关系，例如 Flux 操作或 store。</li>\n<li>会被写成函数式组件除非该组件需要自己的状态，生命周期或者做一些性能优化。</li>\n</ul>\n<h3 id="容器组件"><a href="#%E5%AE%B9%E5%99%A8%E7%BB%84%E4%BB%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>容器组件</h3>\n<p>容器组件只关心数据是怎么加载和变动的，而不关注于页面展示效果。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="73951075043797610000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`//容器组件\nclass TodoListContainer extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      todos: []\n    };\n    this.fetchData = this.fetchData.bind(this);\n  }\n  componentDidMount() {\n    this.fetchData();\n  }\n  fetchData() {\n    fetch(\'/api/todos\').then((data) => {\n      this.setState({\n        todos: data\n      });\n    });\n  }\n  render() {\n    return (\n      <div>\n        <TodoList todos={this.state.todos} />\n      </div>\n    );\n  }\n}`, `73951075043797610000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">//容器组件</span>\n<span class="token keyword">class</span> <span class="token class-name">TodoListContainer</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>\n  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span>\n      todos<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>\n    <span class="token punctuation">}</span><span class="token punctuation">;</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>fetchData <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">fetchData</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">fetchData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token function">fetchData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">\'/api/todos\'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n        todos<span class="token punctuation">:</span> data\n      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token punctuation">(</span>\n      <span class="token operator">&lt;</span>div<span class="token operator">></span>\n        <span class="token operator">&lt;</span>TodoList todos<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>todos<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span>\n      <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>\n    <span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<ul>\n<li><strong>内部可以包含容器组件和展示组件</strong>，但通常没有任何自己的 DOM 标记，除了一些包装 divs，并且从不具有任何样式。</li>\n<li>提供数据和行为给其他的展示组件或容器组件。</li>\n<li>可以调用 Flux 操作并将它们作为回调函数（callback）提供给展示组件。</li>\n<li>往往是<strong>有状态</strong>的，因为它们倾向于<strong>作为数据源</strong></li>\n<li>通常使用<strong>高阶组件</strong>生成，例如 React Redux 的 connect()</li>\n</ul>\n<h2 id="高阶组件"><a href="#%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>高阶组件</h2>\n<p><strong>高阶函数</strong>的定义：接收函数作为输入，或者输出另一个函数的一类函数，被称作高阶函数。</p>\n<p>对于<strong>高阶组件</strong>，它描述的便是接受 React 组件作为输入，输出一个新的 React 组件的组件。</p>\n<p>更通俗的描述为，高阶组件通过包裹（wrapped）被传入的 React 组件，经过一系列处理，最终返回一个<strong>相对增强（enhanced）的 React 组件</strong>，供其他组件调用。使我们的代码更具有复用性、逻辑性和抽象特性，它可以对 render 方法做劫持，也<strong>可以控制 props 、state</strong>。</p>\n<p>实现高阶组件的方法有以下两种：</p>\n<ul>\n<li><strong>属性代理（props proxy）</strong>，高阶组件通过被包裹的 React 组件来操作 props。</li>\n<li><strong>反向继承（inheritance inversion）</strong>，高阶组件继承于被包裹的 React 组件。</li>\n</ul>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="82565711590991720000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// 属性代理\nexport default function withHeader(WrappedComponent) {\n  return class HOC extends React.Component { // 继承与 React.component\n    render() {\n      const newProps = {\n        test:\'hoc\'\n      }\n      // 透传props，并且传递新的newProps\n      return <div>\n        <WrappedComponent {...this.props} {...newProps}/>\n      </div>\n    }\n  }\n}\n\n// 反向继承\nexport default function (WrappedComponent) {\n  return class Inheritance extends WrappedComponent { // 继承于被包裹的 React 组件\n    componentDidMount() {\n      // 可以方便地得到state，做一些更深入的修改。\n      console.log(this.state);\n    }\n    render() {\n      return super.render();\n    }\n  }\n}`, `82565711590991720000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">// 属性代理</span>\n<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token function">withHeader</span><span class="token punctuation">(</span><span class="token parameter">WrappedComponent</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token keyword">class</span> <span class="token class-name">HOC</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span> <span class="token comment">// 继承与 React.component</span>\n    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">const</span> newProps <span class="token operator">=</span> <span class="token punctuation">{</span>\n        test<span class="token punctuation">:</span><span class="token string">\'hoc\'</span>\n      <span class="token punctuation">}</span>\n      <span class="token comment">// 透传props，并且传递新的newProps</span>\n      <span class="token keyword">return</span> <span class="token operator">&lt;</span>div<span class="token operator">></span>\n        <span class="token operator">&lt;</span>WrappedComponent <span class="token punctuation">{</span><span class="token operator">...</span>this<span class="token punctuation">.</span>props<span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token operator">...</span>newProps<span class="token punctuation">}</span><span class="token operator">/</span><span class="token operator">></span>\n      <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// 反向继承</span>\n<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">WrappedComponent</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token keyword">class</span> <span class="token class-name">Inheritance</span> <span class="token keyword">extends</span> <span class="token class-name">WrappedComponent</span> <span class="token punctuation">{</span> <span class="token comment">// 继承于被包裹的 React 组件</span>\n    <span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token comment">// 可以方便地得到state，做一些更深入的修改。</span>\n      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<ul>\n<li>注意：不要在 HOC 内修改一个组件的原型（或以其它方式修改组件）</li>\n<li>贯穿传递不相关 props 属性给被包裹的组件，帮助确保高阶组件最大程度的灵活性和可重用性</li>\n<li>应该使用<strong>最大化的组合性</strong></li>\n<li>为了便于调试，可以选择一个显示名字，传达它是一个高阶组件的结果，<code class="language-text">WrappedComponent.displayName || WrappedComponent.name || &#39;Component&#39;;</code></li>\n<li><strong>不要在 render() 方法中创建 HOC</strong>，否则，每一次渲染，都会重新创建渲染 HOC</li>\n<li>必须将原始组件的静态方法在 HOC 中做拷贝，否则 HOC 将没有原始组件的任何静态方法</li>\n<li>Refs 属性不能贯穿传递，我们可以使用 React.forwardRef 解决</li>\n</ul>\n<h2 id="hook-组件"><a href="#hook-%E7%BB%84%E4%BB%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Hook 组件</h2>\n<p>Hook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。</p>\n<p>但与 class 生命周期不同的是，Hook 更接近于实现状态同步，而不是响应生命周期事件。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="23800065761661960000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`import React, { useState, useEffect } from \'react\';\n\nfunction Example() {\n  // 声明一个叫 &quot;count&quot; 的 state 变量\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    // 需要在 componentDidMount 执行的内容\n    return function cleanup() {\n      // 需要在 componentWillUnmount 执行的内容\n    };\n  }, []);\n\n  useEffect(() => {\n    // 在 componentDidMount，以及 count 更改时 componentDidUpdate 执行的内容\n    document.title = \'You clicked \' + count + \' times\';\n    return () => {\n      // 需要在 count 更改时 componentDidUpdate（先于 document.title = ... 执行，遵守先清理后更新）\n      // 以及 componentWillUnmount 执行的内容\n    }; // 当函数中 Cleanup 函数会按照在代码中定义的顺序先后执行，与函数本身的特性无关\n  }, [count]); // 仅在 count 更改时更新\n\n  return (\n    <div>\n      <p>You clicked {count} times</p>\n      <button onClick={() => setCount(count + 1)}>Click me</button>\n    </div>\n  );\n}`, `23800065761661960000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">{</span> useState<span class="token punctuation">,</span> useEffect <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">\'react\'</span><span class="token punctuation">;</span>\n\n<span class="token keyword">function</span> <span class="token function">Example</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 声明一个叫 "count" 的 state 变量</span>\n  <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n    <span class="token comment">// 需要在 componentDidMount 执行的内容</span>\n    <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token function">cleanup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token comment">// 需要在 componentWillUnmount 执行的内容</span>\n    <span class="token punctuation">}</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n    <span class="token comment">// 在 componentDidMount，以及 count 更改时 componentDidUpdate 执行的内容</span>\n    document<span class="token punctuation">.</span>title <span class="token operator">=</span> <span class="token string">\'You clicked \'</span> <span class="token operator">+</span> count <span class="token operator">+</span> <span class="token string">\' times\'</span><span class="token punctuation">;</span>\n    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n      <span class="token comment">// 需要在 count 更改时 componentDidUpdate（先于 document.title = ... 执行，遵守先清理后更新）</span>\n      <span class="token comment">// 以及 componentWillUnmount 执行的内容</span>\n    <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 当函数中 Cleanup 函数会按照在代码中定义的顺序先后执行，与函数本身的特性无关</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>count<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 仅在 count 更改时更新</span>\n\n  <span class="token keyword">return</span> <span class="token punctuation">(</span>\n    <span class="token operator">&lt;</span>div<span class="token operator">></span>\n      <span class="token operator">&lt;</span>p<span class="token operator">></span>You clicked <span class="token punctuation">{</span>count<span class="token punctuation">}</span> times<span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">></span>\n      <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">setCount</span><span class="token punctuation">(</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">></span>Click me<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span>\n    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>\n  <span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<ul>\n<li>Hooks 组件更接近于实现状态同步，而不是响应生命周期事件</li>\n<li>只能在<strong>函数最外层</strong>调用 Hook。只能在 <strong>React 的函数组件</strong>中调用 Hook。</li>\n<li><code class="language-text">useLayoutEffect</code> 与 <code class="language-text">componentDidMount</code>、<code class="language-text">componentDidUpdate</code> 的调用阶段是一样的。但是，我们推荐你<strong>一开始先用 useEffect</strong>，只有当它出问题的时候再尝试使用 <code class="language-text">useLayoutEffect</code></li>\n<li>与 <code class="language-text">componentDidMount</code> 或 <code class="language-text">componentDidUpdate</code> 不同的是，Hook 在浏览器完成布局与绘制<strong>之后</strong>，传给 <code class="language-text">useEffect</code> 的函数会延迟调用，但会保证在任何新的渲染前执行</li>\n<li>effect 的清除（cleanup）并不会读取“最新”的 props 。它只能读取到定义它的那次渲染中的 props 值</li>\n<li>effect 中可以读取到最新的 count 状态值，并不是 count 的值在“不变”的 effect 中发生了改变，而是 effect 函数本身在每一次渲染中都不相同</li>\n<li>在 class 组件生命周期的思维模型中，副作用的行为和渲染输出是不同的。UI 渲染是被 props 和 state 驱动的，并且能确保步调一致，但副作用并不是这样。这是一类常见问题的来源。</li>\n<li>而在 <code class="language-text">useEffect</code> 的思维模型中，默认都是同步的。副作用变成了 React 数据流的一部分。对于每一个 <code class="language-text">useEffect</code> 调用，一旦你处理正确，你的组件能够更好地处理边缘情况。</li>\n</ul>\n<h1 id="component-源码解读"><a href="#component-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Component 源码解读</h1>\n<p>首先看一下 React.Component 结构</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="19819388250138403000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// ReactBaseClasses.js 文件\n/**\n * Base class helpers for the updating state of a component.\n */\nfunction Component(props, context, updater) {\n  this.props = props; // 属性 props\n  this.context = context; // 上下文 context\n  // If a component has string refs, we will assign a different object later.\n  // 初始化 refs，为 {}，主要在 stringRef 中使用，将 stringRef 节点的实例挂载在 this.refs 上\n  this.refs = emptyObject;\n  // We initialize the default updater but the real one gets injected by the\n  // renderer.\n  this.updater = updater || ReactNoopUpdateQueue; // updater\n}\n\nComponent.prototype.isReactComponent = {};\n\n/**\n * 设置 state 的子集，使用该方法更新 state，避免 state 的值为可突变的状态\n * \\`shouldComponentUpdate\\`只是浅比较更新，\n * 可突变的类型可能导致 \\`shouldComponentUpdate\\` 返回 false，无法重新渲染\n * Immutable.js 可以解决这个问题。它通过结构共享提供不可突变的，持久的集合：\n * 不可突变: 一旦创建，集合就不能在另一个时间点改变。\n * 持久性: 可以使用原始集合和一个突变来创建新的集合。原始集合在新集合创建后仍然可用。\n * 结构共享: 新集合尽可能多的使用原始集合的结构来创建，以便将复制操作降至最少从而提升性能。\n *\n * 并不能保证 \\`this.state\\` 通过 \\`setState\\` 后不可突变的更新，它可能还返回原来的数值\n * 不能保证 \\`setrState\\` 会同步更新 \\`this.state\\`\n * \\`setState\\` 是通过队列形式来更新 state ，当 执行 \\`setState\\` 时，\n * 会把 state 浅合并后放入状态队列，然后批量执行，即它不是立即更新的。\n * 不过，你可以在 callback 回调函数中获取最新的值\n *\n * 注意：对于异步渲染，我们应在 \\`getSnapshotBeforeUpdate\\` 中读取 \\`state\\`、\\`props\\`,\n * 而不是 \\`componentWillUpdate\\`\n *\n * @param {object|function} partialState Next partial state or function to\n *        produce next partial state to be merged with current state.\n * @param {?function} callback Called after state is updated.\n * @final\n * @protected\n */\nComponent.prototype.setState = function(partialState, callback) {\n  // 当 partialState 状态为 object 或 function类型 或 null 时，\n  // 执行 this.updater.enqueueSetState 方法，否则报错\n  invariant(\n    typeof partialState === \'object\' || typeof partialState === \'function\' || partialState == null,\n    \'setState(...): takes an object of state variables to update or a \' +\n      \'function which returns an object of state variables.\'\n  );\n  // 将 \\`setState\\` 事务放入队列中\n  this.updater.enqueueSetState(this, partialState, callback, \'setState\');\n};\n\n/**\n * 强制更新，当且仅当当前不处于 DOM 事物（transaction）中才会被唤起\n * This should only be invoked when it is known with\n * certainty that we are **not** in a DOM transaction.\n *\n * 默认情况下，当组件的state或props改变时，组件将重新渲染。\n * 如果你的\\`render()\\`方法依赖于一些其他的数据，\n * 你可以告诉React组件需要通过调用\\`forceUpdate()\\`重新渲染。\n * 调用\\`forceUpdate()\\`会导致组件跳过 \\`shouldComponentUpdate()\\`,\n * 直接调用 \\`render()\\`。但会调用 \\`componentWillUpdate\\` 和 \\`componentDidUpdate\\`。\n * 这将触发组件的正常生命周期方法,包括每个子组件的 shouldComponentUpdate() 方法。\n * forceUpdate 就是重新 render 。\n * 有些变量不在 state 上，当时你又想达到这个变量更新的时候，刷新 render ；\n * 或者 state 里的某个变量层次太深，更新的时候没有自动触发 render 。\n * 这些时候都可以手动调用 forceUpdate 自动触发 render\n *\n * @param {?function} callback 更新完成后的回调函数.\n * @final\n * @protected\n */\nComponent.prototype.forceUpdate = function(callback) {\n  // updater 强制更新\n  this.updater.enqueueForceUpdate(this, callback, \'forceUpdate\');\n};`, `19819388250138403000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">// ReactBaseClasses.js 文件</span>\n<span class="token comment">/**\n * Base class helpers for the updating state of a component.\n */</span>\n<span class="token keyword">function</span> <span class="token function">Component</span><span class="token punctuation">(</span><span class="token parameter">props<span class="token punctuation">,</span> context<span class="token punctuation">,</span> updater</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>props <span class="token operator">=</span> props<span class="token punctuation">;</span> <span class="token comment">// 属性 props</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>context <span class="token operator">=</span> context<span class="token punctuation">;</span> <span class="token comment">// 上下文 context</span>\n  <span class="token comment">// If a component has string refs, we will assign a different object later.</span>\n  <span class="token comment">// 初始化 refs，为 {}，主要在 stringRef 中使用，将 stringRef 节点的实例挂载在 this.refs 上</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>refs <span class="token operator">=</span> emptyObject<span class="token punctuation">;</span>\n  <span class="token comment">// We initialize the default updater but the real one gets injected by the</span>\n  <span class="token comment">// renderer.</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>updater <span class="token operator">=</span> updater <span class="token operator">||</span> ReactNoopUpdateQueue<span class="token punctuation">;</span> <span class="token comment">// updater</span>\n<span class="token punctuation">}</span>\n\n<span class="token class-name">Component</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>isReactComponent <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n<span class="token comment">/**\n * 设置 state 的子集，使用该方法更新 state，避免 state 的值为可突变的状态\n * `shouldComponentUpdate`只是浅比较更新，\n * 可突变的类型可能导致 `shouldComponentUpdate` 返回 false，无法重新渲染\n * Immutable.js 可以解决这个问题。它通过结构共享提供不可突变的，持久的集合：\n * 不可突变: 一旦创建，集合就不能在另一个时间点改变。\n * 持久性: 可以使用原始集合和一个突变来创建新的集合。原始集合在新集合创建后仍然可用。\n * 结构共享: 新集合尽可能多的使用原始集合的结构来创建，以便将复制操作降至最少从而提升性能。\n *\n * 并不能保证 `this.state` 通过 `setState` 后不可突变的更新，它可能还返回原来的数值\n * 不能保证 `setrState` 会同步更新 `this.state`\n * `setState` 是通过队列形式来更新 state ，当 执行 `setState` 时，\n * 会把 state 浅合并后放入状态队列，然后批量执行，即它不是立即更新的。\n * 不过，你可以在 callback 回调函数中获取最新的值\n *\n * 注意：对于异步渲染，我们应在 `getSnapshotBeforeUpdate` 中读取 `state`、`props`,\n * 而不是 `componentWillUpdate`\n *\n * @param {object|function} partialState Next partial state or function to\n *        produce next partial state to be merged with current state.\n * @param {?function} callback Called after state is updated.\n * @final\n * @protected\n */</span>\n<span class="token class-name">Component</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">setState</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">partialState<span class="token punctuation">,</span> callback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 当 partialState 状态为 object 或 function类型 或 null 时，</span>\n  <span class="token comment">// 执行 this.updater.enqueueSetState 方法，否则报错</span>\n  <span class="token function">invariant</span><span class="token punctuation">(</span>\n    <span class="token keyword">typeof</span> partialState <span class="token operator">===</span> <span class="token string">\'object\'</span> <span class="token operator">||</span> <span class="token keyword">typeof</span> partialState <span class="token operator">===</span> <span class="token string">\'function\'</span> <span class="token operator">||</span> partialState <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">,</span>\n    <span class="token string">\'setState(...): takes an object of state variables to update or a \'</span> <span class="token operator">+</span>\n      <span class="token string">\'function which returns an object of state variables.\'</span>\n  <span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token comment">// 将 `setState` 事务放入队列中</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>updater<span class="token punctuation">.</span><span class="token function">enqueueSetState</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> partialState<span class="token punctuation">,</span> callback<span class="token punctuation">,</span> <span class="token string">\'setState\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n<span class="token comment">/**\n * 强制更新，当且仅当当前不处于 DOM 事物（transaction）中才会被唤起\n * This should only be invoked when it is known with\n * certainty that we are **not** in a DOM transaction.\n *\n * 默认情况下，当组件的state或props改变时，组件将重新渲染。\n * 如果你的`render()`方法依赖于一些其他的数据，\n * 你可以告诉React组件需要通过调用`forceUpdate()`重新渲染。\n * 调用`forceUpdate()`会导致组件跳过 `shouldComponentUpdate()`,\n * 直接调用 `render()`。但会调用 `componentWillUpdate` 和 `componentDidUpdate`。\n * 这将触发组件的正常生命周期方法,包括每个子组件的 shouldComponentUpdate() 方法。\n * forceUpdate 就是重新 render 。\n * 有些变量不在 state 上，当时你又想达到这个变量更新的时候，刷新 render ；\n * 或者 state 里的某个变量层次太深，更新的时候没有自动触发 render 。\n * 这些时候都可以手动调用 forceUpdate 自动触发 render\n *\n * @param {?function} callback 更新完成后的回调函数.\n * @final\n * @protected\n */</span>\n<span class="token class-name">Component</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">forceUpdate</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">callback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// updater 强制更新</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>updater<span class="token punctuation">.</span><span class="token function">enqueueForceUpdate</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> callback<span class="token punctuation">,</span> <span class="token string">\'forceUpdate\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>其中 <code class="language-text">this.refs</code> 值 <code class="language-text">emptyObject</code> 为：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="7392026983440347000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// 设置 refs 初始值为 {}\nconst emptyObject = {};\nif (__DEV__) {\n  Object.freeze(emptyObject); // __DEV__ 模式下， 冻结 emptyObject\n}\n// Object.freeze() 冻结一个对象，被冻结的对象不能被修改（添加，删除，\n// 修改已有属性的可枚举性、可配置性、可写性与属性值，原型）；返回和传入的参数相同的对象。`, `7392026983440347000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">// 设置 refs 初始值为 {}</span>\n<span class="token keyword">const</span> emptyObject <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token keyword">if</span> <span class="token punctuation">(</span>__DEV__<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  Object<span class="token punctuation">.</span><span class="token function">freeze</span><span class="token punctuation">(</span>emptyObject<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// __DEV__ 模式下， 冻结 emptyObject</span>\n<span class="token punctuation">}</span>\n<span class="token comment">// Object.freeze() 冻结一个对象，被冻结的对象不能被修改（添加，删除，</span>\n<span class="token comment">// 修改已有属性的可枚举性、可配置性、可写性与属性值，原型）；返回和传入的参数相同的对象。</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p><code class="language-text">ReactNoopUpdateQueue</code> 为：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="61955371474495860000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// ReactNoopUpdateQueue.js 文件\n/**\n * 这是一个关于 更新队列(update queue) 的抽象 API\n */\nconst ReactNoopUpdateQueue = {\n  /**\n   * 检查复合组件是否装载完成（被插入树中）\n   * @param {ReactClass} publicInstance 测试实例单元\n   * @return {boolean} 装载完成为 true，否则为 false\n   * @protected\n   * @final\n   */\n  isMounted: function(publicInstance) {\n    return false;\n  },\n\n  /**\n   * 强制更新队列，当且仅当当前不处于 DOM 事物（transaction）中才会被唤起\n   *\n   * 当 state 里的某个变量层次太深，更新的时候没有自动触发 render 。\n   * 这些时候就可以调用该方法强制更新队列\n   *\n   * 该方法将跳过 \\`shouldComponentUpdate()\\`, 直接调用 \\`render()\\`, 但它会唤起\n   * \\`componentWillUpdate\\` 和 \\`componentDidUpdate\\`.\n   *\n   * @param {ReactClass} publicInstance 将被重新渲染的实例\n   * @param {?function} callback 组件更新后的回调函数.\n   * @param {?string} callerName 在公共 API 调用该方法的函数名称.\n   * @internal\n   */\n  enqueueForceUpdate: function(publicInstance, callback, callerName) {\n    warnNoop(publicInstance, \'forceUpdate\');\n  },\n\n  /**\n   * 完全替换state，与 \\`setState\\` 不同的是，\\`setState\\` 是以修改和新增的方式改变 \\`state \\`的，\n   * 不会改变没有涉及到的 \\`state\\`。\n   * 而 \\`enqueueReplaceState\\` 则用新的 \\`state\\` 完全替换掉老 \\`state\\`\n   * 使用它或 \\`setState\\` 来改变 state，并且应该把 this.state 设置为不可突变类型对象，\n   * 并且this.state不会立即更改\n   * 我们应该在回调函数 callback 中获取最新的 state\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} completeState Next state.\n   * @param {?function} callback Called after component is updated.\n   * @param {?string} callerName name of the calling function in the public API.\n   * @internal\n   */\n  enqueueReplaceState: function(publicInstance, completeState, callback, callerName) {\n    warnNoop(publicInstance, \'replaceState\');\n  },\n\n  /**\n   * 设置 state 的子集\n   * 它存在的唯一理由是 _pendingState 是内部方法。\n   * \\`enqueueSetState\\` 实现浅合并更新 \\`state\\`\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} partialState Next partial state to be merged with state.\n   * @param {?function} callback Called after component is updated.\n   * @param {?string} Name of the calling function in the public API.\n   * @internal\n   */\n  enqueueSetState: function(publicInstance, partialState, callback, callerName) {\n    warnNoop(publicInstance, \'setState\');\n  }\n};\n\nexport default ReactNoopUpdateQueue;`, `61955371474495860000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">// ReactNoopUpdateQueue.js 文件</span>\n<span class="token comment">/**\n * 这是一个关于 更新队列(update queue) 的抽象 API\n */</span>\n<span class="token keyword">const</span> ReactNoopUpdateQueue <span class="token operator">=</span> <span class="token punctuation">{</span>\n  <span class="token comment">/**\n   * 检查复合组件是否装载完成（被插入树中）\n   * @param {ReactClass} publicInstance 测试实例单元\n   * @return {boolean} 装载完成为 true，否则为 false\n   * @protected\n   * @final\n   */</span>\n  <span class="token function-variable function">isMounted</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">publicInstance</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n\n  <span class="token comment">/**\n   * 强制更新队列，当且仅当当前不处于 DOM 事物（transaction）中才会被唤起\n   *\n   * 当 state 里的某个变量层次太深，更新的时候没有自动触发 render 。\n   * 这些时候就可以调用该方法强制更新队列\n   *\n   * 该方法将跳过 `shouldComponentUpdate()`, 直接调用 `render()`, 但它会唤起\n   * `componentWillUpdate` 和 `componentDidUpdate`.\n   *\n   * @param {ReactClass} publicInstance 将被重新渲染的实例\n   * @param {?function} callback 组件更新后的回调函数.\n   * @param {?string} callerName 在公共 API 调用该方法的函数名称.\n   * @internal\n   */</span>\n  <span class="token function-variable function">enqueueForceUpdate</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">publicInstance<span class="token punctuation">,</span> callback<span class="token punctuation">,</span> callerName</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token function">warnNoop</span><span class="token punctuation">(</span>publicInstance<span class="token punctuation">,</span> <span class="token string">\'forceUpdate\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n\n  <span class="token comment">/**\n   * 完全替换state，与 `setState` 不同的是，`setState` 是以修改和新增的方式改变 `state `的，\n   * 不会改变没有涉及到的 `state`。\n   * 而 `enqueueReplaceState` 则用新的 `state` 完全替换掉老 `state`\n   * 使用它或 `setState` 来改变 state，并且应该把 this.state 设置为不可突变类型对象，\n   * 并且this.state不会立即更改\n   * 我们应该在回调函数 callback 中获取最新的 state\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} completeState Next state.\n   * @param {?function} callback Called after component is updated.\n   * @param {?string} callerName name of the calling function in the public API.\n   * @internal\n   */</span>\n  <span class="token function-variable function">enqueueReplaceState</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">publicInstance<span class="token punctuation">,</span> completeState<span class="token punctuation">,</span> callback<span class="token punctuation">,</span> callerName</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token function">warnNoop</span><span class="token punctuation">(</span>publicInstance<span class="token punctuation">,</span> <span class="token string">\'replaceState\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n\n  <span class="token comment">/**\n   * 设置 state 的子集\n   * 它存在的唯一理由是 _pendingState 是内部方法。\n   * `enqueueSetState` 实现浅合并更新 `state`\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} partialState Next partial state to be merged with state.\n   * @param {?function} callback Called after component is updated.\n   * @param {?string} Name of the calling function in the public API.\n   * @internal\n   */</span>\n  <span class="token function-variable function">enqueueSetState</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">publicInstance<span class="token punctuation">,</span> partialState<span class="token punctuation">,</span> callback<span class="token punctuation">,</span> callerName</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token function">warnNoop</span><span class="token punctuation">(</span>publicInstance<span class="token punctuation">,</span> <span class="token string">\'setState\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n<span class="token keyword">export</span> <span class="token keyword">default</span> ReactNoopUpdateQueue<span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>注意，React API 只是简单的功能介绍，具体的实现是在 react-dom 中，这是因为不同的平台，React API 是一致的，但不同的平台，渲染的流程是不同的，具体的 Component 渲染流程不一致，会根据具体的平台去定制。</p>\n<p>组件生命周期请参考 <a href="https://github.com/sisterAn/blog/issues/34" target="_blank" rel="nofollow noreferrer noopener">Hooks 与 React 生命周期的关系</a></p>',
id:"/github/workspace/blog/React之Component入门学习/index.md absPath of file >>> MarkdownRemark",timeToRead:10,frontmatter:{date:"2019-09-19 21:32:42",path:"/react-component-practice-learn/",tags:"前端, React, PureComponent",title:"React之Component入门学习",draft:null}},{excerpt:"PureComponent  最早在 React v15.3 版本中发布，主要是为了优化 React 应用而产生。 在这段代码中，   会浅比较   或   是否改变，来决定是否重新渲染组件。 实现  和   类似，都是定义一个组件类。不同是   没有实现  ，而   通过 props 和 state 的  浅比较  实现了。 使用场景 当   的 props 和 state 均为基本类型，使用   会节省应用的性能 可能出现的问题及解决方案 当 props 或 state…",html:'<h1 id="purecomponent"><a href="#purecomponent" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>PureComponent</h1>\n<p><code class="language-text">PureComponent</code> 最早在 React v15.3 版本中发布，主要是为了优化 React 应用而产生。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="98418108118836120000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`class Counter extends React.PureComponent {\n  constructor(props) {\n    super(props);\n    this.state = { count: 1 };\n  }\n\n  render() {\n    return (\n      <button color={this.props.color} onClick={() => this.setState((state) => ({ count: state.count + 1 }))}>\n        Count: {this.state.count}\n      </button>\n    );\n  }\n}`, `98418108118836120000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">Counter</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>PureComponent</span> <span class="token punctuation">{</span>\n  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span> count<span class="token punctuation">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token punctuation">(</span>\n      <span class="token operator">&lt;</span>button color<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>color<span class="token punctuation">}</span> onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">state</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span> count<span class="token punctuation">:</span> state<span class="token punctuation">.</span>count <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">></span>\n        Count<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>count<span class="token punctuation">}</span>\n      <span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span>\n    <span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>在这段代码中， <code class="language-text">React.PureComponent</code> 会浅比较 <code class="language-text">props.color</code> 或 <code class="language-text">state.count</code> 是否改变，来决定是否重新渲染组件。</p>\n<ul>\n<li>\n<p><strong>实现</strong></p>\n<p><code class="language-text">React.PureComponent</code> 和 <code class="language-text">React.Component</code> 类似，都是定义一个组件类。不同是 <code class="language-text">React.Component</code> 没有实现 <code class="language-text">shouldComponentUpdate()</code>，而 <code class="language-text">React.PureComponent</code> 通过 props 和 state 的 <strong>浅比较</strong> 实现了。</p>\n</li>\n<li>\n<p><strong>使用场景</strong></p>\n<p>当 <code class="language-text">React.Component</code> 的 props 和 state 均为基本类型，使用 <code class="language-text">React.PureComponent</code> 会节省应用的性能</p>\n</li>\n<li>\n<p><strong>可能出现的问题及解决方案</strong></p>\n<p>当 props 或 state 为 <strong>复杂的数据结构</strong> （例如：嵌套对象和数组）时，因为 <code class="language-text">React.PureComponent</code> 仅仅是 <strong>浅比较</strong> ，可能会渲染出 <strong>错误的结果</strong> 。这时有 <strong>两种解决方案</strong> ：</p>\n<ul>\n<li>当 <strong>知道</strong> 有深度数据结构更新时，可以直接调用 <strong>forceUpdate</strong> 强制更新</li>\n<li>考虑使用 <a href="https://facebook.github.io/immutable-js/" target="_blank" rel="nofollow noreferrer noopener">immutable objects</a> （不可突变的对象），实现快速的比较对象</li>\n</ul>\n</li>\n<li>\n<p><strong>注意</strong></p>\n<p><code class="language-text">React.PureComponent</code> 中的 <code class="language-text">shouldComponentUpdate()</code> 将跳过所有子组件树的 props 更新（具体原因参考 <a href="https://github.com/sisterAn/blog/issues/34" target="_blank" rel="nofollow noreferrer noopener">Hooks 与 React 生命周期</a>：即：更新阶段，由父至子去判断是否需要重新渲染），所以使用 React.PureComponent 的组件，它的所有 <strong>子组件也必须都为 React.PureComponent</strong> 。</p>\n</li>\n</ul>\n<h1 id="purecomponent-与-stateless-functional-component"><a href="#purecomponent-%E4%B8%8E-stateless-functional-component" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>PureComponent 与 Stateless Functional Component</h1>\n<p>对于 React 开发人员来说，知道何时在代码中使用 <strong>Component</strong>，<strong>PureComponent ** 和 **Stateless Functional Component</strong> 非常重要。</p>\n<p>首先，让我们看一下无状态组件。</p>\n<h2 id="无状态组件"><a href="#%E6%97%A0%E7%8A%B6%E6%80%81%E7%BB%84%E4%BB%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>无状态组件</h2>\n<p>输入输出数据完全由 <code class="language-text">props</code> 决定，而且不会产生任何副作用。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="85316676051286100000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`const Button = (props) => <button onClick={props.onClick}>{props.text}</button>;`, `85316676051286100000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">const</span> <span class="token function-variable function">Button</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span>props<span class="token punctuation">.</span>onClick<span class="token punctuation">}</span><span class="token operator">></span><span class="token punctuation">{</span>props<span class="token punctuation">.</span>text<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>无状态组件可以通过减少继承 <code class="language-text">Component</code> 而来的生命周期函数而达到性能优化的效果。从本质上来说，无状态组件就是一个单纯的 <code class="language-text">render</code> 函数，所以无状态组件的缺点也是显而易见的。因为它没有 <code class="language-text">shouldComponentUpdate</code> 生命周期函数，所以每次 <code class="language-text">state</code> 更新，它都会重新绘制 <code class="language-text">render</code> 函数。</p>\n<p>React 16.8 之后，React 引入 Hooks 。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。</p>\n<h2 id="何时使用-purecomponent？"><a href="#%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8-purecomponent%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>何时使用 <code class="language-text">PureComponent</code>？</h2>\n<p><code class="language-text">PureComponent</code> 提高了性能，因为它减少了应用程序中的渲染操作次数，这对于复杂的 UI 来说是一个巨大的胜利，因此建议尽可能使用。此外，还有一些情况需要使用 <code class="language-text">Component</code> 的生命周期方法，在这种情况下，我们不能使用无状态组件。</p>\n<h2 id="何时使用无状态组件？"><a href="#%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8%E6%97%A0%E7%8A%B6%E6%80%81%E7%BB%84%E4%BB%B6%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>何时使用无状态组件？</h2>\n<p>无状态组件易于实施且快速实施。它们适用于非常小的 UI 视图，其中重新渲染成本无关紧要。它们提供更清晰的代码和更少的文件来处理。</p>\n<h1 id="purecomponent-与-reactmemo"><a href="#purecomponent-%E4%B8%8E-reactmemo" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>PureComponent 与 React.memo</h1>\n<p><code class="language-text">React.memo</code> 为高阶组件。它实现的效果与 <code class="language-text">React.PureComponent</code> 相似，不同的是：</p>\n<ul>\n<li><code class="language-text">React.memo</code> 用于函数组件</li>\n<li><code class="language-text">React.PureComponent</code> 适用于 class 组件</li>\n<li><code class="language-text">React.PureComponent</code> 只是浅比较 <code class="language-text">props</code>、<code class="language-text">state</code>，<code class="language-text">React.memo</code> 也是浅比较，但它可以自定义比较函数</li>\n</ul>\n<h2 id="reactmemo"><a href="#reactmemo" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>React.memo</h2>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="90937950304414740000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function MyComponent(props) {\n  /* 使用 props 渲染 */\n}\n\n// 比较函数\nfunction areEqual(prevProps, nextProps) {\n  /*\n  如果把 nextProps 传入 render 方法的返回结果与\n  将 prevProps 传入 render 方法的返回结果一致则返回 true，\n  否则返回 false\n  返回 true，复用最近一次渲染\n  返回 false，重新渲染\n  */\n}\n\nexport default React.memo(MyComponent, areEqual);`, `90937950304414740000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span> <span class="token function">MyComponent</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">/* 使用 props 渲染 */</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// 比较函数</span>\n<span class="token keyword">function</span> <span class="token function">areEqual</span><span class="token punctuation">(</span><span class="token parameter">prevProps<span class="token punctuation">,</span> nextProps</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">/*\n  如果把 nextProps 传入 render 方法的返回结果与\n  将 prevProps 传入 render 方法的返回结果一致则返回 true，\n  否则返回 false\n  返回 true，复用最近一次渲染\n  返回 false，重新渲染\n  */</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">export</span> <span class="token keyword">default</span> React<span class="token punctuation">.</span><span class="token function">memo</span><span class="token punctuation">(</span>MyComponent<span class="token punctuation">,</span> areEqual<span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<ul>\n<li><code class="language-text">React.memo</code> 通过记忆组件渲染结果的方式实现 ，提高组件的性能</li>\n<li>只会对 <code class="language-text">props</code> 浅比较，如果相同，React 将跳过渲染组件的操作并直接复用最近一次渲染的结果。</li>\n<li>可以将自定义的比较函数作为第二个参数，实现自定义比较</li>\n<li>此方法仅作为<strong>性能优化</strong>的方式而存在。但请不要依赖它来“阻止”渲染，这会产生 bug。</li>\n<li>与 class 组件中 <code class="language-text">shouldComponentUpdate()</code> 方法不同的是，如果 props 相等，<code class="language-text">areEqual</code>会返回 <code class="language-text">true</code>；如果 props 不相等，则返回 <code class="language-text">false</code>。这与 <code class="language-text">shouldComponentUpdate</code> 方法的返回值相反。</li>\n</ul>\n<h1 id="使用-purecomponent-常见误区"><a href="#%E4%BD%BF%E7%94%A8-purecomponent-%E5%B8%B8%E8%A7%81%E8%AF%AF%E5%8C%BA" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>使用 PureComponent 常见误区</h1>\n<h2 id="误区一：在渲染方法中创建函数"><a href="#%E8%AF%AF%E5%8C%BA%E4%B8%80%EF%BC%9A%E5%9C%A8%E6%B8%B2%E6%9F%93%E6%96%B9%E6%B3%95%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%87%BD%E6%95%B0" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>误区一：在渲染方法中创建函数</h2>\n<p>如果你在 <code class="language-text">render</code> 方法里创建函数，那么使用 <code class="language-text">props</code> 会抵消使用 <code class="language-text">React.PureComponent</code> 带来的优势。因为每次渲染运行时，都会分配一个新函数，如果你有子组件，即使数据没有改变，它们也会重新渲染，因为浅比较 <code class="language-text">props</code> 的时候总会得到 <code class="language-text">false</code>。</p>\n<p>例如：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="10384369688064066000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// FriendsItem 在父组件引用样式\n<FriendsItem key={friend.id} name={friend.name} id={friend.id} onDeleteClick={() => this.deleteFriends(friend.id)} />\n// 在父组件中绑定\n// 父组件在 props 中传递了一个箭头函数。箭头函数在每次 render 时都会重新分配（和使用 bind 的方式相同）`, `10384369688064066000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">// FriendsItem 在父组件引用样式</span>\n<span class="token operator">&lt;</span>FriendsItem key<span class="token operator">=</span><span class="token punctuation">{</span>friend<span class="token punctuation">.</span>id<span class="token punctuation">}</span> name<span class="token operator">=</span><span class="token punctuation">{</span>friend<span class="token punctuation">.</span>name<span class="token punctuation">}</span> id<span class="token operator">=</span><span class="token punctuation">{</span>friend<span class="token punctuation">.</span>id<span class="token punctuation">}</span> onDeleteClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">deleteFriends</span><span class="token punctuation">(</span>friend<span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span>\n<span class="token comment">// 在父组件中绑定</span>\n<span class="token comment">// 父组件在 props 中传递了一个箭头函数。箭头函数在每次 render 时都会重新分配（和使用 bind 的方式相同）</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>其中，<code class="language-text">FriendsItem</code> 为 <code class="language-text">PureComponent</code>：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="28030940281118876000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// 其中 FriendsItem 为 PureComponent\nclass FriendsItem extends React.PureComponent {\n  render() {\n    const { name, onDeleteClick } = this.props;\n    console.log(\\`FriendsItem：\\${name} 渲染\\`);\n    return (\n      <div>\n        <span>{name}</span>\n        <button onClick={onDeleteClick}>删除</button>\n      </div>\n    );\n  }\n}\n// 每次点击删除操作时，未删除的 FriendsItem 都将被重新渲染`, `28030940281118876000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">// 其中 FriendsItem 为 PureComponent</span>\n<span class="token keyword">class</span> <span class="token class-name">FriendsItem</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>PureComponent</span> <span class="token punctuation">{</span>\n  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">const</span> <span class="token punctuation">{</span> name<span class="token punctuation">,</span> onDeleteClick <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">;</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">FriendsItem：</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> 渲染</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">return</span> <span class="token punctuation">(</span>\n      <span class="token operator">&lt;</span>div<span class="token operator">></span>\n        <span class="token operator">&lt;</span>span<span class="token operator">></span><span class="token punctuation">{</span>name<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>span<span class="token operator">></span>\n        <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span>onDeleteClick<span class="token punctuation">}</span><span class="token operator">></span>删除<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span>\n      <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>\n    <span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n<span class="token comment">// 每次点击删除操作时，未删除的 FriendsItem 都将被重新渲染</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p><a href="https://stackblitz.com/edit/react-ta6tww" target="_blank" rel="nofollow noreferrer noopener">点击查看在线实例</a></p>\n<p>这种在 <code class="language-text">FriendsItem</code> 直接调用 <code class="language-text">() =&gt; this.deleteFriends(friend.id)</code>，看起来操作更简单，逻辑更清晰，但它有一个有一个最大的弊端，甚至打破了像 <code class="language-text">shouldComponentUpdate</code> 和 <code class="language-text">PureComponent</code> 这样的性能优化。</p>\n<p>这是因为：父组件在 <code class="language-text">render</code> 声明了一个函数<code class="language-text">onDeleteClick</code>，每次父组件渲染都会重新生成新的函数。因此，每次父组件重新渲染，都会给每个子组件 <code class="language-text">FriendsItem</code> 传递不同的 <code class="language-text">props</code>，导致每个子组件都会重新渲染， 即使 <code class="language-text">FriendsItem</code> 为 <code class="language-text">PureComponent</code>。</p>\n<p><strong>避免在 render 方法里创建函数并使用它。它会打破了像 shouldComponentUpdate 和 PureComponent 这样的性能优化。</strong></p>\n<p>要解决这个问题，只需要将原本在父组件上的绑定放到子组件上即可。<code class="language-text">FriendsItem</code> 将始终具有相同的 <code class="language-text">props</code>，并且永远不会导致不必要的重新渲染。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="60677988240068490000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// FriendsItem 在父组件引用样式\n<FriendsItem key={friend.id} id={friend.id} name={friend.name} onClick={this.deleteFriends} />`, `60677988240068490000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">// FriendsItem 在父组件引用样式</span>\n<span class="token operator">&lt;</span>FriendsItem key<span class="token operator">=</span><span class="token punctuation">{</span>friend<span class="token punctuation">.</span>id<span class="token punctuation">}</span> id<span class="token operator">=</span><span class="token punctuation">{</span>friend<span class="token punctuation">.</span>id<span class="token punctuation">}</span> name<span class="token operator">=</span><span class="token punctuation">{</span>friend<span class="token punctuation">.</span>name<span class="token punctuation">}</span> onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>deleteFriends<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span></span></pre></div>\n<p><code class="language-text">FriendsItem</code>:</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="59425071380621960000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`class FriendsItem extends React.PureComponent {\n  onDeleteClick = () => {\n    this.props.onClick(this.props.id);\n  }; // 在子组件中绑定\n  render() {\n    const { name } = this.props;\n    console.log(\\`FriendsItem：\\${name} 渲染\\`);\n    return (\n      <div>\n        <span>{name}</span>\n        <button onClick={this.onDeleteClick}>删除</button>\n      </div>\n    );\n  }\n}\n// 每次点击删除操作时，FriendsItem 都不会被重新渲染`, `59425071380621960000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">FriendsItem</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>PureComponent</span> <span class="token punctuation">{</span>\n  <span class="token function-variable function">onDeleteClick</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span><span class="token function">onClick</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 在子组件中绑定</span>\n  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">const</span> <span class="token punctuation">{</span> name <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">;</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">FriendsItem：</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> 渲染</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">return</span> <span class="token punctuation">(</span>\n      <span class="token operator">&lt;</span>div<span class="token operator">></span>\n        <span class="token operator">&lt;</span>span<span class="token operator">></span><span class="token punctuation">{</span>name<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>span<span class="token operator">></span>\n        <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>onDeleteClick<span class="token punctuation">}</span><span class="token operator">></span>删除<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span>\n      <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>\n    <span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n<span class="token comment">// 每次点击删除操作时，FriendsItem 都不会被重新渲染</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p><a href="https://stackblitz.com/edit/react-sr5yvp" target="_blank" rel="nofollow noreferrer noopener">点击查看在线实例</a></p>\n<p>通过此更改，当单击删除操作时，其他 <code class="language-text">FriendsItem</code> 都不会被重新渲染了 👍</p>\n<h2 id="误区二：在渲染方法中派生-state"><a href="#%E8%AF%AF%E5%8C%BA%E4%BA%8C%EF%BC%9A%E5%9C%A8%E6%B8%B2%E6%9F%93%E6%96%B9%E6%B3%95%E4%B8%AD%E6%B4%BE%E7%94%9F-state" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>误区二：在渲染方法中派生 state</h2>\n<p>考虑一个文章列表，您的个人资料组件将从中显示用户最喜欢的 10 个作品。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="88520859309117880000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`render() {\n  const { posts } = this.props\n  // 在渲染函数中生成 topTen，并渲染\n  const topTen = [...posts].sort((a, b) =>\n    b.likes - a.likes).slice(0, 9)\n  return //...\n}\n// 这会导致组件每次重新渲染，都会生成新的 topTen，导致不必要的渲染`, `88520859309117880000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> <span class="token punctuation">{</span> posts <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props\n  <span class="token comment">// 在渲染函数中生成 topTen，并渲染</span>\n  <span class="token keyword">const</span> topTen <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>posts<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token operator">=></span>\n    b<span class="token punctuation">.</span>likes <span class="token operator">-</span> a<span class="token punctuation">.</span>likes<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">)</span>\n  <span class="token keyword">return</span> <span class="token comment">//...</span>\n<span class="token punctuation">}</span>\n<span class="token comment">// 这会导致组件每次重新渲染，都会生成新的 topTen，导致不必要的渲染</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p><code class="language-text">topTen</code>每次组件重新渲染时都会有一个全新的引用，即使 <code class="language-text">posts</code> 没有更改，派生 <code class="language-text">state</code> 也是相同的。</p>\n<p>这个时候，我们应该将 <code class="language-text">topTen</code> 的判断逻辑提取到 <code class="language-text">render</code> 函数之外，通过缓存派生 <code class="language-text">state</code> 来解决此问题。</p>\n<p>例如，在组件的状态中设置派生 <code class="language-text">state</code>，并仅在 <code class="language-text">posts</code> 已更新时更新。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="55051347794643910000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`componentWillMount() {\n  this.setTopTenPosts(this.props.posts)\n}\ncomponentWillReceiveProps(nextProps) {\n  if (this.props.posts !== nextProps.posts) {\n    this.setTopTenPosts(nextProps.posts)\n  }\n}\n// 每次 posts 更新时，更新派生 state，而不是在渲染函数中重新生成\nsetTopTenPosts(posts) {\n  this.setState({\n    topTen: [...posts].sort((a, b) => b.likes - a.likes).slice(0, 9)\n  })\n}`, `55051347794643910000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token function">componentWillMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setTopTenPosts</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>posts<span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n<span class="token function">componentWillReceiveProps</span><span class="token punctuation">(</span><span class="token parameter">nextProps</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>posts <span class="token operator">!==</span> nextProps<span class="token punctuation">.</span>posts<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setTopTenPosts</span><span class="token punctuation">(</span>nextProps<span class="token punctuation">.</span>posts<span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n<span class="token comment">// 每次 posts 更新时，更新派生 state，而不是在渲染函数中重新生成</span>\n<span class="token function">setTopTenPosts</span><span class="token punctuation">(</span><span class="token parameter">posts</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n    topTen<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token operator">...</span>posts<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token operator">=></span> b<span class="token punctuation">.</span>likes <span class="token operator">-</span> a<span class="token punctuation">.</span>likes<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h2 id="总结"><a href="#%E6%80%BB%E7%BB%93" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总结</h2>\n<p>在使用 <code class="language-text">PureComponent</code> 时，请注意：</p>\n<ul>\n<li>突变一般是不好的，但在使用 <code class="language-text">PureComponent</code> 时，问题会更加复杂。</li>\n<li>不要在渲染方法中创建新函数、对象或数组，这会导致项目性能显著降低。</li>\n</ul>\n<h1 id="purecomponent-源码解析"><a href="#purecomponent-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>PureComponent 源码解析</h1>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="28406910491833283000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// 新建了空方法ComponentDummy ，ComponentDummy 的原型 指向 Component 的原型;\nfunction ComponentDummy() {}\nComponentDummy.prototype = Component.prototype;\n\n/**\n * Convenience component with default shallow equality check for sCU.\n */\nfunction PureComponent(props, context, updater) {\n  this.props = props;\n  this.context = context;\n  // If a component has string refs, we will assign a different object later.\n  this.refs = emptyObject;\n  this.updater = updater || ReactNoopUpdateQueue;\n} // 解析同 React.Component，详细请看上一章\n\n/**\n * 实现 React.PureComponent 对 React.Component 的原型继承\n */\n/**\n * 用 ComponentDummy 的原因是为了不直接实例化一个 Component 实例，可以减少一些内存使用\n *\n * 因为，我们这里只需要继承 React.Component 的 原型，直接 PureComponent.prototype = new Component() 的话\n * 会继承包括 constructor 在内的其他 Component 属性方法，但是 PureComponent 已经有自己的 constructor 了，\n * 再继承的话，造成不必要的内存消耗\n * 所以会新建ComponentDummy，只继承Component的原型，不包括constructor，以此来节省内存。\n */\nconst pureComponentPrototype = (PureComponent.prototype = new ComponentDummy());\n\n// 修复 pureComponentPrototype 构造函数指向\npureComponentPrototype.constructor = PureComponent;\n\n// Avoid an extra prototype jump for these methods.\n// 虽然上面两句已经让PureComponent继承了Component\n// 但多加一个 Object.assign()，能有效的避免多一次原型链查找\nObject.assign(pureComponentPrototype, Component.prototype);\n\n// 唯一的区别，原型上添加了 isPureReactComponent 属性去表示该 Component 是 PureComponent\n// 在后续组件渲染的时候，react-dom 会去判断 isPureReactComponent 这个属性，来确定是否浅比较 props、status 实现更新\n/** 在 ReactFiberClassComponent.js 中，有对 isPureReactComponent 的判断\n if (ctor.prototype && ctor.prototype.isPureReactComponent) {\n    return (\n      !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState)\n    );\n  }\n */\npureComponentPrototype.isPureReactComponent = true;`, `28406910491833283000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">// 新建了空方法ComponentDummy ，ComponentDummy 的原型 指向 Component 的原型;</span>\n<span class="token keyword">function</span> <span class="token function">ComponentDummy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n<span class="token class-name">ComponentDummy</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token class-name">Component</span><span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>\n\n<span class="token comment">/**\n * Convenience component with default shallow equality check for sCU.\n */</span>\n<span class="token keyword">function</span> <span class="token function">PureComponent</span><span class="token punctuation">(</span><span class="token parameter">props<span class="token punctuation">,</span> context<span class="token punctuation">,</span> updater</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>props <span class="token operator">=</span> props<span class="token punctuation">;</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>context <span class="token operator">=</span> context<span class="token punctuation">;</span>\n  <span class="token comment">// If a component has string refs, we will assign a different object later.</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>refs <span class="token operator">=</span> emptyObject<span class="token punctuation">;</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>updater <span class="token operator">=</span> updater <span class="token operator">||</span> ReactNoopUpdateQueue<span class="token punctuation">;</span>\n<span class="token punctuation">}</span> <span class="token comment">// 解析同 React.Component，详细请看上一章</span>\n\n<span class="token comment">/**\n * 实现 React.PureComponent 对 React.Component 的原型继承\n */</span>\n<span class="token comment">/**\n * 用 ComponentDummy 的原因是为了不直接实例化一个 Component 实例，可以减少一些内存使用\n *\n * 因为，我们这里只需要继承 React.Component 的 原型，直接 PureComponent.prototype = new Component() 的话\n * 会继承包括 constructor 在内的其他 Component 属性方法，但是 PureComponent 已经有自己的 constructor 了，\n * 再继承的话，造成不必要的内存消耗\n * 所以会新建ComponentDummy，只继承Component的原型，不包括constructor，以此来节省内存。\n */</span>\n<span class="token keyword">const</span> pureComponentPrototype <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">PureComponent</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ComponentDummy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token comment">// 修复 pureComponentPrototype 构造函数指向</span>\npureComponentPrototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> PureComponent<span class="token punctuation">;</span>\n\n<span class="token comment">// Avoid an extra prototype jump for these methods.</span>\n<span class="token comment">// 虽然上面两句已经让PureComponent继承了Component</span>\n<span class="token comment">// 但多加一个 Object.assign()，能有效的避免多一次原型链查找</span>\nObject<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span>pureComponentPrototype<span class="token punctuation">,</span> <span class="token class-name">Component</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token comment">// 唯一的区别，原型上添加了 isPureReactComponent 属性去表示该 Component 是 PureComponent</span>\n<span class="token comment">// 在后续组件渲染的时候，react-dom 会去判断 isPureReactComponent 这个属性，来确定是否浅比较 props、status 实现更新</span>\n<span class="token comment">/** 在 ReactFiberClassComponent.js 中，有对 isPureReactComponent 的判断\n if (ctor.prototype &amp;&amp; ctor.prototype.isPureReactComponent) {\n    return (\n      !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState)\n    );\n  }\n */</span>\npureComponentPrototype<span class="token punctuation">.</span>isPureReactComponent <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>这里只是 <code class="language-text">PureComponent</code> 的声明创建，至于如何实现 <code class="language-text">shouldComponentUpdate()</code> ，核心代码在：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="33455974715666637000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// ReactFiberClassComponent.js\nfunction checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext) {\n  // ...\n  if (ctor.prototype && ctor.prototype.isPureReactComponent) {\n    // 如果是纯组件，比较新老 props、state\n    // 返回 true，重新渲染，\n    // 即 shallowEqual props 返回 false，或 shallowEqual state 返回 false\n    return !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState);\n  }\n  return true;\n}`, `33455974715666637000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">// ReactFiberClassComponent.js</span>\n<span class="token keyword">function</span> <span class="token function">checkShouldComponentUpdate</span><span class="token punctuation">(</span><span class="token parameter">workInProgress<span class="token punctuation">,</span> ctor<span class="token punctuation">,</span> oldProps<span class="token punctuation">,</span> newProps<span class="token punctuation">,</span> oldState<span class="token punctuation">,</span> newState<span class="token punctuation">,</span> nextContext</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// ...</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>ctor<span class="token punctuation">.</span>prototype <span class="token operator">&amp;&amp;</span> ctor<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>isPureReactComponent<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 如果是纯组件，比较新老 props、state</span>\n    <span class="token comment">// 返回 true，重新渲染，</span>\n    <span class="token comment">// 即 shallowEqual props 返回 false，或 shallowEqual state 返回 false</span>\n    <span class="token keyword">return</span> <span class="token operator">!</span><span class="token function">shallowEqual</span><span class="token punctuation">(</span>oldProps<span class="token punctuation">,</span> newProps<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">shallowEqual</span><span class="token punctuation">(</span>oldState<span class="token punctuation">,</span> newState<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p><strong>shallowEqual.js</strong></p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="25716812241001705000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`/**\n * 通过遍历对象上的键并返回 false 来执行相等性\n * 在参数列表中，当任意键对应的值不严格相等时，返回 false。\n * 当所有键的值严格相等时,返回 true。\n */\nfunction shallowEqual(objA: mixed, objB: mixed): boolean {\n  // 通过 Object.is 判断 objA、objB 是否相等\n  if (is(objA, objB)) {\n    return true;\n  }\n\n  if (typeof objA !== \'object\' || objA === null || typeof objB !== \'object\' || objB === null) {\n    return false;\n  }\n\n  // 参数列表\n  const keysA = Object.keys(objA);\n  const keysB = Object.keys(objB);\n\n  // 参数列表长度不相同\n  if (keysA.length !== keysB.length) {\n    return false;\n  }\n\n  // 比较参数列表每一个参数，但仅比较一层\n  for (let i = 0; i < keysA.length; i++) {\n    if (!hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {\n      return false;\n    }\n  }\n\n  return true;\n}`, `25716812241001705000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">/**\n * 通过遍历对象上的键并返回 false 来执行相等性\n * 在参数列表中，当任意键对应的值不严格相等时，返回 false。\n * 当所有键的值严格相等时,返回 true。\n */</span>\n<span class="token keyword">function</span> <span class="token function">shallowEqual</span><span class="token punctuation">(</span><span class="token parameter">objA<span class="token punctuation">:</span> mixed<span class="token punctuation">,</span> objB<span class="token punctuation">:</span> mixed</span><span class="token punctuation">)</span><span class="token punctuation">:</span> boolean <span class="token punctuation">{</span>\n  <span class="token comment">// 通过 Object.is 判断 objA、objB 是否相等</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">is</span><span class="token punctuation">(</span>objA<span class="token punctuation">,</span> objB<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> objA <span class="token operator">!==</span> <span class="token string">\'object\'</span> <span class="token operator">||</span> objA <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token keyword">typeof</span> objB <span class="token operator">!==</span> <span class="token string">\'object\'</span> <span class="token operator">||</span> objB <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token comment">// 参数列表</span>\n  <span class="token keyword">const</span> keysA <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>objA<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">const</span> keysB <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>objB<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token comment">// 参数列表长度不相同</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>keysA<span class="token punctuation">.</span>length <span class="token operator">!==</span> keysB<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token comment">// 比较参数列表每一个参数，但仅比较一层</span>\n  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> keysA<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">hasOwnProperty</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>objB<span class="token punctuation">,</span> keysA<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">is</span><span class="token punctuation">(</span>objA<span class="token punctuation">[</span>keysA<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> objB<span class="token punctuation">[</span>keysA<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h2 id="附：objectis（来自-mdn）"><a href="#%E9%99%84%EF%BC%9Aobjectis%EF%BC%88%E6%9D%A5%E8%87%AA-mdn%EF%BC%89" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>附：Object.is（来自 MDN）</h2>\n<p><code class="language-text">Object.is()</code> 判断两个值是否<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Equality_comparisons_and_sameness" target="_blank" rel="nofollow noreferrer noopener">相同</a>。</p>\n<p>这种相等性判断逻辑和传统的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Equality" target="_blank" rel="nofollow noreferrer noopener"><code class="language-text">==</code></a> 运算不同，<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Equality" target="_blank" rel="nofollow noreferrer noopener"><code class="language-text">==</code></a> 运算符会对它两边的操作数做隐式类型转换（如果它们类型不同），然后才进行相等性比较，（所以才会有类似 <code class="language-text">&quot;&quot; == false</code> 等于 <code class="language-text">true</code> 的现象），但 <code class="language-text">Object.is</code> 不会做这种类型转换。</p>\n<p>这与 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Identity" target="_blank" rel="nofollow noreferrer noopener"><code class="language-text">===</code></a> 运算符的判定方式也不一样。<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Identity" target="_blank" rel="nofollow noreferrer noopener"><code class="language-text">===</code></a> 运算符（和<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Equality" target="_blank" rel="nofollow noreferrer noopener"><code class="language-text">==</code></a> 运算符）将数字值 <code class="language-text">-0</code> 和 <code class="language-text">+0</code> 视为相等，并认为 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/NaN" target="_blank" rel="nofollow noreferrer noopener"><code class="language-text">Number.NaN</code></a> 不等于 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/NaN" target="_blank" rel="nofollow noreferrer noopener"><code class="language-text">NaN</code></a>。</p>\n<p>如果下列任何一项成立，则两个值相同：</p>\n<ul>\n<li>两个值都是 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined" target="_blank" rel="nofollow noreferrer noopener"><code class="language-text">undefined</code></a></li>\n<li>两个值都是 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/null" target="_blank" rel="nofollow noreferrer noopener"><code class="language-text">null</code></a></li>\n<li>两个值都是 <code class="language-text">true</code> 或者都是 <code class="language-text">false</code></li>\n<li>两个值是由相同个数的字符按照相同的顺序组成的字符串</li>\n<li>两个值指向同一个对象</li>\n<li>\n<p>两个值都是数字并且</p>\n<ul>\n<li>都是正零 <code class="language-text">+0</code></li>\n<li>都是负零 <code class="language-text">-0</code></li>\n<li>都是 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/NaN" target="_blank" rel="nofollow noreferrer noopener"><code class="language-text">NaN</code></a></li>\n<li>都是除零和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/NaN" target="_blank" rel="nofollow noreferrer noopener"><code class="language-text">NaN</code></a> 外的其它同一个数字</li>\n</ul>\n</li>\n</ul>',
id:"/github/workspace/blog/React之PureComponent入门学习/index.md absPath of file >>> MarkdownRemark",timeToRead:9,frontmatter:{date:"2019-09-19 19:44:14",path:"/react-purecomponent-practice-learn/",tags:"前端, React, PureComponent",title:"React之PureComponent入门学习",draft:null}},{excerpt:"React 生命周期很多人都了解，但通常我们所了解的都是  单个组件  的生命周期，但针对  Hooks 组件、多个关联组件 （父子组件和兄弟组件） 的生命周期又是怎么样的喃？你有思考和了解过吗，接下来我们将完整的了解 React 生命周期。 关于  组件  ，我们这里指的是   以及   ，但是否包括 Hooks 组件呢？ Hooks 组件 函数组件  的本质是函数，没有 state 的概念的，因此 不存在生命周期 一说，仅仅是一个  render 函数 而已。 但是引入  Hooks…",html:'<p>React 生命周期很多人都了解，但通常我们所了解的都是 <strong>单个组件</strong> 的生命周期，但针对 <strong>Hooks 组件、多个关联组件</strong>（父子组件和兄弟组件） 的生命周期又是怎么样的喃？你有思考和了解过吗，接下来我们将完整的了解 React 生命周期。</p>\n<p>关于 <strong>组件</strong> ，我们这里指的是 <code class="language-text">React.Component</code> 以及 <code class="language-text">React.PureComponent</code> ，但是否包括 Hooks 组件呢？</p>\n<h1 id="hooks-组件"><a href="#hooks-%E7%BB%84%E4%BB%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Hooks 组件</h1>\n<p><strong>函数组件</strong> 的本质是函数，没有 state 的概念的，因此<strong>不存在生命周期</strong>一说，仅仅是一个 <strong>render 函数</strong>而已。</p>\n<p>但是引入 <strong>Hooks</strong> 之后就变得不同了，它能让组件在不使用 class 的情况下使用 state 以及其他的 React 特性，相比与 class 的生命周期概念来说，它更接近于实现状态同步，而不是响应生命周期事件。但我们可以利用 <code class="language-text">useState</code>、 <code class="language-text">useEffect()</code> 和 <code class="language-text">useLayoutEffect()</code> 来模拟实现生命周期。</p>\n<p>即：<strong>Hooks 组件更接近于实现状态同步，而不是响应生命周期事件</strong>。</p>\n<p>下面，是具体的 生命周期 与 Hooks 的<strong>对应关系</strong>：</p>\n<ul>\n<li>\n<p><code class="language-text">constructor</code>：函数组件不需要构造函数，我们可以通过调用 <strong><code class="language-text">useState</code> 来初始化 state</strong>。如果计算的代价比较昂贵，也可以传一个函数给 <code class="language-text">useState</code>。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="76998927352201630000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`const [num, UpdateNum] = useState(0);`, `76998927352201630000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">const</span> <span class="token punctuation">[</span>num<span class="token punctuation">,</span> UpdateNum<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n</li>\n<li>\n<p><code class="language-text">getDerivedStateFromProps</code>：一般情况下，我们不需要使用它，我们可以在<strong>渲染过程中更新 state</strong>，以达到实现 <code class="language-text">getDerivedStateFromProps</code> 的目的。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="53055553390095580000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function ScrollView({ row }) {\nlet [isScrollingDown, setIsScrollingDown] = useState(false);\nlet [prevRow, setPrevRow] = useState(null);\n\nif (row !== prevRow) {\n  // Row 自上次渲染以来发生过改变。更新 isScrollingDown。\n  setIsScrollingDown(prevRow !== null && row > prevRow);\n  setPrevRow(row);\n}\n\nreturn \\`Scrolling down: \\${isScrollingDown}\\`;\n}`, `53055553390095580000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span> <span class="token function">ScrollView</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> row <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n<span class="token keyword">let</span> <span class="token punctuation">[</span>isScrollingDown<span class="token punctuation">,</span> setIsScrollingDown<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">let</span> <span class="token punctuation">[</span>prevRow<span class="token punctuation">,</span> setPrevRow<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token keyword">if</span> <span class="token punctuation">(</span>row <span class="token operator">!==</span> prevRow<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// Row 自上次渲染以来发生过改变。更新 isScrollingDown。</span>\n  <span class="token function">setIsScrollingDown</span><span class="token punctuation">(</span>prevRow <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> row <span class="token operator">></span> prevRow<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token function">setPrevRow</span><span class="token punctuation">(</span>row<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">return</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Scrolling down: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>isScrollingDown<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>React 会立即退出第一次渲染并用更新后的 state 重新运行组件以避免耗费太多性能。</p>\n</li>\n<li>\n<p><code class="language-text">shouldComponentUpdate</code>：可以用 <strong><code class="language-text">React.memo</code></strong> 包裹一个组件来对它的 <code class="language-text">props</code> 进行浅比较</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="70014299857322590000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`const Button = React.memo((props) => {\n// 具体的组件\n});`, `70014299857322590000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">const</span> Button <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">memo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n<span class="token comment">// 具体的组件</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span></span></pre></div>\n<p>注意：<strong><code class="language-text">React.memo</code> 等效于 <code class="language-text">PureComponent</code></strong>，它只浅比较 props。这里也可以使用 <code class="language-text">useMemo</code> 优化每一个节点。</p>\n</li>\n<li>\n<p><code class="language-text">render</code>：这是函数组件体本身。</p>\n</li>\n<li>\n<p><code class="language-text">componentDidMount</code>, <code class="language-text">componentDidUpdate</code>： <code class="language-text">useLayoutEffect</code> 与它们两的调用阶段是一样的。但是，我们推荐你<strong>一开始先用 useEffect</strong>，只有当它出问题的时候再尝试使用 <code class="language-text">useLayoutEffect</code>。<code class="language-text">useEffect</code> 可以表达所有这些的组合。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="87816557337105370000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// componentDidMount\nuseEffect(() => {\n// 需要在 componentDidMount 执行的内容\n}, []);\n\nuseEffect(() => {\n// 在 componentDidMount，以及 count 更改时 componentDidUpdate 执行的内容\ndocument.title = \\`You clicked \\${count} times\\`;\nreturn () => {\n  // 需要在 count 更改时 componentDidUpdate（先于 document.title = ... 执行，遵守先清理后更新）\n  // 以及 componentWillUnmount 执行的内容\n}; // 当函数中 Cleanup 函数会按照在代码中定义的顺序先后执行，与函数本身的特性无关\n}, [count]); // 仅在 count 更改时更新`, `87816557337105370000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">// componentDidMount</span>\n<span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n<span class="token comment">// 需要在 componentDidMount 执行的内容</span>\n<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n<span class="token comment">// 在 componentDidMount，以及 count 更改时 componentDidUpdate 执行的内容</span>\ndocument<span class="token punctuation">.</span>title <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">You clicked </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>count<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> times</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>\n<span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  <span class="token comment">// 需要在 count 更改时 componentDidUpdate（先于 document.title = ... 执行，遵守先清理后更新）</span>\n  <span class="token comment">// 以及 componentWillUnmount 执行的内容</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 当函数中 Cleanup 函数会按照在代码中定义的顺序先后执行，与函数本身的特性无关</span>\n<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>count<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 仅在 count 更改时更新</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p><strong>请记得 React 会等待浏览器完成画面渲染之后才会延迟调用 <code class="language-text">useEffect</code>，因此会使得额外操作很方便</strong></p>\n</li>\n<li>\n<p><code class="language-text">componentWillUnmount</code>：相当于 <code class="language-text">useEffect</code> 里面返回的 <code class="language-text">cleanup</code> 函数</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="87769639973709320000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// componentDidMount/componentWillUnmount\nuseEffect(() => {\n// 需要在 componentDidMount 执行的内容\nreturn function cleanup() {\n  // 需要在 componentWillUnmount 执行的内容\n};\n}, []);`, `87769639973709320000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">// componentDidMount/componentWillUnmount</span>\n<span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n<span class="token comment">// 需要在 componentDidMount 执行的内容</span>\n<span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token function">cleanup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 需要在 componentWillUnmount 执行的内容</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n</li>\n<li>\n<p><code class="language-text">componentDidCatch</code> and <code class="language-text">getDerivedStateFromError</code>：目前<strong>还没有</strong>这些方法的 Hook 等价写法，但很快会加上。</p>\n</li>\n</ul>\n<p>为方便记忆，大致汇总成表格如下。</p>\n<table>\n<thead>\n<tr>\n<th>class 组件</th>\n<th>Hooks 组件</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>constructor</td>\n<td>useState</td>\n</tr>\n<tr>\n<td>getDerivedStateFromProps</td>\n<td>useState 里面 update 函数</td>\n</tr>\n<tr>\n<td>shouldComponentUpdate</td>\n<td>useMemo</td>\n</tr>\n<tr>\n<td>render</td>\n<td>函数本身</td>\n</tr>\n<tr>\n<td>componentDidMount</td>\n<td>useEffect</td>\n</tr>\n<tr>\n<td>componentDidUpdate</td>\n<td>useEffect</td>\n</tr>\n<tr>\n<td>componentWillUnmount</td>\n<td>useEffect 里面返回的函数</td>\n</tr>\n<tr>\n<td>componentDidCatch</td>\n<td>无</td>\n</tr>\n<tr>\n<td>getDerivedStateFromError</td>\n<td>无</td>\n</tr>\n</tbody>\n</table>\n<h1 id="单个组件的生命周期"><a href="#%E5%8D%95%E4%B8%AA%E7%BB%84%E4%BB%B6%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>单个组件的生命周期</h1>\n<h2 id="生命周期"><a href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>生命周期</h2>\n<h3 id="v163-之前"><a href="#v163-%E4%B9%8B%E5%89%8D" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>V16.3 之前</h3>\n<p>我们可以将生命周期分为三个阶段：</p>\n<ul>\n<li>挂载阶段</li>\n<li>组件更新阶段</li>\n<li>卸载阶段</li>\n</ul>\n<p>分开来讲：</p>\n<ol>\n<li>\n<p>挂载阶段</p>\n<ul>\n<li><code class="language-text">constructor</code>：避免将 props 的值复制给 state</li>\n<li><code class="language-text">componentWillMount</code></li>\n<li><code class="language-text">render</code>：react 最重要的步骤，创建虚拟 dom，进行 diff 算法，更新 dom 树都在此进行</li>\n<li><code class="language-text">componentDidMount</code></li>\n</ul>\n</li>\n<li>\n<p>组件更新阶段</p>\n<ul>\n<li><code class="language-text">componentWillReceiveProps</code></li>\n<li><code class="language-text">shouldComponentUpdate</code></li>\n<li><code class="language-text">componentWillUpdate</code></li>\n<li><code class="language-text">render</code></li>\n<li><code class="language-text">componentDidUpdate</code></li>\n</ul>\n</li>\n<li>\n<p>卸载阶段</p>\n<ul>\n<li><code class="language-text">componentWillUnMount</code></li>\n</ul>\n</li>\n</ol>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2019-09-19-15-39-27-eab55b0696e08d1c4eb1c06e80f91656-64b63.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 46.2%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAIAAAC9o5sfAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABMUlEQVQoz31RXW/DIAzs//9je16nqVXapkkWGkJKvgsGDMxptq4P207Iss53WLY3MUYDC3zwBK01IoYY6FFpZShSvpJUJcY5R8yGSCll0zTEGmOEEFRbpCEAZaDrutZLAvEOpRRp5nm+m9FCvYN6j1a3l/FybJqi84jHyb5U02tnQcOU7Nu3rWalj0EUskxqnkuPfuns4OZAoXei5+klrSRDjyOv+S6RaaaGiR1Yuc3anFM3C07fwIClGTbxGzQzH7pU8LKTzmPP2HV/7t4Pep4rIQrGunFYF/HAszmI3mZ85q1BH2QznBLGcnED9dGzo8ha1dEifjc/FyiX6nqW52pkM5ii1odyug42xr/NYYlxvQpv9S5vT9Vg7NflfAj/dPaPj0nk0INB4/BJHu6aH3wCvBUH6w2zt08AAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2019 09 19 15 39 27"\n        title=""\n        src="/static/2019-09-19-15-39-27-eab55b0696e08d1c4eb1c06e80f91656-fee1c.png"\n        srcset="/static/2019-09-19-15-39-27-eab55b0696e08d1c4eb1c06e80f91656-a67b7.png 200w,\n/static/2019-09-19-15-39-27-eab55b0696e08d1c4eb1c06e80f91656-0b187.png 400w,\n/static/2019-09-19-15-39-27-eab55b0696e08d1c4eb1c06e80f91656-fee1c.png 800w,\n/static/2019-09-19-15-39-27-eab55b0696e08d1c4eb1c06e80f91656-b1a91.png 1200w,\n/static/2019-09-19-15-39-27-eab55b0696e08d1c4eb1c06e80f91656-95179.png 1600w,\n/static/2019-09-19-15-39-27-eab55b0696e08d1c4eb1c06e80f91656-64b63.png 2000w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>这种生命周期会存在一个问题，那就是当更新复杂组件的最上层组件时，调用栈会很长，如果在进行复杂的操作时，就可能长时间阻塞主线程，带来不好的用户体验，<strong>Fiber</strong> 就是为了解决该问题而生。</p>\n<h3 id="v163-之后"><a href="#v163-%E4%B9%8B%E5%90%8E" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>V16.3 之后</h3>\n<p><strong>Fiber 本质上是一个虚拟的堆栈帧，新的调度器会按照优先级自由调度这些帧，从而将之前的同步渲染改成了异步渲染，在不影响体验的情况下去分段计算更新。</strong></p>\n<p>对于异步渲染，分为两阶段：</p>\n<ul>\n<li>\n<p><code class="language-text">reconciliation</code>：</p>\n<ul>\n<li><code class="language-text">componentWillMount</code></li>\n<li><code class="language-text">componentWillReceiveProps</code></li>\n<li><code class="language-text">shouldConmponentUpdate</code></li>\n<li><code class="language-text">componentWillUpdate</code></li>\n</ul>\n</li>\n<li>\n<p><code class="language-text">commit</code></p>\n<ul>\n<li><code class="language-text">componentDidMount</code></li>\n<li><code class="language-text">componentDidUpdate</code></li>\n</ul>\n</li>\n</ul>\n<p>其中，<code class="language-text">reconciliation</code> 阶段是可以被打断的，所以 <code class="language-text">reconcilation</code> 阶段执行的函数就会出现多次调用的情况，显然，这是不合理的。</p>\n<p>所以 V16.3 引入了新的 API 来解决这个问题：</p>\n<ol>\n<li>\n<p><code class="language-text">static getDerivedStateFromProps</code>： 该函数在<strong>挂载阶段和组件更新阶段</strong>都会执行，即<strong>每次获取新的<code class="language-text">props</code> 或 <code class="language-text">state</code> 之后都会被执行</strong>，<strong>在挂载阶段用来代替<code class="language-text">componentWillMount</code></strong>；在组件更新阶段配合 <code class="language-text">componentDidUpdate</code>，可以覆盖 <code class="language-text">componentWillReceiveProps</code> 的所有用法。</p>\n<p>同时它是一个静态函数，所以函数体内不能访问 <code class="language-text">this</code>，会根据 <code class="language-text">nextProps</code> 和 <code class="language-text">prevState</code> 计算出预期的状态改变，返回结果会被送给 <code class="language-text">setState</code><strong>，</strong>返回 <code class="language-text">null</code> 则说明不需要更新 <code class="language-text">state</code>，并且这个返回是<strong>必须的</strong>。</p>\n</li>\n<li>\n<p><code class="language-text">getSnapshotBeforeUpdate</code>: 该函数会在 <strong><code class="language-text">render</code> 之后， DOM 更新前</strong>被调用，用于读取最新的 DOM 数据。</p>\n<p>返回一个值，<strong>作为 <code class="language-text">componentDidUpdate</code> 的第三个参数</strong>；配合 <code class="language-text">componentDidUpdate</code>, 可以覆盖<code class="language-text">componentWillUpdate</code> 的所有用法。</p>\n</li>\n</ol>\n<p>注意：V16.3 中只用在组件挂载或组件 <code class="language-text">props</code> 更新过程才会调用，即如果是因为自身 setState 引发或者 forceUpdate 引发，而不是由父组件引发的话，那么<code class="language-text">static getDerivedStateFromProps</code>也不会被调用，在 V16.4 中更正为都调用。</p>\n<p>即更新后的生命周期为：</p>\n<ol>\n<li>\n<p>挂载阶段</p>\n<ul>\n<li><code class="language-text">constructor</code></li>\n<li><code class="language-text">static getDerivedStateFromProps</code></li>\n<li><code class="language-text">render</code></li>\n<li><code class="language-text">componentDidMount</code></li>\n</ul>\n</li>\n<li>\n<p>更新阶段</p>\n<ul>\n<li><code class="language-text">static getDerivedStateFromProps</code></li>\n<li><code class="language-text">shouldComponentUpdate</code></li>\n<li><code class="language-text">render</code></li>\n<li><code class="language-text">getSnapshotBeforeUpdate</code></li>\n<li><code class="language-text">componentDidUpdate</code></li>\n</ul>\n</li>\n<li>\n<p>卸载阶段</p>\n<ul>\n<li><code class="language-text">componentWillUnmount</code></li>\n</ul>\n</li>\n</ol>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2019-09-19-15-42-52-c13f7d524b09e92ec31990247d36fa3c-60fa0.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 65.97845601436265%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAIAAAAmMtkJAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAB1ElEQVQoz11SibKqMAzl///OGRUVAVkLbaH7xuaNF0fvexkmCTk5zekSPf+1bdv2ZF6eZBCE4K7rCIS+36Ht1/ae6C/tA4P3IXAupJTWOcHYSIj3/oPuzV8yYONAT6ejFNwYbYwJIcDYy+VirQVUaw0JpfRwOHDOIY/ei22btr4jPMkqMiqptJIvgyaMe60UJEIIICilMMbg3+RdtdA+rfkxaQqkhLLQTShVSmNMhJAtQowxIJg/FoGetm0lLKt9iW2FbU3dtaCnFMVZl1ZjhU1N3KMzeFQ7F8bCFl5k0BbHMUJo3xX8QhV82Q7XrLuX5Jr3XBpQDrYP/JI/B6aNG7mG62HCwFd2HCbfkiZvOGEGD4Jzaf8jw5FCBD0A1URXWDfUtNQ8Gpo3tB8torodTEUUGeQuG3S9yRCqqur7PkxTCJO1DrxzfvW9FSlpjqg4UHSeVO40dT4474DmoMP7aFmW32sM62yec7949JyJk6VhueH5pOvF1BsUQzt7vq7fV7Su62tymqaE0HkyfMxxdxPsoUXDhmKgGcF30ieCFda0zoowBaE4GTB4yKN5nkEDeO3MrUzi7JJUd1DCLG9ZC/kZKuUdMaSsYmqMs9MlP98eZ6n5Dzwc3073oxEkAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2019 09 19 15 42 52"\n        title=""\n        src="/static/2019-09-19-15-42-52-c13f7d524b09e92ec31990247d36fa3c-fee1c.png"\n        srcset="/static/2019-09-19-15-42-52-c13f7d524b09e92ec31990247d36fa3c-a67b7.png 200w,\n/static/2019-09-19-15-42-52-c13f7d524b09e92ec31990247d36fa3c-0b187.png 400w,\n/static/2019-09-19-15-42-52-c13f7d524b09e92ec31990247d36fa3c-fee1c.png 800w,\n/static/2019-09-19-15-42-52-c13f7d524b09e92ec31990247d36fa3c-b1a91.png 1200w,\n/static/2019-09-19-15-42-52-c13f7d524b09e92ec31990247d36fa3c-95179.png 1600w,\n/static/2019-09-19-15-42-52-c13f7d524b09e92ec31990247d36fa3c-60fa0.png 2228w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<h3 id="生命周期，误区"><a href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%8C%E8%AF%AF%E5%8C%BA" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>生命周期，误区</h3>\n<p><strong>误解一：</strong><code class="language-text">getDerivedStateFromProps</code> 和 <code class="language-text">componentWillReceiveProps</code> 只会在 <code class="language-text">props</code> <strong>改变</strong> 时才会调用</p>\n<p>实际上，<strong>只要父级重新渲染，<code class="language-text">getDerivedStateFromProps</code> 和 <code class="language-text">componentWillReceiveProps</code> 都会重新调用，不管 <code class="language-text">props</code> 有没有变化</strong>。所以，在这两个方法内直接将 props 赋值到 state 是不安全的。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="72732758639652720000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// 子组件\nclass PhoneInput extends Component {\n  state = { phone: this.props.phone };\n\n  handleChange = (e) => {\n    this.setState({ phone: e.target.value });\n  };\n\n  render() {\n    const { phone } = this.state;\n    return <input onChange={this.handleChange} value={phone} />;\n  }\n\n  componentWillReceiveProps(nextProps) {\n    // 不要这样做。\n    // 这会覆盖掉之前所有的组件内 state 更新！\n    this.setState({ phone: nextProps.phone });\n  }\n}\n\n// 父组件\nclass App extends Component {\n  constructor() {\n    super();\n    this.state = {\n      count: 0\n    };\n  }\n\n  componentDidMount() {\n    // 使用了 setInterval，\n    // 每秒钟都会更新一下 state.count\n    // 这将导致 App 每秒钟重新渲染一次\n    this.interval = setInterval(\n      () =>\n        this.setState((prevState) => ({\n          count: prevState.count + 1\n        })),\n      1000\n    );\n  }\n\n  componentWillUnmount() {\n    clearInterval(this.interval);\n  }\n\n  render() {\n    return (\n      <>\n        <p>Start editing to see some magic happen :)</p>\n        <PhoneInput phone=\'call me!\' />\n        <p>\n          This component will re-render every second. Each time it renders, the text you type will be reset. This\n          illustrates a derived state anti-pattern.\n        </p>\n      </>\n    );\n  }\n}`, `72732758639652720000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">// 子组件</span>\n<span class="token keyword">class</span> <span class="token class-name">PhoneInput</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>\n  state <span class="token operator">=</span> <span class="token punctuation">{</span> phone<span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>phone <span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n  <span class="token function-variable function">handleChange</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span> phone<span class="token punctuation">:</span> e<span class="token punctuation">.</span>target<span class="token punctuation">.</span>value <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">const</span> <span class="token punctuation">{</span> phone <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">;</span>\n    <span class="token keyword">return</span> <span class="token operator">&lt;</span>input onChange<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>handleChange<span class="token punctuation">}</span> value<span class="token operator">=</span><span class="token punctuation">{</span>phone<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token function">componentWillReceiveProps</span><span class="token punctuation">(</span><span class="token parameter">nextProps</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 不要这样做。</span>\n    <span class="token comment">// 这会覆盖掉之前所有的组件内 state 更新！</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span> phone<span class="token punctuation">:</span> nextProps<span class="token punctuation">.</span>phone <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// 父组件</span>\n<span class="token keyword">class</span> <span class="token class-name">App</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>\n  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span>\n      count<span class="token punctuation">:</span> <span class="token number">0</span>\n    <span class="token punctuation">}</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 使用了 setInterval，</span>\n    <span class="token comment">// 每秒钟都会更新一下 state.count</span>\n    <span class="token comment">// 这将导致 App 每秒钟重新渲染一次</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>interval <span class="token operator">=</span> <span class="token function">setInterval</span><span class="token punctuation">(</span>\n      <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span>\n        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">prevState</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span>\n          count<span class="token punctuation">:</span> prevState<span class="token punctuation">.</span>count <span class="token operator">+</span> <span class="token number">1</span>\n        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n      <span class="token number">1000</span>\n    <span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token function">componentWillUnmount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token function">clearInterval</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>interval<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token punctuation">(</span>\n      <span class="token operator">&lt;</span><span class="token operator">></span>\n        <span class="token operator">&lt;</span>p<span class="token operator">></span>Start editing to see some magic happen <span class="token punctuation">:</span><span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">></span>\n        <span class="token operator">&lt;</span>PhoneInput phone<span class="token operator">=</span><span class="token string">\'call me!\'</span> <span class="token operator">/</span><span class="token operator">></span>\n        <span class="token operator">&lt;</span>p<span class="token operator">></span>\n          This component will re<span class="token operator">-</span>render every second<span class="token punctuation">.</span> Each time it renders<span class="token punctuation">,</span> the text you type will be reset<span class="token punctuation">.</span> This\n          illustrates a derived state anti<span class="token operator">-</span>pattern<span class="token punctuation">.</span>\n        <span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">></span>\n      <span class="token operator">&lt;</span><span class="token operator">/</span><span class="token operator">></span>\n    <span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p><a href="https://stackblitz.com/edit/react-yammav" target="_blank" rel="nofollow noreferrer noopener">实例可点击这里查看</a></p>\n<p>当然，我们可以在 父组件 App 中 <code class="language-text">shouldComponentUpdate</code> 比较 props 的 email 是不是修改再决定要不要重新渲染，但是如果子组件接受多个 props（较为复杂），就很难处理，而且 <code class="language-text">shouldComponentUpdate</code> 主要是用来性能提升的，不推荐开发者操作 <code class="language-text">shouldComponetUpdate</code>（可以使用 <code class="language-text">React.PureComponet</code>）。</p>\n<p>我们也可以使用 <strong>在 props 变化后修改 state</strong>。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="67523567389041770000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`class PhoneInput extends Component {\n  state = {\n    phone: this.props.phone\n  };\n\n  componentWillReceiveProps(nextProps) {\n    // 只要 props.phone 改变，就改变 state\n    if (nextProps.phone !== this.props.phone) {\n      this.setState({\n        phone: nextProps.phone\n      });\n    }\n  }\n\n  // ...\n}`, `67523567389041770000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">PhoneInput</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>\n  state <span class="token operator">=</span> <span class="token punctuation">{</span>\n    phone<span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>phone\n  <span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n  <span class="token function">componentWillReceiveProps</span><span class="token punctuation">(</span><span class="token parameter">nextProps</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 只要 props.phone 改变，就改变 state</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>nextProps<span class="token punctuation">.</span>phone <span class="token operator">!==</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>phone<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n        phone<span class="token punctuation">:</span> nextProps<span class="token punctuation">.</span>phone\n      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token comment">// ...</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>但这种也会导致一个问题，当 props 较为复杂时，props 与 state 的关系不好控制，可能导致问题</p>\n<p>解决方案一：<strong>完全可控的组件</strong></p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="63160966213018345000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function PhoneInput(props) {\n  return <input onChange={props.onChange} value={props.phone} />;\n}`, `63160966213018345000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span> <span class="token function">PhoneInput</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token operator">&lt;</span>input onChange<span class="token operator">=</span><span class="token punctuation">{</span>props<span class="token punctuation">.</span>onChange<span class="token punctuation">}</span> value<span class="token operator">=</span><span class="token punctuation">{</span>props<span class="token punctuation">.</span>phone<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span></span></pre></div>\n<p><strong>完全由 props 控制，不派生 state</strong></p>\n<p>解决方案二：<strong>有 key 的非可控组件</strong></p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="11656640900655213000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`class PhoneInput extends Component {\n  state = { phone: this.props.defaultPhone };\n\n  handleChange = (event) => {\n    this.setState({ phone: event.target.value });\n  };\n\n  render() {\n    return <input onChange={this.handleChange} value={this.state.phone} />;\n  }\n}\n\n<PhoneInput defaultPhone={this.props.user.phone} key={this.props.user.id} />;`, `11656640900655213000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">PhoneInput</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>\n  state <span class="token operator">=</span> <span class="token punctuation">{</span> phone<span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>defaultPhone <span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n  <span class="token function-variable function">handleChange</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span> phone<span class="token punctuation">:</span> event<span class="token punctuation">.</span>target<span class="token punctuation">.</span>value <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token operator">&lt;</span>input onChange<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>handleChange<span class="token punctuation">}</span> value<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>phone<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token operator">&lt;</span>PhoneInput defaultPhone<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>user<span class="token punctuation">.</span>phone<span class="token punctuation">}</span> key<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>user<span class="token punctuation">.</span>id<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>当 <code class="language-text">key</code> 变化时， React 会<strong>创建一个新的而不是更新一个既有的组件</strong></p>\n<p><strong>误解二</strong>：将 props 的值直接复制给 state</p>\n<p><strong>应避免将 props 的值复制给 state</strong></p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="68655607325617725000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`constructor(props) {\n super(props);\n // 千万不要这样做\n // 直接用 props，保证单一数据源\n this.state = { phone: props.phone };\n}`, `68655607325617725000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>\n <span class="token comment">// 千万不要这样做</span>\n <span class="token comment">// 直接用 props，保证单一数据源</span>\n <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span> phone<span class="token punctuation">:</span> props<span class="token punctuation">.</span>phone <span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h1 id="多个组件的执行顺序"><a href="#%E5%A4%9A%E4%B8%AA%E7%BB%84%E4%BB%B6%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>多个组件的执行顺序</h1>\n<h2 id="父子组件"><a href="#%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>父子组件</h2>\n<ul>\n<li>\n<p><strong>挂载阶段</strong></p>\n<p>分 <strong>两个</strong> 阶段：</p>\n<ul>\n<li>第 <strong>一</strong> 阶段，由父组件开始执行到自身的 <code class="language-text">render</code>，解析其下有哪些子组件需要渲染，并对其中 <strong>同步的子组件</strong> 进行创建，按 <strong>递归顺序</strong> 挨个执行各个子组件至 <code class="language-text">render</code>，生成到父子组件对应的 Virtual DOM 树，并 commit 到 DOM。</li>\n<li>第 <strong>二</strong> 阶段，此时 DOM 节点已经生成完毕，组件挂载完成，开始后续流程。先依次触发同步子组件各自的 <code class="language-text">componentDidMount</code>，最后触发父组件的。</li>\n</ul>\n<p><strong>注意</strong>：如果父组件中包含异步子组件，则会在父组件挂载完成后被创建。</p>\n<p>所以执行顺序是：</p>\n<p>父组件 getDerivedStateFromProps —> 同步子组件 getDerivedStateFromProps —> 同步子组件 componentDidMount —> 父组件 componentDidMount —> 异步子组件 getDerivedStateFromProps —> 异步子组件 componentDidMount</p>\n</li>\n<li>\n<p><strong>更新阶段</strong></p>\n<p><strong>React 的设计遵循单向数据流模型</strong> ，也就是说，数据均是由父组件流向子组件。</p>\n<ul>\n<li>\n<p>第 <strong>一</strong> 阶段，由父组件开始，执行</p>\n</li>\n<li>\n<p><code class="language-text">static getDerivedStateFromProps</code></p>\n</li>\n<li>\n<p><code class="language-text">shouldComponentUpdate</code></p>\n</li>\n</ul>\n<p>更新到自身的 <code class="language-text">render</code>，解析其下有哪些子组件需要渲染，并对 <strong>子组件</strong> 进行创建，按 <strong>递归顺序</strong> 挨个执行各个子组件至 <code class="language-text">render</code>，生成到父子组件对应的 Virtual DOM 树，并与已有的 Virtual DOM 树 比较，计算出 <strong>Virtual DOM 真正变化的部分</strong> ，并只针对该部分进行的原生 DOM 操作。</p>\n<ul>\n<li>\n<p>第 <strong>二</strong> 阶段，此时 DOM 节点已经生成完毕，组件挂载完成，开始后续流程。先依次触发同步子组件以下函数，最后触发父组件的。</p>\n</li>\n<li>\n<p><code class="language-text">getSnapshotBeforeUpdate()</code></p>\n</li>\n<li>\n<p><code class="language-text">componentDidUpdate()</code></p>\n</li>\n</ul>\n<p>React 会按照上面的顺序依次执行这些函数，每个函数都是各个子组件的先执行，然后才是父组件的执行。</p>\n<p>所以执行顺序是：</p>\n<p>父组件 getDerivedStateFromProps —> 父组件 shouldComponentUpdate —> 子组件 getDerivedStateFromProps —> 子组件 shouldComponentUpdate —> 子组件 getSnapshotBeforeUpdate —> 父组件 getSnapshotBeforeUpdate —> 子组件 componentDidUpdate —> 父组件 componentDidUpdate</p>\n</li>\n<li>\n<p><strong>卸载阶段</strong></p>\n<p><code class="language-text">componentWillUnmount()</code>，顺序为 <strong>父组件的先执行，子组件按照在 JSX 中定义的顺序依次执行各自的方法</strong>。</p>\n<p><strong>注意</strong> ：如果卸载旧组件的同时伴随有新组件的创建，新组件会先被创建并执行完 <code class="language-text">render</code>，然后卸载不需要的旧组件，最后新组件执行挂载完成的回调。</p>\n</li>\n</ul>\n<h2 id="兄弟组件"><a href="#%E5%85%84%E5%BC%9F%E7%BB%84%E4%BB%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>兄弟组件</h2>\n<ul>\n<li>\n<p><strong>挂载阶段</strong></p>\n<p>若是同步路由，它们的创建顺序和其在共同父组件中定义的先后顺序是 <strong>一致</strong> 的。</p>\n<p>若是异步路由，它们的创建顺序和 js 加载完成的顺序一致。</p>\n</li>\n<li>\n<p><strong>更新阶段、卸载阶段</strong></p>\n<p>兄弟节点之间的通信主要是经过父组件（Redux 和 Context 也是通过改变父组件传递下来的 <code class="language-text">props</code> 实现的），<strong>满足 React 的设计遵循单向数据流模型</strong>， <strong>因此任何两个组件之间的通信，本质上都可以归结为父子组件更新的情况</strong> 。</p>\n<p>所以，兄弟组件更新、卸载阶段，请参考 <strong>父子组件</strong>。</p>\n</li>\n</ul>',
id:"/github/workspace/blog/React生命周期入门学习/index.md absPath of file >>> MarkdownRemark",timeToRead:9,frontmatter:{date:"2019-09-19 15:29:20",path:"/react-lifecycle-practice-learn/",tags:"前端, React, 生命周期",title:"React生命周期入门学习",draft:null}},{excerpt:"接上文 Webpack 配置笔记 分包策略 在分支   上启动   脚本，得到分包策略如下： 首屏加载对比 原始首屏加载 升级后加载 分包优化步骤 echarts 只提取需要的包 immutable 指向同一份，避免 draft 与 antd 重复打包 分大模块改写法 根据路由来分 这里原来的路由引用模块已经是   形式的了，所以我在   里的   加了如下策略 经实验，可以看到各个页面只加载所需的包 根据组件来分 对其中比较大的组件进行了懒加载处理，react-player/draft…",html:'<p>接上文<a href="/webpack-config-note/">Webpack 配置笔记</a></p>\n<h1 id="分包策略"><a href="#%E5%88%86%E5%8C%85%E7%AD%96%E7%95%A5" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>分包策略</h1>\n<p>在分支 <code class="language-text">feature/optimize_webpack</code> 上启动 <code class="language-text">yarn analyze</code> 脚本，得到分包策略如下：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2019-08-20-14-39-37-7859d5fffe6130839ec4ea995f4afe9a-de767.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 48.45840605002909%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACbUlEQVQozwFiAp39AO/kz/n28fv8/vr58eqrkuGBXtqBYeKDYeR5T+mZlNyfwN2WsdqV1sp728du1qhr6JBQ5IxU4YBW/25A+wD29vT7/P77/f/5/f/tvKnvkG7rgFnqd07iWCTtm43ptNTehKfWgs7FYt23UsifXOZ/NONxOMhrP+9VJ9oA8/T0+Pj4+Pj4+/397b+v7IZf7HZL6nBE3lkl5JCF46bH24Gl1aTPzavcwqberJThnYjqi3zpaGH5UkvqAN/f3+Hh4eXj4/j+/+6rl+trQuxwSPJwR9pPI9eWg97V1djFwOTW4tC13sW15LWq5p6W7IyH8klK+S802wDj4+Pk5OTo6Of7/P/q2KnkvnLguHPkvHTetmfm0a7q3N/cw77Gvc2lpcmssNuRmtmImOR3i+ZffPNNad4A5eXl5ubm6Ojo9vb49PbJ9vq25+yy5eq/+P3K8vPWz9HDzMu1wczOprnMssbfn7fgmLToh6jsbJn4RXvtAOLi4uPj4+jo6fz8+ff16fb06/Xzy+bkyuXixeTpyKvPoY/AeqrTup3QzKrU3arU6KHO7pLH9Xm0+Vyj/QDi4uLh4eHm5ub4+Pfz99vu89Lp6qrq6p/y8KXb6qmm0qCUwoGw2b604dWX3Nyb3ued3PGP1PeX2f6Mz/4A5eXl5ubm5+fm9PL32/qowPJstupite5bpN4+od92iN6MdNZwnN+wrejSjuXVkujljOjzru373sDA39bYAOTk5Obm5unp6Pz5/9f5or34YLLzSafxMn3CB4HBWG3gcEzFRXDVk2XapYbozIvy43329a/3/em+uuTa2O+lwnzOuk/fAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="分包策略"\n        title=""\n        src="/static/2019-08-20-14-39-37-7859d5fffe6130839ec4ea995f4afe9a-fee1c.png"\n        srcset="/static/2019-08-20-14-39-37-7859d5fffe6130839ec4ea995f4afe9a-a67b7.png 200w,\n/static/2019-08-20-14-39-37-7859d5fffe6130839ec4ea995f4afe9a-0b187.png 400w,\n/static/2019-08-20-14-39-37-7859d5fffe6130839ec4ea995f4afe9a-fee1c.png 800w,\n/static/2019-08-20-14-39-37-7859d5fffe6130839ec4ea995f4afe9a-b1a91.png 1200w,\n/static/2019-08-20-14-39-37-7859d5fffe6130839ec4ea995f4afe9a-95179.png 1600w,\n/static/2019-08-20-14-39-37-7859d5fffe6130839ec4ea995f4afe9a-de767.png 1719w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<h1 id="首屏加载对比"><a href="#%E9%A6%96%E5%B1%8F%E5%8A%A0%E8%BD%BD%E5%AF%B9%E6%AF%94" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>首屏加载对比</h1>\n<h2 id="原始首屏加载"><a href="#%E5%8E%9F%E5%A7%8B%E9%A6%96%E5%B1%8F%E5%8A%A0%E8%BD%BD" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>原始首屏加载</h2>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2019-08-20-14-42-05-a2bf22d39e0e36b58ed042d4b584c141-ed146.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 21.993127147766323%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAIAAAABPYjBAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAAkklEQVQI102O2xLDIAhE8/8fmnhBrUREaTvtxvShZxzcGdiF7fAxUKEQYip4++H24CLFlFLOmZnPP1prd8XHtW7o8hpRe6pqE4m9NpWxUB3SdZpdevyYc6Ka2XYn5VwoRoSg8Xm9L9NCRLz3tsAY0rHH5uzSu+oyny0/ig+eiCozDDgEfgDtnLv3QC/ztWDqwI1fXa3kU7K0VbQAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="原始首屏加载大小"\n        title=""\n        src="/static/2019-08-20-14-42-05-a2bf22d39e0e36b58ed042d4b584c141-fee1c.png"\n        srcset="/static/2019-08-20-14-42-05-a2bf22d39e0e36b58ed042d4b584c141-a67b7.png 200w,\n/static/2019-08-20-14-42-05-a2bf22d39e0e36b58ed042d4b584c141-0b187.png 400w,\n/static/2019-08-20-14-42-05-a2bf22d39e0e36b58ed042d4b584c141-fee1c.png 800w,\n/static/2019-08-20-14-42-05-a2bf22d39e0e36b58ed042d4b584c141-b1a91.png 1200w,\n/static/2019-08-20-14-42-05-a2bf22d39e0e36b58ed042d4b584c141-95179.png 1600w,\n/static/2019-08-20-14-42-05-a2bf22d39e0e36b58ed042d4b584c141-ed146.png 1746w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<h2 id="升级后加载"><a href="#%E5%8D%87%E7%BA%A7%E5%90%8E%E5%8A%A0%E8%BD%BD" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>升级后加载</h2>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2019-08-20-14-42-42-9d4635b500dadc398310cd08fe4408c1-009aa.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 26.851851851851855%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAIAAADKYVtkAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAAoklEQVQY03VPyw7DIAzr/38oJVBKeCa0l7mwSrvMQigxsWO2nQ4foiNHPtARzL4TkfPOgw4h5ZT/IDFvORecmFPtrWpXVVHtgHQReVqR67r0xSIBkFsppdYa4wmgBnvfN7Q6LfDkvV961CiwEwatPQNfcYgnOYfpMdFamxEET8YY3BBjcomHDuQa7+YSmWmCmWGxIkjvcLHWov3dPBBK8Cv9AF+YHUoLUXbjAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="升级后加载大小"\n        title=""\n        src="/static/2019-08-20-14-42-42-9d4635b500dadc398310cd08fe4408c1-fee1c.png"\n        srcset="/static/2019-08-20-14-42-42-9d4635b500dadc398310cd08fe4408c1-a67b7.png 200w,\n/static/2019-08-20-14-42-42-9d4635b500dadc398310cd08fe4408c1-0b187.png 400w,\n/static/2019-08-20-14-42-42-9d4635b500dadc398310cd08fe4408c1-fee1c.png 800w,\n/static/2019-08-20-14-42-42-9d4635b500dadc398310cd08fe4408c1-b1a91.png 1200w,\n/static/2019-08-20-14-42-42-9d4635b500dadc398310cd08fe4408c1-95179.png 1600w,\n/static/2019-08-20-14-42-42-9d4635b500dadc398310cd08fe4408c1-009aa.png 1728w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<h1 id="分包优化步骤"><a href="#%E5%88%86%E5%8C%85%E4%BC%98%E5%8C%96%E6%AD%A5%E9%AA%A4" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>分包优化步骤</h1>\n<h2 id="echarts-只提取需要的包"><a href="#echarts-%E5%8F%AA%E6%8F%90%E5%8F%96%E9%9C%80%E8%A6%81%E7%9A%84%E5%8C%85" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>echarts 只提取需要的包</h2>\n<p><code class="language-text">app\\components\\ECharts\\component.js</code></p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="54434859526374170000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`import echarts from \'echarts/lib/echarts\';\nimport \'echarts/lib/chart/bar\';\nimport \'echarts/lib/chart/line\';\nimport \'echarts/lib/chart/pie\';\n\nimport \'echarts/lib/component/tooltip\';\nimport \'echarts/lib/component/legendScroll\';`, `54434859526374170000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">import</span> echarts <span class="token keyword">from</span> <span class="token string">\'echarts/lib/echarts\'</span><span class="token punctuation">;</span>\n<span class="token keyword">import</span> <span class="token string">\'echarts/lib/chart/bar\'</span><span class="token punctuation">;</span>\n<span class="token keyword">import</span> <span class="token string">\'echarts/lib/chart/line\'</span><span class="token punctuation">;</span>\n<span class="token keyword">import</span> <span class="token string">\'echarts/lib/chart/pie\'</span><span class="token punctuation">;</span>\n\n<span class="token keyword">import</span> <span class="token string">\'echarts/lib/component/tooltip\'</span><span class="token punctuation">;</span>\n<span class="token keyword">import</span> <span class="token string">\'echarts/lib/component/legendScroll\'</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h2 id="immutable-指向同一份，避免-draft-与-antd-重复打包"><a href="#immutable-%E6%8C%87%E5%90%91%E5%90%8C%E4%B8%80%E4%BB%BD%EF%BC%8C%E9%81%BF%E5%85%8D-draft-%E4%B8%8E-antd-%E9%87%8D%E5%A4%8D%E6%89%93%E5%8C%85" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>immutable 指向同一份，避免 draft 与 antd 重复打包</h2>\n<p><code class="language-text">internals/webpack/webpack.base.babel.js</code></p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="43534965060929266000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`\'immutable\': path.resolve(process.cwd(), \'node_modules/immutable\'),`, `43534965060929266000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token string">\'immutable\'</span><span class="token punctuation">:</span> path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>process<span class="token punctuation">.</span><span class="token function">cwd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">\'node_modules/immutable\'</span><span class="token punctuation">)</span><span class="token punctuation">,</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<h2 id="分大模块改写法"><a href="#%E5%88%86%E5%A4%A7%E6%A8%A1%E5%9D%97%E6%94%B9%E5%86%99%E6%B3%95" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>分大模块改写法</h2>\n<h3 id="根据路由来分"><a href="#%E6%A0%B9%E6%8D%AE%E8%B7%AF%E7%94%B1%E6%9D%A5%E5%88%86" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>根据路由来分</h3>\n<p>这里原来的路由引用模块已经是 <code class="language-text">import().then()</code> 形式的了，所以我在 <code class="language-text">webpack</code> 里的 <code class="language-text">splitChunks</code> 加了如下策略</p>\n<p><code class="language-text">internals/webpack/webpack.prod.babel.js</code></p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="52209051260246380000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`splitChunks: {\n  chunks: \'all\', // 不管文件是动态还是非动态载入，统一将文件分离。当页面首次载入会引入所有的包\n  maxInitialRequests: 10, // 最大初始化请求数\n  minSize: 0, // 默认30000，为了不合并 chunk\n  cacheGroups: {\n    vendor: {\n      test: /[\\\\/]node_modules[\\\\/]/,\n      name(module) {\n        const packageName = module.context.match(\n          /[\\\\/]node_modules[\\\\/](.*?)([\\\\/]|\\$)/,\n        )[1];\n        return \\`npm.\\${packageName.replace(\'@\', \'\')}\\`; // 提取各个第三方组件，只在需要时提取\n      },\n    },\n  },\n},`, `52209051260246380000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js">splitChunks<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n  chunks<span class="token punctuation">:</span> <span class="token string">\'all\'</span><span class="token punctuation">,</span> <span class="token comment">// 不管文件是动态还是非动态载入，统一将文件分离。当页面首次载入会引入所有的包</span>\n  maxInitialRequests<span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token comment">// 最大初始化请求数</span>\n  minSize<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token comment">// 默认30000，为了不合并 chunk</span>\n  cacheGroups<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n    vendor<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n      test<span class="token punctuation">:</span> <span class="token regex">/[\\\\/]node_modules[\\\\/]/</span><span class="token punctuation">,</span>\n      <span class="token function">name</span><span class="token punctuation">(</span><span class="token parameter">module</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">const</span> packageName <span class="token operator">=</span> module<span class="token punctuation">.</span>context<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>\n          <span class="token regex">/[\\\\/]node_modules[\\\\/](.*?)([\\\\/]|$)/</span><span class="token punctuation">,</span>\n        <span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n        <span class="token keyword">return</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">npm.</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>packageName<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">\'@\'</span><span class="token punctuation">,</span> <span class="token string">\'\'</span><span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span> <span class="token comment">// 提取各个第三方组件，只在需要时提取</span>\n      <span class="token punctuation">}</span><span class="token punctuation">,</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span><span class="token punctuation">,</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>经实验，可以看到各个页面只加载所需的包</p>\n<h3 id="根据组件来分"><a href="#%E6%A0%B9%E6%8D%AE%E7%BB%84%E4%BB%B6%E6%9D%A5%E5%88%86" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>根据组件来分</h3>\n<p>对其中比较大的组件进行了懒加载处理，react-player/draft/echarts</p>\n<p>其中有一个比较大的问题就是懒加载组件引用不到 ref 的问题，经多次实验，更改写法如下</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="32670125350457480000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`import React from \'react\';\nimport Loadable from \'react-loadable\';\n\nconst LoaderCache = new Map();\nexport default function loadComponent(loader, options) {\n  let component = LoaderCache.get(loader);\n  if (!component) {\n    component = Loadable({\n      loader,\n      loading: (props) => {\n        if (props.error) {\n          // eslint-disable-line\n          console.error(\'[chunk loader]\', props.error); // eslint-disable-line\n        }\n        return <div />;\n      },\n      render: (loaded, props) => {\n        const Component = loaded.default;\n        const { withRef, ...rest } = props; // eslint-disable-line\n        return (\n          <Component\n            ref={(r) => {\n              withRef && withRef(r);\n            }}\n            {...rest}\n          />\n        );\n      },\n      ...options\n    });\n    LoaderCache.set(loader, component);\n    // component.preload();\n  }\n  return component;\n}`, `32670125350457480000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js{16-23} 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight has-highlighted-lines" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">import</span> React <span class="token keyword">from</span> <span class="token string">\'react\'</span><span class="token punctuation">;</span>\n<span class="token keyword">import</span> Loadable <span class="token keyword">from</span> <span class="token string">\'react-loadable\'</span><span class="token punctuation">;</span>\n\n<span class="token keyword">const</span> LoaderCache <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token function">loadComponent</span><span class="token punctuation">(</span><span class="token parameter">loader<span class="token punctuation">,</span> options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">let</span> component <span class="token operator">=</span> LoaderCache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>loader<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>component<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    component <span class="token operator">=</span> <span class="token function">Loadable</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n      loader<span class="token punctuation">,</span>\n      <span class="token function-variable function">loading</span><span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>props<span class="token punctuation">.</span>error<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n          <span class="token comment">// eslint-disable-line</span>\n          console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">\'[chunk loader]\'</span><span class="token punctuation">,</span> props<span class="token punctuation">.</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// eslint-disable-line</span>\n        <span class="token punctuation">}</span>\n        <span class="token keyword">return</span> <span class="token operator">&lt;</span>div <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">;</span>\n<span class="gatsby-highlight-code-line">      <span class="token punctuation">}</span><span class="token punctuation">,</span></span><span class="gatsby-highlight-code-line">      <span class="token function-variable function">render</span><span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token parameter">loaded<span class="token punctuation">,</span> props</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span></span><span class="gatsby-highlight-code-line">        <span class="token keyword">const</span> Component <span class="token operator">=</span> loaded<span class="token punctuation">.</span>default<span class="token punctuation">;</span></span><span class="gatsby-highlight-code-line">        <span class="token keyword">const</span> <span class="token punctuation">{</span> withRef<span class="token punctuation">,</span> <span class="token operator">...</span>rest <span class="token punctuation">}</span> <span class="token operator">=</span> props<span class="token punctuation">;</span> <span class="token comment">// eslint-disable-line</span></span><span class="gatsby-highlight-code-line">        <span class="token keyword">return</span> <span class="token punctuation">(</span></span><span class="gatsby-highlight-code-line">          <span class="token operator">&lt;</span>Component</span><span class="gatsby-highlight-code-line">            ref<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token parameter">r</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span></span><span class="gatsby-highlight-code-line">              withRef <span class="token operator">&amp;&amp;</span> <span class="token function">withRef</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span></span>            <span class="token punctuation">}</span><span class="token punctuation">}</span>\n            <span class="token punctuation">{</span><span class="token operator">...</span>rest<span class="token punctuation">}</span>\n          <span class="token operator">/</span><span class="token operator">></span>\n        <span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span><span class="token punctuation">,</span>\n      <span class="token operator">...</span>options\n    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    LoaderCache<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>loader<span class="token punctuation">,</span> component<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token comment">// component.preload();</span>\n  <span class="token punctuation">}</span>\n  <span class="token keyword">return</span> component<span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>用法：</p>\n<p><code class="language-text">app\\components\\GraphHintTextArea\\index.js</code></p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="81488633019406090000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`import loadComponent from \'utils/loader\';\n\nexport default loadComponent(() => import(/* webpackChunkName: &quot;c-graph-hint-text-area&quot; */ \'./component\'), null);`, `81488633019406090000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">import</span> loadComponent <span class="token keyword">from</span> <span class="token string">\'utils/loader\'</span><span class="token punctuation">;</span>\n\n<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token function">loadComponent</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token comment">/* webpackChunkName: "c-graph-hint-text-area" */</span> <span class="token string">\'./component\'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span></span></pre></div>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="55479443728339590000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`<GraphHintTextArea\n  withRef={(r) => {\n    this.graphHintTextArea = r;\n  }}\n/>`, `55479443728339590000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                jsx 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="jsx"><pre style="counter-reset: linenumber NaN" class="language-jsx line-numbers"><code class="language-jsx"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">GraphHintTextArea</span></span>\n  <span class="token attr-name">withRef</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token parameter">r</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>graphHintTextArea <span class="token operator">=</span> r<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">}</span></span>\n<span class="token punctuation">/></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h2 id="antd-只加载需要的-icon"><a href="#antd-%E5%8F%AA%E5%8A%A0%E8%BD%BD%E9%9C%80%E8%A6%81%E7%9A%84-icon" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>antd 只加载需要的 icon</h2>\n<p><code class="language-text">internals/webpack/webpack.base.babel.js</code></p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="68034528991342260000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`\'@ant-design/icons/lib/dist\\$\': path.resolve(\'app/icons\'),`, `68034528991342260000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token string">\'@ant-design/icons/lib/dist$\'</span><span class="token punctuation">:</span> path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">\'app/icons\'</span><span class="token punctuation">)</span><span class="token punctuation">,</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p><code class="language-text">app/icons/index.js</code></p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="53629220766119220000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// fill\nexport { default as ExclamationCircleFill } from \'@ant-design/icons/lib/fill/ExclamationCircleFill\';\n// outline\nexport { default as QuestionCircleOutline } from \'@ant-design/icons/lib/outline/QuestionCircleOutline\';\n// twotone\nexport { default as ProfileTwoTone } from \'@ant-design/icons/lib/twotone/ProfileTwoTone\';`, `53629220766119220000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">// fill</span>\n<span class="token keyword">export</span> <span class="token punctuation">{</span> <span class="token keyword">default</span> <span class="token keyword">as</span> ExclamationCircleFill <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">\'@ant-design/icons/lib/fill/ExclamationCircleFill\'</span><span class="token punctuation">;</span>\n<span class="token comment">// outline</span>\n<span class="token keyword">export</span> <span class="token punctuation">{</span> <span class="token keyword">default</span> <span class="token keyword">as</span> QuestionCircleOutline <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">\'@ant-design/icons/lib/outline/QuestionCircleOutline\'</span><span class="token punctuation">;</span>\n<span class="token comment">// twotone</span>\n<span class="token keyword">export</span> <span class="token punctuation">{</span> <span class="token keyword">default</span> <span class="token keyword">as</span> ProfileTwoTone <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">\'@ant-design/icons/lib/twotone/ProfileTwoTone\'</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>',
id:"/github/workspace/blog/Webpack升级优化——记一次产品端升级/index.md absPath of file >>> MarkdownRemark",timeToRead:4,frontmatter:{date:"2019-08-20 14:33:00",path:"/webpack-upgrade-about-product/",tags:"前端, 前端构建工具, webpack, 预研",title:"Webpack升级优化——记一次产品端升级",draft:null}},{excerpt:"什么是正则表达式? 正则表达式是一组由字母和符号组成的特殊文本, 它可以用来从文本中找出满足你想要的格式的句子. 一个正则表达式是在一个主体字符串中从左到右匹配字符串时的一种样式. “Regular expression”这个词比较拗口, 我们常使用缩写的术语”regex”或”regexp…",html:'<h2 id="什么是正则表达式"><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>什么是正则表达式?</h2>\n<blockquote>\n<p>正则表达式是一组由字母和符号组成的特殊文本, 它可以用来从文本中找出满足你想要的格式的句子.</p>\n</blockquote>\n<p>一个正则表达式是在一个主体字符串中从左到右匹配字符串时的一种样式. “Regular expression”这个词比较拗口, 我们常使用缩写的术语”regex”或”regexp”. 正则表达式可以从一个基础字符串中根据一定的匹配模式替换文本中的字符串、验证表单、提取字符串等等.</p>\n<p>想象你正在写一个应用, 然后你想设定一个用户命名的规则, 让用户名包含字符,数字,下划线和连字符,以及限制字符的个数,好让名字看起来没那么丑. 我们使用以下正则表达式来验证一个用户名:</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2019-08-02-10-48-56-d88dc13f336df51f9044ca25f7d7c7b1-ad3a8.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 396px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 98.98989898989899%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAIAAAAC64paAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAB00lEQVQ4y5WUV2tCQRCF7///G6JY8UHsIIoiNnwQRRF7773EEm++OOF6b2IMGXBdd/ZMOXNWpVarmc1mp9Pp8/l2u52qqrfbTTXa7W7vd5ONnCuXy2W1WjWbTdbr9ar+xxTJk81mnyJPp9PhcJjP55PJZDAY9Pt99qz7/f4VWM6n02mxWMzlcqVSKRaLeb3eeDzudrt7vd7fmfWB2u22JNRI+QJnMpkXYGEon88vFgvt5wNMYTCn51ZMfsrtcrkMqQIWl8LnfD5bLJafmfV4VofD0e12DWXLV71ex7HdbgkxGo3giSTL5RLXbDYbj8eQzAaeWWmekweYo2AwGAgEGo2G1Wr1+/10GAqFNptNKpWKRCLsK5VKNBrlmt1u5+QBxpAXbZOZlRIIdzwe3+6Gi4Gv12tO8FJRp9N5gLU2hBumykj1xOqv0ZfL5TJk1nMzHA5hQSP2G/9krlarBrA+BAKiw98yM20YeQWW2E/B6Exm9g+wuKDK4/HAdjKZVERA2osVqRBYK1t/QYYKnTDCUJ9nhs9Wq/X0j8HwnumeqzJMdENgNsgLSaEzHjMXeMyo5ZtmP8GUjmISiUQ4HLbZbGgrfjeEZTKZCoUCsmPm6XT6ZyEf8Bhrkc4dD9EAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2019 08 02 10 48 56"\n        title=""\n        src="/static/2019-08-02-10-48-56-d88dc13f336df51f9044ca25f7d7c7b1-ad3a8.png"\n        srcset="/static/2019-08-02-10-48-56-d88dc13f336df51f9044ca25f7d7c7b1-2a85e.png 200w,\n/static/2019-08-02-10-48-56-d88dc13f336df51f9044ca25f7d7c7b1-ad3a8.png 396w"\n        sizes="(max-width: 396px) 100vw, 396px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>以上的正则表达式可以接受 <code class="language-text">john_doe</code>, <code class="language-text">jo-hn_doe</code>, <code class="language-text">john12_as</code>. 但不匹配<code class="language-text">Jo</code>, 因为它包含了大写的字母而且太短了.</p>\n<h2 id="基本匹配"><a href="#%E5%9F%BA%E6%9C%AC%E5%8C%B9%E9%85%8D" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>基本匹配</h2>\n<p>正则表达式其实就是在执行搜索时的格式, 它由一些字母和数字组合而成. 例如: 一个正则表达式 <code class="language-text">the</code>, 它表示一个规则: 由字母<code class="language-text">t</code>开始,接着是<code class="language-text">h</code>,再接着是<code class="language-text">e</code>.</p>\n<pre>\n"the" => The fat cat sat on <a href="#learn-regex"><strong>the</strong></a> mat.\n</pre>\n<p><a href="https://regex101.com/r/dmRygT/1" target="_blank" rel="nofollow noreferrer noopener">在线练习</a></p>\n<p>正则表达式<code class="language-text">123</code>匹配字符串<code class="language-text">123</code>. 它逐个字符的与输入的正则表达式做比较.</p>\n<p>正则表达式是大小写敏感的, 所以<code class="language-text">The</code>不会匹配<code class="language-text">the</code>.</p>\n<pre>\n"The" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on the mat.\n</pre>\n<p><a href="https://regex101.com/r/1paXsy/1" target="_blank" rel="nofollow noreferrer noopener">在线练习</a></p>\n<h2 id="元字符"><a href="#%E5%85%83%E5%AD%97%E7%AC%A6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>元字符</h2>\n<p>正则表达式主要依赖于元字符. 元字符不代表他们本身的字面意思, 他们都有特殊的含义. 一些元字符写在方括号中的时候有一些特殊的意思. 以下是一些元字符的介绍:</p>\n<table>\n<thead>\n<tr>\n<th align="center">元字符</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align="center">.</td>\n<td>句号匹配任意单个字符除了换行符.</td>\n</tr>\n<tr>\n<td align="center">[\n \n]</td>\n<td>字符种类. 匹配方括号内的任意字符.</td>\n</tr>\n<tr>\n<td align="center"><code class="language-text">[^ ]</code></td>\n<td>否定的字符种类. 匹配除了方括号里的任意字符</td>\n</tr>\n<tr>\n<td align="center">*</td>\n<td>匹配>=0 个重复的在\n*\n号之前的字符.</td>\n</tr>\n<tr>\n<td align="center">+</td>\n<td>匹配>=1 个重复的+号前的字符.</td>\n</tr>\n<tr>\n<td align="center">?</td>\n<td>标记?之前的字符为可选.</td>\n</tr>\n<tr>\n<td align="center">{n,m}</td>\n<td>匹配 num 个大括号之前的字符 (n &#x3C;= num &#x3C;= m).</td>\n</tr>\n<tr>\n<td align="center">(xyz)</td>\n<td>字符集, 匹配与 xyz 完全相等的字符串.</td>\n</tr>\n<tr>\n<td align="center">|</td>\n<td>或运算符,匹配符号前或后的字符.</td>\n</tr>\n<tr>\n<td align="center">\\</td>\n<td>转义字符,用于匹配一些保留的字符 \n<code>\n<a href=""> </a>\n { } . \n*\n + ? ^ \n$\n \\ \n|\n</code></td>\n</tr>\n<tr>\n<td align="center">^</td>\n<td>从开始行开始匹配.</td>\n</tr>\n<tr>\n<td align="center">$</td>\n<td>从末端开始匹配.</td>\n</tr>\n</tbody>\n</table>\n<h2 id="点运算符-"><a href="#%E7%82%B9%E8%BF%90%E7%AE%97%E7%AC%A6-" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>点运算符 <code class="language-text">.</code></h2>\n<p><code class="language-text">.</code>是元字符中最简单的例子. <code class="language-text">.</code>匹配任意单个字符, 但不匹配换行符. 例如, 表达式<code class="language-text">.ar</code>匹配一个任意字符后面跟着是<code class="language-text">a</code>和<code class="language-text">r</code>的字符串.</p>\n<pre>\n".ar" => The <a href="#learn-regex"><strong>car</strong></a> <a href="#learn-regex"><strong>par</strong></a>ked in the <a href="#learn-regex"><strong>gar</strong></a>age.\n</pre>\n<p><a href="https://regex101.com/r/xc9GkU/1" target="_blank" rel="nofollow noreferrer noopener">在线练习</a></p>\n<h2 id="字符集"><a href="#%E5%AD%97%E7%AC%A6%E9%9B%86" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>字符集</h2>\n<p>字符集也叫做字符类. 方括号用来指定一个字符集. 在方括号中使用连字符来指定字符集的范围. 在方括号中的字符集不关心顺序. 例如, 表达式<code class="language-text">[Tt]he</code> 匹配 <code class="language-text">the</code> 和 <code class="language-text">The</code>.</p>\n<pre>\n"[Tt]he" => <a href="#learn-regex"><strong>The</strong></a> car parked in <a href="#learn-regex"><strong>the</strong></a> garage.\n</pre>\n<p><a href="https://regex101.com/r/2ITLQ4/1" target="_blank" rel="nofollow noreferrer noopener">在线练习</a></p>\n<p>方括号的句号就表示句号. 表达式 <code class="language-text">ar[.]</code> 匹配 <code class="language-text">ar.</code>字符串</p>\n<pre>\n"ar[.]" => A garage is a good place to park a c<a href="#learn-regex"><strong>ar.</strong></a>\n</pre>\n<p><a href="https://regex101.com/r/wL3xtE/1" target="_blank" rel="nofollow noreferrer noopener">在线练习</a></p>\n<h3 id="否定字符集"><a href="#%E5%90%A6%E5%AE%9A%E5%AD%97%E7%AC%A6%E9%9B%86" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>否定字符集</h3>\n<p>一般来说 <code class="language-text">^</code> 表示一个字符串的开头, 但它用在一个方括号的开头的时候, 它表示这个字符集是否定的. 例如, 表达式<code class="language-text">[^c]ar</code> 匹配一个后面跟着<code class="language-text">ar</code>的除了<code class="language-text">c</code>的任意字符.</p>\n<pre>\n"[^c]ar" => The car <a href="#learn-regex"><strong>par</strong></a>ked in the <a href="#learn-regex"><strong>gar</strong></a>age.\n</pre>\n<p><a href="https://regex101.com/r/nNNlq3/1" target="_blank" rel="nofollow noreferrer noopener">在线练习</a></p>\n<h2 id="重复次数"><a href="#%E9%87%8D%E5%A4%8D%E6%AC%A1%E6%95%B0" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>重复次数</h2>\n<p>后面跟着元字符 <code class="language-text">+</code>, <code class="language-text">*</code> or <code class="language-text">?</code> 的, 用来指定匹配子模式的次数. 这些元字符在不同的情况下有着不同的意思.</p>\n<h3 id="-号"><a href="#-%E5%8F%B7" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code class="language-text">*</code> 号</h3>\n<p><code class="language-text">*</code>号匹配 在<code class="language-text">*</code>之前的字符出现<code class="language-text">大于等于0</code>次. 例如, 表达式 <code class="language-text">a*</code> 匹配以 0 或更多个 a 开头的字符, 因为有 0 个这个条件, 其实也就匹配了所有的字符. 表达式<code class="language-text">[a-z]*</code> 匹配一个行中所有以小写字母开头的字符串.</p>\n<pre>\n"[a-z]*" => T<a href="#learn-regex"><strong>he</strong></a> <a href="#learn-regex"><strong>car</strong></a> <a href="#learn-regex"><strong>parked</strong></a> <a href="#learn-regex"><strong>in</strong></a> <a href="#learn-regex"><strong>the</strong></a> <a href="#learn-regex"><strong>garage</strong></a> #21.\n</pre>\n<p><a href="https://regex101.com/r/7m8me5/1" target="_blank" rel="nofollow noreferrer noopener">在线练习</a></p>\n<p><code class="language-text">*</code>字符和<code class="language-text">.</code>字符搭配可以匹配所有的字符<code class="language-text">.*</code>. <code class="language-text">*</code>和表示匹配空格的符号<code class="language-text">\\s</code>连起来用, 如表达式<code class="language-text">\\s*cat\\s*</code>匹配 0 或更多个空格开头和 0 或更多个空格结尾的 cat 字符串.</p>\n<pre>\n"\\s*cat\\s*" => The fat<a href="#learn-regex"><strong> cat </strong></a>sat on the con<a href="#learn-regex"><strong>cat</strong></a>enation.\n</pre>\n<p><a href="https://regex101.com/r/gGrwuz/1" target="_blank" rel="nofollow noreferrer noopener">在线练习</a></p>\n<h3 id="-号-1"><a href="#-%E5%8F%B7-1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code class="language-text">+</code> 号</h3>\n<p><code class="language-text">+</code>号匹配<code class="language-text">+</code>号之前的字符出现 >=1 次. 例如表达式<code class="language-text">c.+t</code> 匹配以首字母<code class="language-text">c</code>开头以<code class="language-text">t</code>结尾,中间跟着任意个字符的字符串.</p>\n<pre>\n"c.+t" => The fat <a href="#learn-regex"><strong>cat sat on the mat</strong></a>.\n</pre>\n<p><a href="https://regex101.com/r/Dzf9Aa/1" target="_blank" rel="nofollow noreferrer noopener">在线练习</a></p>\n<h3 id="-号-2"><a href="#-%E5%8F%B7-2" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code class="language-text">?</code> 号</h3>\n<p>在正则表达式中元字符 <code class="language-text">?</code> 标记在符号前面的字符为可选, 即出现 0 或 1 次. 例如, 表达式 <code class="language-text">[T]?he</code> 匹配字符串 <code class="language-text">he</code> 和 <code class="language-text">The</code>.</p>\n<pre>\n"[T]he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in the garage.\n</pre>\n<p><a href="https://regex101.com/r/cIg9zm/1" target="_blank" rel="nofollow noreferrer noopener">在线练习</a></p>\n<pre>\n"[T]?he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in t<a href="#learn-regex"><strong>he</strong></a> garage.\n</pre>\n<p><a href="https://regex101.com/r/kPpO2x/1" target="_blank" rel="nofollow noreferrer noopener">在线练习</a></p>\n<h2 id="-号-3"><a href="#-%E5%8F%B7-3" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code class="language-text">{}</code> 号</h2>\n<p>在正则表达式中 <code class="language-text">{}</code> 是一个量词, 常用来一个或一组字符可以重复出现的次数. 例如, 表达式 <code class="language-text">[0-9]{2,3}</code> 匹配最少 2 位最多 3 位 0~9 的数字.</p>\n<pre>\n"[0-9]{2,3}" => The number was 9.<a href="#learn-regex"><strong>999</strong></a>7 but we rounded it off to <a href="#learn-regex"><strong>10</strong></a>.0.\n</pre>\n<p><a href="https://regex101.com/r/juM86s/1" target="_blank" rel="nofollow noreferrer noopener">在线练习</a></p>\n<p>我们可以省略第二个参数. 例如, <code class="language-text">[0-9]{2,}</code> 匹配至少两位 0~9 的数字.</p>\n<pre>\n"[0-9]{2,}" => The number was 9.<a href="#learn-regex"><strong>9997</strong></a> but we rounded it off to <a href="#learn-regex"><strong>10</strong></a>.0.\n</pre>\n<p><a href="https://regex101.com/r/Gdy4w5/1" target="_blank" rel="nofollow noreferrer noopener">在线练习</a></p>\n<p>如果逗号也省略掉则表示重复固定的次数. 例如, <code class="language-text">[0-9]{3}</code> 匹配 3 位数字</p>\n<pre>\n"[0-9]{3}" => The number was 9.<a href="#learn-regex"><strong>999</strong></a>7 but we rounded it off to 10.0.\n</pre>\n<p><a href="https://regex101.com/r/Sivu30/1" target="_blank" rel="nofollow noreferrer noopener">在线练习</a></p>\n<h2 id="-特征标群"><a href="#-%E7%89%B9%E5%BE%81%E6%A0%87%E7%BE%A4" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code class="language-text">(...)</code> 特征标群</h2>\n<p>特征标群是一组写在 <code class="language-text">(...)</code> 中的子模式. 例如之前说的 <code class="language-text">{}</code> 是用来表示前面一个字符出现指定次数. 但如果在 <code class="language-text">{}</code> 前加入特征标群则表示整个标群内的字符重复 N 次. 例如, 表达式 <code class="language-text">(ab)*</code> 匹配连续出现 0 或更多个 <code class="language-text">ab</code>.</p>\n<p>我们还可以在 <code class="language-text">()</code> 中用或字符 <code class="language-text">|</code> 表示或. 例如, <code class="language-text">(c|g|p)ar</code> 匹配 <code class="language-text">car</code> 或 <code class="language-text">gar</code> 或 <code class="language-text">par</code>.</p>\n<pre>\n"(c|g|p)ar" => The <a href="#learn-regex"><strong>car</strong></a> is <a href="#learn-regex"><strong>par</strong></a>ked in the <a href="#learn-regex"><strong>gar</strong></a>age.\n</pre>\n<p><a href="https://regex101.com/r/tUxrBG/1" target="_blank" rel="nofollow noreferrer noopener">在线练习</a></p>\n<h2 id="-或运算符"><a href="#-%E6%88%96%E8%BF%90%E7%AE%97%E7%AC%A6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code class="language-text">|</code> 或运算符</h2>\n<p>或运算符就表示或, 用作判断条件.</p>\n<p>例如 <code class="language-text">(T|t)he|car</code> 匹配 <code class="language-text">(T|t)he</code> 或 <code class="language-text">car</code>.</p>\n<pre>\n"(T|t)he|car" => <a href="#learn-regex"><strong>The</strong></a> <a href="#learn-regex"><strong>car</strong></a> is parked in <a href="#learn-regex"><strong>the</strong></a> garage.\n</pre>\n<p><a href="https://regex101.com/r/fBXyX0/1" target="_blank" rel="nofollow noreferrer noopener">在线练习</a></p>\n<h2 id="转码特殊字符"><a href="#%E8%BD%AC%E7%A0%81%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>转码特殊字符</h2>\n<p>反斜线 <code class="language-text">\\</code> 在表达式中用于转码紧跟其后的字符. 用于指定 <code class="language-text">{ } [ ] / \\ + * . $ ^ | ?</code> 这些特殊字符. 如果想要匹配这些特殊字符则要在其前面加上反斜线 <code class="language-text">\\</code>.</p>\n<p>例如 <code class="language-text">.</code> 是用来匹配除换行符外的所有字符的. 如果想要匹配句子中的 <code class="language-text">.</code> 则要写成 <code class="language-text">\\.</code> 以下这个例子 <code class="language-text">\\.?</code>是选择性匹配<code class="language-text">.</code></p>\n<pre>\n"(f|c|m)at\\.?" => The <a href="#learn-regex"><strong>fat</strong></a> <a href="#learn-regex"><strong>cat</strong></a> sat on the <a href="#learn-regex"><strong>mat.</strong></a>\n</pre>\n<p><a href="https://regex101.com/r/DOc5Nu/1" target="_blank" rel="nofollow noreferrer noopener">在线练习</a></p>\n<h2 id="锚点"><a href="#%E9%94%9A%E7%82%B9" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>锚点</h2>\n<p>在正则表达式中, 想要匹配指定开头或结尾的字符串就要使用到锚点. <code class="language-text">^</code> 指定开头, <code class="language-text">$</code> 指定结尾.</p>\n<h3 id="-号-4"><a href="#-%E5%8F%B7-4" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code class="language-text">^</code> 号</h3>\n<p><code class="language-text">^</code> 用来检查匹配的字符串是否在所匹配字符串的开头.</p>\n<p>例如, 在 <code class="language-text">abc</code> 中使用表达式 <code class="language-text">^a</code> 会得到结果 <code class="language-text">a</code>. 但如果使用 <code class="language-text">^b</code> 将匹配不到任何结果. 因为在字符串 <code class="language-text">abc</code> 中并不是以 <code class="language-text">b</code> 开头.</p>\n<p>例如, <code class="language-text">^(T|t)he</code> 匹配以 <code class="language-text">The</code> 或 <code class="language-text">the</code> 开头的字符串.</p>\n<pre>\n"(T|t)he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in <a href="#learn-regex"><strong>the</strong></a> garage.\n</pre>\n<p><a href="https://regex101.com/r/5ljjgB/1" target="_blank" rel="nofollow noreferrer noopener">在线练习</a></p>\n<pre>\n"^(T|t)he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in the garage.\n</pre>\n<p><a href="https://regex101.com/r/jXrKne/1" target="_blank" rel="nofollow noreferrer noopener">在线练习</a></p>\n<h3 id="-号-5"><a href="#-%E5%8F%B7-5" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code class="language-text">$</code> 号</h3>\n<p>同理于 <code class="language-text">^</code> 号, <code class="language-text">$</code> 号用来匹配字符是否是最后一个.</p>\n<p>例如, <code class="language-text">(at\\.)$</code> 匹配以 <code class="language-text">at.</code> 结尾的字符串.</p>\n<pre>\n"(at\\.)" => The fat c<a href="#learn-regex"><strong>at.</strong></a> s<a href="#learn-regex"><strong>at.</strong></a> on the m<a href="#learn-regex"><strong>at.</strong></a>\n</pre>\n<p><a href="https://regex101.com/r/y4Au4D/1" target="_blank" rel="nofollow noreferrer noopener">在线练习</a></p>\n<pre>\n"(at\\.)$" => The fat cat. sat. on the m<a href="#learn-regex"><strong>at.</strong></a>\n</pre>\n<p><a href="https://regex101.com/r/t0AkOd/1" target="_blank" rel="nofollow noreferrer noopener">在线练习</a></p>\n<h2 id="简写字符集"><a href="#%E7%AE%80%E5%86%99%E5%AD%97%E7%AC%A6%E9%9B%86" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>简写字符集</h2>\n<p>正则表达式提供一些常用的字符集简写. 如下:</p>\n<table>\n<thead>\n<tr>\n<th align="center">简写</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align="center">.</td>\n<td>除换行符外的所有字符</td>\n</tr>\n<tr>\n<td align="center">\\w</td>\n<td>匹配所有字母数字, 等同于 \n<code class="language-text">[a-zA-Z0-9_]</code></td>\n</tr>\n<tr>\n<td align="center">\\W</td>\n<td>匹配所有非字母数字, 即符号, 等同于: \n<code class="language-text">[^\\w]</code></td>\n</tr>\n<tr>\n<td align="center">\\d</td>\n<td>匹配数字: \n<code class="language-text">[0-9]</code></td>\n</tr>\n<tr>\n<td align="center">\\D</td>\n<td>匹配非数字: \n<code class="language-text">[^\\d]</code></td>\n</tr>\n<tr>\n<td align="center">\\s</td>\n<td>匹配所有空格字符, 等同于: \n<code class="language-text">[\\t\\n\\f\\r\\p{Z}]</code></td>\n</tr>\n<tr>\n<td align="center">\\S</td>\n<td>匹配所有非空格字符: \n<code class="language-text">[^\\s]</code></td>\n</tr>\n<tr>\n<td align="center">\\f</td>\n<td>匹配一个换页符</td>\n</tr>\n<tr>\n<td align="center">\\n</td>\n<td>匹配一个换行符</td>\n</tr>\n<tr>\n<td align="center">\\r</td>\n<td>匹配一个回车符</td>\n</tr>\n<tr>\n<td align="center">\\t</td>\n<td>匹配一个制表符</td>\n</tr>\n<tr>\n<td align="center">\\v</td>\n<td>匹配一个垂直制表符</td>\n</tr>\n<tr>\n<td align="center">\\p</td>\n<td>匹配 CR/LF (等同于 \n<code class="language-text">\\r\\n</code>\n)，用来匹配 DOS 行终止符</td>\n</tr>\n</tbody>\n</table>\n<h2 id="零宽度断言前后预查"><a href="#%E9%9B%B6%E5%AE%BD%E5%BA%A6%E6%96%AD%E8%A8%80%E5%89%8D%E5%90%8E%E9%A2%84%E6%9F%A5" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>零宽度断言(前后预查)</h2>\n<p>先行断言和后发断言都属于<strong>非捕获簇</strong>(不捕获文本 ，也不针对组合计进行计数). 先行断言用于判断所匹配的格式是否在另一个确定的格式之前, 匹配结果不包含该确定格式(仅作为约束).</p>\n<p>例如, 我们想要获得所有跟在 <code class="language-text">$</code> 符号后的数字, 我们可以使用正后发断言 <code class="language-text">(?&lt;=\\$)[0-9\\.]*</code>. 这个表达式匹配 <code class="language-text">$</code> 开头, 之后跟着 <code class="language-text">0,1,2,3,4,5,6,7,8,9,.</code> 这些字符可以出现大于等于 0 次.</p>\n<p>零宽度断言如下:</p>\n<table>\n<thead>\n<tr>\n<th align="center">符号</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align="center">?=</td>\n<td>正先行断言-存在</td>\n</tr>\n<tr>\n<td align="center">?!</td>\n<td>负先行断言-排除</td>\n</tr>\n<tr>\n<td align="center">?&#x3C;=</td>\n<td>正后发断言-存在</td>\n</tr>\n<tr>\n<td align="center">?&#x3C;!</td>\n<td>负后发断言-排除</td>\n</tr>\n</tbody>\n</table>\n<h3 id="-正先行断言"><a href="#-%E6%AD%A3%E5%85%88%E8%A1%8C%E6%96%AD%E8%A8%80" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code class="language-text">?=...</code> 正先行断言</h3>\n<p><code class="language-text">?=...</code> 正先行断言, 表示第一部分表达式之后必须跟着 <code class="language-text">?=...</code>定义的表达式.</p>\n<p>返回结果只包含满足匹配条件的第一部分表达式. 定义一个正先行断言要使用 <code class="language-text">()</code>. 在括号内部使用一个问号和等号: <code class="language-text">(?=...)</code>.</p>\n<p>正先行断言的内容写在括号中的等号后面. 例如, 表达式 <code class="language-text">(T|t)he(?=\\sfat)</code> 匹配 <code class="language-text">The</code> 和 <code class="language-text">the</code>, 在括号中我们又定义了正先行断言 <code class="language-text">(?=\\sfat)</code> ,即 <code class="language-text">The</code> 和 <code class="language-text">the</code> 后面紧跟着 <code class="language-text">(空格)fat</code>.</p>\n<pre>\n"(T|t)he(?=\\sfat)" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on the mat.\n</pre>\n<p><a href="https://regex101.com/r/IDDARt/1" target="_blank" rel="nofollow noreferrer noopener">在线练习</a></p>\n<h3 id="-负先行断言"><a href="#-%E8%B4%9F%E5%85%88%E8%A1%8C%E6%96%AD%E8%A8%80" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code class="language-text">?!...</code> 负先行断言</h3>\n<p>负先行断言 <code class="language-text">?!</code> 用于筛选所有匹配结果, 筛选条件为 其后不跟随着断言中定义的格式. <code class="language-text">正先行断言</code> 定义和 <code class="language-text">负先行断言</code> 一样, 区别就是 <code class="language-text">=</code> 替换成 <code class="language-text">!</code> 也就是 <code class="language-text">(?!...)</code>.</p>\n<p>表达式 <code class="language-text">(T|t)he(?!\\sfat)</code> 匹配 <code class="language-text">The</code> 和 <code class="language-text">the</code>, 且其后不跟着 <code class="language-text">(空格)fat</code>.</p>\n<pre>\n"(T|t)he(?!\\sfat)" => The fat cat sat on <a href="#learn-regex"><strong>the</strong></a> mat.\n</pre>\n<p><a href="https://regex101.com/r/V32Npg/1" target="_blank" rel="nofollow noreferrer noopener">在线练习</a></p>\n<h3 id="--正后发断言"><a href="#--%E6%AD%A3%E5%90%8E%E5%8F%91%E6%96%AD%E8%A8%80" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code class="language-text">?&lt;= ...</code> 正后发断言</h3>\n<p>正后发断言 记作<code class="language-text">(?&lt;=...)</code> 用于筛选所有匹配结果, 筛选条件为 其前跟随着断言中定义的格式. 例如, 表达式 <code class="language-text">(?&lt;=(T|t)he\\s)(fat|mat)</code> 匹配 <code class="language-text">fat</code> 和 <code class="language-text">mat</code>, 且其前跟着 <code class="language-text">The</code> 或 <code class="language-text">the</code>.</p>\n<pre>\n"(?<=(T|t)he\\s)(fat|mat)" => The <a href="#learn-regex"><strong>fat</strong></a> cat sat on the <a href="#learn-regex"><strong>mat</strong></a>.\n</pre>\n<p><a href="https://regex101.com/r/avH165/1" target="_blank" rel="nofollow noreferrer noopener">在线练习</a></p>\n<h3 id="-负后发断言"><a href="#-%E8%B4%9F%E5%90%8E%E5%8F%91%E6%96%AD%E8%A8%80" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code class="language-text">?&lt;!...</code> 负后发断言</h3>\n<p>负后发断言 记作 <code class="language-text">(?&lt;!...)</code> 用于筛选所有匹配结果, 筛选条件为 其前不跟随着断言中定义的格式. 例如, 表达式 <code class="language-text">(?&lt;!(T|t)he\\s)(cat)</code> 匹配 <code class="language-text">cat</code>, 且其前不跟着 <code class="language-text">The</code> 或 <code class="language-text">the</code>.</p>\n<pre>\n"(?&lt;!(T|t)he\\s)(cat)" => The cat sat on <a href="#learn-regex"><strong>cat</strong></a>.\n</pre>\n<p><a href="https://regex101.com/r/8Efx5G/1" target="_blank" rel="nofollow noreferrer noopener">在线练习</a></p>\n<h2 id="标志"><a href="#%E6%A0%87%E5%BF%97" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>标志</h2>\n<p>标志也叫模式修正符, 因为它可以用来修改表达式的搜索结果. 这些标志可以任意的组合使用, 它也是整个正则表达式的一部分.</p>\n<table>\n<thead>\n<tr>\n<th align="center">标志</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align="center">i</td>\n<td>忽略大小写.</td>\n</tr>\n<tr>\n<td align="center">g</td>\n<td>全局搜索.</td>\n</tr>\n<tr>\n<td align="center">m</td>\n<td>多行的: 锚点元字符 \n<code class="language-text">^</code>\n \n<code class="language-text">$</code>\n 工作范围在每行的起始.</td>\n</tr>\n</tbody>\n</table>\n<h3 id="忽略大小写-case-insensitive"><a href="#%E5%BF%BD%E7%95%A5%E5%A4%A7%E5%B0%8F%E5%86%99-case-insensitive" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>忽略大小写 (Case Insensitive)</h3>\n<p>修饰语 <code class="language-text">i</code> 用于忽略大小写. 例如, 表达式 <code class="language-text">/The/gi</code> 表示在全局搜索 <code class="language-text">The</code>, 在后面的 <code class="language-text">i</code> 将其条件修改为忽略大小写, 则变成搜索 <code class="language-text">the</code> 和 <code class="language-text">The</code>, <code class="language-text">g</code> 表示全局搜索.</p>\n<pre>\n"The" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on the mat.\n</pre>\n<p><a href="https://regex101.com/r/dpQyf9/1" target="_blank" rel="nofollow noreferrer noopener">在线练习</a></p>\n<pre>\n"/The/gi" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on <a href="#learn-regex"><strong>the</strong></a> mat.\n</pre>\n<p><a href="https://regex101.com/r/ahfiuh/1" target="_blank" rel="nofollow noreferrer noopener">在线练习</a></p>\n<h3 id="全局搜索-global-search"><a href="#%E5%85%A8%E5%B1%80%E6%90%9C%E7%B4%A2-global-search" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>全局搜索 (Global search)</h3>\n<p>修饰符 <code class="language-text">g</code> 常用于执行一个全局搜索匹配, 即(不仅仅返回第一个匹配的, 而是返回全部). 例如, 表达式 <code class="language-text">/.(at)/g</code> 表示搜索 任意字符(除了换行) + <code class="language-text">at</code>, 并返回全部结果.</p>\n<pre>\n"/.(at)/" => The <a href="#learn-regex"><strong>fat</strong></a> cat sat on the mat.\n</pre>\n<p><a href="https://regex101.com/r/jnk6gM/1" target="_blank" rel="nofollow noreferrer noopener">在线练习</a></p>\n<pre>\n"/.(at)/g" => The <a href="#learn-regex"><strong>fat</strong></a> <a href="#learn-regex"><strong>cat</strong></a> <a href="#learn-regex"><strong>sat</strong></a> on the <a href="#learn-regex"><strong>mat</strong></a>.\n</pre>\n<p><a href="https://regex101.com/r/dO1nef/1" target="_blank" rel="nofollow noreferrer noopener">在线练习</a></p>\n<h3 id="多行修饰符-multiline"><a href="#%E5%A4%9A%E8%A1%8C%E4%BF%AE%E9%A5%B0%E7%AC%A6-multiline" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>多行修饰符 (Multiline)</h3>\n<p>多行修饰符 <code class="language-text">m</code> 常用语执行一个多行匹配.</p>\n<p>像之前介绍的 <code class="language-text">(^,$)</code> 用于检查格式是否是在待检测字符串的开头或结尾. 但我们如果想要它在每行的开头和结尾生效, 我们需要用到多行修饰符 <code class="language-text">m</code>.</p>\n<p>例如, 表达式 <code class="language-text">/at(.)?$/gm</code> 表示小写字符 <code class="language-text">a</code> 后跟小写字符 <code class="language-text">t</code> , 末尾可选除换行符外任意字符. 根据 <code class="language-text">m</code> 修饰符, 现在表达式匹配每行的结尾.</p>\n<pre>\n"/.at(.)?$/" => The fat\n                cat sat\n                on the <a href="#learn-regex"><strong>mat.</strong></a>\n</pre>\n<p><a href="https://regex101.com/r/hoGMkP/1" target="_blank" rel="nofollow noreferrer noopener">在线练习</a></p>\n<pre>\n"/.at(.)?$/gm" => The <a href="#learn-regex"><strong>fat</strong></a>\n                  cat <a href="#learn-regex"><strong>sat</strong></a>\n                  on the <a href="#learn-regex"><strong>mat.</strong></a>\n</pre>\n<p><a href="https://regex101.com/r/E88WE2/1" target="_blank" rel="nofollow noreferrer noopener">在线练习</a></p>\n<h3 id="贪婪匹配与惰性匹配-greedy-vs-lazy-matching"><a href="#%E8%B4%AA%E5%A9%AA%E5%8C%B9%E9%85%8D%E4%B8%8E%E6%83%B0%E6%80%A7%E5%8C%B9%E9%85%8D-greedy-vs-lazy-matching" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>贪婪匹配与惰性匹配 (Greedy vs lazy matching)</h3>\n<p>正则表达式默认采用贪婪匹配模式，在该模式下意味着会匹配尽可能长的子串。我们可以使用 <code class="language-text">?</code> 将贪婪匹配模式转化为惰性匹配模式。</p>\n<pre>\n"/(.*at)/" => <a href="#learn-regex"><strong>The fat cat sat on the mat</strong></a>. </pre>\n<p><a href="https://regex101.com/r/AyAdgJ/1" target="_blank" rel="nofollow noreferrer noopener">在线练习</a></p>\n<pre>\n"/(.*?at)/" => <a href="#learn-regex"><strong>The fat</strong></a> cat sat on the mat. </pre>\n<p><a href="https://regex101.com/r/AyAdgJ/2" target="_blank" rel="nofollow noreferrer noopener">在线练习</a></p>',
id:"/github/workspace/blog/正则表达式入门学习/index.md absPath of file >>> MarkdownRemark",timeToRead:13,frontmatter:{date:"2019-08-02 10:36:31",path:"/regex-introduce-learn/",tags:"正则表达式",title:"正则表达式入门学习",draft:null}}],page:20,pagesSum:38,length:186,prevPath:"/page/19",nextPath:"/page/21"}}}});