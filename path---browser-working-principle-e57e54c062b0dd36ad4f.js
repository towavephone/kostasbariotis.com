webpackJsonp([29664229663391],{1063:function(a,e){a.exports={data:{file:{childImageSharp:{sizes:{base64:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAeCAYAAAAsEj5rAAAACXBIWXMAAAsSAAALEgHS3X78AAAHlUlEQVRIx11WaWxU1xWewbQlrdofkSIhGiBpMPZ4Vs/2lpm3zupZPOOZ8Sz2YGzANkaAKaYQUrMkLYgiIlxCQjCYQAwYEoMQNJAIFBxaQgUhoCopYceBJo1pKFVDCbOc0/fesOZKV+fM1Tvf/c56R0VYOZW8lvAxtSybvbExAu1+mndGuaDQ2F4rNHVFhCZJZlMeZ1Qrf9Mt+H+qur/ihFORAFA64J0pVTcXVcDmcKFfruIzZ7rY1H89fAZivjbM1MzFxkAnZqWd9M7KJcTmv7zCN44sY+tflm12C79WLxLCqidWN9cwWpYvsfXL13vasZudgm4mgX4hW6h1teRjnrZCwjOzWO/twIR/FjZ7WnEZ35JvcUSeU4gwSXV7W1sJzEH6R8nSRArlXjr6r7S1DqNUvMAzCXCzSfDxDRAUmyDkaoawtEPi1LxHyGLMkby5gEqUy7atjnq1roosAXqE6Yq7DBXa7RLS6HRG8y4hhbwzDiJbj4IkXUwS5e1h07IOorMePUL6ruiKGmRblg2PesJlq9nxrJMMfydIbhIWP9jMPrBLkrIHgXfG0CdmgKMjwFARFKVvHEQo5xUyKDDRN2T7aE17mV5rfZQYm1lM0EQYWUe0aNTxoKl0Qnk5jVqNA/VaFu3SBS7SB7Ju0ougr2KKWg2DBi17mbCaxyghMzgeMTTp2W7CGkTKHshZqn0Q5Osg6opBhAmAzcADY/NheyQJBi2D8mXVehYMOgEsJg9aTIxSN2YTO+ohQ62G6rGZa5AmAjmj0YvzG5vhVP8f4fTO12FtVxfMjTfC6zPbwOsIQNybhK6GlmLCm5DA6cu2aoeSaaOeVheLxRKgpoJcZ5UAly94MeeiQ+jnQtBCcTBTZ8Ght9fDfy58DDdOHIRj2zdA/4uzYWBpZ6Fr6jR8/lfWP8n2usqA2mQgH7msr3Ks0WgEfGvN6lz/q6tgXqgZjgpZOGSLwsldA4CFG4j3rmP/osU47xkdrm5pLfjdETm+p64cf0fJME34HiVFV+VYajF50UGGc/Nnz4XDfW/ArQ09+M++XsCblwD+fQEL356HswuWwdedS+Dg2p5ilZQwa7VrpCHZ9nOl7Ojg44B0hxxg0hbMjx2rh2iwDk4feReKI58hfn8V8c5lwNyXiF+dRbz4Z1jY1g4TJ1rQbnHfc/ORihJDr5q0kw8AyVqDjpeSEpJLAyaMN6HRwMDuTa/B1fcPwcfbBuHc8SPw+cnDsGvzeim7HOg0DpAYoouPBWUMJxUo65y18X4MtbYJOo3zjgQoxwWen1iNDdPmwPu9+2BvfCXsXbQRehf9Hly0B8aN04OuioGqCipvt/hQ5GLzS4Dh0Tdv3+/nvm0qVVUlfUouboOWK8jxmaznMBXIwpbfroWN63th384tcHTfDpj0gg21lQxoK+m8TQGMb5UxAt6OUYSVkUuGK5MPKiuIHicZwWqDmNNqpE6pIFBjpGDxsqXwuxUroWtBN5w4NgSbNvcDIRW61CUFu9UrtV/si7Fjf/ajUmICSvxKgJMtdQxVK2XOU9RpGNBL3VBeQWIqPR3SjR3QOW8xrFmxCnrWbYJMaobEkr1HE/4zIpv4nrK7NIrbpF+tspoYZdpMLte+wNPRu6S1Bs1GqV/1DOqMPFjIMFbq3dg6cyFkGmagqZqHaoOAHF2XZ6ngWg+XBM4RVoLHOWrLVG4uWpo4FvsvfHz6NktFkbT6QafnQGsUoFLHYm1dFj44cgwYPgQVkymkbP6RWl+LNIRjL/uFhltuNjEoYySCXaNUojOsMPSw4aqwa+o9ga5DggiC1RFDmyMG1bYQVlTSIIhRMJq9RaPZJ4VF+DQZ6MCAmOkLurJ/DYiNt/R67VMKs4hrqjL+o+6mjrj0hjBEOG+1h8FOxcFO1oHVFgazPYQGqdfNthBYpUqwEME78nsT4tP7o96WwWSwA1nKb35iyCZ8M85EXE3oYBO3ab4RKWcSKCaFJJMCQprSpPQcUFwKzWQUKo1+lC9x0r7Fcc+0OVOj8zEkNrY8BAuLDV11ruZvDXrhuJ3NIu+bAYK/FXjfdOA8zegUp6DdmQKNMQD+8HTseW1LYeijE/jB4Q+/Wry8a5L01B6MeaetUcDSjfVjjOVM7da+bTMPvHfkbmrKb5DksjkLncmZqXTe6siAnWmAmkhbYUPvQP7cufO5L69fxyvD/8Ctb+/aI2PU8AmvRGqZAoiIityzb8/T165d3X3t2vD/Pjr+KW7b+R6u2/AOrli9CQfePYQXLg3jpSvDeOLkWTxw6Oh3uwYPrJTMlNHlFcLPeNk6/UOXZ7cuGP1A397fP/7v584vvzJ8o+dvn33+Zm/v9q9X/2EDbN+19+ybm3ds33/ww5f63uovf/D9woVL1A90P5dQqYaGhpQfg4N71BJbteoHqyk7Z+e8zlfuSupPHj+/eO2bso5ZcxQ9Fsiqgny6ZOv3+VTfjIwo+iefnFYN7BxQf3FxuEwGH1c+fgxBuIZnTFuIIh9U2qt3844fb9y0Vf0gXPKm7bzKzYZ+wGTKFFWNz1/6v8OLUiuaFKMJz00yEvaa/RQZnK086s6MutpEqRLx+kcT+rH1f+YikeeNfqnwAAAAAElFTkSuQmCC",aspectRatio:.6666666666666666,src:"/static/avatar-a4ccbab8e7381acb89452773ce94d5a0-25c91.png",srcSet:"/static/avatar-a4ccbab8e7381acb89452773ce94d5a0-8a97b.png 200w,\n/static/avatar-a4ccbab8e7381acb89452773ce94d5a0-0fdf3.png 400w,\n/static/avatar-a4ccbab8e7381acb89452773ce94d5a0-25c91.png 600w",srcWebp:"/static/avatar-a4ccbab8e7381acb89452773ce94d5a0-216f6.webp",srcSetWebp:"/static/avatar-a4ccbab8e7381acb89452773ce94d5a0-5d70e.webp 200w,\n/static/avatar-a4ccbab8e7381acb89452773ce94d5a0-d1677.webp 400w,\n/static/avatar-a4ccbab8e7381acb89452773ce94d5a0-216f6.webp 600w",sizes:"(max-width: 600px) 100vw, 600px"}}},site:{siteMetadata:{title:"女王控的博客",description:'前端工程师，黑猫女王控，欢迎勾搭，技术相关<a href="https://github.com/towavephone" target="_blank">@towavephone</a>，QQ闲聊<a href="tencent://AddContact/?fromId=45&fromSubId=1&subcmd=all&uin=634407147&website=www.oicqzone.com">@towave</a>，bili关注<a href="https://space.bilibili.com/11507708#/" target="_blank">@towave</a>',siteUrl:"https://blog.towavephone.com"}},mainPost:{html:'<h1 id="简介"><a href="#%E7%AE%80%E4%BB%8B" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>简介</h1>\n<p>网络浏览器很可能是使用最广的软件。在这篇入门文章中，我将会介绍它们的幕后工作原理。我们会了解到，从您在地址栏输入 google.com 直到您在浏览器屏幕上看到 Google 首页的整个过程中都发生了些什么。</p>\n<h2 id="浏览器的主要功能"><a href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>浏览器的主要功能</h2>\n<p>浏览器的主要功能就是向服务器发出请求，在浏览器窗口中展示您选择的网络资源。这里所说的资源一般是指 HTML 文档，也可以是 PDF、图片或其他的类型。资源的位置由用户使用 URI（统一资源标示符）指定。</p>\n<p>浏览器解释并显示 HTML 文件的方式是在 HTML 和 CSS 规范中指定的。这些规范由网络标准化组织 W3C（万维网联盟）进行维护。</p>\n<p>多年以来，各浏览器都没有完全遵从这些规范，同时还在开发自己独有的扩展程序，这给网络开发人员带来了严重的兼容性问题。如今，大多数的浏览器都是或多或少地遵从规范。</p>\n<p>浏览器的用户界面有很多彼此相同的元素，其中包括：</p>\n<ul>\n<li>用来输入 URI 的地址栏</li>\n<li>前进和后退按钮</li>\n<li>书签设置选项</li>\n<li>用于刷新和停止加载当前文档的刷新和停止按钮</li>\n<li>用于返回主页的主页按钮</li>\n</ul>\n<p>奇怪的是，浏览器的用户界面并没有任何正式的规范，这是多年来的最佳实践自然发展以及彼此之间相互模仿的结果。HTML5 也没有定义浏览器必须具有的用户界面元素，但列出了一些通用的元素，例如地址栏、状态栏和工具栏等。当然，各浏览器也可以有自己独特的功能，比如 Firefox 的下载管理器。</p>\n<h2 id="浏览器的高层结构"><a href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E9%AB%98%E5%B1%82%E7%BB%93%E6%9E%84" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>浏览器的高层结构</h2>\n<p>浏览器的主要组件为</p>\n<ol>\n<li>用户界面 - 包括地址栏、前进/后退按钮、书签菜单等。除了浏览器主窗口显示的您请求的页面外，其他显示的各个部分都属于用户界面。</li>\n<li>浏览器引擎 - 在用户界面和呈现引擎之间传送指令。</li>\n<li>呈现引擎 - 负责显示请求的内容。如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上。</li>\n<li>网络 - 用于网络调用，比如 HTTP 请求。其接口与平台无关，并为所有平台提供底层实现。</li>\n<li>用户界面后端 - 用于绘制基本的窗口小部件，比如组合框和窗口。其公开了与平台无关的通用接口，而在底层使用操作系统的用户界面方法。</li>\n<li>JavaScript 解释器。用于解析和执行 JavaScript 代码。</li>\n<li>数据存储。这是持久层。浏览器需要在硬盘上保存各种数据，例如 Cookie。新的 HTML 规范 (HTML5) 定义了“网络数据库”，这是一个完整（但是轻便）的浏览器内数据库。</li>\n</ol>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-20-01-39-18-4d2efb6ba6e0c185fa557cbfdc53ca2c-28759.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 500px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 67.80000000000001%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAIAAACgpqunAAAACXBIWXMAAA7DAAAOwwHHb6hkAAADKUlEQVQoz2PwsbN7eeTIg337Hu3fD0QP9+27vWvXnT27b+7ccWf3boggUPb5kSPn1qwR4ednYGDozPQ7vKQ7PtiTIcXL6//Nm3/On/9/8eL/S5f+nTv3/9DB3wf2/d2z+9+RwyDBixf/Xbjw//Kl9/v2yIqKAjWfX1b3/9vVuf0NDEoiIgXOTjlOjrlw5OjQFp9S4uGRBxPJsrerDw0rCwxiZWJiZmQ4Obv0/8uT09sqGLj4BbQsbbQsrUHIykbXxh7IcApL0Ld31jS3ArK1rWxUTcxEZRXFpeWB1rIyM56eW/7/7ZkZ7ZUMvjEJj///v/n3z20g+efv2bffLnz8c+r1l7Nvv9/69x8oeOvv3/v//ycV1Skpa3HzCQkKCB6bWfz//sGZHVUMtsFR2z7/X//i54ZXv4Hk0rtvl919t+L+hyW3X69/+Qsk+PLXxnf/IooaDc2cFTUMFZU1Dk7N/3Vt56zOKgZmNnZ2UQk44pSQZhMR17Bx55VVZBUWA4pwiEky8QkIiErLyKsCnc3OwnRkRtG/W3tmAW0W4BNormrrburrqO/ubOjtbuoHsqf0zu1tmdjV0NvZ0AMU72uZEBqaLCqlANTMwcZyaFrB7+tgmzXVdX68/v33/f9/H/7/evv32a0fT29+f3L9y6Pr3748//v/I1Dwz/+f/6dMXMwrJAmx+egMoJ8PgGwWE5GY2LZ0wdRtE1oWTWhe0tu4cHLHipl9G3oa5k1oWTyhefHE1qWLp++KisgXlVZEhPbr06DQBgJObn5pRR0gg5GJCUjy8AlJK2iCuIwgLhAISSjyCooJicOjqgyqedKslv4ZrXOWT80ujOfi5i2p6azvmFbfObO5e4aHXzgrC0tFZWXfhCntHd0TJk728PAA6j+3qPr/xwuze2oZXv06/+jrsVe/zp29uUlSTu7i4x9Hrn7effrl9Zf/26cuE+AXuHfv3tWrV86fP/fs6dNp06YDNW/szPh2cXNDQQrDiafz99+ecfLZgtkbynkFRHqXXepfebVj4ZlZW59GZraxs7HMmTt35cqVixcv3rhxY2pqKijMWFm4gOHGyAgA7BWbacaq9eYAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 20 01 39 18"\n        title=""\n        src="/static/2021-07-20-01-39-18-4d2efb6ba6e0c185fa557cbfdc53ca2c-28759.png"\n        srcset="/static/2021-07-20-01-39-18-4d2efb6ba6e0c185fa557cbfdc53ca2c-6ac48.png 200w,\n/static/2021-07-20-01-39-18-4d2efb6ba6e0c185fa557cbfdc53ca2c-4b8bf.png 400w,\n/static/2021-07-20-01-39-18-4d2efb6ba6e0c185fa557cbfdc53ca2c-28759.png 500w"\n        sizes="(max-width: 500px) 100vw, 500px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>值得注意的是，和大多数浏览器不同，Chrome 浏览器的每个标签页都分别对应一个呈现引擎实例。每个标签页都是一个独立的进程。</p>\n<h1 id="呈现引擎"><a href="#%E5%91%88%E7%8E%B0%E5%BC%95%E6%93%8E" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>呈现引擎</h1>\n<p>呈现引擎的作用就是在浏览器的屏幕上显示请求的内容。</p>\n<p>默认情况下，呈现引擎可显示 HTML 和 XML 文档与图片。通过插件（或浏览器扩展程序），还可以显示其他类型的内容；例如，使用 PDF 查看器插件就能显示 PDF 文档。但是在本章中，我们将集中介绍其主要用途：显示使用 CSS 格式化的 HTML 内容和图片。</p>\n<p>本文所讨论的浏览器（Firefox、Chrome 浏览器和 Safari）是基于两种呈现引擎构建的。Firefox 使用的是 Gecko，这是 Mozilla 公司“自制”的呈现引擎。而 Safari 和 Chrome 浏览器使用的都是 WebKit。</p>\n<p>WebKit 是一种开放源代码呈现引擎，起初用于 Linux 平台，随后由 Apple 公司进行修改，从而支持苹果机和 Windows。</p>\n<h2 id="主流程"><a href="#%E4%B8%BB%E6%B5%81%E7%A8%8B" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>主流程</h2>\n<p>呈现引擎一开始会从网络层获取请求文档的内容，内容的大小一般限制在 8000 个块以内。</p>\n<p>然后进行如下所示的基本流程：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-20-01-41-38-dba2da5da3c0b45fb5977e4418996051-81a6c.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 600px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 10.999999999999998%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAACCAIAAADXZGvcAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAAhUlEQVQI1wF6AIX/AL/K2MrP1dfd446YpAIHD3Z/i9ng58rQ1s7V3igwOycvOcrR2svR19rg6HV+iQQJEo2Xotje5MnO1cTP3ADU2d/Y1tTq6OWjqrIWHy2Nk535+Pjo5+Xr7Ow8RlU5Q1Pq6+zo5+X8+/qPlp8WIC+mrbX59/Xp5+Xh5+2QYlCrmcDn8QAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="图：呈现引擎的基本流程"\n        title=""\n        src="/static/2021-07-20-01-41-38-dba2da5da3c0b45fb5977e4418996051-81a6c.png"\n        srcset="/static/2021-07-20-01-41-38-dba2da5da3c0b45fb5977e4418996051-468c3.png 200w,\n/static/2021-07-20-01-41-38-dba2da5da3c0b45fb5977e4418996051-3ff2b.png 400w,\n/static/2021-07-20-01-41-38-dba2da5da3c0b45fb5977e4418996051-81a6c.png 600w"\n        sizes="(max-width: 600px) 100vw, 600px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>呈现引擎将开始解析 HTML 文档，并将各标记逐个转化成“内容树”上的 DOM 节点。同时也会解析外部 CSS 文件以及样式元素中的样式数据。HTML 中这些带有视觉指令的样式信息将用于创建另一个树结构：呈现树。</p>\n<p>呈现树包含多个带有视觉属性（如颜色和尺寸）的矩形。这些矩形的排列顺序就是它们将在屏幕上显示的顺序。</p>\n<p>呈现树构建完毕之后，进入“布局”处理阶段，也就是为每个节点分配一个应出现在屏幕上的确切坐标。下一个阶段是绘制 - 呈现引擎会遍历呈现树，由用户界面后端层将每个节点绘制出来。</p>\n<p>需要着重指出的是，这是一个渐进的过程。为达到更好的用户体验，呈现引擎会力求尽快将内容显示在屏幕上。它不必等到整个 HTML 文档解析完毕之后，就会开始构建呈现树和设置布局。在不断接收和处理来自网络的其余内容的同时，呈现引擎会将部分内容解析并显示出来。</p>\n<h2 id="主流程示例"><a href="#%E4%B8%BB%E6%B5%81%E7%A8%8B%E7%A4%BA%E4%BE%8B" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>主流程示例</h2>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-20-01-43-09-b2b81d9cf1c9a7547a05e02c3d96d537-37d31.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 624px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 46.31410256410256%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAIAAAC9o5sfAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABh0lEQVQoz2NgYmIAIkZGIMnECGQxMIT5JczvX5+TXMnOzgGUYGFhYQRKEwmAZhjq2nKwcxFW6uvLGBfLIK0g7hYeb+rkBtRr5WgVkhDi4Q9kMzr4h2Q3d0kpKANVsrCwMjODXMHMDGQzAEmG1auZVq1k0LfQn7n3dH7HRB4B0cXrp+w/uayyKQ+oITSzqGfdHhkVTSAb4insAOIxbl5ePUtrYydvCXklIFdCSkJNV19aRoKVnUNJS0dZR4+dk1tRicnUjFVFFewAIAIGFgsrK1C1mr7J8rO31l65VzZpjoyiyr6zG6482pdfmSUqr7X89LXFx6+auXjs2Mn48QvnoaM8ICvBCApYWNlEpBWkVPS4+YX4Bfj0DLU1tNW4ebiZmFmklVRklFVY2bkkJJm0tFllZJkZiitFJ0wTMbFRyuuYkdPawyMoWlaXNX1RZ2JmFNwvDLhi6s079ivX2U1slRLK26ILylV1dCfPa588t9XFyxEoy8rKwszMBDGCCQwgBjIxA8OPAQDJKVVC+8su2wAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="图：WebKit 主流程"\n        title=""\n        src="/static/2021-07-20-01-43-09-b2b81d9cf1c9a7547a05e02c3d96d537-37d31.png"\n        srcset="/static/2021-07-20-01-43-09-b2b81d9cf1c9a7547a05e02c3d96d537-89539.png 200w,\n/static/2021-07-20-01-43-09-b2b81d9cf1c9a7547a05e02c3d96d537-cb00c.png 400w,\n/static/2021-07-20-01-43-09-b2b81d9cf1c9a7547a05e02c3d96d537-37d31.png 624w"\n        sizes="(max-width: 624px) 100vw, 624px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-20-01-43-20-b62fa3cb50eec54e4215a86e1ce83f85-37d31.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 624px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 46.47435897435898%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAIAAAC9o5sfAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABbUlEQVQoz3VRTU/CQBDtTzcx3oxHL/hxMSYaURIvRIMGRQpCMCilaKVsW/u9S9mPAtp2a4saMerLHHZn3sy+eSukC/A0/XngrVNdPAJLlT8g/K5ynqcchVoyWVz/b4Z+CaGqZDkNTbfG4xbQRVWDBD9RuRfeW9TJSEEY1kfgVtPZfP6lLslCsO012z48kx732h3ZsvfFZqFSkzy1pBSLj8ceczOiR8hBu1vqyng6W9YiJAnMZpDZHDI6e32FlPmE0jnD0cQLoYmQizGdzkbQVJGBGIEs58URfHtzhG+jeJpkiGOeJB9rayjYuqrtXDdEoFSs8qV73hzKu/XW9UDxnMIIrAh5E0+nUx8TLYrCZc8QZTf9QX2gDFxdnkjDydDDpKVqmj9mtIPQZf5yFBHD2ARg1Xerd4ZX7skGCuRAakBRxc88Sv7/qjSN48A0NwBYx8FDpT/crta65ujCOj95PnkJXzJfE54v8o1PcfE7Vffy3R2ugdoAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="图：Mozilla 的 Gecko 呈现引擎主流程 "\n        title=""\n        src="/static/2021-07-20-01-43-20-b62fa3cb50eec54e4215a86e1ce83f85-37d31.png"\n        srcset="/static/2021-07-20-01-43-20-b62fa3cb50eec54e4215a86e1ce83f85-89539.png 200w,\n/static/2021-07-20-01-43-20-b62fa3cb50eec54e4215a86e1ce83f85-cb00c.png 400w,\n/static/2021-07-20-01-43-20-b62fa3cb50eec54e4215a86e1ce83f85-37d31.png 624w"\n        sizes="(max-width: 624px) 100vw, 624px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>可以看出，虽然 WebKit 和 Gecko 使用的术语略有不同，但整体流程是基本相同的。</p>\n<p>Gecko 将视觉格式化元素组成的树称为“框架树”。每个元素都是一个框架。WebKit 使用的术语是“呈现树”，它由“呈现对象”组成。对于元素的放置，WebKit 使用的术语是“布局”，而 Gecko 称之为“重排”。</p>\n<p>对于连接 DOM 节点和可视化信息从而创建呈现树的过程，WebKit 使用的术语是“附加”。有一个细微的非语义差别，就是 Gecko 在 HTML 与 DOM 树之间还有一个称为“内容槽”的层，用于生成 DOM 元素。我们会逐一论述流程中的每一部分：</p>\n<p>// TODO <a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#Parsing_general" target="_blank" rel="nofollow noreferrer noopener">https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#Parsing_general</a></p>',excerpt:"简介 网络浏览器很可能是使用最广的软件。在这篇入门文章中，我将会介绍它们的幕后工作原理。我们会了解到，从您在地址栏输入 google.com 直到您在浏览器屏幕上看到 Google…",timeToRead:2,tableOfContents:'<ul>\n<li>\n<p><a href="/browser-working-principle/#%E7%AE%80%E4%BB%8B">简介</a></p>\n<ul>\n<li><a href="/browser-working-principle/#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD">浏览器的主要功能</a></li>\n<li><a href="/browser-working-principle/#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E9%AB%98%E5%B1%82%E7%BB%93%E6%9E%84">浏览器的高层结构</a></li>\n</ul>\n</li>\n<li>\n<p><a href="/browser-working-principle/#%E5%91%88%E7%8E%B0%E5%BC%95%E6%93%8E">呈现引擎</a></p>\n<ul>\n<li><a href="/browser-working-principle/#%E4%B8%BB%E6%B5%81%E7%A8%8B">主流程</a></li>\n<li><a href="/browser-working-principle/#%E4%B8%BB%E6%B5%81%E7%A8%8B%E7%A4%BA%E4%BE%8B">主流程示例</a></li>\n</ul>\n</li>\n</ul>',wordCount:{words:292},frontmatter:{date:"2021-07-20 01:30:15",path:"/browser-working-principle/",tags:"前端, 浏览器, 高级前端",title:"浏览器工作原理",draft:null,catalog_number:null}},nextPost:{html:'<h1 id="前言"><a href="#%E5%89%8D%E8%A8%80" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>前言</h1>\n<p>缓存可以说是性能优化中简单高效的一种优化方式了。一个优秀的缓存策略可以缩短网页请求资源的距离，减少延迟，并且由于缓存文件可以重复利用，还可以减少带宽，降低网络负荷。</p>\n<p>对于一个数据请求来说，可以分为发起网络请求、后端处理、浏览器响应三个步骤。浏览器缓存可以帮助我们在第一和第三步骤中优化性能。比如说直接使用缓存而不发起请求，或者发起了请求但后端存储的数据和前端一致，那么就没有必要再将数据回传回来，这样就减少了响应数据。</p>\n<h1 id="缓存位置"><a href="#%E7%BC%93%E5%AD%98%E4%BD%8D%E7%BD%AE" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>缓存位置</h1>\n<p>从缓存位置上来说分为四种，并且各自有优先级，当依次查找缓存且都没有命中的时候，才会去请求网络</p>\n<h2 id="memory-cache"><a href="#memory-cache" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Memory Cache</h2>\n<p>Memory Cache 也就是内存中的缓存，主要包含的是当前页面中已经抓取到的资源,例如页面上已经下载的样式、脚本、图片等。读取内存中的数据肯定比磁盘快，内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。</p>\n<p>那么既然内存缓存这么高效，我们是不是能让数据都存放在内存中呢？</p>\n<p>这是不可能的。计算机中的内存一定比硬盘容量小得多，操作系统需要精打细算内存的使用，所以能让我们使用的内存必然不多。</p>\n<p>当我们访问过页面以后，再次刷新页面，可以发现很多数据都来自于内存缓存</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-16-18-56-42-280cdf7dc918c053967fd3cba6f72694-75fdb.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 18.295454545454547%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAIAAAABPYjBAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAAyUlEQVQI1x3K0XKDIBBAUf//e/obOuM0xtrUiCJFYHdBMCjoQzO9j2duMUpgAp6zGoQZJXJle64WDEK756wVbf20KBu1ixK9MCtfSOh1Uvrjeyi6R8/FL5tmt4YjnylfZNc9n84H57fXnrrHz+3e1p83pUEbdKtP56WMUfEo2vbO2IAIzllCdNYiQE7JEmmt9hirsqyqsuu+3gJgiDClQ8nldcSCc84YG8eR/SeltNZe1+W9J6Kcc9M0dV2/t23bEDGEkFICgCOnPyDq2wI8Wf40AAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 16 18 56 42"\n        title=""\n        src="/static/2021-07-16-18-56-42-280cdf7dc918c053967fd3cba6f72694-fee1c.png"\n        srcset="/static/2021-07-16-18-56-42-280cdf7dc918c053967fd3cba6f72694-a67b7.png 200w,\n/static/2021-07-16-18-56-42-280cdf7dc918c053967fd3cba6f72694-0b187.png 400w,\n/static/2021-07-16-18-56-42-280cdf7dc918c053967fd3cba6f72694-fee1c.png 800w,\n/static/2021-07-16-18-56-42-280cdf7dc918c053967fd3cba6f72694-75fdb.png 880w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>几乎所有的网络请求资源都会被浏览器自动加入到 memory cache 中。而如果极端情况下 (例如一个页面的缓存就占用了超级多的内存)，那可能在 TAB 没关闭之前，排在前面的缓存就已经失效了。</p>\n<p>预加载（preload）请求过来的资源会被放入 memory cache 中（例如<code class="language-text">&lt;link rel=&quot;prefetch&quot;&gt;</code>）。</p>\n<p>memory cache 机制保证了一个页面中如果有两个相同的请求 (例如两个 src 相同的 ，两个 href 相同的)实际只会被请求最多一次，避免浪费。</p>\n<p>不过在匹配缓存时，除了匹配完全相同的 URL 之外，还会比对他们的类型，CORS 中的域名规则等。因此一个作为脚本 (script) 类型被缓存的资源是不能用在图片 (image) 类型的请求中的，即便他们 src 相等。如果想让 memory cache 也不存储，那就需要在 Http 请求头设置 no-store。</p>\n<h2 id="disk-cache"><a href="#disk-cache" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Disk Cache</h2>\n<p>Disk Cache 也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 Memory Cache 胜在容量和存储时效性上。</p>\n<p>在所有浏览器缓存中，Disk Cache 覆盖面基本是最大的。它会根据 HTTP Header 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。绝大部分的缓存都来自 Disk Cache，关于 HTTP 的协议头中的缓存字段，我们会在下文进行详细介绍。</p>\n<p>浏览器会把哪些文件丢进内存中？哪些丢进硬盘中？</p>\n<ul>\n<li>对于大文件来说，大概率是不存储在内存中的，反之优先</li>\n<li>当前系统内存使用率高的话，文件优先存储进硬盘</li>\n</ul>\n<p>凡是持久性存储都会面临容量增长的问题，disk cache 也不例外。浏览器会根据自身算法自动清理“最老的”或者“最可能过时的”资源。</p>\n<h2 id="service-worker"><a href="#service-worker" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Service Worker</h2>\n<p>Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用 Service Worker 的话，传输协议必须为 HTTPS。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的。</p>\n<p>Service Worker 实现缓存功能一般分为三个步骤：首先需要先注册 Service Worker，然后监听到 install 事件以后就可以缓存需要的文件，那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。</p>\n<p>当 Service Worker 没有命中缓存的时候，我们需要去调用 fetch() 函数获取数据。也就是说，如果我们没有在 Service Worker 命中缓存的话，会根据缓存优先级去查找数据。但是不管我们是从 Memory Cache 中还是从网络请求中获取的数据，浏览器都会显示我们是从 Service Worker 中获取的内容。</p>\n<p>上述的缓存策略以及缓存/读取/失效的动作都是由浏览器内部判断和进行的，我们只能设置响应头的某些字段来告诉浏览器，而不能自己操作。</p>\n<p>Service Worker 借鉴了 Web Worker 的 思路，即让 JS 运行在主线程之外，由于它脱离了浏览器的窗体，因此无法直接访问 DOM。虽然如此，但它仍然能帮助我们完成很多有用的功能，比如离线缓存、消息推送和网络代理等功能。其中的离线缓存就是 Service Worker Cache。</p>\n<p>Service Worker 能够操作的缓存是有别于浏览器内部的 memory cache 或者 disk cache 的。我们可以在 Chrome 开发者工具，Application -> Cache Storage 找到缓存的位置。这个缓存是永久性的，即关闭 TAB 或者浏览器，下次打开依然还在。有两种情况会导致这个缓存中的资源被清除：手动调用 API <code class="language-text">cache.delete(resource)</code> 或者容量超过限制，被浏览器全部清空。</p>\n<h2 id="push-cache"><a href="#push-cache" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Push Cache</h2>\n<p>Push Cache（推送缓存）是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。它只在会话（Session）中存在，一旦会话结束就被释放，并且缓存时间也很短暂，在 Chrome 浏览器中只有 5 分钟左右，同时它也并非严格执行 HTTP 头中的缓存指令。</p>\n<p>Push Cache 在国内能够查到的资料很少，也是因为 HTTP/2 在国内不够普及。这里推荐阅读 Jake Archibald 的 <a href="https://jakearchibald.com/2017/h2-push-tougher-than-i-thought/" target="_blank" rel="nofollow noreferrer noopener">HTTP/2 push is tougher than I thought</a> 这篇文章，文章中的几个结论：</p>\n<ul>\n<li>所有的资源都能被推送，并且能够被缓存，但是 Edge 和 Safari 浏览器支持相对比较差</li>\n<li>可以推送 no-cache 和 no-store 的资源</li>\n<li>一旦连接被关闭，Push Cache 就被释放</li>\n<li>多个页面可以使用同一个 HTTP/2 的连接，也就可以使用同一个 Push Cache。这主要还是依赖浏览器的实现而定，出于对性能的考虑，有的浏览器会对相同域名但不同的 tab 标签使用同一个 HTTP 连接。</li>\n<li>Push Cache 中的缓存只能被使用一次</li>\n<li>浏览器可以拒绝接受已经存在的资源推送</li>\n<li>你可以给其他域名推送资源</li>\n</ul>\n<p>如果以上四种缓存都没有命中的话，那么只能发起请求来获取资源了。</p>\n<p>那么为了性能上的考虑，大部分的接口都应该选择好缓存策略，通常浏览器缓存策略分为两种：强缓存和协商缓存，并且缓存策略都是通过设置 HTTP Header 来实现的。</p>\n<h1 id="查找优先级"><a href="#%E6%9F%A5%E6%89%BE%E4%BC%98%E5%85%88%E7%BA%A7" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>查找优先级</h1>\n<p>ServiceWorker > Memory Cache > Disk Cache > Push Cache > 发送请求</p>\n<h1 id="缓存过程"><a href="#%E7%BC%93%E5%AD%98%E8%BF%87%E7%A8%8B" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>缓存过程</h1>\n<p>浏览器与服务器通信的方式为应答模式，即是：浏览器发起 HTTP 请求 – 服务器响应该请求，那么浏览器怎么确定一个资源该不该缓存，如何去缓存呢？</p>\n<p>浏览器第一次向服务器发起该请求后拿到请求结果后，将请求结果和缓存标识存入浏览器缓存，浏览器对于缓存的处理是根据第一次请求资源时返回的响应头来确定的。具体过程如下图：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-20-00-09-16-c3ddd4b3cd2b2e903b28bb70eb803ad6-b169a.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 670px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 76.4179104477612%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAIAAABr+ngCAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABqUlEQVQoz2WT2XKCQBBF+f//kiqJpSIaNDxoXEBB3MKiyJLjNKAm96Fr6Onlzu1Gu9/v3tbr9/umaZ7P56IosizL8/xyuYxGI13Xe70e/qqqiCzLMk3T6XSKf71ea7iIW61Wvu+TRhARWM6u687n881mkyQJTipS+na7EblYLE6nk8Y3oXEUE4oLCh8K4/F4uVzu93tuCwVJlnhKU04TVxRFxEEhCILdbocNw5AOx+MxV2iTsZCFPOc6GWK0tW37S2E2m2HxUEKiWyvxf5N59vc7yISR0IZka8m8Xq91Mi4Io822ged52OFw2O12DcOgEO8XCyCFWs8305l5JC+g9uFw4PHEoTDdcKYK1I3j+I02OtH/pwGf6M8whQie9paDbERNmw/4+A1oiHiDwQDmLM9kMgkUmIiMg8ODtowuU6j+QaYqkOUpFXjIszOVWEZTwbIsFpCenU4HwtzKwraj4sCbOTySqYcqnwowxKIntdgz2bDXJZGB0bmmTRleIgK+Ema9RG06t8nSlkEgu8YF5aGKQigp1yIhgjFnx3FYFfkxsIyQ/eNFzOIXgXpKYi2NgdQAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 20 00 09 16"\n        title=""\n        src="/static/2021-07-20-00-09-16-c3ddd4b3cd2b2e903b28bb70eb803ad6-b169a.png"\n        srcset="/static/2021-07-20-00-09-16-c3ddd4b3cd2b2e903b28bb70eb803ad6-1714e.png 200w,\n/static/2021-07-20-00-09-16-c3ddd4b3cd2b2e903b28bb70eb803ad6-5c3b9.png 400w,\n/static/2021-07-20-00-09-16-c3ddd4b3cd2b2e903b28bb70eb803ad6-b169a.png 670w"\n        sizes="(max-width: 670px) 100vw, 670px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>由上图我们可以知道：</p>\n<ul>\n<li>浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识</li>\n<li>浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中</li>\n</ul>\n<p>以上两点结论就是浏览器缓存机制的关键，它确保了每个请求的缓存存入与读取，只要我们再理解浏览器缓存的使用规则，那么所有的问题就迎刃而解了，本文也将围绕着这点进行详细分析。为了方便大家理解，这里我们根据是否需要向服务器重新发起 HTTP 请求将缓存过程分为两个部分，分别是强缓存和协商缓存。</p>\n<h1 id="缓存策略"><a href="#%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>缓存策略</h1>\n<p>http 缓存分为强缓存与协商缓存</p>\n<h2 id="强缓存"><a href="#%E5%BC%BA%E7%BC%93%E5%AD%98" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>强缓存</h2>\n<p>不会向服务器发送请求，直接从缓存中读取资源，在 chrome 控制台的 Network 选项中可以看到该请求返回 200 的状态码，并且 Size 显示 from disk cache 或 from memory cache。强缓存可以通过设置两种 HTTP Header 实现：Expires 和 Cache-Control。</p>\n<h3 id="expires"><a href="#expires" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Expires</h3>\n<p>缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点。也就是说，<code class="language-text">Expires=max-age+请求时间</code>，需要和 Last-modified 结合使用。Expires 是 Web 服务器响应消息头字段，在响应 http 请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。</p>\n<p>Expires 是 HTTP/1 的产物，受限于本地时间，如果修改了本地时间，可能会造成缓存失效。<code class="language-text">Expires: Wed, 22 Oct 2018 08:41:00 GMT</code> 表示资源会在 <code class="language-text">Wed, 22 Oct 2018 08:41:00 GMT</code> 后过期，需要再次请求。</p>\n<h3 id="cache-control"><a href="#cache-control" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Cache-Control</h3>\n<p>在 HTTP/1.1 中，Cache-Control 是最重要的规则，主要用于控制网页缓存。比如当 <code class="language-text">Cache-Control: max-age=300</code> 时，则代表在这个请求正确返回时间（浏览器也会记录下来）的 5 分钟内再次加载资源，就会命中强缓存。</p>\n<p>Cache-Control 可以在请求头或者响应头中设置，并且可以组合使用多种指令：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-20-00-18-09-a5bff571a9f17623a64dbecb8bc0ddca-b1c4a.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 562px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 61.032028469750884%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACgElEQVQoz0WSWU8TURTHL0JixMQgQR7wAbdP4TeQ5cUnQ2KMUdEXjSYoxJAuQQSD+GD0zZAYxKioGIXSsthECbHrdLow022mM3Nn7h06LZVSUOniKTV488s/567n3P+9qPG89dTV8daekYZuC+ow/aPTXNdtRV0W1GlpuzR29MII6jDXd1sPdFnROdN/0JWJljtT6NrE2aGZF3bv0y+u53Oe8Q/fH75eevTWCfpk2vl42jk06QCGXy0+gwWz7hqobsBxZuwb6rffmIlUKpViqQz6e6eQ1dVcmhoEG0Q1qEqVFJHFrE4qleqCWkP1d+fah5fq+209L10ZSkUJpySMVQLq9QWCwbVQaM3PsCwbDrBhQtclGUuyWgM1mewnR78eHrTf+hSCw3Z3i9X8xaIiK5RQKSWJgqhpGs/xMT6W38zDbKlUKu+BWiyO06POZsvizY/sn0J+I7dJqa5pRFGwqmqikJIlBeJYNM5xURlOpPrGRi6X+wmggwPzTaYF1Ge7POXdyhhUT/NcNBQMR/l4Ip5ci3CwLRZNhMORAMMG2VA4FCFE1+k6gBru2dqGllDf7PX3wX3D9lvGyGhY01RSKGxX+/uT5SqQ2XZidPnQ4PzFSfemkWaY0MrKKsfxVZ/8YFg4kRQh8HkZvy/A+FmPx+fzMdFonELmxvvzrdbFA/1zve+Y8q9t8BPy6Pp6SpTgtilBwmCsJMPlkwlBSIqU6ITQTCabz2+hZvPC8QfL4Pbtz3vvXCyB7hR2oFojbQgJIRFLEI1iRRWSAlZwreAymF0soWNmR/vI8hGzvfeNN6tTScHgLVjC8zG32wsaCARXV3+4XB4oHsYVRQXgJ2Cs/QVQxR7MwZqxkgAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 20 00 18 09"\n        title=""\n        src="/static/2021-07-20-00-18-09-a5bff571a9f17623a64dbecb8bc0ddca-b1c4a.png"\n        srcset="/static/2021-07-20-00-18-09-a5bff571a9f17623a64dbecb8bc0ddca-3ced9.png 200w,\n/static/2021-07-20-00-18-09-a5bff571a9f17623a64dbecb8bc0ddca-4c4f5.png 400w,\n/static/2021-07-20-00-18-09-a5bff571a9f17623a64dbecb8bc0ddca-b1c4a.png 562w"\n        sizes="(max-width: 562px) 100vw, 562px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<h4 id="public"><a href="#public" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>public</h4>\n<p>所有内容都将被缓存（客户端和代理服务器都可缓存）。具体来说响应可被任何中间节点缓存，如 Browser &#x3C;— proxy1 &#x3C;— proxy2 &#x3C;— Server，中间的 proxy 可以缓存资源，比如下次再请求同一资源 proxy1 直接把自己缓存的东西给 Browser 而不再向 proxy2 要。</p>\n<h4 id="private"><a href="#private" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>private</h4>\n<p>所有内容只有客户端可以缓存，Cache-Control 的默认取值。具体来说，表示中间节点不允许缓存，对于 Browser &#x3C;— proxy1 &#x3C;— proxy2 &#x3C;— Server，proxy 会老老实实把 Server 返回的数据发送给 proxy1，自己不缓存任何数据。当下次 Browser 再次请求时 proxy 会做好请求转发而不是自作主张给自己缓存的数据。</p>\n<h4 id="no-cache"><a href="#no-cache" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>no-cache</h4>\n<p>客户端缓存内容，是否使用缓存则需要经过协商缓存来验证决定。表示不使用 Cache-Control 的缓存控制方式做前置验证，而是使用 Etag 或者 Last-Modified 字段来控制缓存。需要注意的是，no-cache 这个名字有一点误导。设置了 no-cache 之后，并不是说浏览器就不再缓存数据，只是浏览器在使用缓存数据时，需要先确认一下数据是否还跟服务器保持一致。</p>\n<h4 id="no-store"><a href="#no-store" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>no-store</h4>\n<p>所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存</p>\n<h4 id="max-age"><a href="#max-age" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>max-age</h4>\n<p>max-age=xxx (xxx is numeric) 表示缓存内容将在 xxx 秒后失效</p>\n<h4 id="s-maxage"><a href="#s-maxage" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>s-maxage</h4>\n<p>同 max-age 作用一样，只在代理服务器中生效（比如 CDN 缓存）。比如当 s-maxage=60 时，在这 60 秒中，即使更新了 CDN 的内容，浏览器也不会进行请求。max-age 用于普通缓存，而 s-maxage 用于代理缓存。s-maxage 的优先级高于 max-age。如果存在 s-maxage，则会覆盖掉 max-age 和 Expires header。</p>\n<h4 id="max-stale"><a href="#max-stale" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>max-stale</h4>\n<p>能容忍的最大过期时间。max-stale 指令标示了客户端愿意接收一个已经过期了的响应。如果指定了 max-stale 的值，则最大容忍时间为对应的秒数。如果没有指定，那么说明浏览器愿意接收任何 age 的响应（age 表示响应由源站生成或确认的时间与当前时间的差值）。</p>\n<h4 id="min-fresh"><a href="#min-fresh" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>min-fresh</h4>\n<p>能够容忍的最小新鲜度。min-fresh 标示了客户端不愿意接受新鲜度不多于当前的 age 加上 min-fresh 设定的时间之和的响应。</p>\n<h4 id="must-revalidate"><a href="#must-revalidate" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>must-revalidate</h4>\n<p>must-revalidate 告诉缓存，在事先没有跟原始服务器进行再验证的情况下，不能提供这个对象的陈旧副本，缓存仍然可以随意提供新鲜的副本。如果在缓存进行 must-revalidate 新鲜度检查时，原始服务器不可用，缓存就必须返回一条 504 错误。</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-20-00-28-46-72c0aaa7438b3576e8352df558911e51-8f041.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 90.1219512195122%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAIAAADUsmlHAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACZ0lEQVQ4y4VUi27aMBTN/39FNWmVtklsk8pa9bFC260UQiCjFEpIAgkhCcTOw3ES5+HMkJVSqe2OrqIr28f33IfDlXtIEtIZOc3e8qgxvBZtfgyiOGbrlJavgqNsp7KyTNOsPwHnd+qno98NXu9LMCGErReUPh15Sd55BIcBAJ7P4OV5HvgehOsVNMq3wWHfCUwFLCTlvm1N/0TI2+rcRJkbTqsvtXqToWSOlJVqgKLIX5Dh4hFNmmq7rgknWL7x7NlGZ7451GhPPh71DuvCQe32y9mo0dXyLNtdvSGnSYwDlwVkFvowS9Nqg5I4QHi+sJjphq1q5tpxY4JZ7q/k/I/DhNGCXQEWmuvYezppHMdTTXZcN8uLNC+youCqUtOiYPuOi36J1pWgH1+Njm/GrSEwLEiYNIwJSQPXQZqoiZeKcBGovKuPtuRy24qSAhhc8lrtVPh2Ln6ut5qCMdMtxkUI4Shy7KUrd1aPt3L3AkotqA25KoOclj6E0LYxDlOS5Hmapax3yAY2DOBzUnsOMw7MBmjel7o/9cE1VHtRGO7q6TsmmLZl4VIbXAfznmfNtkVhI1NUyXJAEdCMl7tn1vAqmAsRRjty4JjhrKP1LxaDJnPc5XS/T9tWZXlCUlYPB4DVah1HYVVhSjOMkWXbruenWRYTVmD65ngyRDEZK2Z/qNzyD+w7ls04Sd8bzyr5YitmufLqv43DH+LB1/aH73ytoRq2/ySVvkp+Rpbla4iAH6m65Xh4DUP2zt6P/Aw2uoEpoeVIf7jztPvQknbT+n8yIQmYdjThVGzUVP4Eyp0kjsq3/wZ/AfDX9/GRD3dWAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 20 00 28 46"\n        title=""\n        src="/static/2021-07-20-00-28-46-72c0aaa7438b3576e8352df558911e51-fee1c.png"\n        srcset="/static/2021-07-20-00-28-46-72c0aaa7438b3576e8352df558911e51-a67b7.png 200w,\n/static/2021-07-20-00-28-46-72c0aaa7438b3576e8352df558911e51-0b187.png 400w,\n/static/2021-07-20-00-28-46-72c0aaa7438b3576e8352df558911e51-fee1c.png 800w,\n/static/2021-07-20-00-28-46-72c0aaa7438b3576e8352df558911e51-8f041.png 820w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从图中我们可以看到，我们可以将多个指令配合起来一起使用，达到多个目的。比如说我们希望资源能被缓存下来，并且是客户端和代理服务器都能缓存，还能设置缓存失效时间等等。</p>\n<h3 id="expires-和-cache-control-两者对比"><a href="#expires-%E5%92%8C-cache-control-%E4%B8%A4%E8%80%85%E5%AF%B9%E6%AF%94" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Expires 和 Cache-Control 两者对比</h3>\n<p>其实这两者差别不大，区别就在于 Expires 是 http1.0 的产物，Cache-Control 是 http1.1 的产物，两者同时存在的话，Cache-Control 优先级高于 Expires；在某些不支持 HTTP1.1 的环境下，Expires 就会发挥用处。所以 Expires 其实是过时的产物，现阶段它的存在只是一种兼容性的写法。</p>\n<p>强缓存判断是否缓存的依据来自于是否超出某个时间或者某个时间段，而不关心服务器端文件是否已经更新，这可能会导致加载文件不是服务器端最新的内容，那我们如何获知服务器端内容是否已经发生了更新呢？此时我们需要用到协商缓存策略。</p>\n<h2 id="协商缓存"><a href="#%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>协商缓存</h2>\n<p>协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况：</p>\n<ul>\n<li>\n<p>协商缓存生效，返回 304 和 Not Modified</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-20-00-33-21-1adc590c1e2e8a860b83c1ad8c2944b0-e31b0.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 709px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 76.0225669957687%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAIAAABr+ngCAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAByElEQVQoz12S6Y6CUAyFef93mklGYzQuwTUad3BBAbdRdtD5vEWcmf5oyqWnpz2tFsfxYrGoVCqj0cjzvDRNoyi63++n06larX5+fHa73SAIeOEX/na71ev1Wq1m27aWJAl52+0Wz+/H40EGPgzDlTLXdSHIskzAlN4qo4omgMPhIE+tVovCzWZzv9/PZrPr9crfTBmZWZpJC4J6gvlxPp/BUwzvOpC5wHa7ne/5OezlsVAZwZsZtn6/PxgMIJxMJoza6/Ucx4GK0UhL0kTwTCG6aDIJAwOwLIvOATi2YymTtkUF8eSjq6iQMyMdsL0y0zDRuVwul75KtZchBOKt12tWM51ORf+cGQb4vpVdLhdHGZMfD0dejpgKEIWQjv63DSeyEeDJQ4XNZjMcDsfjMeWojuddaKjyBvMKmGECZYhJCZqcz+eGYcBW1JW+yHyD4eGJYerKGo3Gcrk0VyYMsmdyxIv4b8H4ZjwYTNNEc0qwLcDQ0lGqtvR0Sb6qKIz+7FlmBqbreqfTaettWxkjyHrkSH4H+YUxBrRQEchsBAyyViY3X1xYHMVcHoL7vq/RPZwcE3k0UxwDtFwbZ8diCzC/wHCI5FP9BzqPR0Kc/CkRAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 20 00 33 21"\n        title=""\n        src="/static/2021-07-20-00-33-21-1adc590c1e2e8a860b83c1ad8c2944b0-e31b0.png"\n        srcset="/static/2021-07-20-00-33-21-1adc590c1e2e8a860b83c1ad8c2944b0-ae213.png 200w,\n/static/2021-07-20-00-33-21-1adc590c1e2e8a860b83c1ad8c2944b0-0d4a3.png 400w,\n/static/2021-07-20-00-33-21-1adc590c1e2e8a860b83c1ad8c2944b0-e31b0.png 709w"\n        sizes="(max-width: 709px) 100vw, 709px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n</li>\n<li>\n<p>协商缓存失效，返回 200 和请求结果</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-20-00-34-10-a9293f39adadaf1b81a1faf0b7368d91-4c169.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 666px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 77.77777777777777%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAIAAACZeshMAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAB10lEQVQoz22TyZKCQBBE+f8P8qARhieXgwcZBQFxQXHfd2RxHl2IzpIRU/bQlVXZWd3afD7vdDqDweB8PsdxHIZhFEVBEDiOo7d00zC3222swPckSVarFfns3m43bb1e93o9SkB4Pp9sE0n1Rl7X7Pb7/cPh8Emmlm3bNLvf7xpf+X8ymSyXS6qYpmkYBrXYXiwWwsmjLGgDk0IafXa73WazOZ1Ow+HQdV0K7/f76XRKuSROopT3ZhIDhZTMH6elz2w24wgUgkln3/c5XvQTOAL58XhkZDoju9FofCk4tkN/xFtdC/7zD0Q2/IycivSnqxcsyzIUqNVVwF7P85CDOkqT8ybTmeMRNwrYRrau6/BdBVyAtlUYj8cYif7szNfrFY5MmHi5XBgPtUlFFEbirewC1uS/O8McjUacEIfpQM9ardZutzGiXq83m00k5LKJzDUzDPcoJtcrUci9EW2yZpGP+qGQkRF2PB7zKEAIYwsVRPA/c6YqkorFYrlcLpVKlUqlWq2yLhQKOCeziV/4QY4TjR8044FcgLwJ86Az8j57EuXmyz1PHwZ+MAD4cjC5c1go02It3/NX1Wq1GH76MDCQMTL6PInImXlPZHBhfpG5EVTkO82+AWldgLqGiSrhAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 20 00 34 10"\n        title=""\n        src="/static/2021-07-20-00-34-10-a9293f39adadaf1b81a1faf0b7368d91-4c169.png"\n        srcset="/static/2021-07-20-00-34-10-a9293f39adadaf1b81a1faf0b7368d91-76d25.png 200w,\n/static/2021-07-20-00-34-10-a9293f39adadaf1b81a1faf0b7368d91-edf88.png 400w,\n/static/2021-07-20-00-34-10-a9293f39adadaf1b81a1faf0b7368d91-4c169.png 666w"\n        sizes="(max-width: 666px) 100vw, 666px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n</li>\n</ul>\n<p>协商缓存可以通过设置两种 HTTP Header 实现：Last-Modified 和 ETag。</p>\n<h3 id="last-modified-和-if-modified-since"><a href="#last-modified-%E5%92%8C-if-modified-since" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Last-Modified 和 If-Modified-Since</h3>\n<p>浏览器在第一次访问资源时，服务器返回资源的同时，在 response header 中添加 Last-Modified 的 header，值是这个资源在服务器上的最后修改时间，浏览器接收缓存文件和 header；</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="78657153908709820000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`Last-Modified: Fri, 22 Jul 2016 01:47:00 GMT`, `78657153908709820000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">Last-Modified: Fri, 22 Jul 2016 01:47:00 GMT</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>浏览器下一次请求这个资源，浏览器检测到有 Last-Modified 这个 header，于是添加 If-Modified-Since 这个 header，值就是 Last-Modified 中的值；</p>\n<p>服务器再次收到这个资源请求，会根据 If-Modified-Since 中的值与服务器中这个资源的最后修改时间对比，如果没有变化，返回 304 和空的响应体，直接从缓存读取，如果 If-Modified-Since 的时间小于服务器中这个资源的最后修改时间，说明文件有更新，于是返回新的资源文件和 200</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-20-00-40-45-24c91c69e4ddffc1c01ab55b2a2e007f-5032e.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 438px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 86.7579908675799%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAIAAABSJhvpAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAB10lEQVQ4y32Su04CQRSG92l8BtEnsFFaO2Mlb2C8UFkgGgsjhYmWUphIYWFLIoqWaiGJ4S4g1yzsyu7s7syOP3N0g4j8CSfDzPxzvnPOaqZlNS1bZ7YvuBCC81GcId/3B4OBaZq+LzXRN4zzU5a+51KOrP+bPc+TUmYymf14/CSRuMtmtevL2NHS+tPVmhSvXEjOvdnmi2RyORxeCYc3t7a1aHpv7njjWV+V8sXjs8yu68J8cHg4HwotLC7u7Ea13tC4eTvj3q0QUpX8jc3HiqRekDmVSm1EIrFYLPvwqOFU+pKc6qZPhPxH8OAvvUKSStjQcMxcWwgHx7ZtM8a63W6r1apWq+Vy+UOpVqt9KuECHmIj2Y7jauPjwTHGYBiGqUSL4XBoKOFRRGSm+/j9MgdIIxzGCJuYaT9wTjF3Oh0AN5vNYrFYKBRAi0U+n280Gu12G0fgmpIZW8iAq1Qk/F0lePAiIu3/ix0wB4S0M95h1WQxiY1jx3FA1e/3kbZer6PVpVIJC8Cj87quUxepBZNmdKhSqaBURDgR35VoAX8ul8MiSDwL+6+Ifwp2MCpQYdqWZQEEEUNGpIEH3+kUbHyG6Gqv1wMb6sR4gErkKB7wKBt3xjN/AdaHuZODKl++AAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 20 00 40 45"\n        title=""\n        src="/static/2021-07-20-00-40-45-24c91c69e4ddffc1c01ab55b2a2e007f-5032e.png"\n        srcset="/static/2021-07-20-00-40-45-24c91c69e4ddffc1c01ab55b2a2e007f-86481.png 200w,\n/static/2021-07-20-00-40-45-24c91c69e4ddffc1c01ab55b2a2e007f-1ca59.png 400w,\n/static/2021-07-20-00-40-45-24c91c69e4ddffc1c01ab55b2a2e007f-5032e.png 438w"\n        sizes="(max-width: 438px) 100vw, 438px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>但是 Last-Modified 存在一些弊端：</p>\n<ul>\n<li>如果本地打开缓存文件，即使没有对文件进行修改，但还是会造成 Last-Modified 被修改，服务端不能命中缓存导致发送相同的资源</li>\n<li>因为 Last-Modified 只能以秒计时，如果在不可感知的时间内修改完成文件，那么服务端会认为资源还是命中了，不会返回正确的资源</li>\n</ul>\n<p>既然根据文件修改时间来决定是否缓存尚有不足，能否可以直接根据文件内容是否修改来决定缓存策略？所以在 HTTP/1.1 出现了 ETag 和 If-None-Match</p>\n<h3 id="etag-和-if-none-match"><a href="#etag-%E5%92%8C-if-none-match" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>ETag 和 If-None-Match</h3>\n<p>Etag 是服务器响应请求时，返回当前资源文件的一个唯一标识（由服务器生成），只要资源有变化，Etag 就会重新生成。</p>\n<p>浏览器在下一次加载资源向服务器发送请求时，会将上一次返回的 Etag 值放到 request header 里的 If-None-Match 里，服务器只需要比较客户端传来的 If-None-Match 跟自己服务器上该资源的 ETag 是否一致，就能很好地判断资源相对客户端而言是否被修改过了。</p>\n<p>如果服务器发现 ETag 匹配不上，那么直接以常规 GET 200 形式将新的资源（当然也包括了新的 ETag）发给客户端；如果 ETag 是一致的，则直接返回 304 知会客户端直接使用本地缓存即可。</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-20-00-47-46-d84c84d3a0447d31481dee0faa30005d-94f8a.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 546px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 46.88644688644688%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAIAAAC9o5sfAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABCUlEQVQoz22QW2+FIBCE/f8/z8uDxwhWjwp4aSJojA+2n9Ce2qaTaJZhZpndyBjz4WGtzbKsrmspZVVVQoqyLKWQXdcHaK2TJEEW9OM4Rn/MUIiGYVBK9Z2a5wmb8oBvmuaXGV04rOvKs/M8w9JRX+bLFhqF4vF4OOeCfpqmiG9ZFrrCCiGwoWvb9tk8AZFDls6D2MjQvHt8vXye57ZtiHifXs5aRNT8yUlytkAX/DD7vh/HQcafmZFyTQv3jWWx2OEZleX9E/u+sDRNQ8Leb4lgJGcEyDePOI5fC7vM3HEOY9MeypghALPSRuvrDM+Rnq+Xr20TffKgCBPe4W4UJf6iKAif5znb/QSEbfQ2ArxKhwAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 20 00 47 46"\n        title=""\n        src="/static/2021-07-20-00-47-46-d84c84d3a0447d31481dee0faa30005d-94f8a.png"\n        srcset="/static/2021-07-20-00-47-46-d84c84d3a0447d31481dee0faa30005d-e2b97.png 200w,\n/static/2021-07-20-00-47-46-d84c84d3a0447d31481dee0faa30005d-db056.png 400w,\n/static/2021-07-20-00-47-46-d84c84d3a0447d31481dee0faa30005d-94f8a.png 546w"\n        sizes="(max-width: 546px) 100vw, 546px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<h3 id="etag-和-last-modified-两者对比"><a href="#etag-%E5%92%8C-last-modified-%E4%B8%A4%E8%80%85%E5%AF%B9%E6%AF%94" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Etag 和 Last-Modified 两者对比</h3>\n<ul>\n<li>\n<p>在精确度上，Etag 要优于 Last-Modified。</p>\n<p>Last-Modified 的时间单位是秒，如果某个文件在 1 秒内改变了多次，那么他们的 Last-Modified 其实并没有体现出来修改，但是 Etag 每次都会改变确保了精度；如果是负载均衡的服务器，各个服务器生成的 Last-Modified 也有可能不一致。</p>\n</li>\n<li>\n<p>在性能上，Etag 要逊于 Last-Modified，毕竟 Last-Modified 只需要记录时间，而 Etag 需要服务器通过算法来计算出一个 hash 值。</p>\n</li>\n<li>\n<p>在优先级上，服务器校验优先考虑 Etag</p>\n</li>\n</ul>\n<h1 id="缓存机制"><a href="#%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>缓存机制</h1>\n<p>强制缓存优先于协商缓存进行，若强制缓存(Expires 和 Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified / If-Modified-Since 和 Etag / If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，返回 200，重新返回资源和缓存标识，再存入浏览器缓存中；生效则返回 304，继续使用缓存。具体流程图如下：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-20-00-56-37-ba386b410c4a654652feaa89168ab311-561f5.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 519px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 89.01734104046243%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAIAAADUsmlHAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACiklEQVQ4y1WUW5OaQBCF+f8/aF+yL9nHpJJoVtcLqOAa5aIyM9xmGMB8I24q20VZDczp0+d0o6cbfTgcoiiq67r/iNYYXZVVllVpWiVJFYbFble8vzcib41urbG95fKstVLK6+Vq79HZjuDV7XYzQqjVWm23aj4TrzMZbEyhOtvaztihc2BOSyWzLIPQwe5RVVWplNG6qaq6qqxpOdbzkh/T8lgbTXMetLPZzPf9OI4vlwtVjsfjcrWaTqeTyWQ+m++jKIljKcQ5O4s8f9/vN8FmOpmmSeIZY6SQeZ6TjG23bds0jdY62oWFlI6m0b1j7shlLnTdXLJzUzfebbjRJGBEPmR33TAM3CZxQk7ium3trR9abUpVAFFCDv3glWW52+2CIKD/7h70/zZ/22y2q9XSX/vB2j8dj/gPElqYqEVCj07zer0GjFoIAfNkv0dplKXpcrFYzBf5Nccz2Bjf3baOnMTjNORCiNFtgtqj5jRJkQdhodTQ9TTMmOgW2AMMGw6xIaPmUTDmURF+2sMYRGLV8fAnS7PWtJgnxrY55zT7AWwjOWClVBiGq8Vy4wfx8cSQojD69ePn7PdrXdaQy5GZ2T5/eX56emJJR828M/dgknVV6/uc3JCEKKSic2fYCEbhKT5hT1EU/5YMJE++f/u2DTb1w6Se5qnuctspeQdzFG9QiObRME5QkfV6+fqynL/h0wjo3c67JWXgjzlzw9Hr9Qqb/gj0438Uhuf7Jo1DxioSbnELL8qidMy4zWzV58B/VppRIbsqyqrkqpAA8rB/Xy9X1PXGb3D4L9BGxfP5zHrFpxOETmvHfFH86J/OSbzuc/BluAPWun+IMIQECWA+PkmHpBC3/P4Fr8D/SZDkfTcAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 20 00 56 37"\n        title=""\n        src="/static/2021-07-20-00-56-37-ba386b410c4a654652feaa89168ab311-561f5.png"\n        srcset="/static/2021-07-20-00-56-37-ba386b410c4a654652feaa89168ab311-214e0.png 200w,\n/static/2021-07-20-00-56-37-ba386b410c4a654652feaa89168ab311-ef58c.png 400w,\n/static/2021-07-20-00-56-37-ba386b410c4a654652feaa89168ab311-561f5.png 519w"\n        sizes="(max-width: 519px) 100vw, 519px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>看到这里，不知道你是否存在这样一个疑问:如果什么缓存策略都没设置，那么浏览器会怎么处理？</p>\n<p>对于这种情况，浏览器会采用一个启发式的算法，通常会取响应头中的 Date 减去 Last-Modified 值的 10% 作为缓存时间。</p>\n<h1 id="实际场景"><a href="#%E5%AE%9E%E9%99%85%E5%9C%BA%E6%99%AF" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>实际场景</h1>\n<h2 id="频繁变动的资源"><a href="#%E9%A2%91%E7%B9%81%E5%8F%98%E5%8A%A8%E7%9A%84%E8%B5%84%E6%BA%90" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>频繁变动的资源</h2>\n<blockquote>\n<p>Cache-Control: no-cache</p>\n</blockquote>\n<p>对于频繁变动的资源，首先需要使用 Cache-Control: no-cache 使浏览器每次都请求服务器，然后配合 ETag 或者 Last-Modified 来验证资源是否有效。这样的做法虽然不能节省请求数量，但是能显著减少响应数据大小。</p>\n<h2 id="不常变化的资源"><a href="#%E4%B8%8D%E5%B8%B8%E5%8F%98%E5%8C%96%E7%9A%84%E8%B5%84%E6%BA%90" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>不常变化的资源</h2>\n<blockquote>\n<p>Cache-Control: max-age=31536000</p>\n</blockquote>\n<p>通常在处理这类资源时，给它们的 Cache-Control 配置一个很大的 max-age=31536000（一年），这样浏览器之后请求相同的 URL 会命中强制缓存。</p>\n<p>而为了解决更新的问题，就需要在文件名（或者路径）中添加 hash，版本号等动态字符，之后更改动态字符，从而达到更改引用 URL 的目的，让之前的强制缓存失效（其实并未立即失效，只是不再使用了而已）。</p>\n<p>在线提供的类库（如 jquery-3.3.1.min.js, lodash.min.js 等）均采用这个模式。</p>\n<h1 id="用户行为影响"><a href="#%E7%94%A8%E6%88%B7%E8%A1%8C%E4%B8%BA%E5%BD%B1%E5%93%8D" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>用户行为影响</h1>\n<p>所谓用户行为对浏览器缓存的影响，指的就是用户在浏览器如何操作时，会触发怎样的缓存策略。主要有 3 种：</p>\n<ul>\n<li>打开网页，地址栏输入地址：查找 disk cache 中是否有匹配。如有则使用；如没有则发送网络请求。</li>\n<li>普通刷新 (F5)：因为 TAB 并没有关闭，因此 memory cache 是可用的，会被优先使用（如果匹配的话），其次才是 disk cache。</li>\n<li>强制刷新 (Ctrl + F5)：浏览器不使用缓存，因此发送的请求头部均带有 Cache-control: no-cache（为了兼容，还带了 Pragma: no-cache），服务器直接返回 200 和最新内容。</li>\n</ul>',
excerpt:"…",frontmatter:{date:"2021-07-16 18:51:10",path:"/deep-learn-browser-cache/",tags:"前端, 浏览器, 高级前端",title:"深入理解浏览器的缓存机制",draft:null}},prePost:null},pathContext:{mainPostPath:"/browser-working-principle/",nextPostPath:"/deep-learn-browser-cache/",prePostPath:"none"}}}});