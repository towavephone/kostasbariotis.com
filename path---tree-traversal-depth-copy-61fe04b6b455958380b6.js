webpackJsonp([26795806700048],{1457:function(n,a){n.exports={data:{file:{childImageSharp:{sizes:{base64:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAeCAYAAAAsEj5rAAAACXBIWXMAAAsSAAALEgHS3X78AAAHlUlEQVRIx11WaWxU1xWewbQlrdofkSIhGiBpMPZ4Vs/2lpm3zupZPOOZ8Sz2YGzANkaAKaYQUrMkLYgiIlxCQjCYQAwYEoMQNJAIFBxaQgUhoCopYceBJo1pKFVDCbOc0/fesOZKV+fM1Tvf/c56R0VYOZW8lvAxtSybvbExAu1+mndGuaDQ2F4rNHVFhCZJZlMeZ1Qrf9Mt+H+qur/ihFORAFA64J0pVTcXVcDmcKFfruIzZ7rY1H89fAZivjbM1MzFxkAnZqWd9M7KJcTmv7zCN44sY+tflm12C79WLxLCqidWN9cwWpYvsfXL13vasZudgm4mgX4hW6h1teRjnrZCwjOzWO/twIR/FjZ7WnEZ35JvcUSeU4gwSXV7W1sJzEH6R8nSRArlXjr6r7S1DqNUvMAzCXCzSfDxDRAUmyDkaoawtEPi1LxHyGLMkby5gEqUy7atjnq1roosAXqE6Yq7DBXa7RLS6HRG8y4hhbwzDiJbj4IkXUwS5e1h07IOorMePUL6ruiKGmRblg2PesJlq9nxrJMMfydIbhIWP9jMPrBLkrIHgXfG0CdmgKMjwFARFKVvHEQo5xUyKDDRN2T7aE17mV5rfZQYm1lM0EQYWUe0aNTxoKl0Qnk5jVqNA/VaFu3SBS7SB7Ju0ougr2KKWg2DBi17mbCaxyghMzgeMTTp2W7CGkTKHshZqn0Q5Osg6opBhAmAzcADY/NheyQJBi2D8mXVehYMOgEsJg9aTIxSN2YTO+ohQ62G6rGZa5AmAjmj0YvzG5vhVP8f4fTO12FtVxfMjTfC6zPbwOsIQNybhK6GlmLCm5DA6cu2aoeSaaOeVheLxRKgpoJcZ5UAly94MeeiQ+jnQtBCcTBTZ8Ght9fDfy58DDdOHIRj2zdA/4uzYWBpZ6Fr6jR8/lfWP8n2usqA2mQgH7msr3Ks0WgEfGvN6lz/q6tgXqgZjgpZOGSLwsldA4CFG4j3rmP/osU47xkdrm5pLfjdETm+p64cf0fJME34HiVFV+VYajF50UGGc/Nnz4XDfW/ArQ09+M++XsCblwD+fQEL356HswuWwdedS+Dg2p5ilZQwa7VrpCHZ9nOl7Ojg44B0hxxg0hbMjx2rh2iwDk4feReKI58hfn8V8c5lwNyXiF+dRbz4Z1jY1g4TJ1rQbnHfc/ORihJDr5q0kw8AyVqDjpeSEpJLAyaMN6HRwMDuTa/B1fcPwcfbBuHc8SPw+cnDsGvzeim7HOg0DpAYoouPBWUMJxUo65y18X4MtbYJOo3zjgQoxwWen1iNDdPmwPu9+2BvfCXsXbQRehf9Hly0B8aN04OuioGqCipvt/hQ5GLzS4Dh0Tdv3+/nvm0qVVUlfUouboOWK8jxmaznMBXIwpbfroWN63th384tcHTfDpj0gg21lQxoK+m8TQGMb5UxAt6OUYSVkUuGK5MPKiuIHicZwWqDmNNqpE6pIFBjpGDxsqXwuxUroWtBN5w4NgSbNvcDIRW61CUFu9UrtV/si7Fjf/ajUmICSvxKgJMtdQxVK2XOU9RpGNBL3VBeQWIqPR3SjR3QOW8xrFmxCnrWbYJMaobEkr1HE/4zIpv4nrK7NIrbpF+tspoYZdpMLte+wNPRu6S1Bs1GqV/1DOqMPFjIMFbq3dg6cyFkGmagqZqHaoOAHF2XZ6ngWg+XBM4RVoLHOWrLVG4uWpo4FvsvfHz6NktFkbT6QafnQGsUoFLHYm1dFj44cgwYPgQVkymkbP6RWl+LNIRjL/uFhltuNjEoYySCXaNUojOsMPSw4aqwa+o9ga5DggiC1RFDmyMG1bYQVlTSIIhRMJq9RaPZJ4VF+DQZ6MCAmOkLurJ/DYiNt/R67VMKs4hrqjL+o+6mjrj0hjBEOG+1h8FOxcFO1oHVFgazPYQGqdfNthBYpUqwEME78nsT4tP7o96WwWSwA1nKb35iyCZ8M85EXE3oYBO3ab4RKWcSKCaFJJMCQprSpPQcUFwKzWQUKo1+lC9x0r7Fcc+0OVOj8zEkNrY8BAuLDV11ruZvDXrhuJ3NIu+bAYK/FXjfdOA8zegUp6DdmQKNMQD+8HTseW1LYeijE/jB4Q+/Wry8a5L01B6MeaetUcDSjfVjjOVM7da+bTMPvHfkbmrKb5DksjkLncmZqXTe6siAnWmAmkhbYUPvQP7cufO5L69fxyvD/8Ctb+/aI2PU8AmvRGqZAoiIityzb8/T165d3X3t2vD/Pjr+KW7b+R6u2/AOrli9CQfePYQXLg3jpSvDeOLkWTxw6Oh3uwYPrJTMlNHlFcLPeNk6/UOXZ7cuGP1A397fP/7v584vvzJ8o+dvn33+Zm/v9q9X/2EDbN+19+ybm3ds33/ww5f63uovf/D9woVL1A90P5dQqYaGhpQfg4N71BJbteoHqyk7Z+e8zlfuSupPHj+/eO2bso5ZcxQ9Fsiqgny6ZOv3+VTfjIwo+iefnFYN7BxQf3FxuEwGH1c+fgxBuIZnTFuIIh9U2qt3844fb9y0Vf0gXPKm7bzKzYZ+wGTKFFWNz1/6v8OLUiuaFKMJz00yEvaa/RQZnK086s6MutpEqRLx+kcT+rH1f+YikeeNfqnwAAAAAElFTkSuQmCC",aspectRatio:.6666666666666666,src:"/static/avatar-a4ccbab8e7381acb89452773ce94d5a0-25c91.png",srcSet:"/static/avatar-a4ccbab8e7381acb89452773ce94d5a0-8a97b.png 200w,\n/static/avatar-a4ccbab8e7381acb89452773ce94d5a0-0fdf3.png 400w,\n/static/avatar-a4ccbab8e7381acb89452773ce94d5a0-25c91.png 600w",srcWebp:"/static/avatar-a4ccbab8e7381acb89452773ce94d5a0-216f6.webp",srcSetWebp:"/static/avatar-a4ccbab8e7381acb89452773ce94d5a0-5d70e.webp 200w,\n/static/avatar-a4ccbab8e7381acb89452773ce94d5a0-d1677.webp 400w,\n/static/avatar-a4ccbab8e7381acb89452773ce94d5a0-216f6.webp 600w",sizes:"(max-width: 600px) 100vw, 600px"}}},site:{siteMetadata:{title:"女王控的博客",description:'前端工程师，黑猫女王控，欢迎勾搭，技术相关<a href="https://github.com/towavephone" target="_blank">@towavephone</a>，QQ闲聊<a href="tencent://AddContact/?fromId=45&fromSubId=1&subcmd=all&uin=634407147&website=www.oicqzone.com">@towave</a>，bili关注<a href="https://space.bilibili.com/11507708#/" target="_blank">@towave</a>',siteUrl:"https://blog.towavephone.com"}},mainPost:{html:'<h1 id="广度优先搜索"><a href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>广度优先搜索</h1>\n<p>以二叉树的层次遍历举例：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="37291908902947940000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`/*\n * @lc app=leetcode.cn id=102 lang=javascript\n *\n * [102] 二叉树的层次遍历\n *\n * https://leetcode-cn.com/problems/binary-tree-level-order-traversal/description/\n *\n * algorithms\n * Medium (53.64%)\n * Total Accepted:    17.4K\n * Total Submissions: 32.4K\n * Testcase Example:  \'[3,9,20,null,null,15,7]\'\n *\n * 给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。\n *\n * 例如:\n * 给定二叉树: [3,9,20,null,null,15,7],\n *\n * ⁠   3\n * ⁠  / \\\n * ⁠ 9  20\n * ⁠   /  \\\n * ⁠  15   7\n *\n *\n * 返回其层次遍历结果：\n *\n * [\n * ⁠ [3],\n * ⁠ [9,20],\n * ⁠ [15,7]\n * ]\n *\n *\n */\n/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[][]}\n */\nvar levelOrder = function(root) {\n  if (!root) {\n    return [];\n  }\n  const queue = [root];\n  const results = [];\n  while (queue.length) {\n    let count = queue.length;\n    const result = [];\n    while (count--) {\n      const t1 = queue.shift();\n      result.push(t1.val);\n      t1.left && queue.push(t1.left);\n      t1.right && queue.push(t1.right);\n    }\n    results.push(result);\n  }\n  return results;\n};`, `37291908902947940000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">/*\n * @lc app=leetcode.cn id=102 lang=javascript\n *\n * [102] 二叉树的层次遍历\n *\n * https://leetcode-cn.com/problems/binary-tree-level-order-traversal/description/\n *\n * algorithms\n * Medium (53.64%)\n * Total Accepted:    17.4K\n * Total Submissions: 32.4K\n * Testcase Example:  \'[3,9,20,null,null,15,7]\'\n *\n * 给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。\n *\n * 例如:\n * 给定二叉树: [3,9,20,null,null,15,7],\n *\n * ⁠   3\n * ⁠  / \\\n * ⁠ 9  20\n * ⁠   /  \\\n * ⁠  15   7\n *\n *\n * 返回其层次遍历结果：\n *\n * [\n * ⁠ [3],\n * ⁠ [9,20],\n * ⁠ [15,7]\n * ]\n *\n *\n */</span>\n<span class="token comment">/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */</span>\n<span class="token comment">/**\n * @param {TreeNode} root\n * @return {number[][]}\n */</span>\n<span class="token keyword">var</span> <span class="token function-variable function">levelOrder</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token keyword">const</span> queue <span class="token operator">=</span> <span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">;</span>\n  <span class="token keyword">const</span> results <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n  <span class="token keyword">while</span> <span class="token punctuation">(</span>queue<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">let</span> count <span class="token operator">=</span> queue<span class="token punctuation">.</span>length<span class="token punctuation">;</span>\n    <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n    <span class="token keyword">while</span> <span class="token punctuation">(</span>count<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">const</span> t1 <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      result<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>t1<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      t1<span class="token punctuation">.</span>left <span class="token operator">&amp;&amp;</span> queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>t1<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      t1<span class="token punctuation">.</span>right <span class="token operator">&amp;&amp;</span> queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>t1<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n    results<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token keyword">return</span> results<span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h1 id="深度优先搜索"><a href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>深度优先搜索</h1>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="60142558788489800000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`/*深度优先遍历三种方式*/\nlet deepTraversal1 = (node, nodeList = []) => {\n  if (node !== null) {\n    nodeList.push(node);\n    let children = node.children;\n    for (let i = 0; i < children.length; i++) {\n      deepTraversal1(children[i], nodeList);\n    }\n  }\n  return nodeList;\n};\nlet deepTraversal2 = (node) => {\n  let nodes = [];\n  if (node !== null) {\n    nodes.push(node);\n    let children = node.children;\n    for (let i = 0; i < children.length; i++) {\n      nodes = nodes.concat(deepTraversal2(children[i]));\n    }\n  }\n  return nodes;\n};\n// 非递归\nlet deepTraversal3 = (node) => {\n  let stack = [];\n  let nodes = [];\n  if (node) {\n    // 推入当前处理的node\n    stack.push(node);\n    while (stack.length) {\n      let item = stack.pop();\n      let children = item.children;\n      nodes.push(item);\n      // node = [] stack = [parent]\n      // node = [parent] stack = [child3,child2,child1]\n      // node = [parent, child1] stack = [child3,child2,child1-2,child1-1]\n      // node = [parent, child1-1] stack = [child3,child2,child1-2]\n      for (let i = children.length - 1; i >= 0; i--) {\n        stack.push(children[i]);\n      }\n    }\n  }\n  return nodes;\n};`, `60142558788489800000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">/*深度优先遍历三种方式*/</span>\n<span class="token keyword">let</span> <span class="token function-variable function">deepTraversal1</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">node<span class="token punctuation">,</span> nodeList <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span></span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    nodeList<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">let</span> children <span class="token operator">=</span> node<span class="token punctuation">.</span>children<span class="token punctuation">;</span>\n    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> children<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token function">deepTraversal1</span><span class="token punctuation">(</span>children<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> nodeList<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n  <span class="token keyword">return</span> nodeList<span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token keyword">let</span> <span class="token function-variable function">deepTraversal2</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">node</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  <span class="token keyword">let</span> nodes <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    nodes<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">let</span> children <span class="token operator">=</span> node<span class="token punctuation">.</span>children<span class="token punctuation">;</span>\n    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> children<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      nodes <span class="token operator">=</span> nodes<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token function">deepTraversal2</span><span class="token punctuation">(</span>children<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n  <span class="token keyword">return</span> nodes<span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token comment">// 非递归</span>\n<span class="token keyword">let</span> <span class="token function-variable function">deepTraversal3</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">node</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  <span class="token keyword">let</span> stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n  <span class="token keyword">let</span> nodes <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 推入当前处理的node</span>\n    stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">while</span> <span class="token punctuation">(</span>stack<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">let</span> item <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token keyword">let</span> children <span class="token operator">=</span> item<span class="token punctuation">.</span>children<span class="token punctuation">;</span>\n      nodes<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token comment">// node = [] stack = [parent]</span>\n      <span class="token comment">// node = [parent] stack = [child3,child2,child1]</span>\n      <span class="token comment">// node = [parent, child1] stack = [child3,child2,child1-2,child1-1]</span>\n      <span class="token comment">// node = [parent, child1-1] stack = [child3,child2,child1-2]</span>\n      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> children<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>children<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n  <span class="token keyword">return</span> nodes<span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h1 id="深度优先拷贝"><a href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%8B%B7%E8%B4%9D" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>深度优先拷贝</h1>\n<p>目前只拷贝了 Object, Array</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="4535704695055198000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// 如果是对象/数组，返回一个空的对象/数组，\n// 都不是的话直接返回原对象\n// 判断返回的对象和原有对象是否相同就可以知道是否需要继续深拷贝\n// 处理其他的数据类型的话就在这里加判断\nfunction getEmpty(o) {\n  if (Object.prototype.toString.call(o) === \'[object Object]\') {\n    return {};\n  }\n  if (Object.prototype.toString.call(o) === \'[object Array]\') {\n    return [];\n  }\n  return o;\n}\n\nfunction deepCopyBFS(origin) {\n  let queue = [];\n  let map = new Map(); // 记录出现过的对象，用于处理环\n\n  let target = getEmpty(origin);\n  if (target !== origin) {\n    queue.push([origin, target]);\n    map.set(origin, target);\n  }\n\n  while (queue.length) {\n    let [ori, tar] = queue.shift();\n    for (let key in ori) {\n      // 处理环状\n      if (map.get(ori[key])) {\n        tar[key] = map.get(ori[key]);\n        continue;\n      }\n\n      tar[key] = getEmpty(ori[key]);\n      if (tar[key] !== ori[key]) {\n        queue.push([ori[key], tar[key]]);\n        map.set(ori[key], tar[key]);\n      }\n    }\n  }\n\n  return target;\n}\n\nfunction deepCopyDFS(origin) {\n  let stack = [];\n  let map = new Map(); // 记录出现过的对象，用于处理环\n\n  let target = getEmpty(origin);\n  if (target !== origin) {\n    stack.push([origin, target]);\n    map.set(origin, target);\n  }\n\n  while (stack.length) {\n    let [ori, tar] = stack.pop();\n    for (let key in ori) {\n      // 处理环状\n      if (map.get(ori[key])) {\n        tar[key] = map.get(ori[key]);\n        continue;\n      }\n\n      tar[key] = getEmpty(ori[key]);\n      if (tar[key] !== ori[key]) {\n        stack.push([ori[key], tar[key]]);\n        map.set(ori[key], tar[key]);\n      }\n    }\n  }\n\n  return target;\n}`, `4535704695055198000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">// 如果是对象/数组，返回一个空的对象/数组，</span>\n<span class="token comment">// 都不是的话直接返回原对象</span>\n<span class="token comment">// 判断返回的对象和原有对象是否相同就可以知道是否需要继续深拷贝</span>\n<span class="token comment">// 处理其他的数据类型的话就在这里加判断</span>\n<span class="token keyword">function</span> <span class="token function">getEmpty</span><span class="token punctuation">(</span><span class="token parameter">o</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">\'[object Object]\'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">\'[object Array]\'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token keyword">return</span> o<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">function</span> <span class="token function">deepCopyBFS</span><span class="token punctuation">(</span><span class="token parameter">origin</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">let</span> queue <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n  <span class="token keyword">let</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 记录出现过的对象，用于处理环</span>\n\n  <span class="token keyword">let</span> target <span class="token operator">=</span> <span class="token function">getEmpty</span><span class="token punctuation">(</span>origin<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>target <span class="token operator">!==</span> origin<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">[</span>origin<span class="token punctuation">,</span> target<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    map<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>origin<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token keyword">while</span> <span class="token punctuation">(</span>queue<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">let</span> <span class="token punctuation">[</span>ori<span class="token punctuation">,</span> tar<span class="token punctuation">]</span> <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">in</span> ori<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token comment">// 处理环状</span>\n      <span class="token keyword">if</span> <span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>ori<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        tar<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>ori<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">continue</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n\n      tar<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">getEmpty</span><span class="token punctuation">(</span>ori<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token keyword">if</span> <span class="token punctuation">(</span>tar<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">!==</span> ori<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">[</span>ori<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">,</span> tar<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        map<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>ori<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">,</span> tar<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token keyword">return</span> target<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">function</span> <span class="token function">deepCopyDFS</span><span class="token punctuation">(</span><span class="token parameter">origin</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">let</span> stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n  <span class="token keyword">let</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 记录出现过的对象，用于处理环</span>\n\n  <span class="token keyword">let</span> target <span class="token operator">=</span> <span class="token function">getEmpty</span><span class="token punctuation">(</span>origin<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>target <span class="token operator">!==</span> origin<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">[</span>origin<span class="token punctuation">,</span> target<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    map<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>origin<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token keyword">while</span> <span class="token punctuation">(</span>stack<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">let</span> <span class="token punctuation">[</span>ori<span class="token punctuation">,</span> tar<span class="token punctuation">]</span> <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">in</span> ori<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token comment">// 处理环状</span>\n      <span class="token keyword">if</span> <span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>ori<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        tar<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>ori<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">continue</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n\n      tar<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">getEmpty</span><span class="token punctuation">(</span>ori<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token keyword">if</span> <span class="token punctuation">(</span>tar<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">!==</span> ori<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">[</span>ori<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">,</span> tar<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        map<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>ori<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">,</span> tar<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token keyword">return</span> target<span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>',
excerpt:"广度优先搜索 以二叉树的层次遍历举例： 深度优先搜索 深度优先拷贝 目前只拷贝了 Object, Array",timeToRead:2,tableOfContents:'<ul>\n<li><a href="/tree-traversal-depth-copy/#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2">广度优先搜索</a></li>\n<li><a href="/tree-traversal-depth-copy/#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2">深度优先搜索</a></li>\n<li><a href="/tree-traversal-depth-copy/#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%8B%B7%E8%B4%9D">深度优先拷贝</a></li>\n</ul>',wordCount:{words:20},frontmatter:{date:"2019-07-19 11:47:41",path:"/tree-traversal-depth-copy/",tags:"前端, 深度拷贝, 树的遍历",title:"树的遍历算法与深度拷贝函数",draft:null,catalog_number:null}},nextPost:{html:'<p>防抖动是将多次执行变为最后一次执行，节流是将多次执行变成每隔一段时间执行。</p>\n<h1 id="防抖"><a href="#%E9%98%B2%E6%8A%96" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>防抖</h1>\n<p>触发高频事件后 n 秒内函数只会执行一次，如果 n 秒内高频事件再次被触发，则重新计算时间</p>\n<h2 id="思路："><a href="#%E6%80%9D%E8%B7%AF%EF%BC%9A" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>思路：</h2>\n<p>每次触发事件时都取消之前的延时调用方法</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="66073117141667170000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function debounce(fn) {\n  let timeout = null; // 创建一个标记用来存放定时器的返回值\n  return function() {\n    clearTimeout(timeout); // 每当用户输入的时候把前一个 setTimeout clear 掉\n    // 然后又创建一个新的 setTimeout, 这样就能保证输入字符后的 interval 间隔内如果还有字符输入的话，就不会执行 fn 函数\n    timeout = setTimeout(() => {\n      fn.apply(this, arguments);\n    }, 500);\n  };\n}\n\nfunction sayHi() {\n  console.log(\'防抖成功\');\n}\n\nvar inp = document.getElementById(\'inp\');\ninp.addEventListener(\'input\', debounce(sayHi)); // 防抖`, `66073117141667170000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span> <span class="token function">debounce</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">let</span> timeout <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 创建一个标记用来存放定时器的返回值</span>\n  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 每当用户输入的时候把前一个 setTimeout clear 掉</span>\n    <span class="token comment">// 然后又创建一个新的 setTimeout, 这样就能保证输入字符后的 interval 间隔内如果还有字符输入的话，就不会执行 fn 函数</span>\n    timeout <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n      <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">function</span> <span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'防抖成功\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">var</span> inp <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">\'inp\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\ninp<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">\'input\'</span><span class="token punctuation">,</span> <span class="token function">debounce</span><span class="token punctuation">(</span>sayHi<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 防抖</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h1 id="节流"><a href="#%E8%8A%82%E6%B5%81" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>节流</h1>\n<p>高频事件触发，但在 n 秒内只会执行一次，所以节流会稀释函数的执行频率</p>\n<h2 id="思路：-1"><a href="#%E6%80%9D%E8%B7%AF%EF%BC%9A-1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>思路：</h2>\n<p>每次触发事件时都判断当前是否有等待执行的延时函数</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="49205668397259350000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function throttle(fn) {\n  let canRun = true; // 通过闭包保存一个标记\n  return function() {\n    if (!canRun) return; // 在函数开头判断标记是否为 true，不为 true 则 return\n    canRun = false; // 立即设置为 false\n    setTimeout(() => {\n      // 将外部传入的函数的执行放在 setTimeout 中\n      fn.apply(this, arguments);\n      // 最后在 setTimeout 执行完毕后再把标记设置为 true(关键) 表示可以执行下一次循环了\n      // 当定时器没有执行的时候标记永远是 false，在开头被 return 掉\n      canRun = true;\n    }, 500);\n  };\n}\n\nfunction sayHi(e) {\n  console.log(e.target.innerWidth, e.target.innerHeight);\n}\n\nwindow.addEventListener(\'resize\', throttle(sayHi));`, `49205668397259350000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span> <span class="token function">throttle</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">let</span> canRun <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">// 通过闭包保存一个标记</span>\n  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>canRun<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token comment">// 在函数开头判断标记是否为 true，不为 true 则 return</span>\n    canRun <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">// 立即设置为 false</span>\n    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n      <span class="token comment">// 将外部传入的函数的执行放在 setTimeout 中</span>\n      <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token comment">// 最后在 setTimeout 执行完毕后再把标记设置为 true(关键) 表示可以执行下一次循环了</span>\n      <span class="token comment">// 当定时器没有执行的时候标记永远是 false，在开头被 return 掉</span>\n      canRun <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">function</span> <span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>target<span class="token punctuation">.</span>innerWidth<span class="token punctuation">,</span> e<span class="token punctuation">.</span>target<span class="token punctuation">.</span>innerHeight<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\nwindow<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">\'resize\'</span><span class="token punctuation">,</span> <span class="token function">throttle</span><span class="token punctuation">(</span>sayHi<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>',excerpt:"防抖动是将多次执行变为最后一次执行，节流是将多次执行变成每隔一段时间执行。 防抖 触发高频事件后 n 秒内函数只会执行一次，如果 n 秒内高频事件再次被触发，则重新计算时间 思路： 每次触发事件时都取消之前的延时调用方法 节流 高频事件触发，但在 n…",frontmatter:{date:"2019-07-19 11:31:28",path:"/debounce-throttle-difference-realize/",tags:"前端, JS, 防抖, 节流",title:"防抖节流的区别与实现",draft:null}},prePost:{html:'<h2 id="什么是正则表达式"><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>什么是正则表达式?</h2>\n<blockquote>\n<p>正则表达式是一组由字母和符号组成的特殊文本, 它可以用来从文本中找出满足你想要的格式的句子.</p>\n</blockquote>\n<p>一个正则表达式是在一个主体字符串中从左到右匹配字符串时的一种样式. “Regular expression”这个词比较拗口, 我们常使用缩写的术语”regex”或”regexp”. 正则表达式可以从一个基础字符串中根据一定的匹配模式替换文本中的字符串、验证表单、提取字符串等等.</p>\n<p>想象你正在写一个应用, 然后你想设定一个用户命名的规则, 让用户名包含字符,数字,下划线和连字符,以及限制字符的个数,好让名字看起来没那么丑. 我们使用以下正则表达式来验证一个用户名:</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2019-08-02-10-48-56-d88dc13f336df51f9044ca25f7d7c7b1-ad3a8.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 396px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 98.98989898989899%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAIAAAAC64paAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAB00lEQVQ4y5WUV2tCQRCF7///G6JY8UHsIIoiNnwQRRF7773EEm++OOF6b2IMGXBdd/ZMOXNWpVarmc1mp9Pp8/l2u52qqrfbTTXa7W7vd5ONnCuXy2W1WjWbTdbr9ar+xxTJk81mnyJPp9PhcJjP55PJZDAY9Pt99qz7/f4VWM6n02mxWMzlcqVSKRaLeb3eeDzudrt7vd7fmfWB2u22JNRI+QJnMpkXYGEon88vFgvt5wNMYTCn51ZMfsrtcrkMqQIWl8LnfD5bLJafmfV4VofD0e12DWXLV71ex7HdbgkxGo3giSTL5RLXbDYbj8eQzAaeWWmekweYo2AwGAgEGo2G1Wr1+/10GAqFNptNKpWKRCLsK5VKNBrlmt1u5+QBxpAXbZOZlRIIdzwe3+6Gi4Gv12tO8FJRp9N5gLU2hBumykj1xOqv0ZfL5TJk1nMzHA5hQSP2G/9krlarBrA+BAKiw98yM20YeQWW2E/B6Exm9g+wuKDK4/HAdjKZVERA2osVqRBYK1t/QYYKnTDCUJ9nhs9Wq/X0j8HwnumeqzJMdENgNsgLSaEzHjMXeMyo5ZtmP8GUjmISiUQ4HLbZbGgrfjeEZTKZCoUCsmPm6XT6ZyEf8Bhrkc4dD9EAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2019 08 02 10 48 56"\n        title=""\n        src="/static/2019-08-02-10-48-56-d88dc13f336df51f9044ca25f7d7c7b1-ad3a8.png"\n        srcset="/static/2019-08-02-10-48-56-d88dc13f336df51f9044ca25f7d7c7b1-2a85e.png 200w,\n/static/2019-08-02-10-48-56-d88dc13f336df51f9044ca25f7d7c7b1-ad3a8.png 396w"\n        sizes="(max-width: 396px) 100vw, 396px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>以上的正则表达式可以接受 <code class="language-text">john_doe</code>, <code class="language-text">jo-hn_doe</code>, <code class="language-text">john12_as</code>. 但不匹配<code class="language-text">Jo</code>, 因为它包含了大写的字母而且太短了.</p>\n<h2 id="基本匹配"><a href="#%E5%9F%BA%E6%9C%AC%E5%8C%B9%E9%85%8D" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>基本匹配</h2>\n<p>正则表达式其实就是在执行搜索时的格式, 它由一些字母和数字组合而成. 例如: 一个正则表达式 <code class="language-text">the</code>, 它表示一个规则: 由字母<code class="language-text">t</code>开始,接着是<code class="language-text">h</code>,再接着是<code class="language-text">e</code>.</p>\n<pre>\n"the" => The fat cat sat on <a href="#learn-regex"><strong>the</strong></a> mat.\n</pre>\n<p><a href="https://regex101.com/r/dmRygT/1" target="_blank" rel="nofollow noreferrer noopener">在线练习</a></p>\n<p>正则表达式<code class="language-text">123</code>匹配字符串<code class="language-text">123</code>. 它逐个字符的与输入的正则表达式做比较.</p>\n<p>正则表达式是大小写敏感的, 所以<code class="language-text">The</code>不会匹配<code class="language-text">the</code>.</p>\n<pre>\n"The" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on the mat.\n</pre>\n<p><a href="https://regex101.com/r/1paXsy/1" target="_blank" rel="nofollow noreferrer noopener">在线练习</a></p>\n<h2 id="元字符"><a href="#%E5%85%83%E5%AD%97%E7%AC%A6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>元字符</h2>\n<p>正则表达式主要依赖于元字符. 元字符不代表他们本身的字面意思, 他们都有特殊的含义. 一些元字符写在方括号中的时候有一些特殊的意思. 以下是一些元字符的介绍:</p>\n<table>\n<thead>\n<tr>\n<th align="center">元字符</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align="center">.</td>\n<td>句号匹配任意单个字符除了换行符.</td>\n</tr>\n<tr>\n<td align="center">[\n \n]</td>\n<td>字符种类. 匹配方括号内的任意字符.</td>\n</tr>\n<tr>\n<td align="center"><code class="language-text">[^ ]</code></td>\n<td>否定的字符种类. 匹配除了方括号里的任意字符</td>\n</tr>\n<tr>\n<td align="center">*</td>\n<td>匹配>=0 个重复的在\n*\n号之前的字符.</td>\n</tr>\n<tr>\n<td align="center">+</td>\n<td>匹配>=1 个重复的+号前的字符.</td>\n</tr>\n<tr>\n<td align="center">?</td>\n<td>标记?之前的字符为可选.</td>\n</tr>\n<tr>\n<td align="center">{n,m}</td>\n<td>匹配 num 个大括号之前的字符 (n &#x3C;= num &#x3C;= m).</td>\n</tr>\n<tr>\n<td align="center">(xyz)</td>\n<td>字符集, 匹配与 xyz 完全相等的字符串.</td>\n</tr>\n<tr>\n<td align="center">|</td>\n<td>或运算符,匹配符号前或后的字符.</td>\n</tr>\n<tr>\n<td align="center">\\</td>\n<td>转义字符,用于匹配一些保留的字符 \n<code>\n<a href=""> </a>\n { } . \n*\n + ? ^ \n$\n \\ \n|\n</code></td>\n</tr>\n<tr>\n<td align="center">^</td>\n<td>从开始行开始匹配.</td>\n</tr>\n<tr>\n<td align="center">$</td>\n<td>从末端开始匹配.</td>\n</tr>\n</tbody>\n</table>\n<h2 id="点运算符-"><a href="#%E7%82%B9%E8%BF%90%E7%AE%97%E7%AC%A6-" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>点运算符 <code class="language-text">.</code></h2>\n<p><code class="language-text">.</code>是元字符中最简单的例子. <code class="language-text">.</code>匹配任意单个字符, 但不匹配换行符. 例如, 表达式<code class="language-text">.ar</code>匹配一个任意字符后面跟着是<code class="language-text">a</code>和<code class="language-text">r</code>的字符串.</p>\n<pre>\n".ar" => The <a href="#learn-regex"><strong>car</strong></a> <a href="#learn-regex"><strong>par</strong></a>ked in the <a href="#learn-regex"><strong>gar</strong></a>age.\n</pre>\n<p><a href="https://regex101.com/r/xc9GkU/1" target="_blank" rel="nofollow noreferrer noopener">在线练习</a></p>\n<h2 id="字符集"><a href="#%E5%AD%97%E7%AC%A6%E9%9B%86" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>字符集</h2>\n<p>字符集也叫做字符类. 方括号用来指定一个字符集. 在方括号中使用连字符来指定字符集的范围. 在方括号中的字符集不关心顺序. 例如, 表达式<code class="language-text">[Tt]he</code> 匹配 <code class="language-text">the</code> 和 <code class="language-text">The</code>.</p>\n<pre>\n"[Tt]he" => <a href="#learn-regex"><strong>The</strong></a> car parked in <a href="#learn-regex"><strong>the</strong></a> garage.\n</pre>\n<p><a href="https://regex101.com/r/2ITLQ4/1" target="_blank" rel="nofollow noreferrer noopener">在线练习</a></p>\n<p>方括号的句号就表示句号. 表达式 <code class="language-text">ar[.]</code> 匹配 <code class="language-text">ar.</code>字符串</p>\n<pre>\n"ar[.]" => A garage is a good place to park a c<a href="#learn-regex"><strong>ar.</strong></a>\n</pre>\n<p><a href="https://regex101.com/r/wL3xtE/1" target="_blank" rel="nofollow noreferrer noopener">在线练习</a></p>\n<h3 id="否定字符集"><a href="#%E5%90%A6%E5%AE%9A%E5%AD%97%E7%AC%A6%E9%9B%86" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>否定字符集</h3>\n<p>一般来说 <code class="language-text">^</code> 表示一个字符串的开头, 但它用在一个方括号的开头的时候, 它表示这个字符集是否定的. 例如, 表达式<code class="language-text">[^c]ar</code> 匹配一个后面跟着<code class="language-text">ar</code>的除了<code class="language-text">c</code>的任意字符.</p>\n<pre>\n"[^c]ar" => The car <a href="#learn-regex"><strong>par</strong></a>ked in the <a href="#learn-regex"><strong>gar</strong></a>age.\n</pre>\n<p><a href="https://regex101.com/r/nNNlq3/1" target="_blank" rel="nofollow noreferrer noopener">在线练习</a></p>\n<h2 id="重复次数"><a href="#%E9%87%8D%E5%A4%8D%E6%AC%A1%E6%95%B0" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>重复次数</h2>\n<p>后面跟着元字符 <code class="language-text">+</code>, <code class="language-text">*</code> or <code class="language-text">?</code> 的, 用来指定匹配子模式的次数. 这些元字符在不同的情况下有着不同的意思.</p>\n<h3 id="-号"><a href="#-%E5%8F%B7" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code class="language-text">*</code> 号</h3>\n<p><code class="language-text">*</code>号匹配 在<code class="language-text">*</code>之前的字符出现<code class="language-text">大于等于0</code>次. 例如, 表达式 <code class="language-text">a*</code> 匹配以 0 或更多个 a 开头的字符, 因为有 0 个这个条件, 其实也就匹配了所有的字符. 表达式<code class="language-text">[a-z]*</code> 匹配一个行中所有以小写字母开头的字符串.</p>\n<pre>\n"[a-z]*" => T<a href="#learn-regex"><strong>he</strong></a> <a href="#learn-regex"><strong>car</strong></a> <a href="#learn-regex"><strong>parked</strong></a> <a href="#learn-regex"><strong>in</strong></a> <a href="#learn-regex"><strong>the</strong></a> <a href="#learn-regex"><strong>garage</strong></a> #21.\n</pre>\n<p><a href="https://regex101.com/r/7m8me5/1" target="_blank" rel="nofollow noreferrer noopener">在线练习</a></p>\n<p><code class="language-text">*</code>字符和<code class="language-text">.</code>字符搭配可以匹配所有的字符<code class="language-text">.*</code>. <code class="language-text">*</code>和表示匹配空格的符号<code class="language-text">\\s</code>连起来用, 如表达式<code class="language-text">\\s*cat\\s*</code>匹配 0 或更多个空格开头和 0 或更多个空格结尾的 cat 字符串.</p>\n<pre>\n"\\s*cat\\s*" => The fat<a href="#learn-regex"><strong> cat </strong></a>sat on the con<a href="#learn-regex"><strong>cat</strong></a>enation.\n</pre>\n<p><a href="https://regex101.com/r/gGrwuz/1" target="_blank" rel="nofollow noreferrer noopener">在线练习</a></p>\n<h3 id="-号-1"><a href="#-%E5%8F%B7-1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code class="language-text">+</code> 号</h3>\n<p><code class="language-text">+</code>号匹配<code class="language-text">+</code>号之前的字符出现 >=1 次. 例如表达式<code class="language-text">c.+t</code> 匹配以首字母<code class="language-text">c</code>开头以<code class="language-text">t</code>结尾,中间跟着任意个字符的字符串.</p>\n<pre>\n"c.+t" => The fat <a href="#learn-regex"><strong>cat sat on the mat</strong></a>.\n</pre>\n<p><a href="https://regex101.com/r/Dzf9Aa/1" target="_blank" rel="nofollow noreferrer noopener">在线练习</a></p>\n<h3 id="-号-2"><a href="#-%E5%8F%B7-2" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code class="language-text">?</code> 号</h3>\n<p>在正则表达式中元字符 <code class="language-text">?</code> 标记在符号前面的字符为可选, 即出现 0 或 1 次. 例如, 表达式 <code class="language-text">[T]?he</code> 匹配字符串 <code class="language-text">he</code> 和 <code class="language-text">The</code>.</p>\n<pre>\n"[T]he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in the garage.\n</pre>\n<p><a href="https://regex101.com/r/cIg9zm/1" target="_blank" rel="nofollow noreferrer noopener">在线练习</a></p>\n<pre>\n"[T]?he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in t<a href="#learn-regex"><strong>he</strong></a> garage.\n</pre>\n<p><a href="https://regex101.com/r/kPpO2x/1" target="_blank" rel="nofollow noreferrer noopener">在线练习</a></p>\n<h2 id="-号-3"><a href="#-%E5%8F%B7-3" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code class="language-text">{}</code> 号</h2>\n<p>在正则表达式中 <code class="language-text">{}</code> 是一个量词, 常用来一个或一组字符可以重复出现的次数. 例如, 表达式 <code class="language-text">[0-9]{2,3}</code> 匹配最少 2 位最多 3 位 0~9 的数字.</p>\n<pre>\n"[0-9]{2,3}" => The number was 9.<a href="#learn-regex"><strong>999</strong></a>7 but we rounded it off to <a href="#learn-regex"><strong>10</strong></a>.0.\n</pre>\n<p><a href="https://regex101.com/r/juM86s/1" target="_blank" rel="nofollow noreferrer noopener">在线练习</a></p>\n<p>我们可以省略第二个参数. 例如, <code class="language-text">[0-9]{2,}</code> 匹配至少两位 0~9 的数字.</p>\n<pre>\n"[0-9]{2,}" => The number was 9.<a href="#learn-regex"><strong>9997</strong></a> but we rounded it off to <a href="#learn-regex"><strong>10</strong></a>.0.\n</pre>\n<p><a href="https://regex101.com/r/Gdy4w5/1" target="_blank" rel="nofollow noreferrer noopener">在线练习</a></p>\n<p>如果逗号也省略掉则表示重复固定的次数. 例如, <code class="language-text">[0-9]{3}</code> 匹配 3 位数字</p>\n<pre>\n"[0-9]{3}" => The number was 9.<a href="#learn-regex"><strong>999</strong></a>7 but we rounded it off to 10.0.\n</pre>\n<p><a href="https://regex101.com/r/Sivu30/1" target="_blank" rel="nofollow noreferrer noopener">在线练习</a></p>\n<h2 id="-特征标群"><a href="#-%E7%89%B9%E5%BE%81%E6%A0%87%E7%BE%A4" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code class="language-text">(...)</code> 特征标群</h2>\n<p>特征标群是一组写在 <code class="language-text">(...)</code> 中的子模式. 例如之前说的 <code class="language-text">{}</code> 是用来表示前面一个字符出现指定次数. 但如果在 <code class="language-text">{}</code> 前加入特征标群则表示整个标群内的字符重复 N 次. 例如, 表达式 <code class="language-text">(ab)*</code> 匹配连续出现 0 或更多个 <code class="language-text">ab</code>.</p>\n<p>我们还可以在 <code class="language-text">()</code> 中用或字符 <code class="language-text">|</code> 表示或. 例如, <code class="language-text">(c|g|p)ar</code> 匹配 <code class="language-text">car</code> 或 <code class="language-text">gar</code> 或 <code class="language-text">par</code>.</p>\n<pre>\n"(c|g|p)ar" => The <a href="#learn-regex"><strong>car</strong></a> is <a href="#learn-regex"><strong>par</strong></a>ked in the <a href="#learn-regex"><strong>gar</strong></a>age.\n</pre>\n<p><a href="https://regex101.com/r/tUxrBG/1" target="_blank" rel="nofollow noreferrer noopener">在线练习</a></p>\n<h2 id="-或运算符"><a href="#-%E6%88%96%E8%BF%90%E7%AE%97%E7%AC%A6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code class="language-text">|</code> 或运算符</h2>\n<p>或运算符就表示或, 用作判断条件.</p>\n<p>例如 <code class="language-text">(T|t)he|car</code> 匹配 <code class="language-text">(T|t)he</code> 或 <code class="language-text">car</code>.</p>\n<pre>\n"(T|t)he|car" => <a href="#learn-regex"><strong>The</strong></a> <a href="#learn-regex"><strong>car</strong></a> is parked in <a href="#learn-regex"><strong>the</strong></a> garage.\n</pre>\n<p><a href="https://regex101.com/r/fBXyX0/1" target="_blank" rel="nofollow noreferrer noopener">在线练习</a></p>\n<h2 id="转码特殊字符"><a href="#%E8%BD%AC%E7%A0%81%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>转码特殊字符</h2>\n<p>反斜线 <code class="language-text">\\</code> 在表达式中用于转码紧跟其后的字符. 用于指定 <code class="language-text">{ } [ ] / \\ + * . $ ^ | ?</code> 这些特殊字符. 如果想要匹配这些特殊字符则要在其前面加上反斜线 <code class="language-text">\\</code>.</p>\n<p>例如 <code class="language-text">.</code> 是用来匹配除换行符外的所有字符的. 如果想要匹配句子中的 <code class="language-text">.</code> 则要写成 <code class="language-text">\\.</code> 以下这个例子 <code class="language-text">\\.?</code>是选择性匹配<code class="language-text">.</code></p>\n<pre>\n"(f|c|m)at\\.?" => The <a href="#learn-regex"><strong>fat</strong></a> <a href="#learn-regex"><strong>cat</strong></a> sat on the <a href="#learn-regex"><strong>mat.</strong></a>\n</pre>\n<p><a href="https://regex101.com/r/DOc5Nu/1" target="_blank" rel="nofollow noreferrer noopener">在线练习</a></p>\n<h2 id="锚点"><a href="#%E9%94%9A%E7%82%B9" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>锚点</h2>\n<p>在正则表达式中, 想要匹配指定开头或结尾的字符串就要使用到锚点. <code class="language-text">^</code> 指定开头, <code class="language-text">$</code> 指定结尾.</p>\n<h3 id="-号-4"><a href="#-%E5%8F%B7-4" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code class="language-text">^</code> 号</h3>\n<p><code class="language-text">^</code> 用来检查匹配的字符串是否在所匹配字符串的开头.</p>\n<p>例如, 在 <code class="language-text">abc</code> 中使用表达式 <code class="language-text">^a</code> 会得到结果 <code class="language-text">a</code>. 但如果使用 <code class="language-text">^b</code> 将匹配不到任何结果. 因为在字符串 <code class="language-text">abc</code> 中并不是以 <code class="language-text">b</code> 开头.</p>\n<p>例如, <code class="language-text">^(T|t)he</code> 匹配以 <code class="language-text">The</code> 或 <code class="language-text">the</code> 开头的字符串.</p>\n<pre>\n"(T|t)he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in <a href="#learn-regex"><strong>the</strong></a> garage.\n</pre>\n<p><a href="https://regex101.com/r/5ljjgB/1" target="_blank" rel="nofollow noreferrer noopener">在线练习</a></p>\n<pre>\n"^(T|t)he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in the garage.\n</pre>\n<p><a href="https://regex101.com/r/jXrKne/1" target="_blank" rel="nofollow noreferrer noopener">在线练习</a></p>\n<h3 id="-号-5"><a href="#-%E5%8F%B7-5" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code class="language-text">$</code> 号</h3>\n<p>同理于 <code class="language-text">^</code> 号, <code class="language-text">$</code> 号用来匹配字符是否是最后一个.</p>\n<p>例如, <code class="language-text">(at\\.)$</code> 匹配以 <code class="language-text">at.</code> 结尾的字符串.</p>\n<pre>\n"(at\\.)" => The fat c<a href="#learn-regex"><strong>at.</strong></a> s<a href="#learn-regex"><strong>at.</strong></a> on the m<a href="#learn-regex"><strong>at.</strong></a>\n</pre>\n<p><a href="https://regex101.com/r/y4Au4D/1" target="_blank" rel="nofollow noreferrer noopener">在线练习</a></p>\n<pre>\n"(at\\.)$" => The fat cat. sat. on the m<a href="#learn-regex"><strong>at.</strong></a>\n</pre>\n<p><a href="https://regex101.com/r/t0AkOd/1" target="_blank" rel="nofollow noreferrer noopener">在线练习</a></p>\n<h2 id="简写字符集"><a href="#%E7%AE%80%E5%86%99%E5%AD%97%E7%AC%A6%E9%9B%86" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>简写字符集</h2>\n<p>正则表达式提供一些常用的字符集简写. 如下:</p>\n<table>\n<thead>\n<tr>\n<th align="center">简写</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align="center">.</td>\n<td>除换行符外的所有字符</td>\n</tr>\n<tr>\n<td align="center">\\w</td>\n<td>匹配所有字母数字, 等同于 \n<code class="language-text">[a-zA-Z0-9_]</code></td>\n</tr>\n<tr>\n<td align="center">\\W</td>\n<td>匹配所有非字母数字, 即符号, 等同于: \n<code class="language-text">[^\\w]</code></td>\n</tr>\n<tr>\n<td align="center">\\d</td>\n<td>匹配数字: \n<code class="language-text">[0-9]</code></td>\n</tr>\n<tr>\n<td align="center">\\D</td>\n<td>匹配非数字: \n<code class="language-text">[^\\d]</code></td>\n</tr>\n<tr>\n<td align="center">\\s</td>\n<td>匹配所有空格字符, 等同于: \n<code class="language-text">[\\t\\n\\f\\r\\p{Z}]</code></td>\n</tr>\n<tr>\n<td align="center">\\S</td>\n<td>匹配所有非空格字符: \n<code class="language-text">[^\\s]</code></td>\n</tr>\n<tr>\n<td align="center">\\f</td>\n<td>匹配一个换页符</td>\n</tr>\n<tr>\n<td align="center">\\n</td>\n<td>匹配一个换行符</td>\n</tr>\n<tr>\n<td align="center">\\r</td>\n<td>匹配一个回车符</td>\n</tr>\n<tr>\n<td align="center">\\t</td>\n<td>匹配一个制表符</td>\n</tr>\n<tr>\n<td align="center">\\v</td>\n<td>匹配一个垂直制表符</td>\n</tr>\n<tr>\n<td align="center">\\p</td>\n<td>匹配 CR/LF (等同于 \n<code class="language-text">\\r\\n</code>\n)，用来匹配 DOS 行终止符</td>\n</tr>\n</tbody>\n</table>\n<h2 id="零宽度断言前后预查"><a href="#%E9%9B%B6%E5%AE%BD%E5%BA%A6%E6%96%AD%E8%A8%80%E5%89%8D%E5%90%8E%E9%A2%84%E6%9F%A5" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>零宽度断言(前后预查)</h2>\n<p>先行断言和后发断言都属于<strong>非捕获簇</strong>(不捕获文本 ，也不针对组合计进行计数). 先行断言用于判断所匹配的格式是否在另一个确定的格式之前, 匹配结果不包含该确定格式(仅作为约束).</p>\n<p>例如, 我们想要获得所有跟在 <code class="language-text">$</code> 符号后的数字, 我们可以使用正后发断言 <code class="language-text">(?&lt;=\\$)[0-9\\.]*</code>. 这个表达式匹配 <code class="language-text">$</code> 开头, 之后跟着 <code class="language-text">0,1,2,3,4,5,6,7,8,9,.</code> 这些字符可以出现大于等于 0 次.</p>\n<p>零宽度断言如下:</p>\n<table>\n<thead>\n<tr>\n<th align="center">符号</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align="center">?=</td>\n<td>正先行断言-存在</td>\n</tr>\n<tr>\n<td align="center">?!</td>\n<td>负先行断言-排除</td>\n</tr>\n<tr>\n<td align="center">?&#x3C;=</td>\n<td>正后发断言-存在</td>\n</tr>\n<tr>\n<td align="center">?&#x3C;!</td>\n<td>负后发断言-排除</td>\n</tr>\n</tbody>\n</table>\n<h3 id="-正先行断言"><a href="#-%E6%AD%A3%E5%85%88%E8%A1%8C%E6%96%AD%E8%A8%80" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code class="language-text">?=...</code> 正先行断言</h3>\n<p><code class="language-text">?=...</code> 正先行断言, 表示第一部分表达式之后必须跟着 <code class="language-text">?=...</code>定义的表达式.</p>\n<p>返回结果只包含满足匹配条件的第一部分表达式. 定义一个正先行断言要使用 <code class="language-text">()</code>. 在括号内部使用一个问号和等号: <code class="language-text">(?=...)</code>.</p>\n<p>正先行断言的内容写在括号中的等号后面. 例如, 表达式 <code class="language-text">(T|t)he(?=\\sfat)</code> 匹配 <code class="language-text">The</code> 和 <code class="language-text">the</code>, 在括号中我们又定义了正先行断言 <code class="language-text">(?=\\sfat)</code> ,即 <code class="language-text">The</code> 和 <code class="language-text">the</code> 后面紧跟着 <code class="language-text">(空格)fat</code>.</p>\n<pre>\n"(T|t)he(?=\\sfat)" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on the mat.\n</pre>\n<p><a href="https://regex101.com/r/IDDARt/1" target="_blank" rel="nofollow noreferrer noopener">在线练习</a></p>\n<h3 id="-负先行断言"><a href="#-%E8%B4%9F%E5%85%88%E8%A1%8C%E6%96%AD%E8%A8%80" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code class="language-text">?!...</code> 负先行断言</h3>\n<p>负先行断言 <code class="language-text">?!</code> 用于筛选所有匹配结果, 筛选条件为 其后不跟随着断言中定义的格式. <code class="language-text">正先行断言</code> 定义和 <code class="language-text">负先行断言</code> 一样, 区别就是 <code class="language-text">=</code> 替换成 <code class="language-text">!</code> 也就是 <code class="language-text">(?!...)</code>.</p>\n<p>表达式 <code class="language-text">(T|t)he(?!\\sfat)</code> 匹配 <code class="language-text">The</code> 和 <code class="language-text">the</code>, 且其后不跟着 <code class="language-text">(空格)fat</code>.</p>\n<pre>\n"(T|t)he(?!\\sfat)" => The fat cat sat on <a href="#learn-regex"><strong>the</strong></a> mat.\n</pre>\n<p><a href="https://regex101.com/r/V32Npg/1" target="_blank" rel="nofollow noreferrer noopener">在线练习</a></p>\n<h3 id="--正后发断言"><a href="#--%E6%AD%A3%E5%90%8E%E5%8F%91%E6%96%AD%E8%A8%80" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code class="language-text">?&lt;= ...</code> 正后发断言</h3>\n<p>正后发断言 记作<code class="language-text">(?&lt;=...)</code> 用于筛选所有匹配结果, 筛选条件为 其前跟随着断言中定义的格式. 例如, 表达式 <code class="language-text">(?&lt;=(T|t)he\\s)(fat|mat)</code> 匹配 <code class="language-text">fat</code> 和 <code class="language-text">mat</code>, 且其前跟着 <code class="language-text">The</code> 或 <code class="language-text">the</code>.</p>\n<pre>\n"(?<=(T|t)he\\s)(fat|mat)" => The <a href="#learn-regex"><strong>fat</strong></a> cat sat on the <a href="#learn-regex"><strong>mat</strong></a>.\n</pre>\n<p><a href="https://regex101.com/r/avH165/1" target="_blank" rel="nofollow noreferrer noopener">在线练习</a></p>\n<h3 id="-负后发断言"><a href="#-%E8%B4%9F%E5%90%8E%E5%8F%91%E6%96%AD%E8%A8%80" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code class="language-text">?&lt;!...</code> 负后发断言</h3>\n<p>负后发断言 记作 <code class="language-text">(?&lt;!...)</code> 用于筛选所有匹配结果, 筛选条件为 其前不跟随着断言中定义的格式. 例如, 表达式 <code class="language-text">(?&lt;!(T|t)he\\s)(cat)</code> 匹配 <code class="language-text">cat</code>, 且其前不跟着 <code class="language-text">The</code> 或 <code class="language-text">the</code>.</p>\n<pre>\n"(?&lt;!(T|t)he\\s)(cat)" => The cat sat on <a href="#learn-regex"><strong>cat</strong></a>.\n</pre>\n<p><a href="https://regex101.com/r/8Efx5G/1" target="_blank" rel="nofollow noreferrer noopener">在线练习</a></p>\n<h2 id="标志"><a href="#%E6%A0%87%E5%BF%97" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>标志</h2>\n<p>标志也叫模式修正符, 因为它可以用来修改表达式的搜索结果. 这些标志可以任意的组合使用, 它也是整个正则表达式的一部分.</p>\n<table>\n<thead>\n<tr>\n<th align="center">标志</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align="center">i</td>\n<td>忽略大小写.</td>\n</tr>\n<tr>\n<td align="center">g</td>\n<td>全局搜索.</td>\n</tr>\n<tr>\n<td align="center">m</td>\n<td>多行的: 锚点元字符 \n<code class="language-text">^</code>\n \n<code class="language-text">$</code>\n 工作范围在每行的起始.</td>\n</tr>\n</tbody>\n</table>\n<h3 id="忽略大小写-case-insensitive"><a href="#%E5%BF%BD%E7%95%A5%E5%A4%A7%E5%B0%8F%E5%86%99-case-insensitive" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>忽略大小写 (Case Insensitive)</h3>\n<p>修饰语 <code class="language-text">i</code> 用于忽略大小写. 例如, 表达式 <code class="language-text">/The/gi</code> 表示在全局搜索 <code class="language-text">The</code>, 在后面的 <code class="language-text">i</code> 将其条件修改为忽略大小写, 则变成搜索 <code class="language-text">the</code> 和 <code class="language-text">The</code>, <code class="language-text">g</code> 表示全局搜索.</p>\n<pre>\n"The" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on the mat.\n</pre>\n<p><a href="https://regex101.com/r/dpQyf9/1" target="_blank" rel="nofollow noreferrer noopener">在线练习</a></p>\n<pre>\n"/The/gi" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on <a href="#learn-regex"><strong>the</strong></a> mat.\n</pre>\n<p><a href="https://regex101.com/r/ahfiuh/1" target="_blank" rel="nofollow noreferrer noopener">在线练习</a></p>\n<h3 id="全局搜索-global-search"><a href="#%E5%85%A8%E5%B1%80%E6%90%9C%E7%B4%A2-global-search" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>全局搜索 (Global search)</h3>\n<p>修饰符 <code class="language-text">g</code> 常用于执行一个全局搜索匹配, 即(不仅仅返回第一个匹配的, 而是返回全部). 例如, 表达式 <code class="language-text">/.(at)/g</code> 表示搜索 任意字符(除了换行) + <code class="language-text">at</code>, 并返回全部结果.</p>\n<pre>\n"/.(at)/" => The <a href="#learn-regex"><strong>fat</strong></a> cat sat on the mat.\n</pre>\n<p><a href="https://regex101.com/r/jnk6gM/1" target="_blank" rel="nofollow noreferrer noopener">在线练习</a></p>\n<pre>\n"/.(at)/g" => The <a href="#learn-regex"><strong>fat</strong></a> <a href="#learn-regex"><strong>cat</strong></a> <a href="#learn-regex"><strong>sat</strong></a> on the <a href="#learn-regex"><strong>mat</strong></a>.\n</pre>\n<p><a href="https://regex101.com/r/dO1nef/1" target="_blank" rel="nofollow noreferrer noopener">在线练习</a></p>\n<h3 id="多行修饰符-multiline"><a href="#%E5%A4%9A%E8%A1%8C%E4%BF%AE%E9%A5%B0%E7%AC%A6-multiline" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>多行修饰符 (Multiline)</h3>\n<p>多行修饰符 <code class="language-text">m</code> 常用语执行一个多行匹配.</p>\n<p>像之前介绍的 <code class="language-text">(^,$)</code> 用于检查格式是否是在待检测字符串的开头或结尾. 但我们如果想要它在每行的开头和结尾生效, 我们需要用到多行修饰符 <code class="language-text">m</code>.</p>\n<p>例如, 表达式 <code class="language-text">/at(.)?$/gm</code> 表示小写字符 <code class="language-text">a</code> 后跟小写字符 <code class="language-text">t</code> , 末尾可选除换行符外任意字符. 根据 <code class="language-text">m</code> 修饰符, 现在表达式匹配每行的结尾.</p>\n<pre>\n"/.at(.)?$/" => The fat\n                cat sat\n                on the <a href="#learn-regex"><strong>mat.</strong></a>\n</pre>\n<p><a href="https://regex101.com/r/hoGMkP/1" target="_blank" rel="nofollow noreferrer noopener">在线练习</a></p>\n<pre>\n"/.at(.)?$/gm" => The <a href="#learn-regex"><strong>fat</strong></a>\n                  cat <a href="#learn-regex"><strong>sat</strong></a>\n                  on the <a href="#learn-regex"><strong>mat.</strong></a>\n</pre>\n<p><a href="https://regex101.com/r/E88WE2/1" target="_blank" rel="nofollow noreferrer noopener">在线练习</a></p>\n<h3 id="贪婪匹配与惰性匹配-greedy-vs-lazy-matching"><a href="#%E8%B4%AA%E5%A9%AA%E5%8C%B9%E9%85%8D%E4%B8%8E%E6%83%B0%E6%80%A7%E5%8C%B9%E9%85%8D-greedy-vs-lazy-matching" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>贪婪匹配与惰性匹配 (Greedy vs lazy matching)</h3>\n<p>正则表达式默认采用贪婪匹配模式，在该模式下意味着会匹配尽可能长的子串。我们可以使用 <code class="language-text">?</code> 将贪婪匹配模式转化为惰性匹配模式。</p>\n<pre>\n"/(.*at)/" => <a href="#learn-regex"><strong>The fat cat sat on the mat</strong></a>. </pre>\n<p><a href="https://regex101.com/r/AyAdgJ/1" target="_blank" rel="nofollow noreferrer noopener">在线练习</a></p>\n<pre>\n"/(.*?at)/" => <a href="#learn-regex"><strong>The fat</strong></a> cat sat on the mat. </pre>\n<p><a href="https://regex101.com/r/AyAdgJ/2" target="_blank" rel="nofollow noreferrer noopener">在线练习</a></p>',
excerpt:"什么是正则表达式? 正则表达式是一组由字母和符号组成的特殊文本, 它可以用来从文本中找出满足你想要的格式的句子. 一个正则表达式是在一个主体字符串中从左到右匹配字符串时的一种样式. “Regular expression”这个词比较拗口, 我们常使用缩写的术语”regex…",frontmatter:{date:"2019-08-02 10:36:31",path:"/regex-introduce-learn/",tags:"正则表达式",title:"正则表达式入门学习",draft:null}}},pathContext:{mainPostPath:"/tree-traversal-depth-copy/",nextPostPath:"/debounce-throttle-difference-realize/",prePostPath:"/regex-introduce-learn/"}}}});