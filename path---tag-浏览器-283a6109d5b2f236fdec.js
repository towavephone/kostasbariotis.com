webpackJsonp([0x9af82e67e159],{1390:function(n,a){n.exports={data:{site:{siteMetadata:{title:"女王控的博客",description:'前端工程师，黑猫女王控，欢迎勾搭，技术相关<a href="https://github.com/towavephone" target="_blank">@towavephone</a>，QQ闲聊<a href="tencent://AddContact/?fromId=45&fromSubId=1&subcmd=all&uin=634407147&website=www.oicqzone.com">@towave</a>，bili关注<a href="https://space.bilibili.com/11507708#/" target="_blank">@towave</a>',siteUrl:"https://blog.towavephone.com"}}},pathContext:{posts:[{excerpt:"页面性能分析：利用 chrome 做 web 性能分析 “浏览器中的页面循环系统”模块我们已经介绍完了，循环系统是页面的基础，理解了循环系统能让我们从本质上更好地理解页面的工作方式，加深我们对一些前端概念的理解。 接下来我们就要进入新的模块了，也就是“浏览器中的页面”模块，正如专栏简介中所言，页面是浏览器的核心，浏览器中的所有功能点都是服务于页面的，而 Chrome 开发者工具又是工程师调试页面的核心工具，所以在这个模块的开篇，我想先带你来深入了解下 Chrome 开发者工具。 Chrome…",html:'<h1 id="页面性能分析：利用-chrome-做-web-性能分析"><a href="#%E9%A1%B5%E9%9D%A2%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%EF%BC%9A%E5%88%A9%E7%94%A8-chrome-%E5%81%9A-web-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>页面性能分析：利用 chrome 做 web 性能分析</h1>\n<p>“浏览器中的页面循环系统”模块我们已经介绍完了，循环系统是页面的基础，理解了循环系统能让我们从本质上更好地理解页面的工作方式，加深我们对一些前端概念的理解。</p>\n<p>接下来我们就要进入新的模块了，也就是“浏览器中的页面”模块，正如专栏简介中所言，页面是浏览器的核心，浏览器中的所有功能点都是服务于页面的，而 Chrome 开发者工具又是工程师调试页面的核心工具，所以在这个模块的开篇，我想先带你来深入了解下 Chrome 开发者工具。</p>\n<p>Chrome 开发者工具（简称 DevTools）是一组网页制作和调试的工具，内嵌于 Google Chrome 浏览器中。Chrome 开发者工具非常重要，所蕴含的内容也是非常多的，熟练使用它能让你更加深入地了解浏览器内部工作原理。（Chrome 开发者工具也在不停地迭代改进，如果你想使用最新版本，可以使用 Chrome Canary。）</p>\n<p>作为这一模块的第一篇文章，我们主要聚焦页面的源头和网络数据的接收，这些发送和接收的数据都能体现在开发者工具的网络面板上。不过为了你能更好地理解和掌握，我们会先对 Chrome 开发者工具做一个大致的介绍，然后再深入剖析网络面板</p>\n<h2 id="chrome-开发者工具"><a href="#chrome-%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Chrome 开发者工具</h2>\n<p>Chrome 开发者工具有很多重要的面板，比如与性能相关的有网络面板、Performance 面板、内存面板等，与调试页面相关的有 Elements 面板、Sources 面板、Console 面板等。</p>\n<p>你可以在浏览器窗口的右上方选择 Chrome 菜单，然后选择“更多工具–> 开发者工具”来打开 Chrome 开发者工具。打开的页面如下图所示：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-07-09-50-03-ef7efb2c0e645f82c9f3c1d3d39db515-af263.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 23.647798742138363%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAIAAADKYVtkAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAAt0lEQVQY03WOWwvCMAyF/f9/zBtOxTdR7OrUtpnVNo2bu9Vsvijix+EQQnKSkQNjkqlaTFhc5KsZLGfsejGGZHJdz4Gbm6QgKstnOUD0aJo2xjiSaQrZ0aqLkqm9nD0YZ7QHfRJCbHfnwz4/ZTetnHN+AL2/2vuzavrlg5AaAIkCPdjfCkQulCJTqZQmz30I+E3bDpcRQ1EU9QdVVTW914iE6HmUX62/6bquX44/cOo73lrLHv/zAnqMGqo5nVDeAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 07 09 50 03"\n        title=""\n        src="/static/2021-07-07-09-50-03-ef7efb2c0e645f82c9f3c1d3d39db515-fee1c.png"\n        srcset="/static/2021-07-07-09-50-03-ef7efb2c0e645f82c9f3c1d3d39db515-a67b7.png 200w,\n/static/2021-07-07-09-50-03-ef7efb2c0e645f82c9f3c1d3d39db515-0b187.png 400w,\n/static/2021-07-07-09-50-03-ef7efb2c0e645f82c9f3c1d3d39db515-fee1c.png 800w,\n/static/2021-07-07-09-50-03-ef7efb2c0e645f82c9f3c1d3d39db515-b1a91.png 1200w,\n/static/2021-07-07-09-50-03-ef7efb2c0e645f82c9f3c1d3d39db515-af263.png 1590w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从图中可以看出，它一共包含了 10 个功能面板，包括了 Elements、Console、Sources、NetWork、Performance、Memory、Application、Security、Audits 和 Layers。</p>\n<p>关于这 10 个面板的大致功能，我做了一个表格，感兴趣的话，你可以详细看下：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-07-09-50-19-23f102ef79c83df6cfb97ff2fdcc3a2c-a7cc8.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 53.85714285714286%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABnElEQVQoz22QS0/cMBDH8+l6pBSJWw/9LpWqrhASEh+FQ9kuUHHnsTwusCVvx4md+G3HSTgwyW6hVJV+Gtlj/2fmP0Fa2+NrdHJTQDxeFv8wX6KTWzw9vTG/QUeXWUx18OMq3fo2/3zwa/v7z+3ZYh0/wWG2+Dhb7O6ffTk839k7/RtIfvg6P7pIAmcFRg/WYMUzVsccaJKGxjUJ4apErgTSErW2fIfBfacD3yrZRENLFEsIfqR4JZvEKtTqwilkZT5Ghfq2ek859CbovDYye+7qhoRpfJ+Ed7T8rXjatwSSrwyeApD8QzWKWycZCSVLJEtZHUEJXkeMRnCGEuBFNAkAH7TIO1dtsOXQmdFzVTzo0VsGhkUTgxIirzfAdXRhMOBtuWHtGcS0XMEzo2FVrCq8AqVi6QhPQWxV7qcNvbV97TyOXUeCJbBbWj3B2GJaGOB0YXVhZG4k0iLzFmRkg508O8Np+QiVtADPYUOe+ORW8xQWCQdoC616V3mLJ9ZjF+PYnbdSlH2nnGFaUiUJ4B3vWrGm9/J/iOfBvwCro0q9MVEWugAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 07 09 50 19"\n        title=""\n        src="/static/2021-07-07-09-50-19-23f102ef79c83df6cfb97ff2fdcc3a2c-fee1c.png"\n        srcset="/static/2021-07-07-09-50-19-23f102ef79c83df6cfb97ff2fdcc3a2c-a67b7.png 200w,\n/static/2021-07-07-09-50-19-23f102ef79c83df6cfb97ff2fdcc3a2c-0b187.png 400w,\n/static/2021-07-07-09-50-19-23f102ef79c83df6cfb97ff2fdcc3a2c-fee1c.png 800w,\n/static/2021-07-07-09-50-19-23f102ef79c83df6cfb97ff2fdcc3a2c-b1a91.png 1200w,\n/static/2021-07-07-09-50-19-23f102ef79c83df6cfb97ff2fdcc3a2c-a7cc8.png 1400w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>简单来说，Chrome 开发者工具为我们提供了通过界面访问或者编辑 DOM 和 CSSOM 的能力，还提供了强大的调试功能和查看性能指标的能力。</p>\n<p>OK，接下来我们就要重点看下其中重要的 Network 面板，即网络面板</p>\n<h2 id="网络面板"><a href="#%E7%BD%91%E7%BB%9C%E9%9D%A2%E6%9D%BF" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>网络面板</h2>\n<p>网络面板由控制器、过滤器、抓图信息、时间线、详细列表和下载信息概要这 6 个区域构成（如下图所示）。</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-07-09-50-45-b7e1dcc8d872bc75e34bb2ad48f0c4a0-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 52.80210157618214%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAB7klEQVQozzWQS4+bMBRG5yf3p3TfxbTTabuqumi7GFXqNAkZEmKDIQGDAYMDA4g8JoE8mgeTXiepdPTp+Op+WPhmsW82f3fNqjquashmXR/XdXPm9T/SN6vTdn1lU7/ud6fT6ebtQDyYnKm63TeHXTz4raLHnqkMSFuzFGR2ECTtE1ezGBpK8JD2jDLJZfnWyh5Y8cT8Pg+NJMFC6OMxgIXMNosU10Wx0JPkMocdJES2WMhya7wMMr7ln6vwywv7NHM/ztn9zL2T4t1PKchdObqd0Q/A1HkP88no3brUZfkHn2Nf4O9f886vjaVWpFuT7op0K6LUV3+qjbMbCnilKxVqbZ9jWYYff5ku0M9OrJCJ4WbaqMBOjuyp4UkZ2DApdbdADpBpQ5iXmK6yiSyPJnWcTtgf5LQI6w55zxkj5ilWRrjQPP9pRNskwX6o2rxHgdyMUhwss5ksq3lNRRl1Saw5CXJT7OWGn+qsIEEGgr1k4F4kxQwWChLm2K8u5eWhWc5r59EIVfhqLBBL9RBugExQEKpOrHngkLAQ9b2cwM3h9eY37fE3Ky1Mmxv02Q4Sy0tHgTDdsc3jYSRMPyW09OKc8szhBY0mfgLHupyfH6xpdqv6wD1gH7qHM8ezyyP3jvycEcAua4eAHmfywf4Bt9Q7GfH89l4AAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 07 09 50 45"\n        title=""\n        src="/static/2021-07-07-09-50-45-b7e1dcc8d872bc75e34bb2ad48f0c4a0-fee1c.png"\n        srcset="/static/2021-07-07-09-50-45-b7e1dcc8d872bc75e34bb2ad48f0c4a0-a67b7.png 200w,\n/static/2021-07-07-09-50-45-b7e1dcc8d872bc75e34bb2ad48f0c4a0-0b187.png 400w,\n/static/2021-07-07-09-50-45-b7e1dcc8d872bc75e34bb2ad48f0c4a0-fee1c.png 800w,\n/static/2021-07-07-09-50-45-b7e1dcc8d872bc75e34bb2ad48f0c4a0-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<h3 id="控制器"><a href="#%E6%8E%A7%E5%88%B6%E5%99%A8" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>控制器</h3>\n<p>其中，控制器有 4 个比较重要的功能，我们按照下文中的这张图来简单介绍下。</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-07-09-51-02-42d6620dc9869662b20e6522e8bfcab1-f3ec4.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 64.36781609195403%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAIAAAAmMtkJAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAB4ElEQVQoz6VSy4rUQBTtL/IfXLka/Al/wbXg3oUK6oALFyrDgLOwd4LiYsAZsLVx0aF70klXpR5JqlKPTjqpPNvb7WJ6wAHBSzg3N3VO5dxbNdr+R4wOi2HYYVG3x5Pk+XdxNpNPzvGbCbWue3bBnl7Qqh3GXvroczhlxd/FWdkenVzdfbt4+IXdezd/8HEZ5839k/nRe8+6/vFXfOflz/HC3BB3XVcUxSZfS23Hs+TVJfnk8Rfnwdk0ktqc/kCvvwU0zT5M8elk5UViO/TX4rIsEaKZssbkbm0NXuVKySwvjOaMEsJQGCAcccYqk6Uxa5pmNPR9b9SwNlVRhMsgRCQiSRgufER4IlKRGmvhSeBNSKW00lpkah6wTVmOoNFOq8EaV9c4ihDyg2CO0QJTEkWUU6qyDBRGG6O1haw0bIZIstlsduJt3wM2Tc15Eiynvv8LIQJUKaQUWZoKISSjjPOYMQ7+AZM4rip33bNzLk4SSkJCfM6BFGdmXTpn8xxMAVautuucxTHCYDEqd7YPxPBnhK5WK48QOpsti9K1Xde2LcwGkqsbmE+apoQQjHFVVTeOyu0DvgLWdd3v2wH8UwICp9kHlMMwjG67erAGDNgIqP90PQ8D3IJDGI6U8jbOb+Rb1c1kDW/jAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 07 09 51 02"\n        title=""\n        src="/static/2021-07-07-09-51-02-42d6620dc9869662b20e6522e8bfcab1-fee1c.png"\n        srcset="/static/2021-07-07-09-51-02-42d6620dc9869662b20e6522e8bfcab1-a67b7.png 200w,\n/static/2021-07-07-09-51-02-42d6620dc9869662b20e6522e8bfcab1-0b187.png 400w,\n/static/2021-07-07-09-51-02-42d6620dc9869662b20e6522e8bfcab1-fee1c.png 800w,\n/static/2021-07-07-09-51-02-42d6620dc9869662b20e6522e8bfcab1-b1a91.png 1200w,\n/static/2021-07-07-09-51-02-42d6620dc9869662b20e6522e8bfcab1-f3ec4.png 1392w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<ul>\n<li>红色圆点的按钮，表示“开始 / 暂停抓包”，这个功能很常见，很容易理解。</li>\n<li>“全局搜索”按钮，这个功能就非常重要了，可以在所有下载资源中搜索相关内容，还可以快速定位到某几个你想要的文件上。</li>\n<li>Disable cache，即“禁止从 Cache 中加载资源”的功能，它在调试 Web 应用的时候非常有用，因为开启了 Cache 会影响到网络性能测试的结果。</li>\n<li>Online 按钮，是“模拟 2G/3G”功能，它可以限制带宽，模拟弱网情况下页面的展现情况，然后你就可以根据实际展示情况来动态调整策略，以便让 Web 应用更加适用于这些弱网</li>\n</ul>\n<h3 id="过滤器"><a href="#%E8%BF%87%E6%BB%A4%E5%99%A8" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>过滤器</h3>\n<p>网络面板中的过滤器，主要就是起过滤功能。因为有时候一个页面有太多内容在详细列表区域中展示了，而你可能只想查看 JavaScript 文件或者 CSS 文件，这时候就可以通过过滤器模块来筛选你想要的文件类型。</p>\n<h3 id="抓图信息"><a href="#%E6%8A%93%E5%9B%BE%E4%BF%A1%E6%81%AF" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>抓图信息</h3>\n<p>抓图信息区域，可以用来分析用户等待页面加载时间内所看到的内容，分析用户实际的体验情况。比如，如果页面加载 1 秒多之后屏幕截图还是白屏状态，这时候就需要分析是网络还是代码的问题了。（勾选面板上的“Capture screenshots”即可启用屏幕截图。）</p>\n<h3 id="时间线"><a href="#%E6%97%B6%E9%97%B4%E7%BA%BF" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>时间线</h3>\n<p>时间线，主要用来展示 HTTP、HTTPS、WebSocket 加载的状态和时间的一个关系，用于直观感受页面的加载过程。如果是多条竖线堆叠在一起，那说明这些资源被同时被加载。至于具体到每个文件的加载信息，还需要用到下面要讲的详细列表。</p>\n<h3 id="详细列表"><a href="#%E8%AF%A6%E7%BB%86%E5%88%97%E8%A1%A8" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>详细列表</h3>\n<p>这个区域是最重要的，它详细记录了每个资源从发起请求到完成请求这中间所有过程的状态，以及最终请求完成的数据信息。通过该列表，你就能很容易地去诊断一些网络问题。</p>\n<p>详细列表是我们本篇文章介绍的重点，不过内容比较多，所以放到最后去专门介绍了。</p>\n<h3 id="下载信息概要"><a href="#%E4%B8%8B%E8%BD%BD%E4%BF%A1%E6%81%AF%E6%A6%82%E8%A6%81" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>下载信息概要</h3>\n<p>下载信息概要中，你要重点关注下 DOMContentLoaded 和 Load 两个事件，以及这两个事件的完成时间。</p>\n<ul>\n<li>DOMContentLoaded，这个事件发生后，说明页面已经构建好 DOM 了，这意味着构建 DOM 所需要的 HTML 文件、JavaScript 文件、CSS 文件都已经下载完成了。</li>\n<li>Load，说明浏览器已经加载了所有的资源（图像、样式表等）</li>\n</ul>\n<p>通过下载信息概要面板，你可以查看触发这两个事件所花费的时间。</p>\n<h2 id="网络面板中的详细列表"><a href="#%E7%BD%91%E7%BB%9C%E9%9D%A2%E6%9D%BF%E4%B8%AD%E7%9A%84%E8%AF%A6%E7%BB%86%E5%88%97%E8%A1%A8" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>网络面板中的详细列表</h2>\n<p>下面我们就来重点介绍网络面板中的详细列表，这里面包含了大量有用的信息</p>\n<h3 id="列表的属性"><a href="#%E5%88%97%E8%A1%A8%E7%9A%84%E5%B1%9E%E6%80%A7" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>列表的属性</h3>\n<p>列表的属性比较多，比如 Name、Status、Type、Initiator 等等，这个不难理解。当然，你还可以通过点击右键的下拉菜单来添加其他属性，这里我就不再赘述了，你可以自己上手实操一下。</p>\n<p>另外，你也可以按照列表的属性来给列表排序，默认情况下，列表是按请求发起的时间来排序的，最早发起请求的资源在顶部。当然也可以按照返回状态码、请求类型、请求时长、内容大小等基础属性排序，只需点击相应属性即可。</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-07-09-53-01-18b08f827a18ed29c60483a7f3cc1708-56259.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 60.89644513137558%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABrklEQVQoz41Qy3KbQBDkp/Kz+YrccvEhVT5YsS3LziEYUGwFWEDSPtg3ixCkQcotrsoUtTXTMz3dQ6QPDc9i+b6176n8lbDsVWzxxmKb8iyhyU+WIk/4gi8v8FeAvXfRYfeW3n5Lv69ublbx6r7aPJDndfn0WP/YIMnX95evvOCbx+plnd3d5U8PwZrIeq8k/xofP33efonFNA39OCnn+/N5GMcwDK4LTKrzNNkudP3J932rHUpEZLQsfu+SHbnN6FtFtZIdpilzznVdZ7QRQpCShBAE50opKSU9MpTj+RxZowipGKXBSiVbrQ0axyP13iNBielmf+j7HokxRmvNmEA5juNMzvO8qhvKOVt2o8GFuJCttW0rSVUDFAKr52AU5NOVXJblfn8QS4AMt5TSi20og1w3DRa17UyWUlHKZ9sz2eqiKKqqhjJfyOGq3C3KblYmFZRBhm3GOKXidPqrXMB2VTPAi+3rzW652cw313Wz2BZQhgKl7HpzH7q2FVivtMJiWMVWpTSYmHDewz+uBegWMyiNscMwzOTpX4HG9B8RfdTAFYSQpmnw2z+a+QPsnqMS4hOnggAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 07 09 53 01"\n        title=""\n        src="/static/2021-07-07-09-53-01-18b08f827a18ed29c60483a7f3cc1708-fee1c.png"\n        srcset="/static/2021-07-07-09-53-01-18b08f827a18ed29c60483a7f3cc1708-a67b7.png 200w,\n/static/2021-07-07-09-53-01-18b08f827a18ed29c60483a7f3cc1708-0b187.png 400w,\n/static/2021-07-07-09-53-01-18b08f827a18ed29c60483a7f3cc1708-fee1c.png 800w,\n/static/2021-07-07-09-53-01-18b08f827a18ed29c60483a7f3cc1708-b1a91.png 1200w,\n/static/2021-07-07-09-53-01-18b08f827a18ed29c60483a7f3cc1708-56259.png 1294w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<h3 id="详细信息"><a href="#%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>详细信息</h3>\n<p>如果你选中详细列表中的一项，右边就会出现该项的详细信息，如下所示：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-07-09-53-26-311e36009422d59a8e38c15e698b0e77-8edaa.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 82.97213622291021%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAIAAABSJhvpAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAC/ElEQVQ4y22RW2/TZhjH+RBc7WNME5om7YL7adK422fhZhebAHEQG6KiqF1ak7Y5NixNQ0URQpA0PYSkSUpiu/Ep8fm148Sn+Gz8BlC7jUc//f28sn6vree5YlmWbduLsJOY27ZmzLlpwM0CRXfhG8syrblpu6Zlm6YJj6blum4cx1cIghwlxTAjmmJoSmbJtQPw/SPxuwfszepUE5jmgPtpSf7hFvHrioTTEkPTQ4JS1QmUeZ4HQJGBAlRNVjVdU08p+VmDy56Iez0RyOwHWrz7enZ7T16uTSRVU1RZlCXd1KE85gRVGD2tq7/8zd9YE3Ld8Fw6+qe7+o7Kv6ULL4eQGpNvjItJ7hPFfXJ7ny6SWh/K9IiTRsM7r8C396hrD0eP6n6br68cP0TaTwqD9QqxtUtldshMmYSZ9FUqWybT2KQDZVmWJVEcUMLhgGsRQFbtIXf0uoPU+rmj81KTLHdG1e74xSX2WswOr2FQZll2zHLmVPENEJpKGPgG3RDrj9X3iN3PuVjBx7f/TclHswE4gzJQ1LkxfTN07ted+++sAzb2+CO29pfUTE3aiH626WB5B8+7eOELRRfd8kEPyn4QJY9bb52rv7Hf/M7/UYtD8URoLMnNlNpGoInlvfPi1+UIujEKwgrmV1CPMWKPO2Te/CmepMTjVXhFC7EH2UTz8GKCi297aOazHF+uKExizh+Lh49Ba23WS0PONowPm3M8Z6EZG83OsZzdT3ugeyG7QWz6selGQSKPO9LB1vR0x+zuJhjdCsxOZdou66c7Rnd31io5/ADKAfxYnD71fl5XbyCTjX5sdY6HqaVx7hlf2JCfZ2bV0rS6fcGLklbO2ujZhbzSdH9ckq4vg9VebLUb6PIDZnOFSj9N4HIpPpvicympiAj5dbGACJlVvfd+MbDFb8+ciDdiTo/sIA4mso73DQIzCcwYognmorep8zmdMLRJ3Jso/xtYMrJLTXTp+NX6LCcLCxd82pzrOKIg8BynABCFIdxCFP2XOP4IyJhtBgnZ+SIAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 07 09 53 26"\n        title=""\n        src="/static/2021-07-07-09-53-26-311e36009422d59a8e38c15e698b0e77-fee1c.png"\n        srcset="/static/2021-07-07-09-53-26-311e36009422d59a8e38c15e698b0e77-a67b7.png 200w,\n/static/2021-07-07-09-53-26-311e36009422d59a8e38c15e698b0e77-0b187.png 400w,\n/static/2021-07-07-09-53-26-311e36009422d59a8e38c15e698b0e77-fee1c.png 800w,\n/static/2021-07-07-09-53-26-311e36009422d59a8e38c15e698b0e77-b1a91.png 1200w,\n/static/2021-07-07-09-53-26-311e36009422d59a8e38c15e698b0e77-8edaa.png 1292w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>你可以在此查看请求列表中任意一项的请求行和请求头信息，还可以查看响应行、响应头和响应体。然后你可以根据这些查看的信息来判断你的业务逻辑是否正确，或者有时候也可以用来逆向推导别人网站的业务逻辑。</p>\n<h3 id="单个资源的时间线"><a href="#%E5%8D%95%E4%B8%AA%E8%B5%84%E6%BA%90%E7%9A%84%E6%97%B6%E9%97%B4%E7%BA%BF" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>单个资源的时间线</h3>\n<p>了解了每个资源的详细请求信息之后，我们再来分析单个资源请求时间线，这就涉及具体的 HTTP 请求流程了。</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-07-09-53-50-ee8c5554c2d4230d5958c3f13aea2522-57c91.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 37.65182186234818%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAIAAAB2/0i6AAAACXBIWXMAAA7DAAAOwwHHb6hkAAABAUlEQVQY02P4++8/EAEBkICwMRFY+h8QwdVAAAMQ//n14/Gda98+vgWrgckQARj23Psy7+yb6QduLzr9fNnVz+uvf1p06SOIvPhh441Pc8+923zz0+8/fz6eOfXr+ZM773/NOftuyaWPH7//BmluO/gictWD/B3PszY/Sdz8In/7s+j1zwq2PYlcdb9w2+PAZffKdj75+u37kwWzv18+e/TZL/+ld2PXPnr28SdI89+/f379/EHQhT9+/frz5w+6s//+/fvly9cfP358ByMQ4zsQfQczEODTp09/MTVDAgkZYFqLKxQZMBW9ffv23r17Hz9+BDIeP3789OlToOuwagYAeP/A5lSxFy0AAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 07 09 53 50"\n        title=""\n        src="/static/2021-07-07-09-53-50-ee8c5554c2d4230d5958c3f13aea2522-fee1c.png"\n        srcset="/static/2021-07-07-09-53-50-ee8c5554c2d4230d5958c3f13aea2522-a67b7.png 200w,\n/static/2021-07-07-09-53-50-ee8c5554c2d4230d5958c3f13aea2522-0b187.png 400w,\n/static/2021-07-07-09-53-50-ee8c5554c2d4230d5958c3f13aea2522-fee1c.png 800w,\n/static/2021-07-07-09-53-50-ee8c5554c2d4230d5958c3f13aea2522-b1a91.png 1200w,\n/static/2021-07-07-09-53-50-ee8c5554c2d4230d5958c3f13aea2522-57c91.png 1482w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>我们介绍过发起一个 HTTP 请求之后，浏览器首先查找缓存，如果缓存没有命中，那么继续发起 DNS 请求获取 IP 地址，然后利用 IP 地址和服务器端建立 TCP 连接，再发送 HTTP 请求，等待服务器响应；不过，如果服务器响应头中包含了重定向的信息，那么整个流程就需要重新再走一遍。这就是在浏览器中一个 HTTP 请求的基础流程。</p>\n<p>那详细列表中是如何表示出这个流程的呢？这就要重点看下时间线面板了</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-07-09-54-24-cc965f0ae609a55cd5be0788d105afaf-0ac43.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 93.7984496124031%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAATCAIAAAAf7rriAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABoUlEQVQ4y6VU6U6DQBjk/Z/Gq/4wqU9grLH6Q6mBcN/LvbtcdWAJYEqbqBMKdHfnm/mOVjr+A1LbtlmWOY6j63qapoZheJ7n+76iKK7jeF5w+FKTJC3Lslggz3POuYQAeIvjOIoiQggC0QE4QWmZZNSP8qJkFf8Bxlhd1z0ZTFVVnQHY+IVtfGAJfNxhG5pd110gNE1TVRVkcawng2DbNlIlA4T4aQixAg1N00zTRLEksRoPQMjpHPZWlafDszK+wHMYhqjEOcOTchAEMxki6BOqvXQ7KC+v47SORiJNJD+SRc64ixAAs96Tl+t0f5/uN+nrbVMSsY5eImHXdWcyOJOmeDHe/Kerj91G3t3JzzefBaFiF0MBMsTHgolWJQOwd7m3KAqU5pxRZFTfsizYPjckXdtNfYZnHB6V8TBME1wsofKr5Eft4RDJvU3a93kuGAyQKAgDFzXDhE7dXoK3+VaOtzLjtIAynI/krKh1t7ADWtVNN2BVnNcdrVqRNmTGnEvW+ISFCW/alZE8DYfBRsNG8t//DC60RPzI4XA5BUt8A1lsT6oVgRWDAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 07 09 54 24"\n        title=""\n        src="/static/2021-07-07-09-54-24-cc965f0ae609a55cd5be0788d105afaf-fee1c.png"\n        srcset="/static/2021-07-07-09-54-24-cc965f0ae609a55cd5be0788d105afaf-a67b7.png 200w,\n/static/2021-07-07-09-54-24-cc965f0ae609a55cd5be0788d105afaf-0b187.png 400w,\n/static/2021-07-07-09-54-24-cc965f0ae609a55cd5be0788d105afaf-fee1c.png 800w,\n/static/2021-07-07-09-54-24-cc965f0ae609a55cd5be0788d105afaf-b1a91.png 1200w,\n/static/2021-07-07-09-54-24-cc965f0ae609a55cd5be0788d105afaf-0ac43.png 1290w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>那面板中这各项到底是什么含义呢？</p>\n<blockquote>\n<p>第一个是 Queuing，也就是排队的意思，当浏览器发起一个请求的时候，会有很多原因导致该请求不能被立即执行，而是需要排队等待。导致请求处于排队状态的原因有很多。</p>\n</blockquote>\n<ul>\n<li>首先，页面中的资源是有优先级的，比如 CSS、HTML、JavaScript 等都是页面中的核心文件，所以优先级最高；而图片、视频、音频这类资源就不是核心资源，优先级就比较低。通常当后者遇到前者时，就需要“让路”，进入待排队状态。</li>\n<li>其次，我们前面也提到过，浏览器会为每个域名最多维护 6 个 TCP 连接，如果发起一个 HTTP 请求时，这 6 个 TCP 连接都处于忙碌状态，那么这个请求就会处于排队状态。</li>\n<li>最后，网络进程在为数据分配磁盘空间时，新的 HTTP 请求也需要短暂地等待磁盘分配结束。</li>\n</ul>\n<p>等待排队完成之后，就要进入发起连接的状态了。不过在发起连接之前，还有一些原因可能导致连接过程被推迟，这个推迟就表现在面板中的 Stalled 上，它表示停滞的意思。</p>\n<p>这里需要额外说明的是，如果你使用了代理服务器，还会增加一个 Proxy Negotiation 阶段，也就是代理协商阶段，它表示代理服务器连接协商所用的时间，不过在上图中没有体现出来，因为这里我们没有使用代理服务器。</p>\n<p>接下来，就到了 Initial connection/SSL 阶段了，也就是和服务器建立连接的阶段，这包括了建立 TCP 连接所花费的时间；不过如果你使用了 HTTPS 协议，那么还需要一个额外的 SSL 握手时间，这个过程主要是用来协商一些加密信息的。（关于 SSL 协商的详细过程，我们会在 Web 安全模块中介绍。）</p>\n<p>和服务器建立好连接之后，网络进程会准备请求数据，并将其发送给网络，这就是 Request sent 阶段。通常这个阶段非常快，因为只需要把浏览器缓冲区的数据发送出去就结束了，并不需要判断服务器是否接收到了，所以这个时间通常不到 1 毫秒。</p>\n<p>数据发送出去了，接下来就是等待接收服务器第一个字节的数据，这个阶段称为 Waiting (TTFB)，通常也称为“第一字节时间”。 TTFB 是反映服务端响应速度的重要指标，对服务器来说，TTFB 时间越短，就说明服务器响应越快。</p>\n<p>接收到第一个字节之后，进入陆续接收完整数据的阶段，也就是 Content Download 阶段，这意味着从第一字节时间到接收到全部响应数据所用的时间</p>\n<h2 id="优化时间线上耗时项"><a href="#%E4%BC%98%E5%8C%96%E6%97%B6%E9%97%B4%E7%BA%BF%E4%B8%8A%E8%80%97%E6%97%B6%E9%A1%B9" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>优化时间线上耗时项</h2>\n<p>了解了时间线面板上的各项含义之后，我们就可以根据这个请求的时间线来实现相关的优化操作了。</p>\n<h3 id="排队（queuing）时间过久"><a href="#%E6%8E%92%E9%98%9F%EF%BC%88queuing%EF%BC%89%E6%97%B6%E9%97%B4%E8%BF%87%E4%B9%85" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>排队（Queuing）时间过久</h3>\n<p>排队时间过久，大概率是由浏览器为每个域名最多维护 6 个连接导致的。那么基于这个原因，你就可以让 1 个站点下面的资源放在多个域名下面，比如放到 3 个域名下面，这样就可以同时支持 18 个连接了，这种方案称为域名分片技术。除了域名分片技术外，我个人还建议你把站点升级到 HTTP2，因为 HTTP2 已经没有每个域名最多维护 6 个 TCP 连接的限制了。</p>\n<h3 id="第一字节时间（ttfb）时间过久"><a href="#%E7%AC%AC%E4%B8%80%E5%AD%97%E8%8A%82%E6%97%B6%E9%97%B4%EF%BC%88ttfb%EF%BC%89%E6%97%B6%E9%97%B4%E8%BF%87%E4%B9%85" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>第一字节时间（TTFB）时间过久</h3>\n<p>这可能的原因有如下：</p>\n<ul>\n<li>服务器生成页面数据的时间过久。对于动态网页来说，服务器收到用户打开一个页面的请求时，首先要从数据库中读取该页面需要的数据，然后把这些数据传入到模板中，模板渲染后，再返回给用户。服务器在处理这个数据的过程中，可能某个环节会出问题。</li>\n<li>网络的原因。比如使用了低带宽的服务器，或者本来用的是电信的服务器，可联通的网络用户要来访问你的服务器，这样也会拖慢网速。</li>\n<li>发送请求头时带上了多余的用户信息。比如一些不必要的 Cookie 信息，服务器接收到这些 Cookie 信息之后可能需要对每一项都做处理，这样就加大了服务器的处理时长。</li>\n</ul>\n<p>对于这三种问题，你要有针对性地出一些解决方案。面对第一种服务器的问题，你可以想办法去提高服务器的处理速度，比如通过增加各种缓存的技术；针对第二种网络问题，你可以使用 CDN 来缓存一些静态文件；至于第三种，你在发送请求时就去尽可能地减少一些不必要的 Cookie 数据信息</p>\n<h3 id="content-download-时间过久"><a href="#content-download-%E6%97%B6%E9%97%B4%E8%BF%87%E4%B9%85" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Content Download 时间过久</h3>\n<p>如果单个请求的 Content Download 花费了大量时间，有可能是字节数太多的原因导致的。这时候你就需要减少文件大小，比如压缩、去掉源码中不必要的注释等方法。</p>\n<h2 id="总结"><a href="#%E6%80%BB%E7%BB%93" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总结</h2>\n<p>首先我们简单介绍了 Chrome 开发者工具 10 个基础的面板信息；然后重点剖析了网络面板，再结合之前介绍的网络请求流程来重点分析了网络面板中时间线的各个指标的含义；最后我们还简要分析了时间线中各项指标出现异常的可能原因，并给出了一些优化方案。</p>\n<p>其实通过今天的分析，我们可以得出这样一个结论：如果你要去做一些实践性的项目优化，理解其背后的理论至关重要。因为理论就是一条“线”，它会把各种实践的内容“串”在一起，然后你可以围绕着这条“线”来排查问题</p>\n<h1 id="dom-树：javascript-是如何影响-dom-树构建的"><a href="#dom-%E6%A0%91%EF%BC%9Ajavascript-%E6%98%AF%E5%A6%82%E4%BD%95%E5%BD%B1%E5%93%8D-dom-%E6%A0%91%E6%9E%84%E5%BB%BA%E7%9A%84" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>DOM 树：JavaScript 是如何影响 DOM 树构建的</h1>\n<p>在上一篇文章中，我们通过开发者工具中的网络面板，介绍了网络请求过程的几种性能指标以及对页面加载的影响。</p>\n<p>而在渲染流水线中，后面的步骤都直接或者间接地依赖于 DOM 结构，所以本文我们就继续沿着网络数据流路径来介绍 DOM 树是怎么生成的。然后再基于 DOM 树的解析流程介绍两块内容：第一个是在解析过程中遇到 JavaScript 脚本，DOM 解析器是如何处理的？第二个是 DOM 解析器是如何处理跨站点资源的？</p>\n<h2 id="什么是-dom"><a href="#%E4%BB%80%E4%B9%88%E6%98%AF-dom" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>什么是 DOM</h2>\n<p>从网络传给渲染引擎的 HTML 文件字节流是无法直接被渲染引擎理解的，所以要将其转化为渲染引擎能够理解的内部结构，这个结构就是 DOM。DOM 提供了对 HTML 文档结构化的表述。在渲染引擎中，DOM 有三个层面的作用</p>\n<ul>\n<li>从页面的视角来看，DOM 是生成页面的基础数据结构。</li>\n<li>从 JavaScript 脚本视角来看，DOM 提供给 JavaScript 脚本操作的接口，通过这套接口，JavaScript 可以对 DOM 结构进行访问，从而改变文档的结构、样式和内容。</li>\n<li>从安全视角来看，DOM 是一道安全防护线，一些不安全的内容在 DOM 解析阶段就被拒之门外了。</li>\n</ul>\n<p>简言之，DOM 是表述 HTML 的内部数据结构，它会将 Web 页面和 JavaScript 脚本连接起来，并过滤一些不安全的内容。</p>\n<h2 id="dom-树如何生成"><a href="#dom-%E6%A0%91%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>DOM 树如何生成</h2>\n<p>在渲染引擎内部，有一个叫 HTML 解析器（HTMLParser）的模块，它的职责就是负责将 HTML 字节流转换为 DOM 结构。所以这里我们需要先要搞清楚 HTML 解析器是怎么工作的。</p>\n<p>在开始介绍 HTML 解析器之前，我要先解释一个大家在留言区问到过好多次的问题：HTML 解析器是等整个 HTML 文档加载完成之后开始解析的，还是随着 HTML 文档边加载边解析的？</p>\n<p>在这里我统一解答下，HTML 解析器并不是等整个文档加载完成之后再解析的，而是网络进程加载了多少数据，HTML 解析器便解析多少数据。</p>\n<p>那详细的流程是怎样的呢？网络进程接收到响应头之后，会根据响应头中的 content-type 字段来判断文件的类型，比如 content-type 的值是“text/html”，那么浏览器就会判断这是一个 HTML 类型的文件，然后为该请求选择或者创建一个渲染进程。渲染进程准备好之后，网络进程和渲染进程之间会建立一个共享数据的管道，网络进程接收到数据后就往这个管道里面放，而渲染进程则从管道的另外一端不断地读取数据，并同时将读取的数据“喂”给 HTML 解析器。你可以把这个管道想象成一个“水管”，网络进程接收到的字节流像水一样倒进这个“水管”，而“水管”的另外一端是渲染进程的 HTML 解析器，它会动态接收字节流，并将其解析为 DOM。</p>\n<p>解答完这个问题之后，接下来我们就可以来详细聊聊 DOM 的具体生成流程了。</p>\n<p>前面我们说过代码从网络传输过来是字节流的形式，那么后续字节流是如何转换为 DOM 的呢？你可以参考下图：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-12-09-24-58-90e4c67092638cfcc2717bac6051f26d-62f9e.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 57.86736020806242%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABn0lEQVQoz6WRy07CUBCG+yisjIlv4JP4EO5cGbeuTNxoYqImaEQTTAwGU8CKpkirICFCUu7KpUIKFNrSSiltT3s8tooX1I2TybnON/+cMxj8h2G2bZ8yve3b5naCK3aGUBYh16r31f10d5duxB4EaAHjiYXK4LLE7yRaR2lOGY0RadsQAwAsnLCz65mZjdJxrAwzSSsUCN/V5jYLntWbJbwBa+UhETJpcvGs5lm7n99imv1nB7YxNCWqQiD1eFHkm5KGFJDzQ50s81elbr4tI2XAd6Gh5ziFuM7SdUkzzFcYlc1xXDadKjLZxkOxkGMGsuxm/fI4d9tuQSoKxd7kBGMYxuvdi8cpiqaRi4Lgwpbjb1mc0RpIajQCFPkDZlk2GAziOB4Oh2kEi+I3ZXdlmGDlvL5wmF+O1IBlvf12tVr1+XwIJgiCJMlp2DVg2aFC/yDdxvN96/0Wq1Qqfr+foqhkMvlZeZr/oc+qqnY6nZ5jPM8bhvFbKBIEzkd8wNNBqPOyLEuShPJqmvaX8qTISaloHI/Ho9FI13XTNP+AXwDEnpYxybov0wAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 12 09 24 58"\n        title=""\n        src="/static/2021-07-12-09-24-58-90e4c67092638cfcc2717bac6051f26d-fee1c.png"\n        srcset="/static/2021-07-12-09-24-58-90e4c67092638cfcc2717bac6051f26d-a67b7.png 200w,\n/static/2021-07-12-09-24-58-90e4c67092638cfcc2717bac6051f26d-0b187.png 400w,\n/static/2021-07-12-09-24-58-90e4c67092638cfcc2717bac6051f26d-fee1c.png 800w,\n/static/2021-07-12-09-24-58-90e4c67092638cfcc2717bac6051f26d-b1a91.png 1200w,\n/static/2021-07-12-09-24-58-90e4c67092638cfcc2717bac6051f26d-62f9e.png 1538w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从图中你可以看出，字节流转换为 DOM 需要三个阶段。</p>\n<p>第一个阶段，通过分词器将字节流转换为 Token。</p>\n<p>前面文章中我们介绍过，V8 编译 JavaScript 过程中的第一步是做词法分析，将 JavaScript 先分解为一个个 Token。解析 HTML 也是一样的，需要通过分词器先将字节流转换为一个个 Token，分为 Tag Token 和文本 Token。上述 HTML 代码通过词法分析生成的 Token 如下所示：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-12-09-25-24-a8c6d786f6a21428c2e65dec85082976-4f503.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 23.578363384188627%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAIAAADKYVtkAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAA8UlEQVQY02P4+/ff77///oDI/3/+/v8N4QIF/vz5/+cPVPYfiP73BygMEgTxgIx//xjmnH5tP/Nq3a7H4UtulG29H7fqbuCiG12XW06taH3SUD1tyznX+U86jqxecrnsVnf77bbG6001t7tbrlYWvdq7i+Hooy89Bx5tvvFx9rHH6668WXD2zcwTL3c93fHo7M73WzYdvvp00vEPu+5fOPV83cvdO17v2Pp48/qXu7Y9Xrfy881rDP9xgH8w9P//HyiNARiAwn/+/fv7D0j+h5BAka/fv7558+bzp0+fP3958er1l69fQMb9/fsfGf37BwCOuAfq0ZVGxAAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 12 09 25 24"\n        title=""\n        src="/static/2021-07-12-09-25-24-a8c6d786f6a21428c2e65dec85082976-fee1c.png"\n        srcset="/static/2021-07-12-09-25-24-a8c6d786f6a21428c2e65dec85082976-a67b7.png 200w,\n/static/2021-07-12-09-25-24-a8c6d786f6a21428c2e65dec85082976-0b187.png 400w,\n/static/2021-07-12-09-25-24-a8c6d786f6a21428c2e65dec85082976-fee1c.png 800w,\n/static/2021-07-12-09-25-24-a8c6d786f6a21428c2e65dec85082976-b1a91.png 1200w,\n/static/2021-07-12-09-25-24-a8c6d786f6a21428c2e65dec85082976-4f503.png 1442w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>由图可以看出，Tag Token 又分 StartTag 和 EndTag，分别对应图中的蓝色和红色块，文本 Token 对应的绿色块。至于后续的第二个和第三个阶段是同步进行的，需要将 Token 解析为 DOM 节点，并将 DOM 节点添加到 DOM 树中。</p>\n<blockquote>\n<p>HTML 解析器维护了一个 Token 栈结构，该 Token 栈主要用来计算节点之间的父子关系，在第一个阶段中生成的 Token 会被按照顺序压到这个栈中。具体的处理规则如下所示：</p>\n</blockquote>\n<ul>\n<li>如果压入到栈中的是 StartTag Token，HTML 解析器会为该 Token 创建一个 DOM 节点，然后将该节点加入到 DOM 树中，它的父节点就是栈中相邻的那个元素生成的节点。</li>\n<li>如果分词器解析出来是文本 Token，那么会生成一个文本节点，然后将该节点加入到 DOM 树中，文本 Token 是不需要压入到栈中，它的父节点就是当前栈顶 Token 所对应的 DOM 节点。</li>\n<li>如果分词器解析出来的是 EndTag 标签，比如是 EndTag div，HTML 解析器会查看 Token 栈顶的元素是否是 StartTag div，如果是，就将 StartTag div 从栈中弹出，表示该 div 元素解析完成。</li>\n</ul>\n<p>通过分词器产生的新 Token 就这样不停地压栈和出栈，整个解析过程就这样一直持续下去，直到分词器将所有字节流分词完成。</p>\n<p>为了更加直观地理解整个过程，下面我们结合一段 HTML 代码（如下），来一步步分析 DOM 树的生成过程。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="47108796293172660000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`<html>\n  <body>\n    <div>1</div>\n    <div>test</div>\n  </body>\n</html>`, `47108796293172660000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                html 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>这段代码以字节流的形式传给了 HTML 解析器，经过分词器处理，解析出来的第一个 Token 是 StartTag html，解析出来的 Token 会被压入到栈中，并同时创建一个 html 的 DOM 节点，将其加入到 DOM 树中。</p>\n<p>这里需要补充说明下，HTML 解析器开始工作时，会默认创建了一个根为 document 的空 DOM 结构，同时会将一个 StartTag document 的 Token 压入栈底。然后经过分词器解析出来的第一个 StartTag html Token 会被压入到栈中，并创建一个 html 的 DOM 节点，添加到 document 上，如下图所示</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-12-09-45-57-ec38c87f5c2f77e9752986c05bb4f70d-b1ea5.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 74.76489028213166%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAIAAABr+ngCAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABhklEQVQoz5VTuU7DQBD1L9FDS0/JF1BQI/EPUEQgJBBIUKBQQ4uIhAQEAV2Q5ShEDhS+4/i+d83LrhORmCuvsGbezJvZ2VkLJQMhJGcoiqKcADYnCQFJWFbFAJRSgec5juN5XhiGo9EoyzJO2rbten6RhO2uudEcbDbl1qsBNwjGaXEcj8Wo4fs+vrCjKErTlItRjjCyb8b7LeXwVhG1hIeSJKnEOE1dDBdixpVGQE7a9nHbUdxiXvxr57Eh28X2lbp1qXaNbEZsWZYoihiPsxDjMlzXlSQJofIHVGL0MU3TD4K8IOgThlGWphgEYZSYZlOGeTGbmQZBwGNJPHPsPzrzarI6ung2z5+sx55F8uy/Yn4l993h8t5gaeetcaOWNKMLiV/6w/VTee2od3anlGRB8YOkrzY6K7udg+t+SXM6eXb0OyAUM1QzDx1PHBjiu/Wh25QSXh7L9xh8Bu8LUBcbFepH4v8DtjVtBQZuPVOYrLFEbsFmwNvQdR218fpdBk3TYNfFn/RBXAbID3gEAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 12 09 45 57"\n        title=""\n        src="/static/2021-07-12-09-45-57-ec38c87f5c2f77e9752986c05bb4f70d-fee1c.png"\n        srcset="/static/2021-07-12-09-45-57-ec38c87f5c2f77e9752986c05bb4f70d-a67b7.png 200w,\n/static/2021-07-12-09-45-57-ec38c87f5c2f77e9752986c05bb4f70d-0b187.png 400w,\n/static/2021-07-12-09-45-57-ec38c87f5c2f77e9752986c05bb4f70d-fee1c.png 800w,\n/static/2021-07-12-09-45-57-ec38c87f5c2f77e9752986c05bb4f70d-b1a91.png 1200w,\n/static/2021-07-12-09-45-57-ec38c87f5c2f77e9752986c05bb4f70d-b1ea5.png 1276w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>然后按照同样的流程解析出来 StartTag body 和 StartTag div，其 Token 栈和 DOM 的状态如下图所示：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-12-09-46-10-afc78975320d5dacdb2f173c2e9bc4e4-24e6c.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 74.13533834586467%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAIAAABr+ngCAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAB4UlEQVQoz6VTv0/bQBTmr6JTJQa6sbVqUZe0AzMDe7dKHWgodKoKiMDAQjsUhJCiSoiNBUEjIdokipz4R2zH5/jOduw735nnOzdAE6Z+ks9Pd9/3vvfOzzP5f2BGvTjnGOMoimBNkkRtjkYjQkgYhrCQMCZhFEoALQgCkJRiSinIlACO1SbspJTlufhx6b78+vvtbqvnxWCUcQ5ixthfcZpCQghSSuMYGLkQAmxhhbjr06PGsH6DY8oVHwyyLCvFkEYZJimNZJaSwQvxpcmW9vV3xzZJxfiodDZMi3j21pnxuqatHHTcIWQRhmnatq2oms+2z4PvVzhhE2LbGUSetfrTfbKhv6qZNipKcAcDx3GkcX7eTV9sdpa/mUEyIZaMrFrvza3/qey0bERkzwVD9TwM00Yv0BBVXUwRr9X1+fWbN7V23yNyUwS4CPYu4oVNq3oWyoTyeSCWV/b+xJr91H2+pRkDrJwxAbHoIHbajBoWVVWIfJr4Y11/9rlZqbVNryx7/Kkm8W/ZHw6bT6vXi19+GW5QOmPMCwiWCeh2DDiFvHdDkguuO6hloLaB4lE5njCnoFcTKof0Dg/G8z4gN2SFAYKg8BVCxY/+GOp6uaRQyvr9PkJoKAHm8MF9358U3wI6Wk1a/8IQXAAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 12 09 46 10"\n        title=""\n        src="/static/2021-07-12-09-46-10-afc78975320d5dacdb2f173c2e9bc4e4-fee1c.png"\n        srcset="/static/2021-07-12-09-46-10-afc78975320d5dacdb2f173c2e9bc4e4-a67b7.png 200w,\n/static/2021-07-12-09-46-10-afc78975320d5dacdb2f173c2e9bc4e4-0b187.png 400w,\n/static/2021-07-12-09-46-10-afc78975320d5dacdb2f173c2e9bc4e4-fee1c.png 800w,\n/static/2021-07-12-09-46-10-afc78975320d5dacdb2f173c2e9bc4e4-b1a91.png 1200w,\n/static/2021-07-12-09-46-10-afc78975320d5dacdb2f173c2e9bc4e4-24e6c.png 1330w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>接下来解析出来的是第一个 div 的文本 Token，渲染引擎会为该 Token 创建一个文本节点，并将该 Token 添加到 DOM 中，它的父节点就是当前 Token 栈顶元素对应的节点，如下图所示：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-12-09-46-25-e5fd6fa68ed8a69bd7591513d852d088-21e31.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 71.01865136298422%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAIAAACgpqunAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAB5UlEQVQoz3VSTW/TQBDtv0IcuFEOvVT9ARw5V6oEVdSKY1EPSBHiQ6CCxB3UqMmpPSAU5VK4IBGk4ASZhDROothrr9f2ej/c5920aaowh5VnPO+9md23Vvw/lFJCCCml1rLQQispy0yaikbDmu3LsoxSyhjDmee5LUZRFMcxipOAXfjJlDBmUmpiAUYf5xx8SZLg97xIaclf6L36aON17/BsXCZFAWWQLsBgQgkfoAC+bNKazsFFe5ictf3f4+x6nSUwkmnEvUiNSZqmyTWjMru9apGtI/fj93IipW+AldLdruO6bqU+vld1KrWBFpwlieM4s9nMsnztsrfNybd+asdeUvZ9H337DW/9Ze9p40LyFIwYABehzNxvWmTznfv+PL6tbC8dyc6xd+e58/j4n+DpzbEHoWgPSciMrF7e2YIpjSsnowcvOvsnQwtGmcU0E3q3wbY+kC89ZWVXgCMaP6kN71d/Yuc5GOPQWCp13v9x2mmOool9gtXg7U+Du9U/O5/7V8oaD85F9qy5/ai23vp7apTVSjA9qDsPj34d1js8m+8cBAHwUzL1Zl5IQ7gQFsBFAhmG4eKdlZJaZoVKcVo6BHwKz5TuFjLneXYVwMPzC7BdUptp8UKEGK8YHZyEBNZ2t+ISNe8PC3BOXgwAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 12 09 46 25"\n        title=""\n        src="/static/2021-07-12-09-46-25-e5fd6fa68ed8a69bd7591513d852d088-fee1c.png"\n        srcset="/static/2021-07-12-09-46-25-e5fd6fa68ed8a69bd7591513d852d088-a67b7.png 200w,\n/static/2021-07-12-09-46-25-e5fd6fa68ed8a69bd7591513d852d088-0b187.png 400w,\n/static/2021-07-12-09-46-25-e5fd6fa68ed8a69bd7591513d852d088-fee1c.png 800w,\n/static/2021-07-12-09-46-25-e5fd6fa68ed8a69bd7591513d852d088-b1a91.png 1200w,\n/static/2021-07-12-09-46-25-e5fd6fa68ed8a69bd7591513d852d088-21e31.png 1394w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>再接下来，分词器解析出来第一个 EndTag div，这时候 HTML 解析器会去判断当前栈顶的元素是否是 StartTag div，如果是则从栈顶弹出 StartTag div，如下图所示</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-12-09-46-39-189debc09f2159f1319e7288fa16f73d-50f04.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 64.51169188445667%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAIAAAAmMtkJAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABoklEQVQoz41SSy9DQRT2w2xY8Bds/AgSsbAQJOyUhYXYVISwUmkq0op4W1gg8aoirSbq3t5H72Nm7jyv07ml0XbhS2Yyc3K++c6Z7/TF3ZA8/h/6ukPEKkfIjyhTSsKVUooBJAowRTgihEQabbJSqrlLyTknKPDqVcOswxWCIUKxEsUvPLH7sX5VhyRIRghJKTuVhRCE8pj5FIdSk0EVOrFCsXpmnpTCJA2CLTLGyPF88nlf21wwNubf7w6zJ4XL61MlBdTs+z7UZIRyLm/tP6JOstdwqzXTfyq8jQ1Vx4fPcmsjqfTi9g5UazuOZdmQYwZyYs/YuQla/0JIiww9wAmabq5YHhfdweWXmWwFzjoPEyquyuj0xQ0i2anc9kj/2tGzO7BSmc5WkwCLMDQ8m0eZe66V/ir/AuxBDavw4PQvlaYyLWUWcQeZqcvJXHGrSY5VbzLj3HPqF8/maPo1dfAWa58xIh5qnJfzT8Yt2MQFB1pvq7Q+BW9hDBLzwTzOeCxg8BT5AbjQe8KSqmzbDjUcgOv8dzwTNXhbaDDGEp1ufAN3uN+ajZ310QAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 12 09 46 39"\n        title=""\n        src="/static/2021-07-12-09-46-39-189debc09f2159f1319e7288fa16f73d-fee1c.png"\n        srcset="/static/2021-07-12-09-46-39-189debc09f2159f1319e7288fa16f73d-a67b7.png 200w,\n/static/2021-07-12-09-46-39-189debc09f2159f1319e7288fa16f73d-0b187.png 400w,\n/static/2021-07-12-09-46-39-189debc09f2159f1319e7288fa16f73d-fee1c.png 800w,\n/static/2021-07-12-09-46-39-189debc09f2159f1319e7288fa16f73d-b1a91.png 1200w,\n/static/2021-07-12-09-46-39-189debc09f2159f1319e7288fa16f73d-50f04.png 1454w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>按照同样的规则，一路解析，最终结果如下图所示：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-12-09-46-52-ed4fec184a05ef8822bdc6c14cef67ad-9e345.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 70.25139664804469%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAIAAACgpqunAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABj0lEQVQoz6WSSy8DURTH++HEJxAbCxEJOxtWVlYWNr6BRyyISCwklaALNiRIiAhtqrSl2um0nbnvmd6549+5TYt6JU5u5p455/zOayYV/0NS9lJKUUoZY3haS7vdJoRwzgllLSpahHfcjMGCmCiK+jDigiAwxvi+bx1IR5JEV0/+2Gp+fP0h+8riGE6D4DAM+zBSaq2t0oOllFA8oQ/vSSZLqYpssBDiFxiNcNGBy56e2anM7lYdZj7DuHK5nOM46BnvduZ6vV4oFFAcukOjldPGxrnXEgMwmGaz2RsVMCx2WyJpu9zSU5ul6a1nh3Xbxs6+bru3SZQNlOShua2KYp26Hr2p8KIX/mlmIVXcFpcvZmSNLGZUJh+NrpGFA6VNLL+D31cOg9Dl7v5d+qJ0UfErR9kDKD9V7sFSChPG17Wzyb2h5dP548f0xPbw0smcNloK+QEGgzXg82Bzdu3Q7Z8jheocqTiXONaOjfZhlFWJwGctSJH8J5gdoEycXcWW7cOD4rpurVZrNBp2nC/lDSZaHppjNQPGAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 12 09 46 52"\n        title=""\n        src="/static/2021-07-12-09-46-52-ed4fec184a05ef8822bdc6c14cef67ad-fee1c.png"\n        srcset="/static/2021-07-12-09-46-52-ed4fec184a05ef8822bdc6c14cef67ad-a67b7.png 200w,\n/static/2021-07-12-09-46-52-ed4fec184a05ef8822bdc6c14cef67ad-0b187.png 400w,\n/static/2021-07-12-09-46-52-ed4fec184a05ef8822bdc6c14cef67ad-fee1c.png 800w,\n/static/2021-07-12-09-46-52-ed4fec184a05ef8822bdc6c14cef67ad-b1a91.png 1200w,\n/static/2021-07-12-09-46-52-ed4fec184a05ef8822bdc6c14cef67ad-9e345.png 1432w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>通过上面的介绍，相信你已经清楚 DOM 是怎么生成的了。不过在实际生产环境中，HTML 源文件中既包含 CSS 和 JavaScript，又包含图片、音频、视频等文件，所以处理过程远比上面这个示范 Demo 复杂。不过理解了这个简单的 Demo 生成过程，我们就可以往下分析更加复杂的场景了。</p>\n<h2 id="javascript-是如何影响-dom-生成的"><a href="#javascript-%E6%98%AF%E5%A6%82%E4%BD%95%E5%BD%B1%E5%93%8D-dom-%E7%94%9F%E6%88%90%E7%9A%84" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>JavaScript 是如何影响 DOM 生成的</h2>\n<p>我们再来看看稍微复杂点的 HTML 文件，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="80414287373347440000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`<html>\n  <body>\n    <div>1</div>\n    <script>\n      let div1 = document.getElementsByTagName(\'div\')[0];\n      div1.innerText = \'time.geekbang\';\n    </script>\n    <div>test</div>\n  </body>\n</html>`, `80414287373347440000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                html 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">\n      <span class="token keyword">let</span> div1 <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span><span class="token string">\'div\'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n      div1<span class="token punctuation">.</span>innerText <span class="token operator">=</span> <span class="token string">\'time.geekbang\'</span><span class="token punctuation">;</span>\n    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>我在两段 div 中间插入了一段 JavaScript 脚本，这段脚本的解析过程就有点不一样了。script 标签之前，所有的解析流程还是和之前介绍的一样，但是解析到 script 标签时，渲染引擎判断这是一段脚本，此时 HTML 解析器就会暂停 DOM 的解析，因为接下来的 JavaScript 可能要修改当前已经生成的 DOM 结构。</p>\n<p>通过前面 DOM 生成流程分析，我们已经知道当解析到 script 脚本标签时，其 DOM 树结构如下所示：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-12-09-48-15-c1e5af2e2f8efef66efd5338e9c9ea75-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 130.21015761821366%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAaCAIAAAA44esqAAAACXBIWXMAAA7DAAAOwwHHb6hkAAADJElEQVQ4y6VTa0gUURS+uz6LiAof7I+gwn+G9IJKih4/o35EYn82AokeFFkUGYUYlti7jArNx5KmhSVmlKaWS2XurtqGpuRrJbfZGVxnZncee2fnuc3OxBJm7kKHy+Vy7vnO4zvngNB/CJjnT5Bkf1Ci/jgMLyuKEgUsaQZPhvwLq/zpdUxqLZNeSy220NmNXobj1S/dwz/Acviz3EmAiz3xpQPGq8PJl3tBsTOjfIzixChgDRvqnKR2tRA5rb7dzVhOK7nntf+E1cfxQhTwLCEwRLWPlTDdkBPlfg/jQOGbwZ8OlLMh7CQBI2GjpO0i+YUWCKq4hAoysZICFULeO0rVi3IM4DGST6riwW0k6Up/YskXcA+aO5joYD0xEorFDuqCgzttJQr7uLM9geYxOuI6FsLUrnI+z0QopFbLqU2MTpjuG6GFbS+pDS3BtU3spldC5gtYYvdHRiiGmmuEuDvuhGvDSaUD4H7Q/I6JlTC3P7i5BWbWoussrux6d0YDXWSnokeOCIJi4z+Q8SlUXQmGE4KCOHfNihZQP+HcJNmDYl6cUN8eFFU0A2XeCQt7CHdKhIFptwAZvQgcc+v6OcbzNz04PNdNnbexBX3CkVYk30q2utgSu++MPXj8PV7Qy+d3s00j1Ow+S9pMvJ2gQWXIUAEN174bHgVAdehYJ576GIIyr6HME39jFNylzJ3sbLZ1cMckDSxKfBW95PZweJItoXwrYaoPJN6dXFTmSrv5FTyk87r+apWehZ/j7Qjdi8H20Wkbwtg9zJQPOlHGhnF2jOsY8372sC6CDTMyT6twbFqSpL+Vc+yzogVWra/3Fx77tP9Uz8EjXbmHP+Tccl7yUO6jH3NPOswnbeZD1n35tgNHu3NvOosUbUpU4G+wKPBb3mTFvwBLnxlTnhrBc7CjbeM3fDC5EpjKDSnVRtMDY1qNMa4RbGtbLwuStnkRsCjubd+6ojkus2lp5vNly5tAbufOEWJoVe2CNXWm1Q0pWRZTVkP6yobknI7tssZYOHKkAApSBIuTLEEGcILBaUhJskQEZghuhoDq7SXVm51R9RHIL6ZrSNX4YX0tAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 12 09 48 15"\n        title=""\n        src="/static/2021-07-12-09-48-15-c1e5af2e2f8efef66efd5338e9c9ea75-fee1c.png"\n        srcset="/static/2021-07-12-09-48-15-c1e5af2e2f8efef66efd5338e9c9ea75-a67b7.png 200w,\n/static/2021-07-12-09-48-15-c1e5af2e2f8efef66efd5338e9c9ea75-0b187.png 400w,\n/static/2021-07-12-09-48-15-c1e5af2e2f8efef66efd5338e9c9ea75-fee1c.png 800w,\n/static/2021-07-12-09-48-15-c1e5af2e2f8efef66efd5338e9c9ea75-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>这时候 HTML 解析器暂停工作，JavaScript 引擎介入，并执行 script 标签中的这段脚本，因为这段 JavaScript 脚本修改了 DOM 中第一个 div 中的内容，所以执行这段脚本之后，div 节点内容已经修改为 time.geekbang 了。脚本执行完成之后，HTML 解析器恢复解析过程，继续解析后续的内容，直至生成最终的 DOM。</p>\n<p>以上过程应该还是比较好理解的，不过除了在页面中直接内嵌 JavaScript 脚本之外，我们还通常需要在页面中引入 JavaScript 文件，这个解析过程就稍微复杂了些，如下面代码：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="42142260878361170000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`//foo.js\nlet div1 = document.getElementsByTagName(\'div\')[0];\ndiv1.innerText = \'time.geekbang\';`, `42142260878361170000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">//foo.js</span>\n<span class="token keyword">let</span> div1 <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span><span class="token string">\'div\'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\ndiv1<span class="token punctuation">.</span>innerText <span class="token operator">=</span> <span class="token string">\'time.geekbang\'</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span></span></pre></div>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="6160872269058726000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`<html>\n  <body>\n    <div>1</div>\n    <script type=&quot;text/javascript&quot; src=&quot;foo.js&quot;></script>\n    <div>test</div>\n  </body>\n</html>`, `6160872269058726000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                html 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>foo.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>这段代码的功能还是和前面那段代码是一样的，不过这里我把内嵌 JavaScript 脚本修改成了通过 JavaScript 文件加载。其整个执行流程还是一样的，执行到 JavaScript 标签时，暂停整个 DOM 的解析，执行 JavaScript 代码，不过这里执行 JavaScript 时，需要先下载这段 JavaScript 代码。这里需要重点关注下载环境，因为 JavaScript 文件的下载过程会阻塞 DOM 解析，而通常下载又是非常耗时的，会受到网络环境、JavaScript 文件大小等因素的影响。</p>\n<p>不过 Chrome 浏览器做了很多优化，其中一个主要的优化是预解析操作。当渲染引擎收到字节流之后，会开启一个预解析线程，用来分析 HTML 文件中包含的 JavaScript、CSS 等相关文件，解析到相关文件之后，预解析线程会提前下载这些文件。</p>\n<p>再回到 DOM 解析上，我们知道引入 JavaScript 线程会阻塞 DOM，不过也有一些相关的策略来规避，比如使用 CDN 来加速 JavaScript 文件的加载，压缩 JavaScript 文件的体积。另外，如果 JavaScript 文件中没有操作 DOM 相关代码，就可以将该 JavaScript 脚本设置为异步加载，通过 async 或 defer 来标记代码，使用方式如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="75992782597259980000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`<script async type=\'text/javascript\' src=\'foo.js\'></script>`, `75992782597259980000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token operator">&lt;</span>script <span class="token keyword">async</span> type<span class="token operator">=</span><span class="token string">\'text/javascript\'</span> src<span class="token operator">=</span><span class="token string">\'foo.js\'</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="33136729942491394000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`<script defer type=\'text/javascript\' src=\'foo.js\'></script>`, `33136729942491394000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token operator">&lt;</span>script defer type<span class="token operator">=</span><span class="token string">\'text/javascript\'</span> src<span class="token operator">=</span><span class="token string">\'foo.js\'</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>async 和 defer 虽然都是异步的，不过还有一些差异，使用 async 标志的脚本文件一旦加载完成，会立即执行；而使用了 defer 标记的脚本文件，需要在 DOMContentLoaded 事件之前执行。</p>\n<p>现在我们知道了 JavaScript 是如何阻塞 DOM 解析的了，那接下来我们再来结合文中代码看看另外一种情况：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="36822230177798110000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`<head>\n  <style src=&quot;theme.css&quot;></style>\n</head>`, `36822230177798110000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                html 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>theme.css<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token style"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span></span></pre></div>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="58580916402725626000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`<body>\n  <div>1</div>\n  <script>\n    let div1 = document.getElementsByTagName(\'div\')[0]\n    div1.innerText = \'time.geekbang\' // 需要 DOM\n    div1.style.color = \'red\'  // 需要 CSSOM\n  </script>\n  <div>test</div>\n</body>\n</html>`, `58580916402725626000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                html 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">\n    <span class="token keyword">let</span> div1 <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span><span class="token string">\'div\'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>\n    div1<span class="token punctuation">.</span>innerText <span class="token operator">=</span> <span class="token string">\'time.geekbang\'</span> <span class="token comment">// 需要 DOM</span>\n    div1<span class="token punctuation">.</span>style<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token string">\'red\'</span>  <span class="token comment">// 需要 CSSOM</span>\n  </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>该示例中，JavaScript 代码出现了 div1.style.color = ‘red’ 的语句，它是用来操纵 CSSOM 的，所以在执行 JavaScript 之前，需要先解析 JavaScript 语句之上所有的 CSS 样式。所以如果代码里引用了外部的 CSS 文件，那么在执行 JavaScript 之前，还需要等待外部的 CSS 文件下载完成，并解析生成 CSSOM 对象之后，才能执行 JavaScript 脚本。</p>\n<p>而 JavaScript 引擎在解析 JavaScript 之前，是不知道 JavaScript 是否操纵了 CSSOM 的，所以渲染引擎在遇到 JavaScript 脚本时，不管该脚本是否操纵了 CSSOM，都会执行 CSS 文件下载，解析操作，再执行 JavaScript 脚本。</p>\n<p>所以说 JavaScript 脚本是依赖样式表的，这又多了一个阻塞过程。至于如何优化，我们在下篇文章中再来深入探讨。</p>\n<p>通过上面的分析，我们知道了 JavaScript 会阻塞 DOM 生成，而样式文件又会阻塞 JavaScript 的执行，所以在实际的工程中需要重点关注 JavaScript 文件和样式表文件，使用不当会影响到页面性能。</p>\n<h2 id="总结-1"><a href="#%E6%80%BB%E7%BB%93-1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总结</h2>\n<p>首先我们介绍了 DOM 是如何生成的，然后又基于 DOM 的生成过程分析了 JavaScript 是如何影响到 DOM 生成的。因为 CSS 和 JavaScript 都会影响到 DOM 的生成，所以我们又介绍了一些加速生成 DOM 的方案，理解了这些，能让你更加深刻地理解如何去优化首次页面渲染。</p>\n<p>额外说明一下，渲染引擎还有一个安全检查模块叫 XSSAuditor，是用来检测词法安全的。在分词器解析出来 Token 之后，它会检测这些模块是否安全，比如是否引用了外部脚本，是否符合 CSP 规范，是否存在跨站点请求等。如果出现不符合规范的内容，XSSAuditor 会对该脚本或者下载任务进行拦截。详细内容我们会在后面的安全模块介绍，这里就不赘述了</p>\n<h1 id="渲染流水线：css-如何影响首次加载时的白屏时间？"><a href="#%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF%EF%BC%9Acss-%E5%A6%82%E4%BD%95%E5%BD%B1%E5%93%8D%E9%A6%96%E6%AC%A1%E5%8A%A0%E8%BD%BD%E6%97%B6%E7%9A%84%E7%99%BD%E5%B1%8F%E6%97%B6%E9%97%B4%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>渲染流水线：CSS 如何影响首次加载时的白屏时间？</h1>\n<p>在上一篇文章中我们详细介绍了 DOM 的生成过程，并结合具体例子分析了 JavaScript 是如何阻塞 DOM 生成的。那本文我们就继续深入聊聊渲染流水线中的 CSS。因为 CSS 是页面中非常重要的资源，它决定了页面最终显示出来的效果，并影响着用户对整个网站的第一体验。所以，搞清楚浏览器中的 CSS 是怎么工作的很有必要，只有理解了 CSS 是如何工作的，你才能更加深刻地理解如何去优化页面。</p>\n<p>本文我们先站在渲染流水线的视角来介绍 CSS 是如何工作的，然后通过 CSS 的工作流程来分析性能瓶颈，最后再来讨论如何减少首次加载时的白屏时间</p>\n<p>渲染流水线视角下的 CSS 我们先结合下面代码来看看最简单的渲染流程：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="9593109829958779000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`/* theme.css */\ndiv {\n  color: coral;\n  background-color: black;\n}`, `9593109829958779000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                css 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="css"><pre style="counter-reset: linenumber NaN" class="language-css line-numbers"><code class="language-css"><span class="token comment">/* theme.css */</span>\n<span class="token selector">div</span> <span class="token punctuation">{</span>\n  <span class="token property">color</span><span class="token punctuation">:</span> coral<span class="token punctuation">;</span>\n  <span class="token property">background-color</span><span class="token punctuation">:</span> black<span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="91105467251809200000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`<html>\n  <head>\n    <link href=&quot;theme.css&quot; rel=&quot;stylesheet&quot; />\n  </head>\n  <body>\n    <div>geekbang com</div>\n  </body>\n</html>`, `91105467251809200000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                html 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>theme.css<span class="token punctuation">"</span></span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>stylesheet<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>geekbang com<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>这两段代码分别由 CSS 文件和 HTML 文件构成，我们来分析下打开这段 HTML 文件时的渲染流水线，你可以先参考下面这张渲染流水线示意图：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-12-17-57-26-5a2e57bfeb66dc5e650aaa43f5726f6d-50f04.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 51.031636863823934%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACDklEQVQoz23QW28SQRQH8P1+Ptg09tWXfgB98E16MT741NqobY3phesCKRRLUbFADQWtXIvIRS7ZOyx05bKw7MzuzLJuNUZjPPk9zPxzJjlnCNM08WyqiYLe72g3urDX1foi7HUsP6+ClcO+oPWsHsE6WAkUOTRTCFVVKqXGvReF5e3Kkf2UJndqu8vlzdvN3btt36sa6WzZV8obt2rPFr9s3bnaXPi6tVjfXqo9XVBaReL6u9Qolh3u1I7rMuk7ofx7tPPh1eFql1zhQ85WgOS8G+XD9YbrMe9epVxrjHuN9Txi7DaFqhLjmTqqluTQwTjsFIOOumc/7Hr70leNBVPCaz/t2087yD1P3ntUrIciUiQonh73IyEx5FPpNmHtDDrc9Xm0l4zLHxPSRSIYrXrjdOCs0b04B59i6fcZ8owiY0w+kZmmosNUfJSODz+8g6JAYISxgYy5riMVzY2ZrutwOkcK0hU8xwAbACgmmplYRVgDGMPfkGEQQ6mfbXYf+Fv33fU3Fb7A0SWB2U1yS8+/rYfZHENdtts5js/zfIHnfinyXJZlRFkmBlI/1+zYQpTtmDopUVm6bb0PFOkn4fpBmsqydIahswyTY//Is8xnmurKY8IaU0OabgCLooEJhLIKIIamqeE5VDRtarFCAP42BgAidPNh/9TcMCbyZDpVxqPxQJKGg8FEls3/1Q8Gy/hZqoeBqgAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 12 17 57 26"\n        title=""\n        src="/static/2021-07-12-17-57-26-5a2e57bfeb66dc5e650aaa43f5726f6d-fee1c.png"\n        srcset="/static/2021-07-12-17-57-26-5a2e57bfeb66dc5e650aaa43f5726f6d-a67b7.png 200w,\n/static/2021-07-12-17-57-26-5a2e57bfeb66dc5e650aaa43f5726f6d-0b187.png 400w,\n/static/2021-07-12-17-57-26-5a2e57bfeb66dc5e650aaa43f5726f6d-fee1c.png 800w,\n/static/2021-07-12-17-57-26-5a2e57bfeb66dc5e650aaa43f5726f6d-b1a91.png 1200w,\n/static/2021-07-12-17-57-26-5a2e57bfeb66dc5e650aaa43f5726f6d-50f04.png 1454w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>下面我们结合上图来分析这个页面文件的渲染流水线。</p>\n<p>首先是发起主页面的请求，这个发起请求方可能是渲染进程，也有可能是浏览器进程，发起的请求被送到网络进程中去执行。网络进程接收到返回的 HTML 数据之后，将其发送给渲染进程，渲染进程会解析 HTML 数据并构建 DOM。这里你需要特别注意下，请求 HTML 数据和构建 DOM 中间有一段空闲时间，这个空闲时间有可能成为页面渲染的瓶颈。</p>\n<p>上一篇文章中我们提到过，当渲染进程接收 HTML 文件字节流时，会先开启一个预解析线程，如果遇到 JavaScript 文件或者 CSS 文件，那么预解析线程会提前下载这些数据。对于上面的代码，预解析线程会解析出来一个外部的 theme.css 文件，并发起 theme.css 的下载。这里也有一个空闲时间需要你注意一下，就是在 DOM 构建结束之后、theme.css 文件还未下载完成的这段时间内，渲染流水线无事可做，因为下一步是合成布局树，而合成布局树需要 CSSOM 和 DOM，所以这里需要等待 CSS 加载结束并解析成 CSSOM。</p>\n<h2 id="那渲染流水线为什么需要-cssom-呢？"><a href="#%E9%82%A3%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-cssom-%E5%91%A2%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>那渲染流水线为什么需要 CSSOM 呢？</h2>\n<p>和 HTML 一样，渲染引擎也是无法直接理解 CSS 文件内容的，所以需要将其解析成渲染引擎能够理解的结构，这个结构就是 CSSOM。和 DOM 一样，CSSOM 也具有两个作用，第一个是提供给 JavaScript 操作样式表的能力，第二个是为布局树的合成提供基础的样式信息。这个 CSSOM 体现在 DOM 中就是 document.styleSheets。具体结构你可以去查阅相关资料，这里我就不过多介绍了，你知道 CSSOM 的两个作用是怎样的就行了。</p>\n<p>有了 DOM 和 CSSOM，接下来就可以合成布局树了，我们在前面讲解过布局树的构造过程，这里咱们再简单回顾下。等 DOM 和 CSSOM 都构建好之后，渲染引擎就会构造布局树。布局树的结构基本上就是复制 DOM 树的结构，不同之处在于 DOM 树中那些不需要显示的元素会被过滤掉，如 display:none 属性的元素、head 标签、script 标签等。复制好基本的布局树结构之后，渲染引擎会为对应的 DOM 元素选择对应的样式信息，这个过程就是样式计算。样式计算完成之后，渲染引擎还需要计算布局树中每个元素对应的几何位置，这个过程就是计算布局。通过样式计算和计算布局就完成了最终布局树的构建。再之后，就该进行后续的绘制操作了。</p>\n<p>这就是在渲染过程中涉及到 CSS 的一些主要流程。</p>\n<p>了解了这些之后，我们再来看看稍微复杂一点的场景，还是看下面这段 HTML 代码：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="90555916115416730000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`/* theme.css */\ndiv {\n  color: coral;\n  background-color: black;\n}`, `90555916115416730000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                css 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="css"><pre style="counter-reset: linenumber NaN" class="language-css line-numbers"><code class="language-css"><span class="token comment">/* theme.css */</span>\n<span class="token selector">div</span> <span class="token punctuation">{</span>\n  <span class="token property">color</span><span class="token punctuation">:</span> coral<span class="token punctuation">;</span>\n  <span class="token property">background-color</span><span class="token punctuation">:</span> black<span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="45024901179554220000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`<html>\n  <head>\n    <link href=&quot;theme.css&quot; rel=&quot;stylesheet&quot; />\n  </head>\n  <body>\n    <div>geekbang com</div>\n    <script>\n      console.log(\'time.geekbang.org\');\n    </script>\n    <div>geekbang com</div>\n  </body>\n</html>`, `45024901179554220000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                html 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>theme.css<span class="token punctuation">"</span></span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>stylesheet<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>geekbang com<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">\n      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'time.geekbang.org\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>geekbang com<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>这段代码是我在开头代码的基础之上做了一点小修改，在 body 标签内部加了一个简单的 JavaScript。有了 JavaScript，渲染流水线就有点不一样了，可以参考下面这张渲染流水线图：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-12-17-58-30-036e446289655483317250b7e85b33d2-4674f.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 51.00942126514132%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAB5ElEQVQoz4WRy2sTURTG5x9yoSAuBQkFQfeuBHeuBXGrG1GDZuGmICg0j06TSUjSxIzWlIKJ0iZtmmRMJo8mnek8msfkzr2dZCZzMzPe4Ktk4+F3DudwPjgHPsr7Xzhzy7Esz3WdqbGyokhONU3geLHRBnwDNiuA2wfcAWzUIM+NS99UNnW+kzn/kpXZpPo1P6kWJrUCqBWxgajZzCjtc/cDtQdva4UNuvvucd3v4wN3exsBiQl9f3hv++aVnds3PvmuZdeuZ3xXi09ulV+uNV7fmcptSjcMqVppJuJcItGkgz+C67ubsSOGGWxvdaLB4+D7z5u5NkNL8ZAUDyuJsJSMyKmImo7Mx8Pl20a/M0hvKZn45GM0H2Nf0fx6jGun06MMHaX3/LFOiCkPcskRmxwScr+xtRHlep5rW66hYTTCFxCMNagjBMAcguWoAR0gpCML6is4GFNTpJc7ytO08DzbP5TVuiLmW2ePwh0/K1Rk6ehMqCtSXZWrqnKZY0VGlkUZEBy0xGep3ovsSbF7cij0dvn+m1zrQ6FbFk9LwmlZFP40/ygJfWjOKJcY6Cw8z3Y928SYYDuYuOt6C2uBl2D8qzGxfRnHdakV303TRJAEgjq8QIigjcfDwYBUsiICcuyv+CfXVP9mI3tdLAAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 12 17 58 30"\n        title=""\n        src="/static/2021-07-12-17-58-30-036e446289655483317250b7e85b33d2-fee1c.png"\n        srcset="/static/2021-07-12-17-58-30-036e446289655483317250b7e85b33d2-a67b7.png 200w,\n/static/2021-07-12-17-58-30-036e446289655483317250b7e85b33d2-0b187.png 400w,\n/static/2021-07-12-17-58-30-036e446289655483317250b7e85b33d2-fee1c.png 800w,\n/static/2021-07-12-17-58-30-036e446289655483317250b7e85b33d2-b1a91.png 1200w,\n/static/2021-07-12-17-58-30-036e446289655483317250b7e85b33d2-4674f.png 1486w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>那我们就结合这张图来分析含有外部 CSS 文件和 JavaScript 代码的页面渲染流水线，上一篇文章中我们提到过在解析 DOM 的过程中，如果遇到了 JavaScript 脚本，那么需要先暂停 DOM 解析去执行 JavaScript，因为 JavaScript 有可能会修改当前状态下的 DOM。</p>\n<p>不过在执行 JavaScript 脚本之前，如果页面中包含了外部 CSS 文件的引用，或者通过 style 标签内置了 CSS 内容，那么渲染引擎还需要将这些内容转换为 CSSOM，因为 JavaScript 有修改 CSSOM 的能力，所以在执行 JavaScript 之前，还需要依赖 CSSOM。也就是说 CSS 在部分情况下也会阻塞 DOM 的生成。</p>\n<p>我们再来看看更加复杂一点的情况，如果在 body 中被包含的是 JavaScript 外部引用文件，Demo 代码如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="39637328456025550000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`/* theme.css */\ndiv {\n  color: coral;\n  background-color: black;\n}`, `39637328456025550000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                css 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="css"><pre style="counter-reset: linenumber NaN" class="language-css line-numbers"><code class="language-css"><span class="token comment">/* theme.css */</span>\n<span class="token selector">div</span> <span class="token punctuation">{</span>\n  <span class="token property">color</span><span class="token punctuation">:</span> coral<span class="token punctuation">;</span>\n  <span class="token property">background-color</span><span class="token punctuation">:</span> black<span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="80753783922407310000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// foo.js\nconsole.log(\'time.geekbang.org\');`, `80753783922407310000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">// foo.js</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'time.geekbang.org\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span></span></pre></div>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="75544412883321390000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`<html>\n  <head>\n    <link href=&quot;theme.css&quot; rel=&quot;stylesheet&quot; />\n  </head>\n  <body>\n    <div>geekbang com</div>\n    <script src=&quot;foo.js&quot;></script>\n    <div>geekbang com</div>\n  </body>\n</html>`, `75544412883321390000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                html 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>theme.css<span class="token punctuation">"</span></span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>stylesheet<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>geekbang com<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>foo.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>geekbang com<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>从上面代码可以看出来，HTML 文件中包含了 CSS 的外部引用和 JavaScript 外部文件，那它们的渲染流水线是怎样的呢？可参考下图</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-12-17-59-27-6c8864e1ea1f4a83f737f9120b693cd1-b0cb8.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 52.156862745098046%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACBElEQVQoz4WSa2vTYBSA959EEUFEPygy/Avqdz8I+gtkgrCBQ5hip7auWWVt2pV17tLhUOdqbzZpu/WSJs2l6TXJmzdtbk3apqaj+GFfPDzvgfMeHjgHzsL0fzExdGc8npimy6XWgvtMqACGk1lO52idrRls1c0aS7kopbycTUA8LWd/S1hmQJZVuqzWz4ZSdyYPh3oyWXq8ij9ZyxWQDWL9aXHlbvXtQx71NzY/HD24Eb9/7eje1ePF61/vXPn56GZmZbH46nb3h3cm9zWNw3LpLygW2SGCSOXzasb//iy0yaD+MrJ+6g1k/YFjH1ryeerIx8bWJ37b1wh6IJ6cyc50qlGVXjQgHUSlPfQA/f46TCPb5/Je8CQcXw4RGxHcEy6+C5eQaIHfj4HDWG83op7n5zs7tjnu9xxNthW504NYhSvXmImq6P2BW0J5AIEiiLCvqCaUh4o8hGBk6DNZ78NEtfNsi1o+ZHPNFsZzeZbwntSfh1h/ii+2mEKnlW838Waj2GnjF/xptzgFXsgDJUXwS7vE2rfaKUX+IskMTbzYqd1ayr+MEVmWTNSpBEW6rRRDu6QZ2v2pi+J8bM0yBE3sqhIjAxoAFvR2sfabeHe/0GHELikIlCjQQGIAoCXRxS0FVZ3L/2Jk27Zlje2RMxlNJ6YztkaWZRqGoetutizr0pH8BZLC/Hs6REFYAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 12 17 59 27"\n        title=""\n        src="/static/2021-07-12-17-59-27-6c8864e1ea1f4a83f737f9120b693cd1-fee1c.png"\n        srcset="/static/2021-07-12-17-59-27-6c8864e1ea1f4a83f737f9120b693cd1-a67b7.png 200w,\n/static/2021-07-12-17-59-27-6c8864e1ea1f4a83f737f9120b693cd1-0b187.png 400w,\n/static/2021-07-12-17-59-27-6c8864e1ea1f4a83f737f9120b693cd1-fee1c.png 800w,\n/static/2021-07-12-17-59-27-6c8864e1ea1f4a83f737f9120b693cd1-b1a91.png 1200w,\n/static/2021-07-12-17-59-27-6c8864e1ea1f4a83f737f9120b693cd1-b0cb8.png 1530w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从图中可以看出来，在接收到 HTML 数据之后的预解析过程中，HTML 预解析器识别出来了有 CSS 文件和 JavaScript 文件需要下载，然后就同时发起这两个文件的下载请求，需要注意的是，这两个文件的下载过程是重叠的，所以下载时间按照最久的那个文件来算。</p>\n<p>后面的流水线就和前面是一样的了，不管 CSS 文件和 JavaScript 文件谁先到达，都要先等到 CSS 文件下载完成并生成 CSSOM，然后再执行 JavaScript 脚本，最后再继续构建 DOM，构建布局树，绘制页面。</p>\n<h2 id="影响页面展示的因素以及优化策略"><a href="#%E5%BD%B1%E5%93%8D%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%E7%9A%84%E5%9B%A0%E7%B4%A0%E4%BB%A5%E5%8F%8A%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>影响页面展示的因素以及优化策略</h2>\n<p>前面我们为什么要花这么多文字来分析渲染流水线呢？主要原因就是渲染流水线影响到了首次页面展示的速度，而首次页面展示的速度又直接影响到了用户体验，所以我们分析渲染流水线的目的就是为了找出一些影响到首屏展示的因素，然后再基于这些因素做一些针对性的调整。</p>\n<p>那么接下来我们就来看看从发起 URL 请求开始，到首次显示页面的内容，在视觉上经历的三个阶段。</p>\n<ul>\n<li>第一个阶段，等请求发出去之后，到提交数据阶段，这时页面展示出来的还是之前页面的内容。</li>\n<li>第二个阶段，提交数据之后渲染进程会创建一个空白页面，我们通常把这段时间称为解析白屏，并等待 CSS 文件和 JavaScript 文件的加载完成，生成 CSSOM 和 DOM，然后合成布局树，最后还要经过一系列的步骤准备首次渲染。</li>\n<li>第三个阶段，等首次渲染完成之后，就开始进入完整页面的生成阶段了，然后页面会一点点被绘制出来。</li>\n</ul>\n<p>影响第一个阶段的因素主要是网络或者是服务器处理这块儿，前面文章中我们已经讲过了，这里我们就不再继续分析了。至于第三个阶段，我们会在后续文章中分析，所以这里也不做介绍了。</p>\n<p>现在我们重点关注第二个阶段，这个阶段的主要问题是白屏时间，如果白屏时间过久，就会影响到用户体验。为了缩短白屏时间，我们来挨个分析这个阶段的主要任务，包括了解析 HTML、下载 CSS、下载 JavaScript、生成 CSSOM、执行 JavaScript、生成布局树、绘制页面一系列操作。</p>\n<p>通常情况下的瓶颈主要体现在下载 CSS 文件、下载 JavaScript 文件和执行 JavaScript。</p>\n<p>所以要想缩短白屏时长，可以有以下策略</p>\n<ul>\n<li>通过内联 JavaScript、内联 CSS 来移除这两种类型的文件下载，这样获取到 HTML 文件之后就可以直接开始渲染流程了。</li>\n<li>但并不是所有的场合都适合内联，那么还可以尽量减少文件大小，比如通过 webpack 等工具移除一些不必要的注释，并压缩 JavaScript 文件。</li>\n<li>还可以将一些不需要在解析 HTML 阶段使用的 JavaScript 标记上 async 或者 defer。</li>\n<li>对于大的 CSS 文件，可以通过媒体查询属性，将其拆分为多个不同用途的 CSS 文件，这样只有在特定的场景下才会加载特定的 CSS 文件。</li>\n</ul>\n<p>通过以上策略就能缩短白屏展示的时长了，不过在实际项目中，总是存在各种各样的情况，这些策略并不能随心所欲地去引用，所以还需要结合实际情况来调整最佳方案。</p>\n<h2 id="总结-2"><a href="#%E6%80%BB%E7%BB%93-2" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总结</h2>\n<p>我们首先介绍了 CSS 在渲染流水线中的位置，以及 CSS 是如何影响到渲染流程的；接下来我们通过渲染流水线分析了从发出请求到页面首次绘制的三个阶段；最后重点介绍了第二个白屏阶段以及优化该阶段的一些策略。通过今天的内容我们可以知道虽然 JavaScript 和 CSS 给我们带来了极大的便利，不过也对页面的渲染带来了很多的限制，所以我们要关注资源加载速度，需要小心翼翼地处理各种资源之间的关联关系。</p>\n<h1 id="分层和合成机制：为什么-css-动画比-javascript-高效"><a href="#%E5%88%86%E5%B1%82%E5%92%8C%E5%90%88%E6%88%90%E6%9C%BA%E5%88%B6%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88-css-%E5%8A%A8%E7%94%BB%E6%AF%94-javascript-%E9%AB%98%E6%95%88" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>分层和合成机制：为什么 css 动画比 JavaScript 高效</h1>\n<p>本文我们主要讲解渲染引擎的分层和合成机制，因为分层和合成机制代表了浏览器最为先进的合成技术，Chrome 团队为了做到这一点，做了大量的优化工作。了解其工作原理，有助于拓宽你的视野，而且也有助于你更加深刻地理解 CSS 动画和 JavaScript 底层工作机制。</p>\n<h2 id="显示器是怎么显示图像的"><a href="#%E6%98%BE%E7%A4%BA%E5%99%A8%E6%98%AF%E6%80%8E%E4%B9%88%E6%98%BE%E7%A4%BA%E5%9B%BE%E5%83%8F%E7%9A%84" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>显示器是怎么显示图像的</h2>\n<p>每个显示器都有固定的刷新频率，通常是 60HZ，也就是每秒更新 60 张图片，更新的图片都来自于显卡中一个叫前缓冲区的地方，显示器所做的任务很简单，就是每秒固定读取 60 次前缓冲区中的图像，并将读取的图像显示到显示器上。</p>\n<p>那么这里显卡做什么呢？</p>\n<p>显卡的职责就是合成新的图像，并将图像保存到后缓冲区中，一旦显卡把合成的图像写到后缓冲区，系统就会让后缓冲区和前缓冲区互换，这样就能保证显示器能读取到最新显卡合成的图像。通常情况下，显卡的更新频率和显示器的刷新频率是一致的。但有时候，在一些复杂的场景中，显卡处理一张图片的速度会变慢，这样就会造成视觉上的卡顿。</p>\n<h2 id="帧-vs-帧率"><a href="#%E5%B8%A7-vs-%E5%B8%A7%E7%8E%87" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>帧 VS 帧率</h2>\n<p>了解了显示器是怎么显示图像的之后，下面我们再来明确下帧和帧率的概念，因为这是后续一切分析的基础。</p>\n<p>当你通过滚动条滚动页面，或者通过手势缩放页面时，屏幕上就会产生动画的效果。之所以你能感觉到有动画的效果，是因为在滚动或者缩放操作时，渲染引擎会通过渲染流水线生成新的图片，并发送到显卡的后缓冲区。</p>\n<p>大多数设备屏幕的更新频率是 60 次 / 秒，这也就意味着正常情况下要实现流畅的动画效果，渲染引擎需要每秒更新 60 张图片到显卡的后缓冲区。</p>\n<p>我们把渲染流水线生成的每一副图片称为一帧，把渲染流水线每秒更新了多少帧称为帧率，比如滚动过程中 1 秒更新了 60 帧，那么帧率就是 60Hz（或者 60FPS）。</p>\n<p>由于用户很容易观察到那些丢失的帧，如果在一次动画过程中，渲染引擎生成某些帧的时间过久，那么用户就会感受到卡顿，这会给用户造成非常不好的印象。</p>\n<p>要解决卡顿问题，就要解决每帧生成时间过久的问题，为此 Chrome 对浏览器渲染方式做了大量的工作，其中最卓有成效的策略就是引入了分层和合成机制。分层和合成机制代表了当今最先进的渲染技术，所以接下来我们就来分析下什么是合成和渲染技术</p>\n<h2 id="如何生成一帧图像"><a href="#%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90%E4%B8%80%E5%B8%A7%E5%9B%BE%E5%83%8F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>如何生成一帧图像</h2>\n<p>不过在开始之前，我们还需要聊一聊渲染引擎是如何生成一帧图像的。这需要回顾下我们前面介绍的渲染流水线。关于其中任意一帧的生成方式，有重排、重绘和合成三种方式</p>\n<p>这三种方式的渲染路径是不同的，通常渲染路径越长，生成图像花费的时间就越多。比如重排，它需要重新根据 CSSOM 和 DOM 来计算布局树，这样生成一幅图片时，会让整个渲染流水线的每个阶段都执行一遍，如果布局复杂的话，就很难保证渲染的效率了。而重绘因为没有了重新布局的阶段，操作效率稍微高点，但是依然需要重新计算绘制信息，并触发绘制操作之后的一系列操作。</p>\n<p>相较于重排和重绘，合成操作的路径就显得非常短了，并不需要触发布局和绘制两个阶段，如果采用了 GPU，那么合成的效率会非常高。</p>\n<p>所以，关于渲染引擎生成一帧图像的几种方式，按照效率我们推荐合成方式优先，若实在不能满足需求，那么就再退后一步使用重绘或者重排的方式。</p>\n<p>本文我们的焦点在合成上，所以接下来我们就来深入分析下 Chrome 浏览器是怎么实现合成操作的。Chrome 中的合成技术，可以用三个词来概括总结：分层、分块和合成</p>\n<h2 id="分层和合成"><a href="#%E5%88%86%E5%B1%82%E5%92%8C%E5%90%88%E6%88%90" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>分层和合成</h2>\n<p>通常页面的组成是非常复杂的，有的页面里要实现一些复杂的动画效果，比如点击菜单时弹出菜单的动画特效，滚动鼠标滚轮时页面滚动的动画效果，当然还有一些炫酷的 3D 动画特效。如果没有采用分层机制，从布局树直接生成目标图片的话，那么每次页面有很小的变化时，都会触发重排或者重绘机制，这种“牵一发而动全身”的绘制策略会严重影响页面的渲染效率。</p>\n<p>为了提升每帧的渲染效率，Chrome 引入了分层和合成的机制。那该怎么来理解分层和合成机制呢？</p>\n<p>你可以把一张网页想象成是由很多个图片叠加在一起的，每个图片就对应一个图层，Chrome 合成器最终将这些图层合成了用于显示页面的图片。如果你熟悉 PhotoShop 的话，就能很好地理解这个过程了，PhotoShop 中一个项目是由很多图层构成的，每个图层都可以是一张单独图片，可以设置透明度、边框阴影，可以旋转或者设置图层的上下位置，将这些图层叠加在一起后，就能呈现出最终的图片了。</p>\n<p>在这个过程中，将素材分解为多个图层的操作就称为分层，最后将这些图层合并到一起的操作就称为合成。所以，分层和合成通常是一起使用的。</p>\n<p>考虑到一个页面被划分为两个层，当进行到下一帧的渲染时，上面的一帧可能需要实现某些变换，如平移、旋转、缩放、阴影或者 Alpha 渐变，这时候合成器只需要将两个层进行相应的变化操作就可以了，显卡处理这些操作驾轻就熟，所以这个合成过程时间非常短。</p>\n<p>理解了为什么要引入合成和分层机制，下面我们再来看看 Chrome 是怎么实现分层和合成机制的。</p>\n<p>在 Chrome 的渲染流水线中，分层体现在生成布局树之后，渲染引擎会根据布局树的特点将其转换为层树（Layer Tree），层树是渲染流水线后续流程的基础结构。</p>\n<p>层树中的每个节点都对应着一个图层，下一步的绘制阶段就依赖于层树中的节点。在前面我们介绍过，绘制阶段其实并不是真正地绘出图片，而是将绘制指令组合成一个列表，比如一个图层要设置的背景为黑色，并且还要在中间画一个圆形，那么绘制过程会生成|Paint BackGroundColor:Black | Paint Circle|这样的绘制指令列表，绘制过程就完成了。</p>\n<p>有了绘制列表之后，就需要进入光栅化阶段了，光栅化就是按照绘制列表中的指令生成图片。每一个图层都对应一张图片，合成线程有了这些图片之后，会将这些图片合成为“一张”图片，并最终将生成的图片发送到后缓冲区。这就是一个大致的分层、合成流程。</p>\n<p>需要重点关注的是，合成操作是在合成线程上完成的，这也就意味着在执行合成操作时，是不会影响到主线程执行的。这就是为什么经常主线程卡住了，但是 CSS 动画依然能执行的原因。</p>\n<h2 id="分块"><a href="#%E5%88%86%E5%9D%97" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>分块</h2>\n<p>如果说分层是从宏观上提升了渲染效率，那么分块则是从微观层面提升了渲染效率。</p>\n<p>通常情况下，页面的内容都要比屏幕大得多，显示一个页面时，如果等待所有的图层都生成完毕，再进行合成的话，会产生一些不必要的开销，也会让合成图片的时间变得更久。</p>\n<p>因此，合成线程会将每个图层分割为大小固定的图块，然后优先绘制靠近视口的图块，这样就可以大大加速页面的显示速度。不过有时候， 即使只绘制那些优先级最高的图块，也要耗费不少的时间，因为涉及到一个很关键的因素——纹理上传，这是因为从计算机内存上传到 GPU 内存的操作会比较慢。</p>\n<p>为了解决这个问题，Chrome 又采取了一个策略：在首次合成图块的时候使用一个低分辨率的图片。比如可以是正常分辨率的一半，分辨率减少一半，纹理就减少了四分之三。在首次显示页面内容的时候，将这个低分辨率的图片显示出来，然后合成器继续绘制正常比例的网页内容，当正常比例的网页内容绘制完成后，再替换掉当前显示的低分辨率内容。这种方式尽管会让用户在开始时看到的是低分辨率的内容，但是也比用户在开始时什么都看不到要好</p>\n<h2 id="如何利用分层技术优化代码"><a href="#%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E5%88%86%E5%B1%82%E6%8A%80%E6%9C%AF%E4%BC%98%E5%8C%96%E4%BB%A3%E7%A0%81" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>如何利用分层技术优化代码</h2>\n<p>通过上面的介绍，相信你已经理解了渲染引擎是怎么将布局树转换为漂亮图片的，理解其中原理之后，你就可以利用分层和合成技术来优化代码了。</p>\n<p>在写 Web 应用的时候，你可能经常需要对某个元素做几何形状变换、透明度变换或者一些缩放操作，如果使用 JavaScript 来写这些效果，会牵涉到整个渲染流水线，所以 JavaScript 的绘制效率会非常低下。</p>\n<p>这时你可以使用 will-change 来告诉渲染引擎你会对该元素做一些特效变换，CSS 代码如下：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="76864739832962960000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`.box {\n  will-change: transform, opacity;\n}`, `76864739832962960000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                css 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="css"><pre style="counter-reset: linenumber NaN" class="language-css line-numbers"><code class="language-css"><span class="token selector">.box</span> <span class="token punctuation">{</span>\n  <span class="token property">will-change</span><span class="token punctuation">:</span> transform<span class="token punctuation">,</span> opacity<span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span></span></pre></div>\n<p>这段代码就是提前告诉渲染引擎 box 元素将要做几何变换和透明度变换操作，这时候渲染引擎会将该元素单独实现一帧，等这些变换发生时，渲染引擎会通过合成线程直接去处理变换，这些变换并没有涉及到主线程，这样就大大提升了渲染的效率。这也是 CSS 动画比 JavaScript 动画高效的原因。</p>\n<p>所以，如果涉及到一些可以使用合成线程来处理 CSS 特效或者动画的情况，就尽量使用 will-change 来提前告诉渲染引擎，让它为该元素准备独立的层。但是凡事都有两面性，每当渲染引擎为一个元素准备一个独立层的时候，它占用的内存也会大大增加，因为从层树开始，后续每个阶段都会多一个层结构，这些都需要额外的内存，所以你需要恰当地使用 will-change。</p>\n<h2 id="总结-3"><a href="#%E6%80%BB%E7%BB%93-3" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总结</h2>\n<ul>\n<li>首先我们介绍了显示器显示图像的原理，以及帧和帧率的概念，然后基于帧和帧率我们又介绍渲染引擎是如何实现一帧图像的。通常渲染引擎生成一帧图像有三种方式：重排、重绘和合成。其中重排和重绘操作都是在渲染进程的主线程上执行的，比较耗时；而合成操作是在渲染进程的合成线程上执行的，执行速度快，且不占用主线程。</li>\n<li>然后我们重点介绍了浏览器是怎么实现合成的，其技术细节主要可以使用三个词来概括：分层、分块和合成。</li>\n<li>最后我们还讲解了 CSS 动画比 JavaScript 动画高效的原因，以及怎么使用 will-change 来优化动画或特效。</li>\n</ul>\n<h1 id="页面性能：如何系统优化页面"><a href="#%E9%A1%B5%E9%9D%A2%E6%80%A7%E8%83%BD%EF%BC%9A%E5%A6%82%E4%BD%95%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96%E9%A1%B5%E9%9D%A2" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>页面性能：如何系统优化页面</h1>\n<p>在前面几篇文章中，我们分析了页面加载和 DOM 生成，讨论了 JavaScript 和 CSS 是如何影响到 DOM 生成的，还结合渲染流水线来讲解了分层和合成机制，同时在这些文章里面，我们还穿插说明了很多优化页面性能的最佳实践策略。通过这些知识点的学习，相信你已经知道渲染引擎是怎么绘制出帧的，不过之前我们介绍的内容比较零碎、比较散，那么今天我们就来将这些内容系统性地串起来。</p>\n<p>那么怎么才能把这些知识点串起来呢？我的思路是从如何系统优化页面速度的角度来切入。</p>\n<p>这里我们所谈论的页面优化，其实就是要让页面更快地显示和响应。由于一个页面在它不同的阶段，所侧重的关注点是不一样的，所以如果我们要讨论页面优化，就要分析一个页面生存周期的不同阶段。</p>\n<p>通常一个页面有三个阶段：加载阶段、交互阶段和关闭阶段</p>\n<ul>\n<li>加载阶段，是指从发出请求到渲染出完整页面的过程，影响到这个阶段的主要因素有网络和 JavaScript 脚本。</li>\n<li>交互阶段，主要是从页面加载完成到用户交互的整合过程，影响到这个阶段的主要因素是 JavaScript 脚本。</li>\n<li>关闭阶段，主要是用户发出关闭指令后页面所做的一些清理操作</li>\n</ul>\n<p>这里我们需要重点关注加载阶段和交互阶段，因为影响到我们体验的因素主要都在这两个阶段，下面我们就来逐个详细分析下。</p>\n<h2 id="加载阶段"><a href="#%E5%8A%A0%E8%BD%BD%E9%98%B6%E6%AE%B5" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>加载阶段</h2>\n<p>我们先来分析如何系统优化加载阶段中的页面，还是先看一个典型的渲染流水线，如下图所示</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-13-09-21-14-ad68a5cc5c801a3043467e68c88c21e3-0d494.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 50.81967213114754%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAB7klEQVQoz22P7W/SUBTG+9f6L/jN+Gku0Rg1MWSZOux46wvCgi5iYqYTZR2MwQYUSm9774UyIhS6i9D29gVbdJ/05JeTJ885J08Os9lsQt/3ya2/jPHIliXxYodQYv1xtiPLu1vwiRW4DuMF4QzpIJ9ReLaTOVDFFBAPNSGpial2+g0u5oCQ1EW2ye4r3NtB7vWAZ2WOVbIHlnzN2C7Fcmf8XoTvMip/2M8m1bzYKHzCR2KfT6lcupIuXucLuphSBP40W5L5NBBTOJ8mvXacbGJ4U8hgPjkpibDAdl89qLFPEbevZ57B3MMG+6iXTUz4PSzsNLmXWGAnxZzBJUm3xUQ/B45jg76NtOnnj73Ertk4WtQFCjvLVuVq596iknNBw4E9JXF/lH9OsWpriqP2/bnJeJ5nWpY2Xwwscvnt5PjFk5YxvdBGeO3IeFh4vNsFcGhTwwvKe4lquWz4ISJEJ8uF4zD2et0H4EunfVyTzhCsj43TXver3C5Vf3yoSfWb8TmCkq6daaD5cyIhWNWABPXvQEVRchAEUXJzNGxgFHGBUR3Bc107uWpFSECNdA3qdajHWgOXo2FEHSPDWmx/DsMVdf/ixvxynKivKV1RGvfI2bK6I9LU9+PjMAw3/9StZc2mU3M2m5smdd3N/+o3E90AS1dAFl4AAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 13 09 21 14"\n        title=""\n        src="/static/2021-07-13-09-21-14-ad68a5cc5c801a3043467e68c88c21e3-fee1c.png"\n        srcset="/static/2021-07-13-09-21-14-ad68a5cc5c801a3043467e68c88c21e3-a67b7.png 200w,\n/static/2021-07-13-09-21-14-ad68a5cc5c801a3043467e68c88c21e3-0b187.png 400w,\n/static/2021-07-13-09-21-14-ad68a5cc5c801a3043467e68c88c21e3-fee1c.png 800w,\n/static/2021-07-13-09-21-14-ad68a5cc5c801a3043467e68c88c21e3-b1a91.png 1200w,\n/static/2021-07-13-09-21-14-ad68a5cc5c801a3043467e68c88c21e3-0d494.png 1464w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>观察上面这个渲染流水线，你能分析出来有哪些因素影响了页面加载速度吗？下面我们就先来分析下这个问题。</p>\n<p>通过前面文章的讲解，你应该已经知道了并非所有的资源都会阻塞页面的首次绘制，比如图片、音频、视频等文件就不会阻塞页面的首次渲染；而 JavaScript、首次请求的 HTML 资源文件、CSS 文件是会阻塞首次渲染的，因为在构建 DOM 的过程中需要 HTML 和 JavaScript 文件，在构造渲染树的过程中需要用到 CSS 文件。</p>\n<p>我们把这些能阻塞网页首次渲染的资源称为关键资源。基于关键资源，我们可以继续细化出来三个影响页面首次渲染的核心因素。</p>\n<p>第一个是关键资源个数。关键资源个数越多，首次页面的加载时间就会越长。比如上图中的关键资源个数就是 3 个，1 个 HTML 文件、1 个 JavaScript 和 1 个 CSS 文件。</p>\n<p>第二个是关键资源大小。通常情况下，所有关键资源的内容越小，其整个资源的下载时间也就越短，那么阻塞渲染的时间也就越短。上图中关键资源的大小分别是 6KB、8KB 和 9KB，那么整个关键资源大小就是 23KB。</p>\n<p>第三个是请求关键资源需要多少个 RTT（Round Trip Time）。那什么是 RTT 呢？ 在之前中我们分析过，当使用 TCP 协议传输一个文件时，比如这个文件大小是 0.1M，由于 TCP 的特性，这个数据并不是一次传输到服务端的，而是需要拆分成一个个数据包来回多次进行传输的。RTT 就是这里的往返时延。它是网络中一个重要的性能指标，表示从发送端发送数据开始，到发送端收到来自接收端的确认，总共经历的时延。通常 1 个 HTTP 的数据包在 14KB 左右，所以 1 个 0.1M 的页面就需要拆分成 8 个包来传输了，也就是说需要 8 个 RTT</p>\n<p>我们可以结合上图来看看它的关键资源请求需要多少个 RTT。首先是请求 HTML 资源，大小是 6KB，小于 14KB，所以 1 个 RTT 就可以解决了。至于 JavaScript 和 CSS 文件，这里需要注意一点，由于渲染引擎有一个预解析的线程，在接收到 HTML 数据之后，预解析线程会快速扫描 HTML 数据中的关键资源，一旦扫描到了，会立马发起请求，你可以认为 JavaScript 和 CSS 是同时发起请求的，所以它们的请求是重叠的，那么计算它们的 RTT 时，只需要计算体积最大的那个数据就可以了。这里最大的是 CSS 文件（9KB），所以我们就按照 9KB 来计算，同样由于 9KB 小于 14KB，所以 JavaScript 和 CSS 资源也就可以算成 1 个 RTT。也就是说，上图中关键资源请求共花费了 2 个 RTT。</p>\n<p>了解了影响加载过程中的几个核心因素之后，接下来我们就可以系统性地考虑优化方案了。总的优化原则就是减少关键资源个数，降低关键资源大小，降低关键资源的 RTT 次数</p>\n<ul>\n<li>如何减少关键资源的个数？一种方式是可以将 JavaScript 和 CSS 改成内联的形式，比如上图的 JavaScript 和 CSS，若都改成内联模式，那么关键资源的个数就由 3 个减少到了 1 个。另一种方式，如果 JavaScript 代码没有 DOM 或者 CSSOM 的操作，则可以改成 sync 或者 defer 属性；同样对于 CSS，如果不是在构建页面之前加载的，则可以添加媒体取消阻止显现的标志。当 JavaScript 标签加上了 sync 或者 defer、CSSlink 属性之前加上了取消阻止显现的标志后，它们就变成了非关键资源了。</li>\n<li>如何减少关键资源的大小？可以压缩 CSS 和 JavaScript 资源，移除 HTML、CSS、JavaScript 文件中一些注释内容，也可以通过前面讲的取消 CSS 或者 JavaScript 中关键资源的方式。</li>\n<li>如何减少关键资源 RTT 的次数？可以通过减少关键资源的个数和减少关键资源的大小搭配来实现。除此之外，还可以使用 CDN 来减少每次 RTT 时长。</li>\n</ul>\n<p>在优化实际的页面加载速度时，你可以先画出优化之前关键资源的图表，然后按照上面优化关键资源的原则去优化，优化完成之后再画出优化之后的关键资源图表。</p>\n<h2 id="交互阶段"><a href="#%E4%BA%A4%E4%BA%92%E9%98%B6%E6%AE%B5" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>交互阶段</h2>\n<p>接下来我们再来聊聊页面加载完成之后的交互阶段以及应该如何去优化。谈交互阶段的优化，其实就是在谈渲染进程渲染帧的速度，因为在交互阶段，帧的渲染速度决定了交互的流畅度。因此讨论页面优化实际上就是讨论渲染引擎是如何渲染帧的，否则就无法优化帧率。</p>\n<p>我们先来看看交互阶段的渲染流水线（如下图）。和加载阶段的渲染流水线有一些不同的地方是，在交互阶段没有了加载关键资源和构建 DOM、CSSOM 流程，通常是由 JavaScript 触发交互动画的。</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-13-09-22-31-4d3bbcdc4f4fe11835f7807d06189aac-b0aef.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 51.34370579915134%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABtUlEQVQoz3WS307bMBTG8367GKJdKapAXExFaOJiDzCkIXa3gYB2BSZBt3YXCCFtEpNW9Q12t12U0tI27QKxmyZO4r9JS8dxBNKG2Kefj+3Px85xZGM6nY4faqKb1g0Iuv8lGJTSIAyVFJHkKiGSYhwpn7gXzUa71eyb3TiSiX+PErESGGODcw6HUzVx6GTEbgAnjEd07IRjm6hrTyI/cvlU+9qMgWEQEz5xPc/gQqCrwdvaaOb91fzBIHtgpXeaqe3zuZKZ3etn98H5nSmZmVIvd+QsVILFT/582V898XvW0GBcsMDbrJMn2+azQjtV6M5sNZ6++zW7C+NOumimS/1UsTu70577gHIf/VyZZA7Ji2OiN0PZkdLltZC8xOoSy7bNNfh+imRnqFo2b1ohOLDUsoXpKMd1ddmeg49/hGvf6Jsa3fgOsCT+RY2tn3lrp9brr3j9zH31ZbhVdy3bMRjj1qC3W0dLZbzyGS9X0XIVIs5XUb6CdEycfMVe2jtfLPx8fthbKDZeVjqd/rURxzFLRP8BbiM0QgMzMPXfEfJuwAWlzPjzmODlQI4PIiQIAvjAo2m3tpT9oJxzZbcAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 13 09 22 31"\n        title=""\n        src="/static/2021-07-13-09-22-31-4d3bbcdc4f4fe11835f7807d06189aac-fee1c.png"\n        srcset="/static/2021-07-13-09-22-31-4d3bbcdc4f4fe11835f7807d06189aac-a67b7.png 200w,\n/static/2021-07-13-09-22-31-4d3bbcdc4f4fe11835f7807d06189aac-0b187.png 400w,\n/static/2021-07-13-09-22-31-4d3bbcdc4f4fe11835f7807d06189aac-fee1c.png 800w,\n/static/2021-07-13-09-22-31-4d3bbcdc4f4fe11835f7807d06189aac-b1a91.png 1200w,\n/static/2021-07-13-09-22-31-4d3bbcdc4f4fe11835f7807d06189aac-b0aef.png 1414w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>结合上图，我们来一起回顾下交互阶段是如何生成一个帧的。大部分情况下，生成一个新的帧都是由 JavaScript 通过修改 DOM 或者 CSSOM 来触发的。还有另外一部分帧是由 CSS 来触发的。</p>\n<p>如果在计算样式阶段发现有布局信息的修改，那么就会触发重排操作，然后触发后续渲染流水线的一系列操作，这个代价是非常大的。</p>\n<p>同样如果在计算样式阶段没有发现有布局信息的修改，只是修改了颜色一类的信息，那么就不会涉及到布局相关的调整，所以可以跳过布局阶段，直接进入绘制阶段，这个过程叫重绘。不过重绘阶段的代价也是不小的。</p>\n<p>还有另外一种情况，通过 CSS 实现一些变形、渐变、动画等特效，这是由 CSS 触发的，并且是在合成线程上执行的，这个过程称为合成。因为它不会触发重排或者重绘，而且合成操作本身的速度就非常快，所以执行合成是效率最高的方式。</p>\n<p>回顾了在交互过程中的帧是如何生成的，那接下来我们就可以讨论优化方案了。一个大的原则就是让单个帧的生成速度变快。所以，下面我们就来分析下在交互阶段渲染流水线中有哪些因素影响了帧的生成速度以及如何去优化</p>\n<h3 id="减少-javascript-脚本执行时间"><a href="#%E5%87%8F%E5%B0%91-javascript-%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E6%97%B6%E9%97%B4" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>减少 JavaScript 脚本执行时间</h3>\n<p>有时 JavaScript 函数的一次执行时间可能有几百毫秒，这就严重霸占了主线程执行其他渲染任务的时间。针对这种情况我们可以采用以下两种策略</p>\n<ul>\n<li>一种是将一次执行的函数分解为多个任务，使得每次的执行时间不要过久。</li>\n<li>另一种是采用 Web Workers。你可以把 Web Workers 当作主线程之外的一个线程，在 Web Workers 中是可以执行 JavaScript 脚本的，不过 Web Workers 中没有 DOM、CSSOM 环境，这意味着在 Web Workers 中是无法通过 JavaScript 来访问 DOM 的，所以我们可以把一些和 DOM 操作无关且耗时的任务放到 Web Workers 中去执行</li>\n</ul>\n<p>总之，在交互阶段，对 JavaScript 脚本总的原则就是不要一次霸占太久主线程。</p>\n<h3 id="避免强制同步布局"><a href="#%E9%81%BF%E5%85%8D%E5%BC%BA%E5%88%B6%E5%90%8C%E6%AD%A5%E5%B8%83%E5%B1%80" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>避免强制同步布局</h3>\n<p>在介绍强制同步布局之前，我们先来聊聊正常情况下的布局操作。通过 DOM 接口执行添加元素或者删除元素等操作后，是需要重新计算样式和布局的，不过正常情况下这些操作都是在另外的任务中异步完成的，这样做是为了避免当前的任务占用太长的主线程时间。为了直观理解，你可以参考下面的代码：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="86348946771751710000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`<html>\n  <body>\n    <div id=&quot;mian_div&quot;>\n      <li id=&quot;time_li&quot;>time</li>\n      <li>geekbang</li>\n    </div>\n\n    <p id=&quot;demo&quot;>强制布局 demo</p>\n    <button onclick=&quot;foo()&quot;>添加新元素</button>\n\n    <script>\n      function foo() {\n        let main_div = document.getElementById(\'mian_div\');\n        let new_node = document.createElement(\'li\');\n        let textnode = document.createTextNode(\'time.geekbang\');\n        new_node.appendChild(textnode);\n        document.getElementById(\'mian_div\').appendChild(new_node);\n      }\n    </script>\n  </body>\n</html>`, `86348946771751710000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                html 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>mian_div<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>time_li<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>time<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>geekbang<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>demo<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>强制布局 demo<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onclick</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>foo()<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>添加新元素<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>\n\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">\n      <span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">let</span> main_div <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">\'mian_div\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">let</span> new_node <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">\'li\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">let</span> textnode <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createTextNode</span><span class="token punctuation">(</span><span class="token string">\'time.geekbang\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        new_node<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>textnode<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">\'mian_div\'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>new_node<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>对于上面这段代码，我们可以使用 Performance 工具来记录添加元素的过程，如下图所示：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-13-09-25-18-cab02dee06966f47e2be4557132c0d35-b6993.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 32.763157894736835%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAIAAACHqfpvAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABIUlEQVQY032Qy07CQBSGeVB9AJ/DpTvXRiQGN27deIkkNhWjQRsaBKogqFCYMtPOnenMtLaNMZoQv/xnMmfxLc5fyyuyrEzBitl3ZD5iI3W5L7CdQLsgNt9E7ednK3nfSbeacrspvVkhZLvnbOeU7l3zzfLnWw+Go2geRLMAhS+tzrB+FZy0hoPRlGJ46aOLR3D7DJcAL0ECIgyiJFwkccxKeXx3OHk4HrhHfbfhO43ArQfOwap/Bsf3y9mkNyVtD7S70PHimyfk+onbha0O8l9pKWtJU0mVpJxiQmiMEAjnUnCbCq0EVTk3VXTO0u9QnUvz9+aqtkwppbVRaUooo4wxihkljGCt9X+FVa5dr9dSyuIVQnDOixEV2pii0N8p+AKzvYaV0+zbuAAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 13 09 25 18"\n        title=""\n        src="/static/2021-07-13-09-25-18-cab02dee06966f47e2be4557132c0d35-fee1c.png"\n        srcset="/static/2021-07-13-09-25-18-cab02dee06966f47e2be4557132c0d35-a67b7.png 200w,\n/static/2021-07-13-09-25-18-cab02dee06966f47e2be4557132c0d35-0b187.png 400w,\n/static/2021-07-13-09-25-18-cab02dee06966f47e2be4557132c0d35-fee1c.png 800w,\n/static/2021-07-13-09-25-18-cab02dee06966f47e2be4557132c0d35-b1a91.png 1200w,\n/static/2021-07-13-09-25-18-cab02dee06966f47e2be4557132c0d35-b6993.png 1520w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从图中可以看出来，执行 JavaScript 添加元素是在一个任务中执行的，重新计算样式布局是在另外一个任务中执行，这就是正常情况下的布局操作。</p>\n<p>理解了正常情况下的布局操作，接下来我们就可以聊什么是强制同步布局了。</p>\n<p>所谓强制同步布局，是指 JavaScript 强制将计算样式和布局操作提前到当前的任务中。为了直观理解，这里我们对上面的代码做了一点修改，让它变成强制同步布局，修改后的代码如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="37697249749142500000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function foo() {\n  let main_div = document.getElementById(\'mian_div\');\n  let new_node = document.createElement(\'li\');\n  let textnode = document.createTextNode(\'time.geekbang\');\n  new_node.appendChild(textnode);\n  document.getElementById(\'mian_div\').appendChild(new_node);\n  // 由于要获取到 offsetHeight，\n  // 但是此时的 offsetHeight 还是老的数据，\n  // 所以需要立即执行布局操作\n  console.log(main_div.offsetHeight);\n}`, `37697249749142500000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">let</span> main_div <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">\'mian_div\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">let</span> new_node <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">\'li\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">let</span> textnode <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createTextNode</span><span class="token punctuation">(</span><span class="token string">\'time.geekbang\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  new_node<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>textnode<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">\'mian_div\'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>new_node<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token comment">// 由于要获取到 offsetHeight，</span>\n  <span class="token comment">// 但是此时的 offsetHeight 还是老的数据，</span>\n  <span class="token comment">// 所以需要立即执行布局操作</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>main_div<span class="token punctuation">.</span>offsetHeight<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>将新的元素添加到 DOM 之后，我们又调用了 main<em>div.offsetHeight 来获取新 main</em>div 的高度信息。如果要获取到 main<em>div 的高度，就需要重新布局，所以这里在获取到 main</em>div 的高度之前，JavaScript 还需要强制让渲染引擎默认执行一次布局操作。我们把这个操作称为强制同步布局。</p>\n<p>同样，你可以看下面通过 Performance 记录的任务状态：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-13-09-26-01-6c4f4b8648e2991e73dafd1fb04c8e4b-57c91.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 43.45479082321187%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAIAAAC9o5sfAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABO0lEQVQoz52PzU7CQBSF+5gmbvUhjFt9ATcmgjEu/Nm4UBZYIKARokBaLSYQ+VMEhtA2tQMtbenMXC9FBSMrb05Ozpx7v8VIfggBg0kAbvDt/izM5U0XeVH6IWMMAKRCcu8xt18vxtvlw1Y5jmqWYq1SrFlEn+c4PtvRKtoetGsF14vg7ssNaWR79Yz6cKkpKU1NPynpippBR2mzjJ5Cj4Jce7513BETyArJ5zAVgN4fjqpNXXegrNpJmdzlzcZrIGeG2bz7ZkDfhq4F3Q8gNn5NhBEtCcFRgA4cIPSm/EIZn9zTZMVJaJNazwPOhMDTZX2N9JNEVL5bbP3Y3jilm2d07cg+VzwsGV+F/oUHlG8nxruys3PtbF2N5aqPJV8mVsL/mF8w55wQ0ul0BoQYhm5ZlmmahmFQSlfCn9g/7n0rpEtxAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 13 09 26 01"\n        title=""\n        src="/static/2021-07-13-09-26-01-6c4f4b8648e2991e73dafd1fb04c8e4b-fee1c.png"\n        srcset="/static/2021-07-13-09-26-01-6c4f4b8648e2991e73dafd1fb04c8e4b-a67b7.png 200w,\n/static/2021-07-13-09-26-01-6c4f4b8648e2991e73dafd1fb04c8e4b-0b187.png 400w,\n/static/2021-07-13-09-26-01-6c4f4b8648e2991e73dafd1fb04c8e4b-fee1c.png 800w,\n/static/2021-07-13-09-26-01-6c4f4b8648e2991e73dafd1fb04c8e4b-b1a91.png 1200w,\n/static/2021-07-13-09-26-01-6c4f4b8648e2991e73dafd1fb04c8e4b-57c91.png 1482w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从上图可以看出来，计算样式和布局都是在当前脚本执行过程中触发的，这就是强制同步布局。</p>\n<p>为了避免强制同步布局，我们可以调整策略，在修改 DOM 之前查询相关值。代码如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="45073810774871710000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function foo() {\n  let main_div = document.getElementById(\'mian_div\');\n  // 为了避免强制同步布局，在修改 DOM 之前查询相关值\n  console.log(main_div.offsetHeight);\n  let new_node = document.createElement(\'li\');\n  let textnode = document.createTextNode(\'time.geekbang\');\n  new_node.appendChild(textnode);\n  document.getElementById(\'mian_div\').appendChild(new_node);\n}`, `45073810774871710000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">let</span> main_div <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">\'mian_div\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token comment">// 为了避免强制同步布局，在修改 DOM 之前查询相关值</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>main_div<span class="token punctuation">.</span>offsetHeight<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">let</span> new_node <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">\'li\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">let</span> textnode <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createTextNode</span><span class="token punctuation">(</span><span class="token string">\'time.geekbang\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  new_node<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>textnode<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">\'mian_div\'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>new_node<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h3 id="避免布局抖动"><a href="#%E9%81%BF%E5%85%8D%E5%B8%83%E5%B1%80%E6%8A%96%E5%8A%A8" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>避免布局抖动</h3>\n<p>还有一种比强制同步布局更坏的情况，那就是布局抖动。所谓布局抖动，是指在一次 JavaScript 执行过程中，多次执行强制布局和抖动操作。为了直观理解，你可以看下面的代码：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="21298716969834607000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function foo() {\n  let time_li = document.getElementById(\'time_li\');\n  for (let i = 0; i < 100; i++) {\n    let main_div = document.getElementById(\'mian_div\');\n    let new_node = document.createElement(\'li\');\n    let textnode = document.createTextNode(\'time.geekbang\');\n    new_node.appendChild(textnode);\n    new_node.offsetHeight = time_li.offsetHeight;\n    document.getElementById(\'mian_div\').appendChild(new_node);\n  }\n}`, `21298716969834607000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">let</span> time_li <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">\'time_li\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">let</span> main_div <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">\'mian_div\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">let</span> new_node <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">\'li\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">let</span> textnode <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createTextNode</span><span class="token punctuation">(</span><span class="token string">\'time.geekbang\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    new_node<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>textnode<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    new_node<span class="token punctuation">.</span>offsetHeight <span class="token operator">=</span> time_li<span class="token punctuation">.</span>offsetHeight<span class="token punctuation">;</span>\n    document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">\'mian_div\'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>new_node<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>我们在一个 for 循环语句里面不断读取属性值，每次读取属性值之前都要进行计算样式和布局。执行代码之后，使用 Performance 记录的状态如下所示</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-13-09-30-08-78f6365a27f9266e2c021f1cc62b44e1-9ea27.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 42.68456375838927%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAIAAAC9o5sfAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABN0lEQVQoz5VRy06DUBTkL93p7+hKF+5MShN1U+2DisUWo4AELlAwMaUPLU00MalieaRAixTwUI0l1sQ4mdzMnTNz7uJivu/Pgn8DWosowoTWflc8GN0WDa1oqAVDw0cgNHzJAujsqubMTONDteC5Y4xpXomsLHES4hDiFOlGQayIOElk24iTwRRYUWAVgYEpUnhJ5mUYKXzbm3pYt0IO6tRdiQD2qlS/TqnH5U6ZHFGXj+fUoFIzqsRzszms1PQTQj8969ca9yTdJyh/YmFphiT9wrdIwygmO7OSNm/1wovuvKGHphdniWQVw9I1LMepOY03cAe4deRuHroglKd38OPV/l/Ly9OdJTu0v037e0ywex2AeHhd/FFOcoBkjsn6Mz/LYRjatu1+wnFsy5qYby/jMXztevkD9HPgqZLkbf8AAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 13 09 30 08"\n        title=""\n        src="/static/2021-07-13-09-30-08-78f6365a27f9266e2c021f1cc62b44e1-fee1c.png"\n        srcset="/static/2021-07-13-09-30-08-78f6365a27f9266e2c021f1cc62b44e1-a67b7.png 200w,\n/static/2021-07-13-09-30-08-78f6365a27f9266e2c021f1cc62b44e1-0b187.png 400w,\n/static/2021-07-13-09-30-08-78f6365a27f9266e2c021f1cc62b44e1-fee1c.png 800w,\n/static/2021-07-13-09-30-08-78f6365a27f9266e2c021f1cc62b44e1-b1a91.png 1200w,\n/static/2021-07-13-09-30-08-78f6365a27f9266e2c021f1cc62b44e1-9ea27.png 1490w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从上图可以看出，在 foo 函数内部重复执行计算样式和布局，这会大大影响当前函数的执行效率。这种情况的避免方式和强制同步布局一样，都是尽量不要在修改 DOM 结构时再去查询一些相关值。</p>\n<h3 id="合理利用-css-合成动画"><a href="#%E5%90%88%E7%90%86%E5%88%A9%E7%94%A8-css-%E5%90%88%E6%88%90%E5%8A%A8%E7%94%BB" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>合理利用 CSS 合成动画</h3>\n<p>合成动画是直接在合成线程上执行的，这和在主线程上执行的布局、绘制等操作不同，如果主线程被 JavaScript 或者一些布局任务占用，CSS 动画依然能继续执行。所以要尽量利用好 CSS 合成动画，如果能让 CSS 处理动画，就尽量交给 CSS 来操作。</p>\n<p>另外，如果能提前知道对某个元素执行动画操作，那就最好将其标记为 will-change，这是告诉渲染引擎需要将该元素单独生成一个图层。</p>\n<h3 id="避免频繁的垃圾回收"><a href="#%E9%81%BF%E5%85%8D%E9%A2%91%E7%B9%81%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>避免频繁的垃圾回收</h3>\n<p>我们知道 JavaScript 使用了自动垃圾回收机制，如果在一些函数中频繁创建临时对象，那么垃圾回收器也会频繁地去执行垃圾回收策略。这样当垃圾回收操作发生时，就会占用主线程，从而影响到其他任务的执行，严重的话还会让用户产生掉帧、不流畅的感觉。</p>\n<p>所以要尽量避免产生那些临时垃圾数据。那该怎么做呢？可以尽可能优化储存结构，尽可能避免小颗粒对象的产生。</p>\n<h2 id="总结-4"><a href="#%E6%80%BB%E7%BB%93-4" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总结</h2>\n<p>我们主要讲解了如何系统优化加载阶段和交互阶段的页面。</p>\n<p>在加载阶段，核心的优化原则是：优化关键资源的加载速度，减少关键资源的个数，降低关键资源的 RTT 次数。</p>\n<p>在交互阶段，核心的优化原则是：尽量减少一帧的生成时间。可以通过减少单次 JavaScript 的执行时间、避免强制同步布局、避免布局抖动、尽量采用 CSS 的合成动画、避免频繁的垃圾回收等方式来减少一帧生成的时长。</p>\n<h1 id="虚拟-dom：虚拟-dom-和实际-dom-有何不同"><a href="#%E8%99%9A%E6%8B%9F-dom%EF%BC%9A%E8%99%9A%E6%8B%9F-dom-%E5%92%8C%E5%AE%9E%E9%99%85-dom-%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>虚拟 DOM：虚拟 DOM 和实际 DOM 有何不同</h1>\n<p>虚拟 DOM 是最近非常火的技术，两大著名前端框架 React 和 Vue 都使用了虚拟 DOM，所以我觉得非常有必要结合浏览器的工作机制对虚拟 DOM 进行一次分析。当然了，React 和 Vue 框架本身所蕴含的知识点非常多，而且也不是我们专栏的重点，所以在这里我们还是把重心聚焦在虚拟 DOM 上。</p>\n<p>在本文我们会先聊聊 DOM 的一些缺陷，然后在此基础上介绍虚拟 DOM 是如何解决这些缺陷的，最后再站在双缓存和 MVC 的视角来聊聊虚拟 DOM。理解了这些会让你对目前的前端框架有一个更加底层的认识，这也有助于你更好地理解这些前端框架。</p>\n<h2 id="dom-的缺陷"><a href="#dom-%E7%9A%84%E7%BC%BA%E9%99%B7" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>DOM 的缺陷</h2>\n<p>通过前面一系列文章的学习，你对 DOM 的生成过程应该已经有了比较深刻的理解，并且也知道了通过 JavaScript 操纵 DOM 是会影响到整个渲染流水线的。另外，DOM 还提供了一组 JavaScript 接口用来遍历或者修改节点，这套接口包含了 getElementById、removeChild、appendChild 等方法。</p>\n<p>比如，我们可以调用 document.body.appendChild(node)往 body 节点上添加一个元素，调用该 API 之后会引发一系列的连锁反应。首先渲染引擎会将 node 节点添加到 body 节点之上，然后触发样式计算、布局、绘制、栅格化、合成等任务，我们把这一过程称为重排。除了重排之外，还有可能引起重绘或者合成操作，形象地理解就是“牵一发而动全身”。另外，对于 DOM 的不当操作还有可能引发强制同步布局和布局抖动的问题，这些操作都会大大降低渲染效率。因此，对于 DOM 的操作我们时刻都需要非常小心谨慎。</p>\n<p>当然，对于简单的页面来说，其 DOM 结构还是比较简单的，所以以上这些操作 DOM 的问题并不会对用户体验产生太多影响。但是对于一些复杂的页面或者目前使用非常多的单页应用来说，其 DOM 结构是非常复杂的，而且还需要不断地去修改 DOM 树，每次操作 DOM 渲染引擎都需要进行重排、重绘或者合成等操作，因为 DOM 结构复杂，所生成的页面结构也会很复杂，对于这些复杂的页面，执行一次重排或者重绘操作都是非常耗时的，这就给我们带来了真正的性能问题。</p>\n<p>所以我们需要有一种方式来减少 JavaScript 对 DOM 的操作，这时候虚拟 DOM 就上场了</p>\n<h2 id="什么是虚拟-dom"><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%99%9A%E6%8B%9F-dom" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>什么是虚拟 DOM</h2>\n<p>在谈论什么是虚拟 DOM 之前，我们先来看看虚拟 DOM 到底要解决哪些事情。</p>\n<ul>\n<li>将页面改变的内容应用到虚拟 DOM 上，而不是直接应用到 DOM 上。</li>\n<li>变化被应用到虚拟 DOM 上时，虚拟 DOM 并不急着去渲染页面，而仅仅是调整虚拟 DOM 的内部状态，这样操作虚拟 DOM 的代价就变得非常轻了。</li>\n<li>在虚拟 DOM 收集到足够的改变时，再把这些变化一次性应用到真实的 DOM 上。</li>\n</ul>\n<p>基于以上三点，我们再来看看什么是虚拟 DOM。为了直观理解，你可以参考下图：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-13-09-32-19-c94f25db6854093a879f5e720abac50f-5fd75.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 39.56043956043956%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAIAAAB2/0i6AAAACXBIWXMAAA7DAAAOwwHHb6hkAAAA+klEQVQY03VQgW6FIAzk///Q5OUtcXn6BEUFBQoUduqybIm7ENJC766tKKXknLWeIhECpPVESIX5O75QkuecGK+gcMWnoBid91KNRAjjsizWWu/2ZoirSwjWdd026wMl1Zh56Pv+pcxn9x5XElZPz8fz4yUXJcNmIQT/FKNUkxonf6ZwCyEM7w4qaMERj5a2wALNUfAhePIeHODosNacEmjOOe9cZZZSGmN+hrogkEMYnMyHA6ovK3jie3NO9Z15NBip/mKW8wjU7fvetu08z6CZE5DQWuPGIqBdOdc7iEPmxJ/FloK1YVWQrv9D3L6mlK6141ZKIb0t+wK5VdKbD9gyNQAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 13 09 32 19"\n        title=""\n        src="/static/2021-07-13-09-32-19-c94f25db6854093a879f5e720abac50f-fee1c.png"\n        srcset="/static/2021-07-13-09-32-19-c94f25db6854093a879f5e720abac50f-a67b7.png 200w,\n/static/2021-07-13-09-32-19-c94f25db6854093a879f5e720abac50f-0b187.png 400w,\n/static/2021-07-13-09-32-19-c94f25db6854093a879f5e720abac50f-fee1c.png 800w,\n/static/2021-07-13-09-32-19-c94f25db6854093a879f5e720abac50f-b1a91.png 1200w,\n/static/2021-07-13-09-32-19-c94f25db6854093a879f5e720abac50f-5fd75.png 1456w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>该图是我结合 React 流程画的一张虚拟 DOM 执行流程图，下面我们就结合这张图来分析下虚拟 DOM 到底怎么运行的。</p>\n<ul>\n<li>创建阶段。首先依据 JSX 和基础数据创建出来虚拟 DOM，它反映了真实的 DOM 树的结构。然后由虚拟 DOM 树创建出真实 DOM 树，真实的 DOM 树生成完后，再触发渲染流水线往屏幕输出页面。</li>\n<li>更新阶段。如果数据发生了改变，那么就需要根据新的数据创建一个新的虚拟 DOM 树；然后 React 比较两个树，找出变化的地方，并把变化的地方一次性更新到真实的 DOM 树上；最后渲染引擎更新渲染流水线，并生成新的页面</li>\n</ul>\n<p>既然聊到虚拟 DOM 的更新，那我们就不得不聊聊最新的 React Fiber 更新机制。通过上图我们知道，当有数据更新时，React 会生成一个新的虚拟 DOM，然后拿新的虚拟 DOM 和之前的虚拟 DOM 进行比较，这个过程会找出变化的节点，然后再将变化的节点应用到 DOM 上。</p>\n<p>这里我们重点关注下比较过程，最开始的时候，比较两个虚拟 DOM 的过程是在一个递归函数里执行的，其核心算法是 reconciliation。通常情况下，这个比较过程执行得很快，不过当虚拟 DOM 比较复杂的时候，执行比较函数就有可能占据主线程比较久的时间，这样就会导致其他任务的等待，造成页面卡顿。为了解决这个问题，React 团队重写了 reconciliation 算法，新的算法称为 Fiber reconciler，之前老的算法称为 Stack reconciler。</p>\n<p>在前面我们介绍了协程，其实协程的另外一个称呼就是 Fiber，所以在这里我们可以把 Fiber 和协程关联起来，那么所谓的 Fiber reconciler 相信你也很清楚了，就是在执行算法的过程中出让主线程，这样就解决了 Stack reconciler 函数占用时间过久的问题。至于具体的实现过程在这里我就不详细分析了，如果感兴趣的话，你可以自行查阅相关资料进行学习。</p>\n<p>了解完虚拟 DOM 的大致执行流程，你应该也就知道为何需要虚拟 DOM 了。不过以上都从单纯的技术视角来分析虚拟 DOM 的，那接下来我们再从双缓存和 MVC 模型这两个视角来聊聊虚拟 DOM。</p>\n<h3 id="双缓存"><a href="#%E5%8F%8C%E7%BC%93%E5%AD%98" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>双缓存</h3>\n<p>在开发游戏或者处理其他图像的过程中，屏幕从前缓冲区读取数据然后显示。但是很多图形操作都很复杂且需要大量的运算，比如一幅完整的画面，可能需要计算多次才能完成，如果每次计算完一部分图像，就将其写入缓冲区，那么就会造成一个后果，那就是在显示一个稍微复杂点的图像的过程中，你看到的页面效果可能是一部分一部分地显示出来，因此在刷新页面的过程中，会让用户感受到界面的闪烁。</p>\n<p>而使用双缓存，可以让你先将计算的中间结果存放在另一个缓冲区中，等全部的计算结束，该缓冲区已经存储了完整的图形之后，再将该缓冲区的图形数据一次性复制到显示缓冲区，这样就使得整个图像的输出非常稳定。</p>\n<p>在这里，你可以把虚拟 DOM 看成是 DOM 的一个 buffer，和图形显示一样，它会在完成一次完整的操作之后，再把结果应用到 DOM 上，这样就能减少一些不必要的更新，同时还能保证 DOM 的稳定输出。</p>\n<h3 id="mvc-模式"><a href="#mvc-%E6%A8%A1%E5%BC%8F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>MVC 模式</h3>\n<p>到这里我们了解了虚拟 DOM 是一种类似双缓存的实现。不过如果站在技术角度来理解虚拟缓存，依然不能全面理解其含义。那么接下来我们再来看看虚拟 DOM 在 MVC 模式中所扮演的角色。</p>\n<p>在各大设计模式当中，MVC 是一个非常重要且应用广泛的模式，因为它能将数据和视图进行分离，在涉及到一些复杂的项目时，能够大大减轻项目的耦合度，使得程序易于维护。</p>\n<p>关于 MVC 的基础结构，你可以先参考下图：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-13-09-33-49-994da06d1189b0fa8a858d692fe207cf-4a0d2.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 92.54032258064515%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAATCAIAAAAf7rriAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACfklEQVQ4y6VUWU8TURTu7zLxxUTtgwuLMXF9wAQNRBNJjOiDgUQNJpJIgkAohQhIgIKVRSBsNjURXNgCNtBSKLWddrrMcmfp7Z07t96ZQlNahBhPbk4yZ873nXO+e2Ysmf8wy9FholOn+t2JqTqN28tF/gHMzTcG35xSvfNGRMcngomRBoGW3NWEsLr7VVy0p6MejQ/S+gSnjwMTk17+NRFqPRu2l7GO6pizhnVUhW2XmK5ylNwp6P9I8Hio+QxjL4v0VUT777ADlWHbRaajBCX8J4OlNWew6TTTeYXpLGfspZHu6+E2a6jNihI7BcNbinWiFZLTL6S1YWljTPZMSusj8sZ4cvr5geykAGzqlJYTU/W8u5kKBpk1LLHZPKKl9ZSIQQTFvTSSCixilc+yWHJkVN5w+4VI9zUYWkZxHwas2SQye9nGUgyDqLDQTi+Pm2nItmnJvySN/50KfKNtp9nNXNAk12FohSBVXh+Jj9XS5cmrnDMMCefHMQ/RlMKtgSKKbhCkYC5waGYVESmlizDDiUrMv5zYWVXJIWF0apmMElwCgaWUqiCoYpLBuglucim3esQHw+DpuFLjlG73CK9m9yvrJsPPoPboo/xkBLyc5Bpd8NknmT6+nlMMcMOMUmIT7g6A2lGp2gFKO4S6CXl/DnMjPnvRZZtwtUusHpIffgA3uwHNvz8kGeD6SfncW/7GO7FqkL4QrS3841EpHzy3lT7fwpfbhYo+8d4AqHgvWlv5yn5ggF0+1PsdDi7DoVXoWIG9P+DsJjrQ2fARUZ/dQjTNvY2++A0/50ULAc1yzLdO8jT768+AqlJ82GiUZVmfz+fxePb2goa8RecPNnsH8xEeRBgAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 13 09 33 49"\n        title=""\n        src="/static/2021-07-13-09-33-49-994da06d1189b0fa8a858d692fe207cf-fee1c.png"\n        srcset="/static/2021-07-13-09-33-49-994da06d1189b0fa8a858d692fe207cf-a67b7.png 200w,\n/static/2021-07-13-09-33-49-994da06d1189b0fa8a858d692fe207cf-0b187.png 400w,\n/static/2021-07-13-09-33-49-994da06d1189b0fa8a858d692fe207cf-fee1c.png 800w,\n/static/2021-07-13-09-33-49-994da06d1189b0fa8a858d692fe207cf-4a0d2.png 992w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>通过上图你可以发现，MVC 的整体结构比较简单，由模型、视图和控制器组成，其核心思想就是将数据和视图分离，也就是说视图和模型之间是不允许直接通信的，它们之间的通信都是通过控制器来完成的。通常情况下的通信路径是视图发生了改变，然后通知控制器，控制器再根据情况判断是否需要更新模型数据。当然还可以根据不同的通信路径和控制器不同的实现方式，基于 MVC 又能衍生出很多其他的模式，如 MVP、MVVM 等，不过万变不离其宗，它们的基础骨架都是基于 MVC 而来。</p>\n<p>所以在分析基于 React 或者 Vue 这些前端框架时，我们需要先重点把握大的 MVC 骨架结构，然后再重点查看通信方式和控制器的具体实现方式，这样我们就能从架构的视角来理解这些前端框架了。比如在分析 React 项目时，我们可以把 React 的部分看成是一个 MVC 中的视图，在项目中结合 Redux 就可以构建一个 MVC 的模型结构，如下图所示：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-13-09-34-07-84ff3dbb02e1fa28f5af094d47ff1f46-71011.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 46.21513944223108%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAIAAAC9o5sfAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABKElEQVQoz2VRy06FMBDly03c3+XdufQTTDQxxrgwuQvd6A1bH4kKFChtp7SlLxyKGsCTdvqY95lsTIgJIcF7bxOmi3Mo//7HNTLcwzAopYwxWikAiatpJ0gJggsppdYabTjnGHHrbANmXoVEU6Mk2PGLBbyEpJ6KcW7lrN8O5PKE3e+h+ZC0uHiG3a1+fO1L2jNQJWlIXfc1IUUJ1UtPi6puKwolBUyZDWXeHc7Yw3m0aoz++tjt70ReBKaiHqxW/WCdZTRaFKRrCZJAwdRcuTCX7TxnNNGGDRg856qwVUopUjU/Q4hh3V4Wp3c4vovTK9jdiFb6ZDexgCwKIULYUhJ/w2fzwXR8+nR54Y37UcWFQ9zwuWR7CRwmjgTHgxLTdl3HEwDgv/M3h5wHJLDlsssAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 13 09 34 07"\n        title=""\n        src="/static/2021-07-13-09-34-07-84ff3dbb02e1fa28f5af094d47ff1f46-fee1c.png"\n        srcset="/static/2021-07-13-09-34-07-84ff3dbb02e1fa28f5af094d47ff1f46-a67b7.png 200w,\n/static/2021-07-13-09-34-07-84ff3dbb02e1fa28f5af094d47ff1f46-0b187.png 400w,\n/static/2021-07-13-09-34-07-84ff3dbb02e1fa28f5af094d47ff1f46-fee1c.png 800w,\n/static/2021-07-13-09-34-07-84ff3dbb02e1fa28f5af094d47ff1f46-b1a91.png 1200w,\n/static/2021-07-13-09-34-07-84ff3dbb02e1fa28f5af094d47ff1f46-71011.png 1506w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>在该图中，我们可以把虚拟 DOM 看成是 MVC 的视图部分，其控制器和模型都是由 Redux 提供的。其具体实现过程如下：</p>\n<ul>\n<li>图中的控制器是用来监控 DOM 的变化，一旦 DOM 发生变化，控制器便会通知模型，让其更新数据；</li>\n<li>模型数据更新好之后，控制器会通知视图，告诉它模型的数据发生了变化；</li>\n<li>视图接收到更新消息之后，会根据模型所提供的数据来生成新的虚拟 DOM；</li>\n<li>新的虚拟 DOM 生成好之后，就需要与之前的虚拟 DOM 进行比较，找出变化的节点；</li>\n<li>比较出变化的节点之后，React 将变化的虚拟节点应用到 DOM 上，这样就会触发 DOM 节点的更新；</li>\n<li>DOM 节点的变化又会触发后续一系列渲染流水线的变化，从而实现页面的更新</li>\n</ul>\n<p>在实际工程项目中，你需要学会分析出这各个模块，并梳理出它们之间的通信关系，这样对于任何框架你都能轻松上手了。</p>\n<h2 id="总结-5"><a href="#%E6%80%BB%E7%BB%93-5" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总结</h2>\n<p>首先我们分析了直接操作 DOM 会触发渲染流水线的一系列反应，如果对 DOM 操作不当的话甚至还会触发强制同步布局和布局抖动的问题，这也是我们在操作 DOM 时需要非常小心谨慎的原因。</p>\n<p>在此分析的基础上，我们介绍了虚拟 DOM 是怎么解决直接操作 DOM 所带来的问题以及 React Fiber 更新机制。</p>\n<p>要聊前端框架，就绕不开设计模式，所以接下来我们又从双缓存和 MVC 角度分析了虚拟 DOM。双缓存是一种经典的思路，应用在很多场合，能解决页面无效刷新和闪屏的问题，虚拟 DOM 就是双缓存思想的一种体现。而基于 MVC 的设计思想也广泛地渗透到各种场合，并且基于 MVC 又衍生出了很多其他模式（如 MVP、MVVM 等），不过万变不离其宗，它们的基础骨架都是基于 MVC 而来。站在 MVC 视角来理解虚拟 DOM 能让你看到更为“广阔的世界”。</p>\n<h1 id="pwa：解决了-web-应用哪些问题"><a href="#pwa%EF%BC%9A%E8%A7%A3%E5%86%B3%E4%BA%86-web-%E5%BA%94%E7%94%A8%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>PWA：解决了 web 应用哪些问题</h1>\n<p>PWA，全称是 Progressive Web App，翻译过来就是渐进式网页应用。根据字面意思，它就是“渐进式 +Web 应用”。对于 Web 应用很好理解了，就是目前我们普通的 Web 页面，所以 PWA 所支持的首先是一个 Web 页面。至于“渐进式”，就需要从下面两个方面来理解。</p>\n<ul>\n<li>站在 Web 应用开发者来说，PWA 提供了一个渐进式的过渡方案，让普通站点逐步过渡到 Web 应用。采取渐进式可以降低站点改造的代价，使得站点逐步支持各项新技术，而不是一步到位。</li>\n<li>站在技术角度来说，PWA 技术也是一个渐进式的演化过程，在技术层面会一点点演进，比如逐渐提供更好的设备特性支持，不断优化更加流畅的动画效果，不断让页面的加载速度变得更快，不断实现本地应用的特性。</li>\n</ul>\n<p>从这两点可以看出来，PWA 采取的是非常一个缓和的渐进式策略，不再像以前那样激进，动不动就是取代本地 App、取代小程序。与之相反，而是要充分发挥 Web 的优势，渐进式地缩短和本地应用或者小程序的距离。</p>\n<p>那么 Web 最大的优势是什么呢？我认为是自由开放，也正是因为自由和开放，所以大家就很容易对同一件事情达成共识，达成共识之后，一套代码就可以运行在各种设备之上了，这就是跨平台，这也恰恰是本地应用所不具备的。而对于小程序，倒是可以实现跨平台，但要让各家达成共识，目前来看，似乎还是非常不切实际的。</p>\n<p>所以我给 PWA 的定义就是：它是一套理念，渐进式增强 Web 的优势，并通过技术手段渐进式缩短和本地应用或者小程序的距离。基于这套理念之下的技术都可以归类到 PWA。</p>\n<p>那今天我们就主要来聊聊 PWA 主要采用了哪些技术手段来缩短它和本地应用或者小程序的距离。</p>\n<h2 id="web-应用-vs-本地应用"><a href="#web-%E5%BA%94%E7%94%A8-vs-%E6%9C%AC%E5%9C%B0%E5%BA%94%E7%94%A8" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Web 应用 VS 本地应用</h2>\n<p>那相对于本地应用，Web 页面到底缺少了什么？</p>\n<ul>\n<li>首先，Web 应用缺少离线使用能力，在离线或者在弱网环境下基本上是无法使用的。而用户需要的是沉浸式的体验，在离线或者弱网环境下能够流畅地使用是用户对一个应用的基本要求。</li>\n<li>其次，Web 应用还缺少了消息推送的能力，因为作为一个 App 厂商，需要有将消息送达到应用的能力。</li>\n<li>最后，Web 应用缺少一级入口，也就是将 Web 应用安装到桌面，在需要的时候直接从桌面打开 Web 应用，而不是每次都需要通过浏览器来打开。</li>\n</ul>\n<p>针对以上 Web 缺陷，PWA 提出了两种解决方案：通过引入 Service Worker 来试着解决离线存储和消息推送的问题，通过引入 manifest.json 来解决一级入口的问题。下面我们就来详细分析下 Service Worker 是如何工作的。</p>\n<h2 id="什么是-service-worker"><a href="#%E4%BB%80%E4%B9%88%E6%98%AF-service-worker" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>什么是 Service Worker</h2>\n<p>我们先来看看 Service Worker 是怎么解决离线存储和消息推送的问题。</p>\n<p>其实在 Service Worker 之前，WHATWG 小组就推出过用 App Cache 标准来缓存页面，不过在使用过程中 App Cache 所暴露的问题比较多，遭到多方吐槽，所以这个标准最终也只能被废弃了，可见一个成功的标准是需要经历实践考量的。</p>\n<p>所以在 2014 年的时候，标准委员会就提出了 Service Worker 的概念，它的主要思想是在页面和网络之间增加一个拦截器，用来缓存和拦截请求。整体结构如下图所示：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-13-11-14-17-3ba65eaf5c941f0854e96faf4d728664-0ac43.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 54.418604651162795%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABLElEQVQoz5VSO0/DMBDOX2RDrGXgsbKysDIjwUArkQF+AhsSEoJKFQKhTqAuSUrTJsSpE7/P4ZJAU0oVxCfr9Nl3n30PO2CLfy1bNHCKdli7wkn/1u+dgFKNGM/tF1aVtvKVxBi048vz4e4m5HkjNlBoXLYkCwBn8c21nARlAGfAOVoyDWejNyllKa6fOrtjnYvJtjvt3edWC84YHgfu6Utn4/XowGplpaiz0ADVG9CIuw9sx/X33LHbz5TIM0rR+X7VHe5vjY4PrdZS6+8qyrb90TAM0CwnzwORxLil8zmlVAruJebJV7q6wPkRv+gQFmkMSdPMQJKmuuqtMSAF8z7Mo7dGvA5Y29KNaKNoFkeRFKI17V9ohtf+SYQQSYL5poQQJGEYBkFQj2cZn2b1eJdya/rrAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 13 11 14 17"\n        title=""\n        src="/static/2021-07-13-11-14-17-3ba65eaf5c941f0854e96faf4d728664-fee1c.png"\n        srcset="/static/2021-07-13-11-14-17-3ba65eaf5c941f0854e96faf4d728664-a67b7.png 200w,\n/static/2021-07-13-11-14-17-3ba65eaf5c941f0854e96faf4d728664-0b187.png 400w,\n/static/2021-07-13-11-14-17-3ba65eaf5c941f0854e96faf4d728664-fee1c.png 800w,\n/static/2021-07-13-11-14-17-3ba65eaf5c941f0854e96faf4d728664-b1a91.png 1200w,\n/static/2021-07-13-11-14-17-3ba65eaf5c941f0854e96faf4d728664-0ac43.png 1290w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>在没有安装 Service Worker 之前，WebApp 都是直接通过网络模块来请求资源的。安装了 Service Worker 模块之后，WebApp 请求资源时，会先通过 Service Worker，让它判断是返回 Service Worker 缓存的资源还是重新去网络请求资源。一切的控制权都交由 Service Worker 来处理。</p>\n<h2 id="service-worker-的设计思路"><a href="#service-worker-%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Service Worker 的设计思路</h2>\n<p>现在我们知道 Service Worker 的主要功能就是拦截请求和缓存资源，接下来我们就从 Web 应用的需求角度来看看 Service Worker 的设计思路。</p>\n<h3 id="架构"><a href="#%E6%9E%B6%E6%9E%84" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>架构</h3>\n<p>通过前面页面循环系统的分析，我们已经知道了 JavaScript 和页面渲染流水线的任务都是在页面主线程上执行的，如果一段 JavaScript 执行时间过久，那么就会阻塞主线程，使得渲染一帧的时间变长，从而让用户产生卡顿的感觉，这对用户来说体验是非常不好的。</p>\n<p>为了避免 JavaScript 过多占用页面主线程时长的情况，浏览器实现了 Web Worker 的功能。Web Worker 的目的是让 JavaScript 能够运行在页面主线程之外，不过由于 Web Worker 中是没有当前页面的 DOM 环境的，所以在 Web Worker 中只能执行一些和 DOM 无关的 JavaScript 脚本，并通过 postMessage 方法将执行的结果返回给主线程。所以说在 Chrome 中， Web Worker 其实就是在渲染进程中开启的一个新线程，它的生命周期是和页面关联的。</p>\n<p>“让其运行在主线程之外”就是 Service Worker 来自 Web Worker 的一个核心思想。不过 Web Worker 是临时的，每次 JavaScript 脚本执行完成之后都会退出，执行结果也不能保存下来，如果下次还有同样的操作，就还得重新来一遍。所以 Service Worker 需要在 Web Worker 的基础之上加上储存功能。</p>\n<p>另外，由于 Service Worker 还需要会为多个页面提供服务，所以还不能把 Service Worker 和单个页面绑定起来。在目前的 Chrome 架构中，Service Worker 是运行在浏览器进程中的，因为浏览器进程生命周期是最长的，所以在浏览器的生命周期内，能够为所有的页面提供服务。</p>\n<h3 id="消息推送"><a href="#%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>消息推送</h3>\n<p>消息推送也是基于 Service Worker 来实现的。因为消息推送时，浏览器页面也许并没有启动，这时就需要 Service Worker 来接收服务器推送的消息，并将消息通过一定方式展示给用户。关于消息推送的细节这里我们就不详述了，如果你感兴趣的话可以自行搜索相关资料去学习。</p>\n<h3 id="安全"><a href="#%E5%AE%89%E5%85%A8" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>安全</h3>\n<p>基于 Web 应用的业务越来越多了，其安全问题是不可忽视的，所以在设计 Service Worker 之初，安全问题就被提上了日程。</p>\n<p>关于安全，其中最为核心的一条就是 HTTP。我们知道，HTTP 采用的是明文传输信息，存在被窃听、被篡改和被劫持的风险，在项目中使用 HTTP 来传输数据无疑是“裸奔”。所以在设计之初，就考虑对 Service Worker 采用 HTTPS 协议，因为采用 HTTPS 的通信数据都是经过加密的，即便拦截了数据，也无法破解数据内容，而且 HTTPS 还有校验机制，通信双方很容易知道数据是否被篡改。关于 HTTPS 协议，我们会在最后的安全模块详细介绍。</p>\n<p>所以要使站点支持 Service Worker，首先必要的一步就是要将站点升级到 HTTPS。</p>\n<p>除了必须要使用 HTTPS，Service Worker 还需要同时支持 Web 页面默认的安全策略、储入同源策略、内容安全策略（CSP）等，关于这些，后续我们也会详细介绍。</p>\n<h2 id="总结-6"><a href="#%E6%80%BB%E7%BB%93-6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总结</h2>\n<p>我们先分析了 PWA，它是由很多技术组成的一个理念，其核心思想是渐进式。对于开发者，它提供了非常温和的方式，让开发者将普通的站点逐步过渡到 Web 应用。对于技术本身而言，它是渐进式演进，逐渐将 Web 技术发挥到极致的同时，也逐渐缩小和本地应用的差距。在此基础上，我们又分析了 PWA 中的 Service Worker 的设计思路。</p>\n<p>另外，PWA 还提供了 manifest.json 配置文件，可以让开发者自定义桌面的图标、显示名称、启动方式等信息，还可以设置启动画面、页面主题颜色等信息。关于 manifest.json 的配置还是比较简单的，详细使用教程网上有很多，这里我就不做介绍了。</p>\n<p>添加桌面标、增加离线缓存、增加消息推送等功能是 PWA 走向设备的必备功能，但我认为真正决定 PWA 能否崛起的还是底层技术，比如页面渲染效率、对系统设备的支持程度、WebAssembly 等，而这些技术也在渐进式进化过程中。所以未来如何，我们拭目以待</p>\n<h1 id="webcomponent：像搭积木一样构建-web-应用"><a href="#webcomponent%EF%BC%9A%E5%83%8F%E6%90%AD%E7%A7%AF%E6%9C%A8%E4%B8%80%E6%A0%B7%E6%9E%84%E5%BB%BA-web-%E5%BA%94%E7%94%A8" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>webComponent：像搭积木一样构建 web 应用</h1>\n<p>什么是组件化呢？</p>\n<p>其实组件化并没有一个明确的定义，不过这里我们可以使用 10 个字来形容什么是组件化，那就是：对内高内聚，对外低耦合。对内各个元素彼此紧密结合、相互依赖，对外和其他组件的联系最少且接口简单。</p>\n<p>可以说，程序员对组件化开发有着天生的需求，因为一个稍微复杂点的项目，就涉及到多人协作开发的问题，每个人负责的组件需要尽可能独立完成自己的功能，其组件的内部状态不能影响到别人的组件，在需要和其他组件交互的地方得提前协商好接口。通过组件化可以降低整个系统的耦合度，同时也降低程序员之间沟通复杂度，让系统变得更加易于维护。</p>\n<p>使用组件化能带来很多优势，所以很多语言天生就对组件化提供了很好的支持，比如 C/C++ 就可以很好地将功能封装成模块，无论是业务逻辑，还是基础功能，抑或是 UI，都能很好地将其组合在一起，实现组件内部的高度内聚、组件之间的低耦合。</p>\n<p>大部分语言都能实现组件化，归根结底在于编程语言特性，大多数语言都有自己的函数级作用域、块级作用域和类，可以将内部的状态数据隐藏在作用域之下或者对象的内部，这样外部就无法访问了，然后通过约定好的接口和外部进行通信。</p>\n<p>JavaScript 虽然有不少缺点，但是作为一门编程语言，它也能很好地实现组件化，毕竟有自己的函数级作用域和块级作用域，所以封装内部状态数据并提供接口给外部都是没有问题的。</p>\n<p>既然 JavaScript 可以很好地实现组件化，那么我们所谈论的 WebComponent 到底又是什么呢？</p>\n<h2 id="阻碍前端组件化的因素"><a href="#%E9%98%BB%E7%A2%8D%E5%89%8D%E7%AB%AF%E7%BB%84%E4%BB%B6%E5%8C%96%E7%9A%84%E5%9B%A0%E7%B4%A0" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>阻碍前端组件化的因素</h2>\n<p>在前端虽然 HTML、CSS 和 JavaScript 是强大的开发语言，但是在大型项目中维护起来会比较困难，如果在页面中嵌入第三方内容时，还需要确保第三方的内容样式不会影响到当前内容，同样也要确保当前的 DOM 不会影响到第三方的内容。</p>\n<p>所以要聊 WebComponent，得先看看 HTML 和 CSS 是如何阻碍前端组件化的，这里我们就通过下面这样一个简单的例子来分析下：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="91653231217315090000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`<style>\n  p {\n    background-color: brown;\n    color: cornsilk;\n  }\n</style>\n<p>time.geekbang.org</p>`, `91653231217315090000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                html 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">\n  <span class="token selector">p</span> <span class="token punctuation">{</span>\n    <span class="token property">background-color</span><span class="token punctuation">:</span> brown<span class="token punctuation">;</span>\n    <span class="token property">color</span><span class="token punctuation">:</span> cornsilk<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>time.geekbang.org<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="14177997980080792000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`<style>\n  p {\n    background-color: red;\n    color: blue;\n  }\n</style>\n<p>time.geekbang</p>`, `14177997980080792000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                html 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">\n  <span class="token selector">p</span> <span class="token punctuation">{</span>\n    <span class="token property">background-color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>\n    <span class="token property">color</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>time.geekbang<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>上面这两段代码分别实现了自己 p 标签的属性，如果两个人分别负责开发这两段代码的话，那么在测试阶段可能没有什么问题，不过当最终项目整合的时候，其中内部的 CSS 属性会影响到其他外部的 p 标签的，之所以会这样，是因为 CSS 是影响全局的。</p>\n<p>渲染引擎会将所有的 CSS 内容解析为 CSSOM，在生成布局树的时候，会在 CSSOM 中为布局树中的元素查找样式，所以有两个相同标签最终所显示出来的效果是一样的，渲染引擎是不能为它们分别单独设置样式的。</p>\n<p>除了 CSS 的全局属性会阻碍组件化，DOM 也是阻碍组件化的一个因素，因为在页面中只有一个 DOM，任何地方都可以直接读取和修改 DOM。所以使用 JavaScript 来实现组件化是没有问题的，但是 JavaScript 一旦遇上 CSS 和 DOM，那么就相当难办了</p>\n<h2 id="webcomponent-组件化开发"><a href="#webcomponent-%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>WebComponent 组件化开发</h2>\n<p>现在我们了解了 CSS 和 DOM 是阻碍组件化的两个因素，那要怎么解决呢？</p>\n<p>WebComponent 给出了解决思路，它提供了对局部视图封装能力，可以让 DOM、CSSOM 和 JavaScript 运行在局部环境中，这样就使得局部的 CSS 和 DOM 不会影响到全局。</p>\n<p>了解了这些，下面我们就结合具体代码来看看 WebComponent 是怎么实现组件化的。</p>\n<p>前面我们说了，WebComponent 是一套技术的组合，具体涉及到了 Custom elements（自定义元素）、Shadow DOM（影子 DOM）和 HTML templates（HTML 模板），详细内容你可以参考 MDN 上的<a href="https://developer.mozilla.org/zh-CN/docs/Web/Web_Components" target="_blank" rel="nofollow noreferrer noopener">相关链接</a>。</p>\n<p>下面我们就来演示下这 3 个技术是怎么实现数据封装的，如下面代码所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="83539821061812420000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`<!DOCTYPE html>\n<html>\n  <body>\n    <!--\n      一：定义模板\n      二：定义内部 CSS 样式\n      三：定义 JavaScript 行为\n    -->\n    <template id=&quot;geekbang-t&quot;>\n      <style>\n        p {\n          background-color: brown;\n          color: cornsilk;\n        }\n\n        div {\n          width: 200px;\n          background-color: bisque;\n          border: 3px solid chocolate;\n          border-radius: 10px;\n        }\n      </style>\n      <div>\n        <p>time.geekbang.org</p>\n        <p>time1.geekbang.org</p>\n      </div>\n      <script>\n        function foo() {\n          console.log(\'inner log\');\n        }\n      </script>\n    </template>\n    <script>\n      class GeekBang extends HTMLElement {\n        constructor() {\n          super();\n          // 获取组件模板\n          const content = document.querySelector(\'#geekbang-t\').content;\n          // 创建影子 DOM 节点\n          const shadowDOM = this.attachShadow({ mode: \'open\' });\n          // 将模板添加到影子 DOM 上\n          shadowDOM.appendChild(content.cloneNode(true));\n        }\n      }\n      customElements.define(\'geek-bang\', GeekBang);\n    </script>\n\n    <geek-bang></geek-bang>\n    <div>\n      <p>time.geekbang.org</p>\n      <p>time1.geekbang.org</p>\n    </div>\n    <geek-bang></geek-bang>\n  </body>\n</html>`, `83539821061812420000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                html 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>\n    <span class="token comment">&lt;!--\n      一：定义模板\n      二：定义内部 CSS 样式\n      三：定义 JavaScript 行为\n    --></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>geekbang-t<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">\n        <span class="token selector">p</span> <span class="token punctuation">{</span>\n          <span class="token property">background-color</span><span class="token punctuation">:</span> brown<span class="token punctuation">;</span>\n          <span class="token property">color</span><span class="token punctuation">:</span> cornsilk<span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n\n        <span class="token selector">div</span> <span class="token punctuation">{</span>\n          <span class="token property">width</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>\n          <span class="token property">background-color</span><span class="token punctuation">:</span> bisque<span class="token punctuation">;</span>\n          <span class="token property">border</span><span class="token punctuation">:</span> 3px solid chocolate<span class="token punctuation">;</span>\n          <span class="token property">border-radius</span><span class="token punctuation">:</span> 10px<span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n      </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>\n        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>time.geekbang.org<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>\n        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>time1.geekbang.org<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">\n        <span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'inner log\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n      </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">\n      <span class="token keyword">class</span> <span class="token class-name">GeekBang</span> <span class="token keyword">extends</span> <span class="token class-name">HTMLElement</span> <span class="token punctuation">{</span>\n        <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n          <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n          <span class="token comment">// 获取组件模板</span>\n          <span class="token keyword">const</span> content <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">\'#geekbang-t\'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>content<span class="token punctuation">;</span>\n          <span class="token comment">// 创建影子 DOM 节点</span>\n          <span class="token keyword">const</span> shadowDOM <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">attachShadow</span><span class="token punctuation">(</span><span class="token punctuation">{</span> mode<span class="token punctuation">:</span> <span class="token string">\'open\'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n          <span class="token comment">// 将模板添加到影子 DOM 上</span>\n          shadowDOM<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>content<span class="token punctuation">.</span><span class="token function">cloneNode</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n      <span class="token punctuation">}</span>\n      customElements<span class="token punctuation">.</span><span class="token function">define</span><span class="token punctuation">(</span><span class="token string">\'geek-bang\'</span><span class="token punctuation">,</span> GeekBang<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>\n\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>geek-bang</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>geek-bang</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>time.geekbang.org<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>time1.geekbang.org<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>geek-bang</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>geek-bang</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>详细观察上面这段代码，我们可以得出：要使用 WebComponent，通常要实现下面三个步骤。</p>\n<p>首先，使用 template 属性来创建模板。利用 DOM 可以查找到模板的内容，但是模板元素是不会被渲染到页面上的，也就是说 DOM 树中的 template 节点不会出现在布局树中，所以我们可以使用 template 来自定义一些基础的元素结构，这些基础的元素结构是可以被重复使用的。一般模板定义好之后，我们还需要在模板的内部定义样式信息。</p>\n<p>其次，我们需要创建一个 GeekBang 的类。在该类的构造函数中要完成三件事：</p>\n<ul>\n<li>查找模板内容；</li>\n<li>创建影子 DOM；</li>\n<li>再将模板添加到影子 DOM 上</li>\n</ul>\n<p>上面最难理解的是影子 DOM，其实影子 DOM 的作用是将模板中的内容与全局 DOM 和 CSS 进行隔离，这样我们就可以实现元素和样式的私有化了。你可以把影子 DOM 看成是一个作用域，其内部的样式和元素是不会影响到全局的样式和元素的，而在全局环境下，要访问影子 DOM 内部的样式或者元素也是需要通过约定好的接口的。</p>\n<p>总之，通过影子 DOM，我们就实现了 CSS 和元素的封装，在创建好封装影子 DOM 的类之后，我们就可以使用 <code class="language-text">customElements.define</code> 来自定义元素了（可参考上述代码定义元素的方式）。</p>\n<blockquote>\n<p>最后，就很简单了，可以像正常使用 HTML 元素一样使用该元素，如上述代码中的 <code class="language-text">&lt;geek-bang&gt;&lt;/geek-bang&gt;</code>。</p>\n</blockquote>\n<p>上述代码最终渲染出来的页面，如下图所示：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-13-11-51-51-075e14c217ffe70c86539ac84710a79f-62dab.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 87.68768768768768%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAIAAADUsmlHAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAC5klEQVQ4y42U208TQRTG+TssUGjpttsLbLvttt1uu9uuhdC3LlTik5oQ3vVFHzQmBoNGBY0gCqIiiYiiYDBeokFCiEQMkRaBShrAxHLb3qtg6HbqtEahKNGT2ZeZ/M53zndmtiANMgBk/gy4n0gkwuHwOs+HQiGe52OxWCQSicfj4BdQAL/lqbHp/htzQ3dnn9yZGbw9df/a4ujTNAANDQ0WksSwCo1Go1KpHA4HQRAejwfykIIpsvD8q4E3l06+vX5urO3sSMvpwWP17242w4I8dXVqTI9pdUq1pjQbEpFIRJJkNBrdhpfGnk90NHnvtX7ouTLZ3TJ8/oTvYSes7NDhI3qrg7I7LTZGq9PhOA71XS4XrH8b/hYPR1cWY6tL8bXPX8PBrSQvbCbS6XRNradYLEYVCjmCGI1Gk9mMIHK73Z6nHApHPwUW5wMLgYWllVU+k7NDEASOq90nKpQhcoVCiet0RkIPm3c6nXlwMhkP8cvra1/49eVYjAdAgEdQ2e3mEFRlZasMJovFZKLNBkQqsdFMHhx8PzzV0zL7qPPjg3Zvb+t4e6P/WS+U57gaGaom2WotYdFgOlSlLiosstlsebD/Zf/rpuOjVxtHLp8Zvnjq8dH68Y5muA+V5SqNbX+1gbRiuF6L60tKSnbDwckRX1/b3FD37OCtmYGuia4L8y/6QA4ulUgptspEs4TFptMTUqmUZdk8t0F6KyNsgNRGJrUBhE0Avuf8SsOyy1C1gWIwg1GpUisUCpiLpuk85V3x8/ZBwzg3VyyRkVaGspAOlrVSVDlOMHY2Go3shMHOBUA6OyoIc5xcXWFmnBhuQJUonBO8Zbt73kvZDd2WyeyVLpJmTRRjJCmpRAJveF7Pe8AChKUIamIqcZLOjkqplPwnDB07UHdQqTWWa3EEQWRlZYhcLhaL/2HY7xSBQMDr9U37cisXPp/P7/fDvNvveWfAg2AwCB89/BMkk8lYLlKp1F8FfgDWJ+OPjhOz2AAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 13 11 51 51"\n        title=""\n        src="/static/2021-07-13-11-51-51-075e14c217ffe70c86539ac84710a79f-fee1c.png"\n        srcset="/static/2021-07-13-11-51-51-075e14c217ffe70c86539ac84710a79f-a67b7.png 200w,\n/static/2021-07-13-11-51-51-075e14c217ffe70c86539ac84710a79f-0b187.png 400w,\n/static/2021-07-13-11-51-51-075e14c217ffe70c86539ac84710a79f-fee1c.png 800w,\n/static/2021-07-13-11-51-51-075e14c217ffe70c86539ac84710a79f-b1a91.png 1200w,\n/static/2021-07-13-11-51-51-075e14c217ffe70c86539ac84710a79f-62dab.png 1332w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从图中我们可以看出，影子 DOM 内部的样式是不会影响到全局 CSSOM 的。另外，使用 DOM 接口也是无法直接查询到影子 DOM 内部元素的，比如你可以使用 document.getElementsByTagName(‘div’)来查找所有 div 元素，这时候你会发现影子 DOM 内部的元素都是无法查找的，因为要想查找影子 DOM 内部的元素需要专门的接口，所以通过这种方式又将影子内部的 DOM 和外部的 DOM 进行了隔离。</p>\n<p>通过影子 DOM 可以隔离 CSS 和 DOM，不过需要注意一点，影子 DOM 的 JavaScript 脚本是不会被隔离的，比如在影子 DOM 定义的 JavaScript 函数依然可以被外部访问，这是因为 JavaScript 语言本身已经可以很好地实现组件化了。</p>\n<h2 id="浏览器如何实现影子-dom"><a href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%BD%B1%E5%AD%90-dom" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>浏览器如何实现影子 DOM</h2>\n<p>关于 WebComponent 的使用方式我们就介绍到这里。WebComponent 整体知识点不多，内容也不复杂，我认为核心就是影子 DOM。上面我们介绍影子 DOM 的作用主要有以下两点：</p>\n<ul>\n<li>影子 DOM 中的元素对于整个网页是不可见的；</li>\n<li>影子 DOM 的 CSS 不会影响到整个网页的 CSSOM，影子 DOM 内部的 CSS 只对内部的元素起作用。</li>\n</ul>\n<p>那么浏览器是如何实现影子 DOM 的呢？下面我们就来分析下，如下图：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-13-11-52-29-b6fd9f3ed0845c4a5c2401ea8e2df156-74b04.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 73.4877734877735%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAIAAABr+ngCAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACwUlEQVQoz22R2U8TURTG+zeZ+GxUxGiqxu0BlaCR8ESMbyQ8mZiYGMRQYFrazkAtKQIq1CKCkc0EgQJFutCFwnSh03am69yZztK5d+pQeEDply83595zfsk95+hqdama1WMj9fgKJNWTghmAtBiqp9mT1FnpzsRIPZYGoDynfN4BoYykxUhVtLPu/2mdWn85zCnj7mIgVfm5x05vFzZJfmqL2Yiyrj/lCXd+/bAys1uaD/BQbQQni8pCqHJUVj3J6uqBGM7CpYgQZtTlEJjzlXwpaY2U3HEZoX/hk058VBX7xe5SyoxfsG/wogxrUMwC9MUDlsLCrJ9XFQkheO7b9W55CaZZBQgwz0MaIEmuikIFiDBIVWJ5OZLmRVFQFOV0KKdWdbVGUiCCUDkqobFt0RWqzYRqclVB6PzAEALkBthfZsPLkVAoEIkHwwdF/3x2c1LKx2BVBtHVCrmWCazs70ejZCIRDXKRRRBeVPiCDilSytFOmW8mhvSjhHlgZMpK2OMmfbznQskzKYPcEX43i98KWp5YbJOGEdcnoi9lbEoMNvHxLQ2WM442xngpYb5jxe29hGsAn0ha72UNF1nvtMQyaVMzY7ocMLe+w51vie+jhIk2X88MNfMJj66mCGHHywXsBWnS+0wtTqx7B3vsH3q08P5p2euEbNprblvFOmLYjTWs3TXYFTbe9xhb3cbnQnJbg7lNxyucsKett0nLAwwfj1pbPERn/4Cx4HXV2Pgc8frjiKVkveK2dpoIR8ly9Rv+5oMFkxNuDQa/x3sGbc44/jCIPzOM/vARHesjXQbLGOOd02DncC9hc+Qs11aI7n77LGXVf7X1DRM2MbGl0zbG56linhbogwpDFgo5nolxuWSOTktcEVaFAkUW6ZSU2WOzMYZmhEyoRCcLNAUlrvGeNcmyzPEVFnBlwKmq2rDmL1hP+73t5BMCAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 13 11 52 29"\n        title=""\n        src="/static/2021-07-13-11-52-29-b6fd9f3ed0845c4a5c2401ea8e2df156-fee1c.png"\n        srcset="/static/2021-07-13-11-52-29-b6fd9f3ed0845c4a5c2401ea8e2df156-a67b7.png 200w,\n/static/2021-07-13-11-52-29-b6fd9f3ed0845c4a5c2401ea8e2df156-0b187.png 400w,\n/static/2021-07-13-11-52-29-b6fd9f3ed0845c4a5c2401ea8e2df156-fee1c.png 800w,\n/static/2021-07-13-11-52-29-b6fd9f3ed0845c4a5c2401ea8e2df156-b1a91.png 1200w,\n/static/2021-07-13-11-52-29-b6fd9f3ed0845c4a5c2401ea8e2df156-74b04.png 1554w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>该图是上面那段示例代码对应的 DOM 结构图，从图中可以看出，我们使用了两次 geek-bang 属性，那么就会生成两个影子 DOM，并且每个影子 DOM 都有一个 shadow root 的根节点，我们可以将要展示的样式或者元素添加到影子 DOM 的根节点上，每个影子 DOM 你都可以看成是一个独立的 DOM，它有自己的样式、自己的属性，内部样式不会影响到外部样式，外部样式也不会影响到内部样式。</p>\n<p>浏览器为了实现影子 DOM 的特性，在代码内部做了大量的条件判断，比如当通过 DOM 接口去查找元素时，渲染引擎会去判断 geek-bang 属性下面的 shadow-root 元素是否是影子 DOM，如果是影子 DOM，那么就直接跳过 shadow-root 元素的查询操作。所以这样通过 DOM API 就无法直接查询到影子 DOM 的内部元素了。</p>\n<p>另外，当生成布局树的时候，渲染引擎也会判断 geek-bang 属性下面的 shadow-root 元素是否是影子 DOM，如果是，那么在影子 DOM 内部元素的节点选择 CSS 样式的时候，会直接使用影子 DOM 内部的 CSS 属性。所以这样最终渲染出来的效果就是影子 DOM 内部定义的样式。</p>\n<h2 id="总结-7"><a href="#%E6%80%BB%E7%BB%93-7" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总结</h2>\n<p>首先，我们介绍了组件化开发是程序员的刚需，所谓组件化就是功能模块要实现高内聚、低耦合的特性。不过由于 DOM 和 CSSOM 都是全局的，所以它们是影响了前端组件化的主要元素。基于这个原因，就出现 WebComponent，它包含自定义元素、影子 DOM 和 HTML 模板三种技术，使得开发者可以隔离 CSS 和 DOM。在此基础上，我们还重点介绍了影子 DOM 到底是怎么实现的。</p>\n<p>关于 WebComponent 的未来如何，这里我们不好预测和评判，但是有一点可以肯定，WebComponent 也会采用渐进式迭代的方式向前推进，未来依然有很多坑需要去填</p>',
id:"/github/workspace/blog/浏览器工作原理与实践——浏览器中的页面/index.md absPath of file >>> MarkdownRemark",timeToRead:30,frontmatter:{date:"2021-07-07 09:41:05",path:"/browser-working-principle-page/",tags:"前端, 浏览器, 高级前端",title:"浏览器工作原理与实践——浏览器中的页面",draft:null}},{excerpt:"消息队列和事件循环：页面是怎么活起来的 前面我们讲到了每个渲染进程都有一个主线程，并且主线程非常繁忙，既要处理 DOM，又要计算样式，还要处理布局，同时还需要处理 JavaScript…",html:'<h1 id="消息队列和事件循环：页面是怎么活起来的"><a href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%EF%BC%9A%E9%A1%B5%E9%9D%A2%E6%98%AF%E6%80%8E%E4%B9%88%E6%B4%BB%E8%B5%B7%E6%9D%A5%E7%9A%84" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>消息队列和事件循环：页面是怎么活起来的</h1>\n<p>前面我们讲到了每个渲染进程都有一个主线程，并且主线程非常繁忙，既要处理 DOM，又要计算样式，还要处理布局，同时还需要处理 JavaScript 任务以及各种输入事件。要让这么多不同类型的任务在主线程中有条不紊地执行，这就需要一个系统来统筹调度这些任务，这个统筹调度系统就是我们今天要讲的消息队列和事件循环系统。</p>\n<p>在写这篇文章之前，我翻阅了大量的资料，却发现没有一篇文章能把消息循环系统给讲清楚的，所以我决定用一篇文章来专门介绍页面的事件循环系统。事件循环非常底层且非常重要，学会它能让你理解页面到底是如何运行的，所以在本篇文章中，我们会将页面的事件循环给梳理清楚、讲透彻。</p>\n<p>为了能让你更加深刻地理解事件循环机制，我们就从最简单的场景来分析，然后带你一步步了解浏览器页面主线程是如何运作的。</p>\n<p>需要说明的是，文章中的代码我会采用 C++ 来示范。如果你不熟悉 C++，也没有关系，这里并没有涉及到任何复杂的知识点，只要你了解 JavaScript 或 Python，你就会看懂</p>\n<h2 id="使用单线程处理安排好的任务"><a href="#%E4%BD%BF%E7%94%A8%E5%8D%95%E7%BA%BF%E7%A8%8B%E5%A4%84%E7%90%86%E5%AE%89%E6%8E%92%E5%A5%BD%E7%9A%84%E4%BB%BB%E5%8A%A1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>使用单线程处理安排好的任务</h2>\n<p>我们先从最简单的场景讲起，比如有如下一系列的任务：</p>\n<ul>\n<li>任务 1：1+2</li>\n<li>任务 2：20/5</li>\n<li>任务 3：7*8</li>\n<li>任务 4：打印出任务 1、任务 2、任务 3 的运算结果</li>\n</ul>\n<p>现在要在一个线程中去执行这些任务，通常我们会这样编写代码</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="73742317157259076000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`void MainThread() {\n  int num1 = 1+2; // 任务 1\n  int num2 = 20/5; // 任务 2\n  int num3 = 7*8; // 任务 3\n  print(&quot; 最终计算的值为:%d,%d,%d&quot;,num, num2, num3)； // 任务 4\n}`, `73742317157259076000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                cpp 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="cpp"><pre style="counter-reset: linenumber NaN" class="language-cpp line-numbers"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">MainThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">int</span> num1 <span class="token operator">=</span> <span class="token number">1</span><span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// 任务 1</span>\n  <span class="token keyword">int</span> num2 <span class="token operator">=</span> <span class="token number">20</span><span class="token operator">/</span><span class="token number">5</span><span class="token punctuation">;</span> <span class="token comment">// 任务 2</span>\n  <span class="token keyword">int</span> num3 <span class="token operator">=</span> <span class="token number">7</span><span class="token operator">*</span><span class="token number">8</span><span class="token punctuation">;</span> <span class="token comment">// 任务 3</span>\n  <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">" 最终计算的值为:%d,%d,%d"</span><span class="token punctuation">,</span>num<span class="token punctuation">,</span> num2<span class="token punctuation">,</span> num3<span class="token punctuation">)</span>； <span class="token comment">// 任务 4</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>在上面的执行代码中，我们把所有任务代码按照顺序写进主线程里，等线程执行时，这些任务会按照顺序在线程中依次被执行；等所有任务执行完成之后，线程会自动退出。可以参考下图来直观地理解下其执行过程：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-05-15-34-41-14ad4d9a6ca3928b729da147297fc26b-ed3f4.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 55.590062111801245%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABc0lEQVQoz6VSuVLDMBDN31HyC/wNP5BjaGhS0FLQkDAThmFiQ0NBAUzuOD4kW7YTy5IV62AdTwJh0qF5eiPt6mlXq22Yf4zG742UknFeFAVMIQQwr7d7hqG1Pi1mjKfrNQ4jH6EoIsABxgDPDxAOwR6RuCzL0+I8z8ezGQpDL0ARIV4QgBKEwGB0Vu7naATZKX1SzNjHaOzjcLpwMImB3QDPl+7S9ebOaun6o9milBJOQu6AI3HBmcgiQYkWmWRJkcdiE5Z5zBLEUszXodkmr464+1KHyFUSQrDHQcdL6NULb1l526IdmzWHtDWksG5ZtG3nYO/YtGmLs25xcSsw1Q2onlSS88x67iZMPExNb6Jq9KeqP/nB/UQN5ur6TZ7fbC+ftutCV2nrKngVXytptDCKV5DsDyAEfIg9jnvvoSmpktujN0MNoJQ1diXZ3Vi7TOUqpQanMaWqDujGydaB/yCEZFmGEErTNEmSzWZj9rccuuQbn+duCydzpwcAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 05 15 34 41"\n        title=""\n        src="/static/2021-07-05-15-34-41-14ad4d9a6ca3928b729da147297fc26b-fee1c.png"\n        srcset="/static/2021-07-05-15-34-41-14ad4d9a6ca3928b729da147297fc26b-a67b7.png 200w,\n/static/2021-07-05-15-34-41-14ad4d9a6ca3928b729da147297fc26b-0b187.png 400w,\n/static/2021-07-05-15-34-41-14ad4d9a6ca3928b729da147297fc26b-fee1c.png 800w,\n/static/2021-07-05-15-34-41-14ad4d9a6ca3928b729da147297fc26b-b1a91.png 1200w,\n/static/2021-07-05-15-34-41-14ad4d9a6ca3928b729da147297fc26b-ed3f4.png 1288w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<h2 id="在线程运行过程中处理新任务"><a href="#%E5%9C%A8%E7%BA%BF%E7%A8%8B%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%A4%84%E7%90%86%E6%96%B0%E4%BB%BB%E5%8A%A1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>在线程运行过程中处理新任务</h2>\n<p>但并不是所有的任务都是在执行之前统一安排好的，大部分情况下，新的任务是在线程运行过程中产生的。比如在线程执行过程中，又接收到了一个新的任务要求计算“10+2”，那上面那种方式就无法处理这种情况了。</p>\n<p>要想在线程运行过程中，能接收并执行新的任务，就需要采用事件循环机制。我们可以通过一个 for 循环语句来监听是否有新的任务，如下面的示例代码：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="95784149505695290000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// GetInput\n// 等待用户从键盘输入一个数字，并返回该输入的数字\nint GetInput() {\n  int input_number = 0;\n  cout<<&quot;请输入一个数:&quot;;\n  cin>>input_number;\n  return input_number;\n}\n\n// 主线程(Main Thread)\nvoid MainThread() {\n  for(;;){\n    int first_num = GetInput();\n    int second_num = GetInput();\n    result_num = first_num + second_num;\n    print(&quot;最终计算的值为:%d&quot;,result_num);\n  }\n}`, `95784149505695290000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                cpp 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="cpp"><pre style="counter-reset: linenumber NaN" class="language-cpp line-numbers"><code class="language-cpp"><span class="token comment">// GetInput</span>\n<span class="token comment">// 等待用户从键盘输入一个数字，并返回该输入的数字</span>\n<span class="token keyword">int</span> <span class="token function">GetInput</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">int</span> input_number <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>\n  cout<span class="token operator">&lt;&lt;</span><span class="token string">"请输入一个数:"</span><span class="token punctuation">;</span>\n  cin<span class="token operator">>></span>input_number<span class="token punctuation">;</span>\n  <span class="token keyword">return</span> input_number<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// 主线程(Main Thread)</span>\n<span class="token keyword">void</span> <span class="token function">MainThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n    <span class="token keyword">int</span> first_num <span class="token operator">=</span> <span class="token function">GetInput</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">int</span> second_num <span class="token operator">=</span> <span class="token function">GetInput</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    result_num <span class="token operator">=</span> first_num <span class="token operator">+</span> second_num<span class="token punctuation">;</span>\n    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"最终计算的值为:%d"</span><span class="token punctuation">,</span>result_num<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>相较于第一版的线程，这一版的线程做了两点改进。</p>\n<ul>\n<li>第一点引入了循环机制，具体实现方式是在线程语句最后添加了一个 for 循环语句，线程会一直循环执行。</li>\n<li>第二点是引入了事件，可以在线程运行过程中，等待用户输入的数字，等待过程中线程处于暂停状态，一旦接收到用户输入的信息，那么线程会被激活，然后执行相加运算，最后输出结果。</li>\n</ul>\n<p>通过引入事件循环机制，就可以让该线程“活”起来了，我们每次输入两个数字，都会打印出两数字相加的结果，你可以结合下图来参考下这个改进版的线程：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-05-15-36-22-cf284cfa7deb324afd661f712c7b9a60-29961.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 82.36272878535773%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAIAAACZeshMAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABqElEQVQoz42Ty07cMBSG86BsWCBYsIQdGxa8QCUkVAlWLFhxa4vUMiosgUpFDCBoCa3IaEqYXBzHThzfOYkJjBDT4ZdlHV8+H19+e3a0tNaqlZQSaugZnuCNIo0xeZ7jRi7IsowQAv3jYciTpmmv1/N9v9/vuxghNJz8f5lJoyYzyTCGOCf07cymlm4D055Zam2S6EGJAkaaMvrMQLlxN1HpunXdx4sHbH5fbF1JO7SA90RYS+K74OKbNapAUXJ/R5L73u0VRVHM7HpXbf8yP0M7/UnsXqt6U6aF3W7PLg8/rEzcILtyzFZP6NqP8uMR2ejy2S9yaofTHNky2jovJzZFIYzL70nFq4pCo3u6t742gyvzO7G3qC5+agNsD//qyW0+wMxy0rnhc19F+QzXt2RUfTzOBM1eXYlrLJ/Imc9i4bteOigroZ77PTtObl431J0/2v+X5hgxVoE45+Ph9kLrl0NJPBgM4jgGw4Bt3gU7XiodRVEYhgAHQZAkyXvhISO96G24KApKKWMMzAy/oixL2CR8DDD8+F8FGPBQg7FhFYBx4+1X8CMYAZeRWApgQAAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 05 15 36 22"\n        title=""\n        src="/static/2021-07-05-15-36-22-cf284cfa7deb324afd661f712c7b9a60-fee1c.png"\n        srcset="/static/2021-07-05-15-36-22-cf284cfa7deb324afd661f712c7b9a60-a67b7.png 200w,\n/static/2021-07-05-15-36-22-cf284cfa7deb324afd661f712c7b9a60-0b187.png 400w,\n/static/2021-07-05-15-36-22-cf284cfa7deb324afd661f712c7b9a60-fee1c.png 800w,\n/static/2021-07-05-15-36-22-cf284cfa7deb324afd661f712c7b9a60-b1a91.png 1200w,\n/static/2021-07-05-15-36-22-cf284cfa7deb324afd661f712c7b9a60-29961.png 1202w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<h2 id="处理其他线程发送过来的任务"><a href="#%E5%A4%84%E7%90%86%E5%85%B6%E4%BB%96%E7%BA%BF%E7%A8%8B%E5%8F%91%E9%80%81%E8%BF%87%E6%9D%A5%E7%9A%84%E4%BB%BB%E5%8A%A1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>处理其他线程发送过来的任务</h2>\n<p>上面我们改进了线程的执行方式，引入了事件循环机制，可以让其在执行过程中接受新的任务。不过在第二版的线程模型中，所有的任务都是来自于线程内部的，如果另外一个线程想让主线程执行一个任务，利用第二版的线程模型是无法做到的。</p>\n<p>那下面我们就来看看其他线程是如何发送消息给渲染主线程的，具体形式你可以参考下图：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-05-15-36-37-f640306f8b3ea0982b29ce147087fce9-5cdb5.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 70.18072289156628%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAIAAACgpqunAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABqElEQVQoz41SbU/bQAzmL6P9nP0CJNBA6gZ8Qkj9tEpo00rE2sIUhaZpmijkck3uzrGNr1fe1lXaI+fii++xn3N8wMz9v8AvQMTdKBFJ6EBiSqluiza8jDHj8Xg0Gg2HwyRJnHNt60OySEhrLb4nSxoJ8A6KfJml83SerHUj21AqAAAkxQeyqKuLGHpUlsQ65IfH5TReTOJ0Ei/WwEVLsxKBPFnEfSB3XXN99bnU5nxGgzsYROYsMqeR/fKjObs15xM4+WUPL9x9RUzQvpLDBcTR9SrIw6eKNmq94EaJaAZnVaPcHtn8vr/Fipw/iKpGIUsKrQlg753JA7fkckXWbsgKNxL6bEFdR/wflbnI2Hkyq4p17R27ZrB7KwPYu+jKOFhqXuQ6q2y25rzlVS1fKNcYl+77HDuQ7ux22+ib0UnVum9TGkzpq9jv/vinPrqpT2/NxYyOI/x06f488Vu35YIyMaJExoiQJKvEmJwYoS2zefIwbepSLtOjk1NMfRhBT5ZHaGH/AguSwxuGP9cjhrg1JjhSckv+C5LrcYM0TfM8F0fW9+P5imenpyUDdr7C3AAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 05 15 36 37"\n        title=""\n        src="/static/2021-07-05-15-36-37-f640306f8b3ea0982b29ce147087fce9-fee1c.png"\n        srcset="/static/2021-07-05-15-36-37-f640306f8b3ea0982b29ce147087fce9-a67b7.png 200w,\n/static/2021-07-05-15-36-37-f640306f8b3ea0982b29ce147087fce9-0b187.png 400w,\n/static/2021-07-05-15-36-37-f640306f8b3ea0982b29ce147087fce9-fee1c.png 800w,\n/static/2021-07-05-15-36-37-f640306f8b3ea0982b29ce147087fce9-b1a91.png 1200w,\n/static/2021-07-05-15-36-37-f640306f8b3ea0982b29ce147087fce9-5cdb5.png 1328w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从上图可以看出，渲染主线程会频繁接收到来自于 IO 线程的一些任务，接收到这些任务之后，渲染进程就需要着手处理，比如接收到资源加载完成的消息后，渲染进程就要着手进行 DOM 解析了；接收到鼠标点击的消息后，渲染主线程就要开始执行相应的 JavaScript 脚本来处理该点击事件。</p>\n<p>那么如何设计好一个线程模型，能让其能够接收其他线程发送的消息呢？</p>\n<p>一个通用模式是使用消息队列。在解释如何实现之前，我们先说说什么是消息队列，可以参考下图：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-05-15-36-49-b9932e0a0b3732be6d12a4f8e7aec6b5-0a2a7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 33.43239227340268%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAIAAACHqfpvAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABFklEQVQY032QS0+DQBSF+WOuXPggGlf+Bn+Sr8RFY6ML122JTXwU4wot0CCEEoYCnaC0oVBmYJgZaXXTxnpzF+ec3JObfAJfHcrYP7t2LHBKGaVZlsYRxPMZ3zx1PUsmWTJFCP14gXxGnJAc40d1KPXdVzPomWPZGPU+whfDfzbDWsi1sKBsePeq+6A6uCzpLGFVJZD4i6dJalsnd/bODTy6VA6brnjxtnXlbJ++7zXcg4a9e6aIt1A8V/avwXHTRp5LgLMolzDkKMfz7MnwW/q4qwFpEEgqaOlBR/U6eiBpvtQH7QGsw7YWdHWfFEU1iRdlVhG+SoItbTKNwdCKwhEl5Z8AlsA2cC5KkiOM6yeU/oZ0nfk38Hd+EIyNiqYAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 05 15 36 49"\n        title=""\n        src="/static/2021-07-05-15-36-49-b9932e0a0b3732be6d12a4f8e7aec6b5-fee1c.png"\n        srcset="/static/2021-07-05-15-36-49-b9932e0a0b3732be6d12a4f8e7aec6b5-a67b7.png 200w,\n/static/2021-07-05-15-36-49-b9932e0a0b3732be6d12a4f8e7aec6b5-0b187.png 400w,\n/static/2021-07-05-15-36-49-b9932e0a0b3732be6d12a4f8e7aec6b5-fee1c.png 800w,\n/static/2021-07-05-15-36-49-b9932e0a0b3732be6d12a4f8e7aec6b5-b1a91.png 1200w,\n/static/2021-07-05-15-36-49-b9932e0a0b3732be6d12a4f8e7aec6b5-0a2a7.png 1346w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从图中可以看出，消息队列是一种数据结构，可以存放要执行的任务。它符合队列“先进先出”的特点，也就是说要添加任务的话，添加到队列的尾部；要取出任务的话，从队列头部去取。</p>\n<p>有了队列之后，我们就可以继续改造线程模型了，改造方案如下图所示：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-05-15-37-02-0559f3d4e4ffa48ccad5e3695fcd821a-eb890.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 66.13119143239625%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAIAAAAmMtkJAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACCklEQVQoz3VS227TQBDNLyOhliIhfoBnoIAqISQeUQpJWim8FNpKbaER4DZx6jR2nNRJnNjry+5674ydUCoqjo6smdWcnTnrqRljWIXiHvIsS9OUUgqx4EWc0SijSnImBBdCa11TSuV5jjGWEo7ULQsuh67XvxrkhCql55l8e86eHfHzwWLcv3QdB/Q1uCDPie87/qhzGph6VzT7qrGiXX4/2ao9UI/afBDpSWY2W8nM96aTMed8JS4HVEowaQg3+ZoaV8yY0cbsX8nnZ6LhmAMXMgNtwWk5NliCXOkS5v9wQnHyzYV6KIO2pRgihFCCEF4uOYp+Wf0Xx+Odo+vXX69fHjivDofbh+6bY3f7i/Pu1AsuLbGYYUrFqjOIoyhKk6QI52YyPDmzNhqDp43u4/rFww/W1sfe5m73SdPeqlsbu/aFc2NwSihdd4Yx4C9JKSkhmJDR2Oc4MYLNJyNBUsPIIvAlzQ2nmuGCMcIYFIt/PANEQeIwAONKyuXsBk6yFGVJfP8t/o4Nm6CURGg6CElnGLmRdJH+4cVurJyQW34yjJWH9Ajp9z9VZ6rK1+aVGKIgCLI0cT3rs41bXb7XK/Z6rNVjzV6xb/MqLiBt99mDJt35DmMqWLp159UCSiFhU/+QVxR3gvI8wVBWykACfmt3neiKUmmUZuEimoeLJM1yTCKUwlbc1tziNySS08FDlEaXAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 05 15 37 02"\n        title=""\n        src="/static/2021-07-05-15-37-02-0559f3d4e4ffa48ccad5e3695fcd821a-fee1c.png"\n        srcset="/static/2021-07-05-15-37-02-0559f3d4e4ffa48ccad5e3695fcd821a-a67b7.png 200w,\n/static/2021-07-05-15-37-02-0559f3d4e4ffa48ccad5e3695fcd821a-0b187.png 400w,\n/static/2021-07-05-15-37-02-0559f3d4e4ffa48ccad5e3695fcd821a-fee1c.png 800w,\n/static/2021-07-05-15-37-02-0559f3d4e4ffa48ccad5e3695fcd821a-b1a91.png 1200w,\n/static/2021-07-05-15-37-02-0559f3d4e4ffa48ccad5e3695fcd821a-eb890.png 1494w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从上图可以看出，我们的改造可以分为下面三个步骤：</p>\n<ul>\n<li>添加一个消息队列；</li>\n<li>IO 线程中产生的新任务添加进消息队列尾部；</li>\n<li>渲染主线程会循环地从消息队列头部中读取任务，执行任务。</li>\n</ul>\n<p>有了这些步骤之后，那么接下来我们就可以按步骤使用代码来实现第三版的线程模型。</p>\n<p>首先，构造一个队列。当然，在本篇文章中我们不需要考虑队列实现的细节，只是构造队列的接口：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="40814211050762280000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`class TaskQueue{\n  public:\n  Task takeTask(); // 取出队列头部的一个任务\n  void pushTask(Task task); // 添加一个任务到队列尾部\n};`, `40814211050762280000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                cpp 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="cpp"><pre style="counter-reset: linenumber NaN" class="language-cpp line-numbers"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">TaskQueue</span><span class="token punctuation">{</span>\n  <span class="token keyword">public</span><span class="token operator">:</span>\n  Task <span class="token function">takeTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 取出队列头部的一个任务</span>\n  <span class="token keyword">void</span> <span class="token function">pushTask</span><span class="token punctuation">(</span>Task task<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 添加一个任务到队列尾部</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>接下来，改造主线程，让主线程从队列中读取任务：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="34335564412591178000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`TaskQueue task_queue；\nvoid ProcessTask();\nvoid MainThread(){\n  for(;;){\n    Task task = task_queue.takeTask();\n    ProcessTask(task);\n  }\n}`, `34335564412591178000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                cpp 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="cpp"><pre style="counter-reset: linenumber NaN" class="language-cpp line-numbers"><code class="language-cpp">TaskQueue task_queue；\n<span class="token keyword">void</span> <span class="token function">ProcessTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">void</span> <span class="token function">MainThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n    Task task <span class="token operator">=</span> task_queue<span class="token punctuation">.</span><span class="token function">takeTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token function">ProcessTask</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>在上面的代码中，我们添加了一个消息队列的对象，然后在主线程的 for 循环代码块中，从消息队列中读取一个任务，然后执行该任务，主线程就这样一直循环往下执行，因此只要消息队列中有任务，主线程就会去执行。</p>\n<p>主线程的代码就这样改造完成了。这样改造后，主线程执行的任务都全部从消息队列中获取。所以如果有其他线程想要发送任务让主线程去执行，只需要将任务添加到该消息队列中就可以了，添加任务的代码如下：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="93677938094949290000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`Task clickTask;\ntask_queue.pushTask(clickTask)`, `93677938094949290000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                cpp 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="cpp"><pre style="counter-reset: linenumber NaN" class="language-cpp line-numbers"><code class="language-cpp">Task clickTask<span class="token punctuation">;</span>\ntask_queue<span class="token punctuation">.</span><span class="token function">pushTask</span><span class="token punctuation">(</span>clickTask<span class="token punctuation">)</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span></span></pre></div>\n<p>由于是多个线程操作同一个消息队列，所以在添加任务和取出任务时还会加上一个同步锁，这块内容也要注意下。</p>\n<h2 id="处理其他进程发送过来的任务"><a href="#%E5%A4%84%E7%90%86%E5%85%B6%E4%BB%96%E8%BF%9B%E7%A8%8B%E5%8F%91%E9%80%81%E8%BF%87%E6%9D%A5%E7%9A%84%E4%BB%BB%E5%8A%A1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>处理其他进程发送过来的任务</h2>\n<p>通过使用消息队列，我们实现了线程之间的消息通信。在 Chrome 中，跨进程之间的任务也是频繁发生的，那么如何处理其他进程发送过来的任务？你可以参考下图：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-05-15-38-28-02da4c333940e73b4389e085ab5e2544-794d5.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 78.69986168741356%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAIAAACZeshMAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACW0lEQVQoz3VSX0/UQBC/r+mn0BD1RT6A8VkUE1+RBDlPxb9vEKIi+CD2jt5xd3CAR6+93Xa32223+9dpGwgQmUw2s7P7m5nfzLSklEVRlJUIVausT5HzJEYpJY1TSeEHxTQurC6LUoqyNMa0OOeUpkJkeani3CS5ibmmwk5Rurvf743OksIyoX+eqqUd8Xhbfu9Nx7/3DrtdDeAsy3CcnIy++QHr9N1G37yvdWNgP43dx2HlaffMvc/SOffr3C5+oRmehbOZUqqV5zkkt0a7WuylWmuMNdZqW/lXPfV0T610bR9Vdygb+LaAMFy0sVCGsdfg10I5t3/CD7wJ2BBRCFGBoWyEcUFIyRieHL36MX62dfRye/R8c7i0OXqxBTpc3p4sbx2u7Y7TkV+SJC+gqXVmxlgYRZJSFfzFfvfJ18HC28GjdwcL7e7d9d7DTu8B6Mbwfttb/DA4n85cSgoBVddg4AzU4S5FEROC5pHVMktpgiKnJSMJiZGW8JqDQk6gCfzKq5xtRcqFYZRQCkaEMElZY1CWVU2B/l10FOQ/YJpgzlIwGE1yXoEZiXnGGpQy7jw19ccLMIUVYbzk0c44WtlXa3/yjq/bvnrtiQ5M+ECteeKNr8GG8856uepVQy3EBRghHAbjk+kEZfo0JEfTeZDwIOYhKUDPInocxGHCz3De8djxPIdthRlVS9LwaMo2WqYkTnAE7YJlrqhKkaUEnDwlrqn4irQuLeghdBNjjBCCnWuIwSyi+XwWhs1QnLsWoXU1kq4FPsHZdPGG59bMN6JEEaSsBDbR3SL/AGN0f51WcJ54AAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 05 15 38 28"\n        title=""\n        src="/static/2021-07-05-15-38-28-02da4c333940e73b4389e085ab5e2544-fee1c.png"\n        srcset="/static/2021-07-05-15-38-28-02da4c333940e73b4389e085ab5e2544-a67b7.png 200w,\n/static/2021-07-05-15-38-28-02da4c333940e73b4389e085ab5e2544-0b187.png 400w,\n/static/2021-07-05-15-38-28-02da4c333940e73b4389e085ab5e2544-fee1c.png 800w,\n/static/2021-07-05-15-38-28-02da4c333940e73b4389e085ab5e2544-b1a91.png 1200w,\n/static/2021-07-05-15-38-28-02da4c333940e73b4389e085ab5e2544-794d5.png 1446w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从图中可以看出，渲染进程专门有一个 IO 线程用来接收其他进程传进来的消息，接收到消息之后，会将这些消息组装成任务发送给渲染主线程，后续的步骤就和前面讲解的“处理其他线程发送的任务”一样了，这里就不再重复了。</p>\n<h2 id="消息队列中的任务类型"><a href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%B8%AD%E7%9A%84%E4%BB%BB%E5%8A%A1%E7%B1%BB%E5%9E%8B" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>消息队列中的任务类型</h2>\n<p>现在你知道页面主线程是如何接收外部任务的了，那接下来我们再来看看消息队列中的任务类型有哪些。你可以参考下 Chromium 的<a href="https://cs.chromium.org/chromium/src/third_party/blink/public/platform/task_type.h" target="_blank" rel="nofollow noreferrer noopener">官方源码</a>，这里面包含了很多内部消息类型，如输入事件（鼠标滚动、点击、移动）、微任务、文件读写、WebSocket、JavaScript 定时器等等。</p>\n<p>除此之外，消息队列中还包含了很多与页面相关的事件，如 JavaScript 执行、解析 DOM、样式计算、布局计算、CSS 动画等。</p>\n<p>以上这些事件都是在主线程中执行的，所以在编写 Web 应用时，你还需要衡量这些事件所占用的时长，并想办法解决单个任务占用主线程过久的问题。</p>\n<h2 id="如何安全退出"><a href="#%E5%A6%82%E4%BD%95%E5%AE%89%E5%85%A8%E9%80%80%E5%87%BA" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>如何安全退出</h2>\n<p>当页面主线程执行完成之后，又该如何保证页面主线程能够安全退出呢？Chrome 是这样解决的，确定要退出当前页面时，页面主线程会设置一个退出标志的变量，在每次执行完一个任务时，判断是否有设置退出标志。</p>\n<p>如果设置了，那么就直接中断当前的所有任务，退出线程，你可以参考下面代码：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="97569735340406550000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`TaskQueue task_queue；\nvoid ProcessTask();\nbool keep_running = true;\nvoid MainThread() {\n  for(;;){\n    Task task = task_queue.takeTask();\n    ProcessTask(task);\n    if(!keep_running) // 如果设置了退出标志，那么直接退出线程循环\n      break;\n  }\n}`, `97569735340406550000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                cpp 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="cpp"><pre style="counter-reset: linenumber NaN" class="language-cpp line-numbers"><code class="language-cpp">TaskQueue task_queue；\n<span class="token keyword">void</span> <span class="token function">ProcessTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">bool</span> keep_running <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n<span class="token keyword">void</span> <span class="token function">MainThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n    Task task <span class="token operator">=</span> task_queue<span class="token punctuation">.</span><span class="token function">takeTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token function">ProcessTask</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>keep_running<span class="token punctuation">)</span> <span class="token comment">// 如果设置了退出标志，那么直接退出线程循环</span>\n      <span class="token keyword">break</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h2 id="页面使用单线程的缺点"><a href="#%E9%A1%B5%E9%9D%A2%E4%BD%BF%E7%94%A8%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%BC%BA%E7%82%B9" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>页面使用单线程的缺点</h2>\n<p>上面讲述的就是页面线程的循环系统是如何工作的，那接下来，我们继续探讨页面线程的一些特征。</p>\n<p>通过上面的介绍，你应该清楚了，页面线程所有执行的任务都来自于消息队列。消息队列是“先进先出”的属性，也就是说放入队列中的任务，需要等待前面的任务被执行完，才会被执行。鉴于这个属性，就有如下两个问题需要解决。</p>\n<h3 id="如何处理高优先级的任务"><a href="#%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E9%AB%98%E4%BC%98%E5%85%88%E7%BA%A7%E7%9A%84%E4%BB%BB%E5%8A%A1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>如何处理高优先级的任务</h3>\n<p>比如一个典型的场景是监控 DOM 节点的变化情况（节点的插入、修改、删除等动态变化），然后根据这些变化来处理相应的业务逻辑。一个通用的设计的是，利用 JavaScript 设计一套监听接口，当变化发生时，渲染引擎同步调用这些接口，这是一个典型的观察者模式。</p>\n<p>不过这个模式有个问题，因为 DOM 变化非常频繁，如果每次发生变化的时候，都直接调用相应的 JavaScript 接口，那么这个当前的任务执行时间会被拉长，从而导致执行效率的下降。</p>\n<p>如果将这些 DOM 变化做成异步的消息事件，添加到消息队列的尾部，那么又会影响到监控的实时性，因为在添加到消息队列的过程中，可能前面就有很多任务在排队了。</p>\n<p>这也就是说，如果 DOM 发生变化，采用同步通知的方式，会影响当前任务的执行效率；如果采用异步方式，又会影响到监控的实时性</p>\n<p>那该如何权衡效率和实时性呢？</p>\n<p>针对这种情况，微任务就应用而生了，下面我们来看看微任务是如何权衡效率和实时性的。</p>\n<p>通常我们把消息队列中的任务称为宏任务，每个宏任务中都包含了一个微任务队列，在执行宏任务的过程中，如果 DOM 有变化，那么就会将该变化添加到微任务列表中，这样就不会影响到宏任务的继续执行，因此也就解决了执行效率的问题。</p>\n<p>等宏任务中的主要功能都直接完成之后，这时候，渲染引擎并不着急去执行下一个宏任务，而是执行当前宏任务中的微任务，因为 DOM 变化的事件都保存在这些微任务队列中，这样也就解决了实时性问题。</p>\n<h3 id="如何解决单个任务执行时长过久的问题"><a href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%8D%95%E4%B8%AA%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C%E6%97%B6%E9%95%BF%E8%BF%87%E4%B9%85%E7%9A%84%E9%97%AE%E9%A2%98" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>如何解决单个任务执行时长过久的问题</h3>\n<p>因为所有的任务都是在单线程中执行的，所以每次只能执行一个任务，而其他任务就都处于等待状态。如果其中一个任务执行时间过久，那么下一个任务就要等待很长时间。可以参考下图：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-05-15-40-26-fbe86c8a14dcdaf3adaf8d1ce8e6c092-e7341.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 52.22052067381316%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABQUlEQVQoz5VQa0vCUBjejy36IkIfhKAgocCoP9CXoCK6fFogpMYSxUg3DWKgYm4MraPn5BzbnCv1XDpraXSvw8N7Xp7zPOe9COwPh0xB3/PCTyYaiEeuA04O4OEe2N95MnsvNP3dHIp8BPWVmB6LqpF5r2UEPCHfmkMPjwRjnjwiqC0t1qML9cjc1+ZZJ5/btpqNByltlWUrnx07TigO5W+V+X+OZZqoa0Jg2xa6qdjiMRSPtN1tlDp1Msl+23A9x7V6GE9eK/Pu+NUyKrBvFqtAkmu569ucamTF89L6ViaeSMU3MqsJeW2zkL4sVO+UWlvtjM6aZDimAiHBYFojr3V7cocpgMr3VAGsBNhVlykogIxYEXKG87QMqKTj5Ytxx6UC+//hA9MPC+MUmWKCydD3B5438IYcPMeEzl7DbfHwDK/qLvi4DRj8AAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 05 15 40 26"\n        title=""\n        src="/static/2021-07-05-15-40-26-fbe86c8a14dcdaf3adaf8d1ce8e6c092-fee1c.png"\n        srcset="/static/2021-07-05-15-40-26-fbe86c8a14dcdaf3adaf8d1ce8e6c092-a67b7.png 200w,\n/static/2021-07-05-15-40-26-fbe86c8a14dcdaf3adaf8d1ce8e6c092-0b187.png 400w,\n/static/2021-07-05-15-40-26-fbe86c8a14dcdaf3adaf8d1ce8e6c092-fee1c.png 800w,\n/static/2021-07-05-15-40-26-fbe86c8a14dcdaf3adaf8d1ce8e6c092-b1a91.png 1200w,\n/static/2021-07-05-15-40-26-fbe86c8a14dcdaf3adaf8d1ce8e6c092-e7341.png 1306w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从图中你可以看到，如果在执行动画过程中，其中有个 JavaScript 任务因执行时间过久，占用了动画单帧的时间，这样会给用户制造了卡顿的感觉，这当然是极不好的用户体验。针对这种情况，JavaScript 可以通过回调功能来规避这种问题，也就是让要执行的 JavaScript 任务滞后执行。至于浏览器是如何实现回调功能的，我们在后面的章节中再详细介绍。</p>\n<h2 id="实践：浏览器页面是如何运行的"><a href="#%E5%AE%9E%E8%B7%B5%EF%BC%9A%E6%B5%8F%E8%A7%88%E5%99%A8%E9%A1%B5%E9%9D%A2%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%90%E8%A1%8C%E7%9A%84" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>实践：浏览器页面是如何运行的</h2>\n<p>有了上面的基础知识之后，我们最后来看看浏览器的页面是如何运行的。</p>\n<p>你可以打开开发者工具，点击“Performance”标签，选择左上角的“start porfiling and load page”来记录整个页面加载过程中的事件执行情况，如下图所示：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-05-15-40-55-fe1a25c4b0d62bf2788fbf2f76146412-604fe.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 68.09338521400778%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAIAAACgpqunAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABwUlEQVQoz32SaW+bQBCG/f//UKV8y4ekquTa5jAOMTc+MDbgZS+Ohe3s2jhK02b06GUG5t0RMDOMMaXkRl1jQlTCGOWcQXDOu64FHgEpPBJCSClngR/EcZIm+yTZbb04DKIk2afpIYpiP4QqCqM4CEGiOI6UprHnvWNcK7PtrpeOtVwvTde0t5a9NW84/toJ1rZna5xN6LxFoHDHXL0taqLN75sXz/2ZXcq8KEpUn4rS2u42Uf4yN55ff63M1W/Lni9eDWNuGAvLNo95djz4bdcr8wmdzuTS9pK1I29BJaID5jLdFX6Q5Vl1KcpznoRL331y9ouUtQMmTdO0ykyaAWy0GR5wdcrYDbIfZdMrOimLQ+0+bTLjxHuJuYAPp8zQzZpPZno/ThAudCm4kMURrX9YuXthnWoeRjlN1h2aYdJPwLTyhJN5gs5MN3+YR5ijkVMy8k4pnUqdSEoEJj3rJJR3c3XF1yuqqmsFqpOyAkVqXyiDDarht+CJmmCluO/1kiBUEYxwXTGKH3AGEIBpOCwco0wr5yq5b9j5UgoB7/BXyOkqxy9xf2Mw92KQX0K7lN4m/C9m/3QihK46yrL8xvwHgEMaMgvgciAAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 05 15 40 55"\n        title=""\n        src="/static/2021-07-05-15-40-55-fe1a25c4b0d62bf2788fbf2f76146412-fee1c.png"\n        srcset="/static/2021-07-05-15-40-55-fe1a25c4b0d62bf2788fbf2f76146412-a67b7.png 200w,\n/static/2021-07-05-15-40-55-fe1a25c4b0d62bf2788fbf2f76146412-0b187.png 400w,\n/static/2021-07-05-15-40-55-fe1a25c4b0d62bf2788fbf2f76146412-fee1c.png 800w,\n/static/2021-07-05-15-40-55-fe1a25c4b0d62bf2788fbf2f76146412-b1a91.png 1200w,\n/static/2021-07-05-15-40-55-fe1a25c4b0d62bf2788fbf2f76146412-604fe.png 1542w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从图中可以看出，我们点击展开了 Main 这个项目，其记录了主线程执行过程中的所有任务。图中灰色的就是一个个任务，每个任务下面还有子任务，其中的 Parse HTML 任务，是把 HTML 解析为 DOM 的任务。值得注意的是，在执行 Parse HTML 的时候，如果遇到 JavaScript 脚本，那么会暂停当前的 HTML 解析而去执行 JavaScript 脚本。</p>\n<p>至于 Performance 工具，在后面的章节中我们还会详细介绍，在这里你只需要建立一个直观的印象就可以了。</p>\n<h2 id="总结"><a href="#%E6%80%BB%E7%BB%93" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总结</h2>\n<ul>\n<li>如果有一些确定好的任务，可以使用一个单线程来按照顺序处理这些任务，这是第一版线程模型。</li>\n<li>要在线程执行过程中接收并处理新的任务，就需要引入循环语句和事件系统，这是第二版线程模型。</li>\n<li>如果要接收其他线程发送过来的任务，就需要引入消息队列，这是第三版线程模型。</li>\n<li>如果其他进程想要发送任务给页面主线程，那么先通过 IPC 把任务发送给渲染进程的 IO 线程，IO 线程再把任务发送给页面主线程。</li>\n<li>消息队列机制并不是太灵活，为了适应效率和实时性，引入了微任务</li>\n</ul>\n<p>基于消息队列的设计是目前使用最广的消息架构，无论是安卓还是 Chrome 都采用了类似的任务机制，所以理解了本篇文章的内容后，你再理解其他项目的任务机制也会比较轻松。</p>\n<h1 id="webapi：settimeout-是怎么实现的"><a href="#webapi%EF%BC%9Asettimeout-%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Webapi：setTimeout 是怎么实现的</h1>\n<p>本篇文章主要介绍的是 setTimeout。其实说起 setTimeout 方法，从事开发的同学想必都不会陌生，它就是一个定时器，用来指定某个函数在多少毫秒之后执行。它会返回一个整数，表示定时器的编号，同时你还可以通过该编号来取消这个定时器。下面的示例代码就演示了定时器最基础的使用方式：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="99074114387711050000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function showName() {\n  console.log(\'极客时间\');\n}\nvar timerID = setTimeout(showName, 200);`, `99074114387711050000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span> <span class="token function">showName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'极客时间\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">var</span> timerID <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span>showName<span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>执行上述代码，输出的结果也很明显，通过 setTimeout 指定在 200 毫秒之后调用 showName 函数，并输出“极客时间”四个字。</p>\n<p>简单了解了 setTimeout 的使用方法后，那接下来我们就来看看浏览器是如何实现定时器的，然后再介绍下定时器在使用过程中的一些注意事项</p>\n<h2 id="浏览器怎么实现-settimeout"><a href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0-settimeout" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>浏览器怎么实现 setTimeout</h2>\n<p>要了解定时器的工作原理，就得先来回顾下之前讲的事件循环系统，我们知道渲染进程中所有运行在主线程上的任务都需要先添加到消息队列，然后事件循环系统再按照顺序执行消息队列中的任务。下面我们来看看那些典型的事件</p>\n<ul>\n<li>当接收到 HTML 文档数据，渲染引擎就会将“解析 DOM”事件添加到消息队列中，</li>\n<li>当用户改变了 Web 页面的窗口大小，渲染引擎就会将“重新布局”的事件添加到消息队列中。</li>\n<li>当触发了 JavaScript 引擎垃圾回收机制，渲染引擎会将“垃圾回收”任务添加到消息队列中。</li>\n<li>同样，如果要执行一段异步 JavaScript 代码，也是需要将执行任务添加到消息队列中</li>\n</ul>\n<p>以上列举的只是一小部分事件，这些事件被添加到消息队列之后，事件循环系统就会按照消息队列中的顺序来执行事件。</p>\n<p>所以说要执行一段异步任务，需要先将任务添加到消息队列中。不过通过定时器设置回调函数有点特别，它们需要在指定的时间间隔内被调用，但消息队列中的任务是按照顺序执行的，所以为了保证回调函数能在指定时间内执行，你不能将定时器的回调函数直接添加到消息队列中。</p>\n<p>那么该怎么设计才能让定时器设置的回调事件在规定时间内被执行呢？你也可以思考下，如果让你在消息循环系统的基础之上加上定时器的功能，你会如何设计？</p>\n<p>在 Chrome 中除了正常使用的消息队列之外，还有另外一个消息队列，这个队列中维护了需要延迟执行的任务列表，包括了定时器和 Chromium 内部一些需要延迟执行的任务。所以当通过 JavaScript 创建一个定时器时，渲染进程会将该定时器的回调任务添加到延迟队列中</p>\n<p>源码中延迟执行队列的定义如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="84595980445958570000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`DelayedIncomingQueue delayed_incoming_queue;`, `84595980445958570000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                cpp 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="cpp"><pre style="counter-reset: linenumber NaN" class="language-cpp line-numbers"><code class="language-cpp">DelayedIncomingQueue delayed_incoming_queue<span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>当通过 JavaScript 调用 setTimeout 设置回调函数的时候，渲染进程将会创建一个回调任务，包含了回调函数 showName、当前发起时间、延迟执行时间，其模拟代码如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="52528996960828424000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`struct DelayTask{\n  int64 id；\n  CallBackFunction cbf;\n  int start_time;\n  int delay_time;\n};\nDelayTask timerTask;\ntimerTask.cbf = showName;\ntimerTask.start_time = getCurrentTime(); // 获取当前时间\ntimerTask.delay_time = 200; // 设置延迟执行时间`, `52528996960828424000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                cpp 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="cpp"><pre style="counter-reset: linenumber NaN" class="language-cpp line-numbers"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">DelayTask</span><span class="token punctuation">{</span>\n  int64 id；\n  CallBackFunction cbf<span class="token punctuation">;</span>\n  <span class="token keyword">int</span> start_time<span class="token punctuation">;</span>\n  <span class="token keyword">int</span> delay_time<span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\nDelayTask timerTask<span class="token punctuation">;</span>\ntimerTask<span class="token punctuation">.</span>cbf <span class="token operator">=</span> showName<span class="token punctuation">;</span>\ntimerTask<span class="token punctuation">.</span>start_time <span class="token operator">=</span> <span class="token function">getCurrentTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取当前时间</span>\ntimerTask<span class="token punctuation">.</span>delay_time <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span> <span class="token comment">// 设置延迟执行时间</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>创建好回调任务之后，再将该任务添加到延迟执行队列中，代码如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="85238204109529020000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`delayed_incoming_queue.push(timerTask);`, `85238204109529020000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                cpp 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="cpp"><pre style="counter-reset: linenumber NaN" class="language-cpp line-numbers"><code class="language-cpp">delayed_incoming_queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>timerTask<span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>现在通过定时器发起的任务就被保存到延迟队列中了，那接下来我们再来看看消息循环系统是怎么触发延迟队列的。</p>\n<p>我们可以来完善上一篇文章中消息循环的代码，在其中加入执行延迟队列的代码，如下所示</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="89510031744191250000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`void ProcessTimerTask(){\n  // 从 delayed_incoming_queue 中取出已经到期的定时器任务\n  // 依次执行这些任务\n}\n\nTaskQueue task_queue；\nvoid ProcessTask();\nbool keep_running = true;\nvoid MainTherad(){\n  for(;;){\n    // 执行消息队列中的任务\n    Task task = task_queue.takeTask();\n    ProcessTask(task);\n\n    // 执行延迟队列中的任务\n    ProcessDelayTask()\n\n    if(!keep_running) // 如果设置了退出标志，那么直接退出线程循环\n        break;\n  }\n}`, `89510031744191250000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                cpp 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="cpp"><pre style="counter-reset: linenumber NaN" class="language-cpp line-numbers"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">ProcessTimerTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n  <span class="token comment">// 从 delayed_incoming_queue 中取出已经到期的定时器任务</span>\n  <span class="token comment">// 依次执行这些任务</span>\n<span class="token punctuation">}</span>\n\nTaskQueue task_queue；\n<span class="token keyword">void</span> <span class="token function">ProcessTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">bool</span> keep_running <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n<span class="token keyword">void</span> <span class="token function">MainTherad</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n    <span class="token comment">// 执行消息队列中的任务</span>\n    Task task <span class="token operator">=</span> task_queue<span class="token punctuation">.</span><span class="token function">takeTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token function">ProcessTask</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    <span class="token comment">// 执行延迟队列中的任务</span>\n    <span class="token function">ProcessDelayTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n\n    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>keep_running<span class="token punctuation">)</span> <span class="token comment">// 如果设置了退出标志，那么直接退出线程循环</span>\n        <span class="token keyword">break</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>从上面代码可以看出来，我们添加了一个 ProcessDelayTask 函数，该函数是专门用来处理延迟执行任务的。这里我们要重点关注它的执行时机，在上段代码中，处理完消息队列中的一个任务之后，就开始执行 ProcessDelayTask 函数。ProcessDelayTask 函数会根据发起时间和延迟时间计算出到期的任务，然后依次执行这些到期的任务。等到期的任务执行完成之后，再继续下一个循环过程。通过这样的方式，一个完整的定时器就实现了。</p>\n<p>设置一个定时器，JavaScript 引擎会返回一个定时器的 ID。那通常情况下，当一个定时器的任务还没有被执行的时候，也是可以取消的，具体方法是调用 clearTimeout 函数，并传入需要取消的定时器的 ID。如下面代码所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="19548283328464056000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`clearTimeout(timer_id)`, `19548283328464056000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                cpp 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="cpp"><pre style="counter-reset: linenumber NaN" class="language-cpp line-numbers"><code class="language-cpp"><span class="token function">clearTimeout</span><span class="token punctuation">(</span>timer_id<span class="token punctuation">)</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>其实浏览器内部实现取消定时器的操作也是非常简单的，就是直接从 <code class="language-text">delayed_incoming_queue</code> 延迟队列中，通过 ID 查找到对应的任务，然后再将其从队列中删除掉就可以了。</p>\n<h2 id="使用-settimeout-的一些注意事项"><a href="#%E4%BD%BF%E7%94%A8-settimeout-%E7%9A%84%E4%B8%80%E4%BA%9B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>使用 setTimeout 的一些注意事项</h2>\n<p>现在你应该知道在浏览器内部定时器是如何工作的了。不过在使用定时器的过程中，如果你不了解定时器的一些细节，那么很有可能掉进定时器的一些陷阱里。所以接下来，我们就来讲解一下在使用定时器过程中存在的那些陷阱。</p>\n<h3 id="如果当前任务执行时间过久，会影延迟到期定时器任务的执行"><a href="#%E5%A6%82%E6%9E%9C%E5%BD%93%E5%89%8D%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C%E6%97%B6%E9%97%B4%E8%BF%87%E4%B9%85%EF%BC%8C%E4%BC%9A%E5%BD%B1%E5%BB%B6%E8%BF%9F%E5%88%B0%E6%9C%9F%E5%AE%9A%E6%97%B6%E5%99%A8%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%89%A7%E8%A1%8C" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>如果当前任务执行时间过久，会影延迟到期定时器任务的执行</h3>\n<p>在使用 setTimeout 的时候，有很多因素会导致回调函数执行比设定的预期值要久，其中一个就是当前任务执行时间过久从而导致定时器设置的任务被延后执行。我们先看下面这段代码：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="18080992972020015000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function bar() {\n  console.log(\'bar\');\n}\nfunction foo() {\n  setTimeout(bar, 0);\n  for (let i = 0; i < 5000; i++) {\n    let i = 5 + 8 + 8 + 8;\n    console.log(i);\n  }\n}\nfoo();`, `18080992972020015000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'bar\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token function">setTimeout</span><span class="token punctuation">(</span>bar<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">5</span> <span class="token operator">+</span> <span class="token number">8</span> <span class="token operator">+</span> <span class="token number">8</span> <span class="token operator">+</span> <span class="token number">8</span><span class="token punctuation">;</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>这段代码中，在执行 foo 函数的时候使用 setTimeout 设置了一个 0 延时的回调任务，设置好回调任务后，foo 函数会继续执行 5000 次 for 循环。</p>\n<p>通过 setTimeout 设置的回调任务被放入了消息队列中并且等待下一次执行，这里并不是立即执行的；要执行消息队列中的下个任务，需要等待当前的任务执行完成，由于当前这段代码要执行 5000 次的 for 循环，所以当前这个任务的执行时间会比较久一点。这势必会影响到下个任务的执行时间。</p>\n<p>你也可以打开 Performance 来看看其执行过程，如下图所示：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-06-15-26-14-7bb0e7e6c04df25dfd7d09d82763354e-44aed.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 49.67741935483871%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAByElEQVQoz2P4+fPn9eu3rl69ef3Grdu3boMAiLyDYCMEQeSdO3dv37n7/fuP////Mzx9+qS5Mm1ye25LdYZfoI+vv7ePn5dfgI+3r6dvgA+QDRTxAzOAsj7+Xt7eTh4uVjdv3gBpfv78eUtTXXdnc3NTXVJyckxsTFx8XExsbGx8XGwcCMXEAYViQWygeHREZu2kggmb7z96BtJ85+5deUUlAUFhYRFRCQkJSTCQgpBgIAkFUlIycqJCvIHVqzNWfrxxD6z5xYtXNeU1jfVNLa2dza3dTS2dDc0dDc0gsh6EOoGosbWrqamtqbG5trLeIrBE2TLm0tVbIM2vX32YWDtxdsfUOR1TZ7VNWtI3e/30JWsmL1g3bcnWOcu2zVywbvLsxd2T53ROW9Azc3L9NE1DVyF583MXwX7+9v3nsTPXjpy6evj4xcNHzx09fuH4iUsnTl48eOxy46Lz1XNOlc062bX05LGTlw6funr01JVzF66du3j969dvIM3/cYP2fb9il31PXPmjbe9vIPffP3QFIM1/0QFU1emHv3de/7n7xs9TD37++4dFBRabf//+/fbt21evXn399Pbzu5ffPr398/s7VqcBACg8m/5TKF3FAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 06 15 26 14"\n        title=""\n        src="/static/2021-07-06-15-26-14-7bb0e7e6c04df25dfd7d09d82763354e-fee1c.png"\n        srcset="/static/2021-07-06-15-26-14-7bb0e7e6c04df25dfd7d09d82763354e-a67b7.png 200w,\n/static/2021-07-06-15-26-14-7bb0e7e6c04df25dfd7d09d82763354e-0b187.png 400w,\n/static/2021-07-06-15-26-14-7bb0e7e6c04df25dfd7d09d82763354e-fee1c.png 800w,\n/static/2021-07-06-15-26-14-7bb0e7e6c04df25dfd7d09d82763354e-b1a91.png 1200w,\n/static/2021-07-06-15-26-14-7bb0e7e6c04df25dfd7d09d82763354e-44aed.png 1550w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从图中可以看到，执行 foo 函数所消耗的时长是 500 毫秒，这也就意味着通过 setTimeout 设置的任务会被推迟到 500 毫秒以后再去执行，而设置 setTimeout 的回调延迟时间是 0。</p>\n<h3 id="如果-settimeout-存在嵌套调用，那么系统会设置最短时间间隔为-4-毫秒"><a href="#%E5%A6%82%E6%9E%9C-settimeout-%E5%AD%98%E5%9C%A8%E5%B5%8C%E5%A5%97%E8%B0%83%E7%94%A8%EF%BC%8C%E9%82%A3%E4%B9%88%E7%B3%BB%E7%BB%9F%E4%BC%9A%E8%AE%BE%E7%BD%AE%E6%9C%80%E7%9F%AD%E6%97%B6%E9%97%B4%E9%97%B4%E9%9A%94%E4%B8%BA-4-%E6%AF%AB%E7%A7%92" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>如果 setTimeout 存在嵌套调用，那么系统会设置最短时间间隔为 4 毫秒</h3>\n<p>也就是说在定时器函数里面嵌套调用定时器，也会延长定时器的执行时间，可以先看下面的这段代码：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="76011835488694120000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function cb() {\n  setTimeout(cb, 0);\n}\nsetTimeout(cb, 0);`, `76011835488694120000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span> <span class="token function">cb</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token function">setTimeout</span><span class="token punctuation">(</span>cb<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token function">setTimeout</span><span class="token punctuation">(</span>cb<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>上述这段代码你有没有看出存在什么问题？</p>\n<p>你还是可以通过 Performance 来记录下这段代码的执行过程，如下图所示</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-06-15-27-09-d3fa068a4d0d5ef6fc33dae934bd357a-68b8a.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 40.07537688442211%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAIAAAB2/0i6AAAACXBIWXMAAA7DAAAOwwHHb6hkAAABiUlEQVQY03WOS0sCURiG3RWmEmnM1JyZ0+Ro2lTaLpK8T7eFLU1nnEydGaVVkxIUBFbQHxCidbZo2T8SpTLX3SB1OmcWbqKXh4/nfPB+HMv9Q3M/KxYVNZ3JlhRV0crp/cxhoahqlUxWlOV8uXIk5mRRyqnlinyQz4iSomrdt65hGJZ6/dLucLjdHAVoFAjnTGGQAEAjIIRogYRhIIKiAMuyrVYLl8+vGgQXWllP0XyC9EbhsuAObsKlJM0n6cUE5Y8TnijpjSEB/gRe8klvINZ9fcbls+vbMXKNDe6SC8IUlyB8woxfcHFJlwchoOnkMNOmT3sFp0eAfOzluYPLFzd347Oh+dU9wO8Svi2K3yF9W6R/e8ZkJCMnFrbRvzods3xab1hsAXRyko1bwYaDidroyAQI25iwnYlgp/HEMBG0sYKIiw21221cbj4+pdLagVqTinpOrcpaTSzoUqkqK9UconQiFhE6Qirp5lPPq8e9Xg+XjT8ZDAbfXx9fn+/9/o8x7BvG0Pgnv/cXvdBpUYdPAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 06 15 27 09"\n        title=""\n        src="/static/2021-07-06-15-27-09-d3fa068a4d0d5ef6fc33dae934bd357a-fee1c.png"\n        srcset="/static/2021-07-06-15-27-09-d3fa068a4d0d5ef6fc33dae934bd357a-a67b7.png 200w,\n/static/2021-07-06-15-27-09-d3fa068a4d0d5ef6fc33dae934bd357a-0b187.png 400w,\n/static/2021-07-06-15-27-09-d3fa068a4d0d5ef6fc33dae934bd357a-fee1c.png 800w,\n/static/2021-07-06-15-27-09-d3fa068a4d0d5ef6fc33dae934bd357a-b1a91.png 1200w,\n/static/2021-07-06-15-27-09-d3fa068a4d0d5ef6fc33dae934bd357a-68b8a.png 1592w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>上图中的竖线就是定时器的函数回调过程，从图中可以看出，前面五次调用的时间间隔比较小，嵌套调用超过五次以上，后面每次的调用最小时间间隔是 4 毫秒。之所以出现这样的情况，是因为在 Chrome 中，定时器被嵌套调用 5 次以上，系统会判断该函数方法被阻塞了，如果定时器的调用时间间隔小于 4 毫秒，那么浏览器会将每次调用的时间间隔设置为 4 毫秒。下面是 Chromium 实现 4 毫秒延迟的代码，你可以看下：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="29013476552235717000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`static const int kMaxTimerNestingLevel = 5;\n\n// Chromium uses a minimum timer interval of 4ms. We\'d like to go\n// lower; however, there are poorly coded websites out there which do\n// create CPU-spinning loops.  Using 4ms prevents the CPU from\n// spinning too busily and provides a balance between CPU spinning and\n// the smallest possible interval timer.\nstatic constexpr base::TimeDelta kMinimumInterval = base::TimeDelta::FromMilliseconds(4);`, `29013476552235717000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                cpp 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="cpp"><pre style="counter-reset: linenumber NaN" class="language-cpp line-numbers"><code class="language-cpp"><span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> kMaxTimerNestingLevel <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>\n\n<span class="token comment">// Chromium uses a minimum timer interval of 4ms. We\'d like to go</span>\n<span class="token comment">// lower; however, there are poorly coded websites out there which do</span>\n<span class="token comment">// create CPU-spinning loops.  Using 4ms prevents the CPU from</span>\n<span class="token comment">// spinning too busily and provides a balance between CPU spinning and</span>\n<span class="token comment">// the smallest possible interval timer.</span>\n<span class="token keyword">static</span> <span class="token keyword">constexpr</span> base<span class="token operator">::</span>TimeDelta kMinimumInterval <span class="token operator">=</span> base<span class="token operator">::</span>TimeDelta<span class="token operator">::</span><span class="token function">FromMilliseconds</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="24697145563853406000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`base::TimeDelta interval_milliseconds =\n      std::max(base::TimeDelta::FromMilliseconds(1), interval);\n\n  if (interval_milliseconds < kMinimumInterval &&\n      nesting_level_ >= kMaxTimerNestingLevel)\n    interval_milliseconds = kMinimumInterval;\n\n  if (single_shot)\n    StartOneShot(interval_milliseconds, FROM_HERE);\n  else\n    StartRepeating(interval_milliseconds, FROM_HERE);`, `24697145563853406000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                cpp 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="cpp"><pre style="counter-reset: linenumber NaN" class="language-cpp line-numbers"><code class="language-cpp">base<span class="token operator">::</span>TimeDelta interval_milliseconds <span class="token operator">=</span>\n      std<span class="token operator">::</span><span class="token function">max</span><span class="token punctuation">(</span>base<span class="token operator">::</span>TimeDelta<span class="token operator">::</span><span class="token function">FromMilliseconds</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> interval<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>interval_milliseconds <span class="token operator">&lt;</span> kMinimumInterval <span class="token operator">&amp;&amp;</span>\n      nesting_level_ <span class="token operator">>=</span> kMaxTimerNestingLevel<span class="token punctuation">)</span>\n    interval_milliseconds <span class="token operator">=</span> kMinimumInterval<span class="token punctuation">;</span>\n\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>single_shot<span class="token punctuation">)</span>\n    <span class="token function">StartOneShot</span><span class="token punctuation">(</span>interval_milliseconds<span class="token punctuation">,</span> FROM_HERE<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">else</span>\n    <span class="token function">StartRepeating</span><span class="token punctuation">(</span>interval_milliseconds<span class="token punctuation">,</span> FROM_HERE<span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>所以，一些实时性较高的需求就不太适合使用 setTimeout 了，比如你用 setTimeout 来实现 JavaScript 动画就不是一个很好的主意。</p>\n<h3 id="未激活的页面，settimeout-执行最小间隔是-1000-毫秒"><a href="#%E6%9C%AA%E6%BF%80%E6%B4%BB%E7%9A%84%E9%A1%B5%E9%9D%A2%EF%BC%8Csettimeout-%E6%89%A7%E8%A1%8C%E6%9C%80%E5%B0%8F%E9%97%B4%E9%9A%94%E6%98%AF-1000-%E6%AF%AB%E7%A7%92" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>未激活的页面，setTimeout 执行最小间隔是 1000 毫秒</h3>\n<p>除了前面的 4 毫秒延迟，还有一个很容易被忽略的地方，那就是未被激活的页面中定时器最小值大于 1000 毫秒，也就是说，如果标签不是当前的激活标签，那么定时器最小的时间间隔是 1000 毫秒，目的是为了优化后台页面的加载损耗以及降低耗电量。这一点你在使用定时器的时候要注意。</p>\n<h3 id="延时执行时间有最大值"><a href="#%E5%BB%B6%E6%97%B6%E6%89%A7%E8%A1%8C%E6%97%B6%E9%97%B4%E6%9C%89%E6%9C%80%E5%A4%A7%E5%80%BC" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>延时执行时间有最大值</h3>\n<p>除了要了解定时器的回调函数时间比实际设定值要延后之外，还有一点需要注意下，那就是 Chrome、Safari、Firefox 都是以 32 个 bit 来存储延时值的，32bit 最大只能存放的数字是 2147483647 毫秒，这就意味着，如果 setTimeout 设置的延迟值大于 2147483647 毫秒（大约 24.8 天）时就会溢出，这导致定时器会被立即执行。你可以运行下面这段代码：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="10628466206646682000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function showName() {\n  console.log(\'极客时间\');\n}\nvar timerID = setTimeout(showName, 2147483648); // 会被理解调用执行`, `10628466206646682000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span> <span class="token function">showName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'极客时间\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">var</span> timerID <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span>showName<span class="token punctuation">,</span> <span class="token number">2147483648</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 会被理解调用执行</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>运行后可以看到，这段代码是立即被执行的。但如果将延时值修改为小于 2147483647 毫秒的某个值，那么执行时就没有问题了。</p>\n<h3 id="使用-settimeout-设置的回调函数中的-this-不符合直觉"><a href="#%E4%BD%BF%E7%94%A8-settimeout-%E8%AE%BE%E7%BD%AE%E7%9A%84%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84-this-%E4%B8%8D%E7%AC%A6%E5%90%88%E7%9B%B4%E8%A7%89" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>使用 setTimeout 设置的回调函数中的 this 不符合直觉</h3>\n<p>如果被 setTimeout 推迟执行的回调函数是某个对象的方法，那么该方法中的 this 关键字将指向全局环境，而不是定义时所在的那个对象。这点在前面介绍 this 的时候也提过，你可以看下面这段代码的执行结果：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="88064492062092410000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`var name = 1;\nvar MyObj = {\n  name: 2,\n  showName: function() {\n    console.log(this.name);\n  }\n};\nsetTimeout(MyObj.showName, 1000);`, `88064492062092410000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>\n<span class="token keyword">var</span> MyObj <span class="token operator">=</span> <span class="token punctuation">{</span>\n  name<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span>\n  <span class="token function-variable function">showName</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token function">setTimeout</span><span class="token punctuation">(</span>MyObj<span class="token punctuation">.</span>showName<span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>这里输出的是 1，因为这段代码在编译的时候，执行上下文中的 this 会被设置为全局 window，如果是严格模式，会被设置为 undefined。</p>\n<p>那么该怎么解决这个问题呢？通常可以使用下面这两种方法。</p>\n<p>第一种是将 MyObj.showName 放在匿名函数中执行，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="15135900741048648000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// 箭头函数\nsetTimeout(() => {\n  MyObj.showName();\n}, 1000);\n// 或者 function 函数\nsetTimeout(function() {\n  MyObj.showName();\n}, 1000);`, `15135900741048648000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">// 箭头函数</span>\n<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  MyObj<span class="token punctuation">.</span><span class="token function">showName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token comment">// 或者 function 函数</span>\n<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  MyObj<span class="token punctuation">.</span><span class="token function">showName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>第二种是使用 bind 方法，将 showName 绑定在 MyObj 上面，代码如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="56112384213191180000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`setTimeout(MyObj.showName.bind(MyObj), 1000);`, `56112384213191180000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token function">setTimeout</span><span class="token punctuation">(</span>MyObj<span class="token punctuation">.</span><span class="token function">showName</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>MyObj<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<h2 id="总结-1"><a href="#%E6%80%BB%E7%BB%93-1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总结</h2>\n<ul>\n<li>首先，为了支持定时器的实现，浏览器增加了延时队列。</li>\n<li>其次，由于消息队列排队和一些系统级别的限制，通过 setTimeout 设置的回调任务并非总是可以实时地被执行，这样就不能满足一些实时性要求较高的需求了。</li>\n<li>最后，在定时器中使用过程中，还存在一些陷阱，需要你多加注意。</li>\n</ul>\n<p>通过分析和讲解，你会发现函数 setTimeout 在时效性上面有很多先天的不足，所以对于一些时间精度要求比较高的需求，应该有针对性地采取一些其他的方案</p>\n<h1 id="webapi：xmlhttprequest-是怎么实现的"><a href="#webapi%EF%BC%9Axmlhttprequest-%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Webapi：XMLHttpRequest 是怎么实现的</h1>\n<p>自从网页中引入了 JavaScript，我们就可以操作 DOM 树中任意一个节点，例如隐藏/显示节点、改变颜色、获得或改变文本内容、为元素添加事件响应函数等等，几乎可以“为所欲为”了。</p>\n<p>不过在 XMLHttpRequest 出现之前，如果服务器数据有更新，依然需要重新刷新整个页面。而 XMLHttpRequest 提供了从 Web 服务器获取数据的能力，如果你想要更新某条数据，只需要通过 XMLHttpRequest 请求服务器提供的接口，就可以获取到服务器的数据，然后再操作 DOM 来更新页面内容，整个过程只需要更新网页的一部分就可以了，而不用像之前那样还得刷新整个页面，这样既有效率又不会打扰到用户。</p>\n<p>关于 XMLHttpRequest，本来我是想一带而过的，后来发现这个 WebAPI 用于教学非常好。首先前面讲了那么网络内容，现在可以通过它把 HTTP 协议实践一遍；其次，XMLHttpRequest 是一个非常典型的 WebAPI，通过它来讲解浏览器是如何实现 WebAPI 的很合适，这对于你理解其他 WebAPI 也有非常大的帮助，同时在这个过程中我们还可以把一些安全问题给串起来。</p>\n<p>但在深入讲解 XMLHttpRequest 之前，我们得先介绍下同步回调和异步回调这两个概念，这会帮助你更加深刻地理解 WebAPI 是怎么工作的</p>\n<h2 id="回调函数-vs-系统调用栈"><a href="#%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0-vs-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%A0%88" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>回调函数 VS 系统调用栈</h2>\n<p>那什么是回调函数呢（Callback Function）？</p>\n<p>将一个函数作为参数传递给另外一个函数，那作为参数的这个函数就是回调函数。简化的代码如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="10514541727159600000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`let callback = function() {\n  console.log(\'i am do homework\');\n};\nfunction doWork(cb) {\n  console.log(\'start do work\');\n  cb();\n  console.log(\'end do work\');\n}\ndoWork(callback);`, `10514541727159600000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">let</span> <span class="token function-variable function">callback</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'i am do homework\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token keyword">function</span> <span class="token function">doWork</span><span class="token punctuation">(</span><span class="token parameter">cb</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'start do work\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token function">cb</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'end do work\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token function">doWork</span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>在上面示例代码中，我们将一个匿名函数赋值给变量 callback，同时将 callback 作为参数传递给了 doWork() 函数，这时在函数 doWork() 中 callback 就是回调函数。</p>\n<p>上面的回调方法有个特点，就是回调函数 callback 是在主函数 doWork 返回之前执行的，我们把这个回调过程称为同步回调。</p>\n<p>既然有同步回调，那肯定也有异步回调。下面我们再来看看异步回调的例子：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="28982796989499593000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`let callback = function() {\n  console.log(\'i am do homework\');\n};\nfunction doWork(cb) {\n  console.log(\'start do work\');\n  setTimeout(cb, 1000);\n  console.log(\'end do work\');\n}\ndoWork(callback);`, `28982796989499593000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">let</span> <span class="token function-variable function">callback</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'i am do homework\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token keyword">function</span> <span class="token function">doWork</span><span class="token punctuation">(</span><span class="token parameter">cb</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'start do work\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token function">setTimeout</span><span class="token punctuation">(</span>cb<span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'end do work\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token function">doWork</span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>在这个例子中，我们使用了 setTimeout 函数让 callback 在 doWork 函数执行结束后，又延时了 1 秒再执行，这次 callback 并没有在主函数 doWork 内部被调用，我们把这种回调函数在主函数外部执行的过程称为异步回调。</p>\n<p>现在你应该知道什么是同步回调和异步回调了，那下面我们再深入点，站在消息循环的视角来看看同步回调和异步回调的区别。理解了这些，可以让你从本质上理解什么是回调。</p>\n<p>你应该已经知道浏览器页面是通过事件循环机制来驱动的，每个渲染进程都有一个消息队列，页面主线程按照顺序来执行消息队列中的事件，如执行 JavaScript 事件、解析 DOM 事件、计算布局事件、用户输入事件等等，如果页面有新的事件产生，那新的事件将会追加到事件队列的尾部。所以可以说是消息队列和主线程循环机制保证了页面有条不紊地运行。</p>\n<p>这里还需要补充一点，那就是当循环系统在执行一个任务的时候，都要为这个任务维护一个系统调用栈。这个系统调用栈类似于 JavaScript 的调用栈，只不过系统调用栈是 Chromium 的开发语言 C++ 来维护的，其完整的调用栈信息你可以通过 chrome://tracing/ 来抓取。当然，你也可以通过 Performance 来抓取它核心的调用信息，如下图所示：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-06-17-50-52-6f37242a303832ef121ac1f50821cbde-d868f.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 31.25827814569536%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAIAAABM9SnKAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABEklEQVQY021Pa0/CQBDs//8dRhPRpDFRUlKkFaStpFYD+EoRSMQg0gd9XO/a7a2rxQ8mTvZ2Z2cnm1tFlGXOWMHyIk85SwGElCAlUtS1rGWDH06P9BpriQBArbL+jNULXRtMWvr04Nxr6U+67WuG1TGdnuVeDr2OeaMZdm/oda/vSdf7o+5g1Hf9jAlFVLD0nU2YjOeJPf3wZtlqE78+Gg/jW/Xo2DLt5YtlGe3TQ/V54t45+tlJ+0ozVuudRFSgliWgqOiHSD1l4oDIRbWYv0dhRmKSFovZW5pxXmG0g+02y5kgp4KI+6ukbILcZVkyxugsLjiRCuDXRsNvNEXB/1AULAyDXRyHQRBFkeD873y/4guajEtjKmtvyQAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 06 17 50 52"\n        title=""\n        src="/static/2021-07-06-17-50-52-6f37242a303832ef121ac1f50821cbde-fee1c.png"\n        srcset="/static/2021-07-06-17-50-52-6f37242a303832ef121ac1f50821cbde-a67b7.png 200w,\n/static/2021-07-06-17-50-52-6f37242a303832ef121ac1f50821cbde-0b187.png 400w,\n/static/2021-07-06-17-50-52-6f37242a303832ef121ac1f50821cbde-fee1c.png 800w,\n/static/2021-07-06-17-50-52-6f37242a303832ef121ac1f50821cbde-b1a91.png 1200w,\n/static/2021-07-06-17-50-52-6f37242a303832ef121ac1f50821cbde-d868f.png 1510w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>这幅图记录了一个 Parse HTML 的任务执行过程，其中黄色的条目表示执行 JavaScript 的过程，其他颜色的条目表示浏览器内部系统的执行过程。</p>\n<p>通过该图你可以看出来，Parse HTML 任务在执行过程中会遇到一系列的子过程，比如在解析页面的过程中遇到了 JavaScript 脚本，那么就暂停解析过程去执行该脚本，等执行完成之后，再恢复解析过程。然后又遇到了样式表，这时候又开始解析样式表……直到整个任务执行完成。</p>\n<p>需要说明的是，整个 Parse HTML 是一个完整的任务，在执行过程中的脚本解析、样式表解析都是该任务的子过程，其下拉的长条就是执行过程中调用栈的信息。</p>\n<p>每个任务在执行过程中都有自己的调用栈，那么同步回调就是在当前主函数的上下文中执行回调函数，这个没有太多可讲的。下面我们主要来看看异步回调过程，异步回调是指回调函数在主函数之外执行，一般有两种方式</p>\n<ul>\n<li>第一种是把异步函数做成一个任务，添加到消息队列尾部；</li>\n<li>第二种是把异步函数添加到微任务队列中，这样就可以在当前任务的末尾处执行微任务了</li>\n</ul>\n<h2 id="xmlhttprequest-运作机制"><a href="#xmlhttprequest-%E8%BF%90%E4%BD%9C%E6%9C%BA%E5%88%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>XMLHttpRequest 运作机制</h2>\n<p>理解了什么是同步回调和异步回调，接下来我们就来分析 XMLHttpRequest 背后的实现机制，具体工作过程你可以参考下图：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-06-17-51-21-3b86b8c6f2c0d3d3341a6661100522e4-b0aef.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 57.42574257425742%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABmElEQVQoz3VS227bMAzNJ/Vhv7S/6QcMfeg/JMjzsA4Dhr20WNJla2pnTerUjWMpsq37hRztFF2BoAeUQFA8PJSoESICQOoRaZE/RFKMiaLDIQ4Gx6O3GFHIWuu8TzFA9HX1XDxuqtZBCkz6VW2CD1o7qZTUzrn4tkRPVko3gvGGc4u7xnzL5XSZ8r19Enp8y0AyI0UK7lW/d17JUqq62uZlOdvjHYfxEqdLWFTpScbJnYqqicFjUnjaNt3TDn2n4KNVySlt7I/FWh/2GY/j3y0lzXZwdd8WwiOGnKWrh7QR8KLcdh0ry2w+v5nN89XfLMtuZz/N83ZRNJNfnJI+TvyHC3fxXaDZnn9pzj65y+vwX5meohG8Ltecs7re1axGr+8rPf3Tuo7fFPZrbtZ7iWBzDqS8PioTmZj9eKxGKVAJlAeQB/Td6mDHpBy6BBrR4QlelPudM1MUpixN8WiqCqPftPB5pahsBEzDUw9fYPCPZFohBBKnUTvqfzBPoPl6H0PA9zE6DZGC1lrR9LWmpqSUnHOqdpr5D9Ztc8a8+Ms6AAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 06 17 51 21"\n        title=""\n        src="/static/2021-07-06-17-51-21-3b86b8c6f2c0d3d3341a6661100522e4-fee1c.png"\n        srcset="/static/2021-07-06-17-51-21-3b86b8c6f2c0d3d3341a6661100522e4-a67b7.png 200w,\n/static/2021-07-06-17-51-21-3b86b8c6f2c0d3d3341a6661100522e4-0b187.png 400w,\n/static/2021-07-06-17-51-21-3b86b8c6f2c0d3d3341a6661100522e4-fee1c.png 800w,\n/static/2021-07-06-17-51-21-3b86b8c6f2c0d3d3341a6661100522e4-b1a91.png 1200w,\n/static/2021-07-06-17-51-21-3b86b8c6f2c0d3d3341a6661100522e4-b0aef.png 1414w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>这是 XMLHttpRequest 的总执行流程图，下面我们就来分析从发起请求到接收数据的完整流程。</p>\n<p>我们先从 XMLHttpRequest 的用法开始，首先看下面这样一段请求代码：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="14200472077575578000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function GetWebData(URL) {\n  /**\n   * 1: 新建 XMLHttpRequest 请求对象\n   */\n  let xhr = new XMLHttpRequest();\n\n  /**\n   * 2: 注册相关事件回调处理函数\n   */\n  xhr.onreadystatechange = function() {\n    switch (xhr.readyState) {\n      case 0: // 请求未初始化\n        console.log(\'请求未初始化\');\n        break;\n      case 1: // OPENED\n        console.log(\'OPENED\');\n        break;\n      case 2: // HEADERS_RECEIVED\n        console.log(\'HEADERS_RECEIVED\');\n        break;\n      case 3: // LOADING\n        console.log(\'LOADING\');\n        break;\n      case 4: // DONE\n        if (this.status == 200 || this.status == 304) {\n          console.log(this.responseText);\n        }\n        console.log(\'DONE\');\n        break;\n    }\n  };\n\n  xhr.ontimeout = function(e) {\n    console.log(\'ontimeout\');\n  };\n  xhr.onerror = function(e) {\n    console.log(\'onerror\');\n  };\n\n  /**\n   * 3: 打开请求\n   */\n  xhr.open(\'Get\', URL, true); // 创建一个 Get 请求, 采用异步\n\n  /**\n   * 4: 配置参数\n   */\n  xhr.timeout = 3000; // 设置 xhr 请求的超时时间\n  xhr.responseType = \'text\'; // 设置响应返回的数据格式\n  xhr.setRequestHeader(\'X_TEST\', \'time.geekbang\');\n\n  /**\n   * 5: 发送请求\n   */\n  xhr.send();\n}`, `14200472077575578000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span> <span class="token function">GetWebData</span><span class="token punctuation">(</span><span class="token parameter"><span class="token constant">URL</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">/**\n   * 1: 新建 XMLHttpRequest 请求对象\n   */</span>\n  <span class="token keyword">let</span> xhr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token comment">/**\n   * 2: 注册相关事件回调处理函数\n   */</span>\n  xhr<span class="token punctuation">.</span><span class="token function-variable function">onreadystatechange</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">switch</span> <span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>readyState<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">case</span> <span class="token number">0</span><span class="token punctuation">:</span> <span class="token comment">// 请求未初始化</span>\n        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'请求未初始化\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">break</span><span class="token punctuation">;</span>\n      <span class="token keyword">case</span> <span class="token number">1</span><span class="token punctuation">:</span> <span class="token comment">// OPENED</span>\n        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'OPENED\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">break</span><span class="token punctuation">;</span>\n      <span class="token keyword">case</span> <span class="token number">2</span><span class="token punctuation">:</span> <span class="token comment">// HEADERS_RECEIVED</span>\n        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'HEADERS_RECEIVED\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">break</span><span class="token punctuation">;</span>\n      <span class="token keyword">case</span> <span class="token number">3</span><span class="token punctuation">:</span> <span class="token comment">// LOADING</span>\n        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'LOADING\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">break</span><span class="token punctuation">;</span>\n      <span class="token keyword">case</span> <span class="token number">4</span><span class="token punctuation">:</span> <span class="token comment">// DONE</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">==</span> <span class="token number">200</span> <span class="token operator">||</span> <span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">==</span> <span class="token number">304</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>responseText<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'DONE\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">break</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n  xhr<span class="token punctuation">.</span><span class="token function-variable function">ontimeout</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'ontimeout\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">;</span>\n  xhr<span class="token punctuation">.</span><span class="token function-variable function">onerror</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'onerror\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n  <span class="token comment">/**\n   * 3: 打开请求\n   */</span>\n  xhr<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">\'Get\'</span><span class="token punctuation">,</span> <span class="token constant">URL</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 创建一个 Get 请求, 采用异步</span>\n\n  <span class="token comment">/**\n   * 4: 配置参数\n   */</span>\n  xhr<span class="token punctuation">.</span>timeout <span class="token operator">=</span> <span class="token number">3000</span><span class="token punctuation">;</span> <span class="token comment">// 设置 xhr 请求的超时时间</span>\n  xhr<span class="token punctuation">.</span>responseType <span class="token operator">=</span> <span class="token string">\'text\'</span><span class="token punctuation">;</span> <span class="token comment">// 设置响应返回的数据格式</span>\n  xhr<span class="token punctuation">.</span><span class="token function">setRequestHeader</span><span class="token punctuation">(</span><span class="token string">\'X_TEST\'</span><span class="token punctuation">,</span> <span class="token string">\'time.geekbang\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token comment">/**\n   * 5: 发送请求\n   */</span>\n  xhr<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>上面是一段利用了 XMLHttpRequest 来请求数据的代码，再结合上面的流程图，我们可以分析下这段代码是怎么执行的</p>\n<h3 id="创建-xmlhttprequest-对象"><a href="#%E5%88%9B%E5%BB%BA-xmlhttprequest-%E5%AF%B9%E8%B1%A1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>创建 XMLHttpRequest 对象</h3>\n<p>当执行到 let xhr = new XMLHttpRequest() 后，JavaScript 会创建一个 XMLHttpRequest 对象 xhr，用来执行实际的网络请求操作。</p>\n<h3 id="为-xhr-对象注册回调函数"><a href="#%E4%B8%BA-xhr-%E5%AF%B9%E8%B1%A1%E6%B3%A8%E5%86%8C%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>为 xhr 对象注册回调函数</h3>\n<p>因为网络请求比较耗时，所以要注册回调函数，这样后台任务执行完成之后就会通过调用回调函数来告诉其执行结果。</p>\n<p>XMLHttpRequest 的回调函数主要有下面几种：</p>\n<ul>\n<li>ontimeout，用来监控超时请求，如果后台请求超时了，该函数会被调用；</li>\n<li>onerror，用来监控出错信息，如果后台请求出错了，该函数会被调用；</li>\n<li>onreadystatechange，用来监控后台请求过程中的状态，比如可以监控到 HTTP 头加载完成的消息、HTTP 响应体消息以及数据加载完成的消息等。</li>\n</ul>\n<h3 id="配置基础的请求信息"><a href="#%E9%85%8D%E7%BD%AE%E5%9F%BA%E7%A1%80%E7%9A%84%E8%AF%B7%E6%B1%82%E4%BF%A1%E6%81%AF" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>配置基础的请求信息</h3>\n<p>注册好回调事件之后，接下来就需要配置基础的请求信息了，首先要通过 open 接口配置一些基础的请求信息，包括请求的地址、请求方法（是 get 还是 post）和请求方式（同步还是异步请求）。</p>\n<p>然后通过 xhr 内部属性类配置一些其他可选的请求信息，你可以参考文中示例代码，我们通过 xhr.timeout = 3000 来配置超时时间，也就是说如果请求超过 3000 毫秒还没有响应，那么这次请求就被判断为失败了。</p>\n<p>我们还可以通过 xhr.responseType = “text” 来配置服务器返回的格式，将服务器返回的数据自动转换为自己想要的格式，如果将 responseType 的值设置为 json，那么系统会自动将服务器返回的数据转换为 JavaScript 对象格式。下面的图表是我列出的一些返回类型的描述：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-06-17-52-35-d6dd01b803d27862029c63d9610c71ea-c7aa5.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 52.40174672489083%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABvUlEQVQoz01Qy27TQBTNFyGhpqxYIvEN8BVIkHTDAj4A/gRiRxVZIbY0qloEDbbr1zw8M/b47dgex+6C6zpApaOrozNz5twzs7I56Fu8uQrWW7K6QKsLPEHbAghgc0XPL+mk3E+ib8nn7zgu1czm+dO35y8/fnv2bjNfrJ6crU/P9HEu9ZOFdvJGe/Hh6/P3Xx6/1uYL7XS5ni91OHr06tOlI2ddp7KMFWVYVUIIx/N2ANO8RsgIApsQUwjPcW+AY2xy7lB667o3GBt9r2ZD39UFHdrwrpNNFUTclNwKmVGmqN2zQzPqg5IwJzLxvgkHMPd9xwOzyHCvZBb7AfkdMiuVnmAWowaQrom6Jnw4D23U7vnRHHG7qfjdIalykiV+keJ9QYsU5SmKhF1mBN4Fw0Oo+q+Zop17+yMOHbCJwJoIIwbFu7pkg4onw33yEdDo2BluZwkCqS4hEAOqnOYJymIviVxYATYqM6zq8N8K/5MDvEulq2qRJ37ErSRyoCqQWNiefY29n4KZnBr7gjQVg7Y9mMfO7ZicSB95vwJiVDlLpZ8nuMgoiOn4f4ZgNihpjFKJeGDBjr1KVB1B8h/Q9gegQgkMNQAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 06 17 52 35"\n        title=""\n        src="/static/2021-07-06-17-52-35-d6dd01b803d27862029c63d9610c71ea-fee1c.png"\n        srcset="/static/2021-07-06-17-52-35-d6dd01b803d27862029c63d9610c71ea-a67b7.png 200w,\n/static/2021-07-06-17-52-35-d6dd01b803d27862029c63d9610c71ea-0b187.png 400w,\n/static/2021-07-06-17-52-35-d6dd01b803d27862029c63d9610c71ea-fee1c.png 800w,\n/static/2021-07-06-17-52-35-d6dd01b803d27862029c63d9610c71ea-b1a91.png 1200w,\n/static/2021-07-06-17-52-35-d6dd01b803d27862029c63d9610c71ea-c7aa5.png 1374w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>假如你还需要添加自己专用的请求头属性，可以通过 xhr.setRequestHeader 来添加。</p>\n<h3 id="发起请求"><a href="#%E5%8F%91%E8%B5%B7%E8%AF%B7%E6%B1%82" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>发起请求</h3>\n<p>一切准备就绪之后，就可以调用 xhr.send 来发起网络请求了。你可以对照上面那张请求流程图，可以看到：渲染进程会将请求发送给网络进程，然后网络进程负责资源的下载，等网络进程接收到数据之后，就会利用 IPC 来通知渲染进程；渲染进程接收到消息之后，会将 xhr 的回调函数封装成任务并添加到消息队列中，等主线程循环系统执行到该任务的时候，就会根据相关的状态来调用对应的回调函数</p>\n<ul>\n<li>如果网络请求出错了，就会执行 xhr.onerror；</li>\n<li>如果超时了，就会执行 xhr.ontimeout；</li>\n<li>如果是正常的数据接收，就会执行 onreadystatechange 来反馈相应的状态。</li>\n</ul>\n<p>这就是一个完整的 XMLHttpRequest 请求流程，如果你感兴趣，可以参考下 Chromium 对 <a href="https://chromium.googlesource.com/chromium/src/+/refs/heads/master/third_party/blink/renderer/core/xmlhttprequest/" target="_blank" rel="nofollow noreferrer noopener">XMLHttpRequest 的实现</a>。</p>\n<h2 id="xmlhttprequest-使用过程中的坑"><a href="#xmlhttprequest-%E4%BD%BF%E7%94%A8%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%9D%91" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>XMLHttpRequest 使用过程中的“坑”</h2>\n<p>上述过程看似简单，但由于浏览器很多安全策略的限制，所以会导致你在使用过程中踩到非常多的“坑”。</p>\n<p>浏览器安全问题是前端工程师避不开的一道坎，通常在使用过程中遇到的“坑”，很大一部分都是由安全策略引起的，不管你喜不喜欢，它都在这里。本来很完美的一个方案，正是由于加了安全限制，导致使用起来非常麻烦。</p>\n<p>而你要做的就是去正视这各种的安全问题。也就是说要想更加完美地使用 XMLHttpRequest，你就要了解浏览器的安全策略。</p>\n<p>下面我们就来看看在使用 XMLHttpRequest 的过程中所遇到的跨域问题和混合内容问题。</p>\n<h3 id="跨域问题"><a href="#%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>跨域问题</h3>\n<p>比如在极客邦的官网使用 XMLHttpRequest 请求极客时间的页面内容，由于极客邦的官网是 www.geekbang.org，极客时间的官网是 time.geekbang.org，它们不是同一个源，所以就涉及到了跨域（在 A 站点中去访问不同源的 B 站点的内容）。默认情况下，跨域请求是不被允许的，你可以看下面的示例代码：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="36435383049948310000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`var xhr = new XMLHttpRequest();\nvar url = \'https://time.geekbang.org/\';\nfunction handler() {\n  switch (xhr.readyState) {\n    case 0: // 请求未初始化\n      console.log(\' 请求未初始化 \');\n      break;\n    case 1: // OPENED\n      console.log(\'OPENED\');\n      break;\n    case 2: // HEADERS_RECEIVED\n      console.log(\'HEADERS_RECEIVED\');\n      break;\n    case 3: // LOADING\n      console.log(\'LOADING\');\n      break;\n    case 4: // DONE\n      if (this.status == 200 || this.status == 304) {\n        console.log(this.responseText);\n      }\n      console.log(\'DONE\');\n      break;\n  }\n}\n\nfunction callOtherDomain() {\n  if (xhr) {\n    xhr.open(\'GET\', url, true);\n    xhr.onreadystatechange = handler;\n    xhr.send();\n  }\n}\ncallOtherDomain();`, `36435383049948310000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">var</span> xhr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">var</span> url <span class="token operator">=</span> <span class="token string">\'https://time.geekbang.org/\'</span><span class="token punctuation">;</span>\n<span class="token keyword">function</span> <span class="token function">handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">switch</span> <span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>readyState<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">case</span> <span class="token number">0</span><span class="token punctuation">:</span> <span class="token comment">// 请求未初始化</span>\n      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\' 请求未初始化 \'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token keyword">break</span><span class="token punctuation">;</span>\n    <span class="token keyword">case</span> <span class="token number">1</span><span class="token punctuation">:</span> <span class="token comment">// OPENED</span>\n      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'OPENED\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token keyword">break</span><span class="token punctuation">;</span>\n    <span class="token keyword">case</span> <span class="token number">2</span><span class="token punctuation">:</span> <span class="token comment">// HEADERS_RECEIVED</span>\n      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'HEADERS_RECEIVED\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token keyword">break</span><span class="token punctuation">;</span>\n    <span class="token keyword">case</span> <span class="token number">3</span><span class="token punctuation">:</span> <span class="token comment">// LOADING</span>\n      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'LOADING\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token keyword">break</span><span class="token punctuation">;</span>\n    <span class="token keyword">case</span> <span class="token number">4</span><span class="token punctuation">:</span> <span class="token comment">// DONE</span>\n      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">==</span> <span class="token number">200</span> <span class="token operator">||</span> <span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">==</span> <span class="token number">304</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>responseText<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'DONE\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token keyword">break</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">function</span> <span class="token function">callOtherDomain</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>xhr<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    xhr<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">\'GET\'</span><span class="token punctuation">,</span> url<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    xhr<span class="token punctuation">.</span>onreadystatechange <span class="token operator">=</span> handler<span class="token punctuation">;</span>\n    xhr<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n<span class="token function">callOtherDomain</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>你可以在控制台测试下。首先通过浏览器打开 www.geekbang.org，然后打开控制台，在控制台输入以上示例代码，再执行，会看到请求被 Block 了。控制台的提示信息如下：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="68140295773522050000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`Access to XMLHttpRequest at \'https://time.geekbang.org/\' from origin \'https://www.geekbang.org\' has been blocked by CORS policy: No \'Access-Control-Allow-Origin\' header is present on the requested resource.`, `68140295773522050000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">Access to XMLHttpRequest at &#39;https://time.geekbang.org/&#39; from origin &#39;https://www.geekbang.org&#39; has been blocked by CORS policy: No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource.</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>因为 www.geekbang.org 和 time.geekbang.com 不属于一个域，所以以上访问就属于跨域访问了，这次访问失败就是由于跨域问题导致的。</p>\n<h3 id="https-混合内容的问题"><a href="#https-%E6%B7%B7%E5%90%88%E5%86%85%E5%AE%B9%E7%9A%84%E9%97%AE%E9%A2%98" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>HTTPS 混合内容的问题</h3>\n<p>了解完跨域问题后，我们再来看看 HTTPS 的混合内容。HTTPS 混合内容是 HTTPS 页面中包含了不符合 HTTPS 安全要求的内容，比如包含了 HTTP 资源，通过 HTTP 加载的图像、视频、样式表、脚本等，都属于混合内容。</p>\n<p>通常，如果 HTTPS 请求页面中使用混合内容，浏览器会针对 HTTPS 混合内容显示警告，用来向用户表明此 HTTPS 页面包含不安全的资源。比如打开站点 <a href="https://www.iteye.com/groups" target="_blank" rel="nofollow noreferrer noopener">https://www.iteye.com/groups</a> ，可以通过控制台看到混合内容的警告，参考下图：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-06-17-55-02-6993958a4ad8300358f3b888530c3d6b-4be21.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 37.532467532467535%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAIAAAB2/0i6AAAACXBIWXMAAA7DAAAOwwHHb6hkAAABZUlEQVQY03WO2XKjMBRE+f+PSqqCx8bYGLMYs4lVYg+SzNixkQSB5HXm1Klbdbv6oaUXJQ9MXhQ/SbdKP79wN97wIhsIG/CvfCD8L10S8bjxOx0HMgkmVVc59/ddplexVkYaBFoeHjNfTT0VhUcEDk2q98j8hEabalV0uNVOX9hlqPKhk0h+yC5vDVBqoBTBDnp/KqAml48yUFJHht4WmO/Aei9DBcNTn2tDZTXJCUNdvKiEmyT0zCJzqtxGiZUAI4st4GkwsdYQeVlkxuG5Kbw7ze4kGx81JXCg+SSeUhudgL6pfRU5culuc2cHDDky5NjapPY2NjfoqsDrrvL3eNkfazg91+GxDfY/s10dGbvSNdDl1AGnCew6uNSBXSxzXBM559I1K9+q19xuQruL1k4b2OIxSHxkgnHO+HpH9iMXXExczGKepnme5t8CG9kCX2vru+TS/C+ezy9Kad/3bdsszP/hG/Hrsj26RDttAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 06 17 55 02"\n        title=""\n        src="/static/2021-07-06-17-55-02-6993958a4ad8300358f3b888530c3d6b-fee1c.png"\n        srcset="/static/2021-07-06-17-55-02-6993958a4ad8300358f3b888530c3d6b-a67b7.png 200w,\n/static/2021-07-06-17-55-02-6993958a4ad8300358f3b888530c3d6b-0b187.png 400w,\n/static/2021-07-06-17-55-02-6993958a4ad8300358f3b888530c3d6b-fee1c.png 800w,\n/static/2021-07-06-17-55-02-6993958a4ad8300358f3b888530c3d6b-b1a91.png 1200w,\n/static/2021-07-06-17-55-02-6993958a4ad8300358f3b888530c3d6b-4be21.png 1540w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从上图可以看出，通过 HTML 文件加载的混合资源，虽然给出警告，但大部分类型还是能加载的。而使用 XMLHttpRequest 请求时，浏览器认为这种请求可能是攻击者发起的，会阻止此类危险的请求。比如我通过浏览器打开地址 <code class="language-text">https://www.iteye.com/groups</code>，然后通过控制台，使用 XMLHttpRequest 来请求 <code class="language-text">http://img-ads.csdn.net/2018/201811150919211586.jpg</code>，这时候请求就会报错，出错信息如下图所示：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-06-17-55-11-fd0668221db3d0cc98c4a7935b9e93f5-ff8ad.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 48.883666274970615%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABAElEQVQoz52R3WrDMAyF+/5PNpouScMKK+xiNCRNE//Ltpw4dqexi/ZmkE0cbGH4JB1rl3NeU1xzuv89dgQro40RyxxJPnicvfUQ12UTjDPGuKSUqX2iyGmJM91b4PvIWXfrtEENkqmRq5FqbRqbGjCuur5jE3OSM9YP/adgw1bPxgF4+M+HifF2bdug5CxFUAKl9HxybPKc0UtCnwOSKEkBnTHo7APWdaHLva0PUO6hKa/14VK8XKqibaqhqcampHM6Hd35hO9v0/FVfpyfPFuzgl7NjxRyhoJ/DwIajXJKeK2iswlt8jaTAj7gZw+0LHDOhwCOVu0pl0qBtb95/gJibERyYvjvZQAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 06 17 55 11"\n        title=""\n        src="/static/2021-07-06-17-55-11-fd0668221db3d0cc98c4a7935b9e93f5-fee1c.png"\n        srcset="/static/2021-07-06-17-55-11-fd0668221db3d0cc98c4a7935b9e93f5-a67b7.png 200w,\n/static/2021-07-06-17-55-11-fd0668221db3d0cc98c4a7935b9e93f5-0b187.png 400w,\n/static/2021-07-06-17-55-11-fd0668221db3d0cc98c4a7935b9e93f5-fee1c.png 800w,\n/static/2021-07-06-17-55-11-fd0668221db3d0cc98c4a7935b9e93f5-b1a91.png 1200w,\n/static/2021-07-06-17-55-11-fd0668221db3d0cc98c4a7935b9e93f5-95179.png 1600w,\n/static/2021-07-06-17-55-11-fd0668221db3d0cc98c4a7935b9e93f5-ff8ad.png 1702w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<h2 id="总结-2"><a href="#%E6%80%BB%E7%BB%93-2" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总结</h2>\n<p>首先我们介绍了回调函数和系统调用栈；接下来我们站在循环系统的视角，分析了 XMLHttpRequest 是怎么工作的；最后又说明了由于一些安全因素的限制，在使用 XMLHttpRequest 的过程中会遇到跨域问题和混合内容的问题。</p>\n<p>本篇文章跨度比较大，不是单纯地讲一个问题，而是将回调类型、循环系统、网络请求和安全问题“串联”起来了。</p>\n<p>对比上一篇文章，setTimeout 是直接将延迟任务添加到延迟队列中，而 XMLHttpRequest 发起请求，是由浏览器的其他进程或者线程去执行，然后再将执行结果利用 IPC 的方式通知渲染进程，之后渲染进程再将对应的消息添加到消息队列中。如果你搞懂了 setTimeout 和 XMLHttpRequest 的工作机制后，再来理解其他 WebAPI 就会轻松很多了，因为大部分 WebAPI 的工作逻辑都是类似的。</p>\n<h1 id="宏任务和微任务：不是所有的任务都是一个待遇"><a href="#%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BE%AE%E4%BB%BB%E5%8A%A1%EF%BC%9A%E4%B8%8D%E6%98%AF%E6%89%80%E6%9C%89%E7%9A%84%E4%BB%BB%E5%8A%A1%E9%83%BD%E6%98%AF%E4%B8%80%E4%B8%AA%E5%BE%85%E9%81%87" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>宏任务和微任务：不是所有的任务都是一个待遇</h1>\n<p>在前面几篇文章中，我们介绍了消息队列，并结合消息队列介绍了两种典型的 WebAPI——setTimeout 和 XMLHttpRequest，通过这两个 WebAPI 我们搞清楚了浏览器的消息循环系统是怎么工作的。不过随着浏览器的应用领域越来越广泛，消息队列中这种粗时间颗粒度的任务已经不能胜任部分领域的需求，所以又出现了一种新的技术——微任务。微任务可以在实时性和效率之间做一个有效的权衡。</p>\n<p>从目前的情况来看，微任务已经被广泛地应用，基于微任务的技术有 MutationObserver、Promise 以及以 Promise 为基础开发出来的很多其他的技术。所以微任务的重要性也与日俱增，了解其底层的工作原理对于你读懂别人的代码，以及写出更高效、更具现代的代码有着决定性的作用。</p>\n<p>有微任务，也就有宏任务，那这二者到底有什么区别？它们又是如何相互取长补短的？</p>\n<h2 id="宏任务"><a href="#%E5%AE%8F%E4%BB%BB%E5%8A%A1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>宏任务</h2>\n<p>前面我们已经介绍过了，页面中的大部分任务都是在主线程上执行的，这些任务包括了：</p>\n<ul>\n<li>渲染事件（如解析 DOM、计算布局、绘制）；</li>\n<li>用户交互事件（如鼠标点击、滚动页面、放大缩小等）；</li>\n<li>JavaScript 脚本执行事件；</li>\n<li>网络请求完成、文件读写完成事件。</li>\n</ul>\n<p>为了协调这些任务有条不紊地在主线程上执行，页面进程引入了消息队列和事件循环机制，渲染进程内部会维护多个消息队列，比如延迟执行队列和普通的消息队列。然后主线程采用一个 for 循环，不断地从这些任务队列中取出任务并执行任务。我们把这些消息队列中的任务称为宏任务。</p>\n<p>消息队列中的任务是通过事件循环系统来执行的，这里我们可以看看在 WHATWG 规范中是怎么定义事件循环机制的。</p>\n<p>由于规范需要支持语义上的完备性，所以通常写得都会比较啰嗦，这里我就大致总结了下 WHATWG 规范定义的大致流程：</p>\n<ul>\n<li>先从多个消息队列中选出一个最老的任务，这个任务称为 oldestTask；</li>\n<li>然后循环系统记录任务开始执行的时间，并把这个 oldestTask 设置为当前正在执行的任务；</li>\n<li>当任务执行完成之后，删除当前正在执行的任务，并从对应的消息队列中删除掉这个 oldestTask；</li>\n<li>最后统计执行完成的时长等信息。</li>\n</ul>\n<p>以上就是消息队列中宏任务的执行过程，通过前面的学习，相信你也很熟悉这套执行流程了。</p>\n<p>宏任务可以满足我们大部分的日常需求，不过如果有对时间精度要求较高的需求，宏任务就难以胜任了，下面我们就来分析下为什么宏任务难以满足对时间精度要求较高的任务。</p>\n<p>前面我们说过，页面的渲染事件、各种 IO 的完成事件、执行 JavaScript 脚本的事件、用户交互的事件等都随时有可能被添加到消息队列中，而且添加事件是由系统操作的，JavaScript 代码不能准确掌控任务要添加到队列中的位置，控制不了任务在消息队列中的位置，所以很难控制开始执行任务的时间。为了直观理解，你可以看下面这段代码：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="76598148833379190000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`<!DOCTYPE html>\n<html>\n  <body>\n    <div id=&quot;demo&quot;>\n      <ol>\n        <li>test</li>\n      </ol>\n    </div>\n  </body>\n  <script type=&quot;text/javascript&quot;>\n    function timerCallback2() {\n      console.log(2);\n    }\n    function timerCallback() {\n      console.log(1);\n      setTimeout(timerCallback2, 0);\n    }\n    setTimeout(timerCallback, 0);\n  </script>\n</html>`, `76598148833379190000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                html 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>demo<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ol</span><span class="token punctuation">></span></span>\n        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ol</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">\n    <span class="token keyword">function</span> <span class="token function">timerCallback2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n    <span class="token keyword">function</span> <span class="token function">timerCallback</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token function">setTimeout</span><span class="token punctuation">(</span>timerCallback2<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n    <span class="token function">setTimeout</span><span class="token punctuation">(</span>timerCallback<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>在这段代码中，我的目的是想通过 setTimeout 来设置两个回调任务，并让它们按照前后顺序来执行，中间也不要再插入其他的任务，因为如果这两个任务的中间插入了其他的任务，就很有可能会影响到第二个定时器的执行时间了。</p>\n<p>但实际情况是我们不能控制的，比如在你调用 setTimeout 来设置回调任务的间隙，消息队列中就有可能被插入很多系统级的任务。你可以打开 Performance 工具，来记录下这段任务的执行过程，也可参考文中我记录的图片：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-06-17-57-31-729686ac6d9ac5e589055eaaeb1f77b9-3c94e.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 43.279172821270315%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAIAAAC9o5sfAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABrElEQVQoz32RPW/TUBSG/RuYkGBm6dK9IAQDA8rCyoQYWZDgXzAjZiRagVqQAqhQaJQPRQgatylxaxc7aUnSOrXje23XubHv9+XSEokO8OgsRzrvkc55DCUl51wIoX4jZ/UPpEbIU3RnFAU+HoUUM0o5YZIwVRBZYJwXf8jzHOshDWFCKl2MS86YzhtpelJv1Wutqu3a7S9ly/zo2c2h6x1ud0bdg4Hj9p0f4X7f3/N6HXNna23gNiDwMVVCSINzGSRwOB6lCI97687yTb96Hxd8cnQc1yrxuzew/DqufEo2WtMs6a4/7L69Q5IuFTosjMkUBSCkku+NrEbPLFefvXj/9KtvbTZftecv1eYufpu/vHHlwv6Du0SpVv+kvIvMIxYhpH9ljOOg0f7ctOr2Qf1JY3hjUd1aEivOz35n1StdbZcWtkoLm9fm7Ef33KjzeBVcf65uL+KKsytFbui7JxmCIFGM7oRq6Tt9aVE/078UDCGVT2mawsMhDAKUZeag+OCyNY+G8VQJbpwTMZMk/2PrL86HpTr1pwghAAAIQAxhFEW6PRs4UyVmm38BrgrfBu/ZH9gAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 06 17 57 31"\n        title=""\n        src="/static/2021-07-06-17-57-31-729686ac6d9ac5e589055eaaeb1f77b9-fee1c.png"\n        srcset="/static/2021-07-06-17-57-31-729686ac6d9ac5e589055eaaeb1f77b9-a67b7.png 200w,\n/static/2021-07-06-17-57-31-729686ac6d9ac5e589055eaaeb1f77b9-0b187.png 400w,\n/static/2021-07-06-17-57-31-729686ac6d9ac5e589055eaaeb1f77b9-fee1c.png 800w,\n/static/2021-07-06-17-57-31-729686ac6d9ac5e589055eaaeb1f77b9-b1a91.png 1200w,\n/static/2021-07-06-17-57-31-729686ac6d9ac5e589055eaaeb1f77b9-3c94e.png 1354w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>setTimeout 函数触发的回调函数都是宏任务，如图中，左右两个黄色块就是 setTimeout 触发的两个定时器任务。</p>\n<p>现在你可以重点观察上图中间浅红色区域，这里有很多一段一段的任务，这些是被渲染引擎插在两个定时器任务中间的任务。试想一下，如果中间被插入的任务执行时间过久的话，那么就会影响到后面任务的执行了。</p>\n<p>所以说宏任务的时间粒度比较大，执行的时间间隔是不能精确控制的，对一些高实时性的需求就不太符合了，比如后面要介绍的监听 DOM 变化的需求。</p>\n<h2 id="微任务"><a href="#%E5%BE%AE%E4%BB%BB%E5%8A%A1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>微任务</h2>\n<p>在理解了宏任务之后，下面我们就可以来看看什么是微任务了。在上一篇文章中，我们介绍过异步回调的概念，其主要有两种方式。</p>\n<p>第一种是把异步回调函数封装成一个宏任务，添加到消息队列尾部，当循环系统执行到该任务的时候执行回调函数。这种比较好理解，我们前面介绍的 setTimeout 和 XMLHttpRequest 的回调函数都是通过这种方式来实现的。</p>\n<p>第二种方式的执行时机是在主函数执行结束之后、当前宏任务结束之前执行回调函数，这通常都是以微任务形式体现的。</p>\n<p>那这里说的微任务到底是什么呢？</p>\n<p>微任务就是一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前。</p>\n<p>不过要搞清楚微任务系统是怎么运转起来的，就得站在 V8 引擎的层面来分析下。</p>\n<p>我们知道当 JavaScript 执行一段脚本的时候，V8 会为其创建一个全局执行上下文，在创建全局执行上下文的同时，V8 引擎也会在内部创建一个微任务队列。顾名思义，这个微任务队列就是用来存放微任务的，因为在当前宏任务执行的过程中，有时候会产生多个微任务，这时候就需要使用这个微任务队列来保存这些微任务了。不过这个微任务队列是给 V8 引擎内部使用的，所以你是无法通过 JavaScript 直接访问的。</p>\n<p>也就是说每个宏任务都关联了一个微任务队列。那么接下来，我们就需要分析两个重要的时间点——微任务产生的时机和执行微任务队列的时机。</p>\n<p>我们先来看看微任务是怎么产生的？在现代浏览器里面，产生微任务有两种方式。</p>\n<p>第一种方式是使用 MutationObserver 监控某个 DOM 节点，然后再通过 JavaScript 来修改这个节点，或者为这个节点添加、删除部分子节点，当 DOM 节点发生变化时，就会产生 DOM 变化记录的微任务。</p>\n<p>第二种方式是使用 Promise，当调用 Promise.resolve() 或者 Promise.reject() 的时候，也会产生微任务。</p>\n<p>通过 DOM 节点变化产生的微任务或者使用 Promise 产生的微任务都会被 JavaScript 引擎按照顺序保存到微任务队列中。</p>\n<p>好了，现在微任务队列中有了微任务了，那接下来就要看看微任务队列是何时被执行的。</p>\n<p>通常情况下，在当前宏任务中的 JavaScript 快执行完成时，也就在 JavaScript 引擎准备退出全局执行上下文并清空调用栈的时候，JavaScript 引擎会检查全局执行上下文中的微任务队列，然后按照顺序执行队列中的微任务。WHATWG 把执行微任务的时间点称为检查点。当然除了在退出全局执行上下文式这个检查点之外，还有其他的检查点，不过不是太重要，这里就不做介绍了。</p>\n<p>如果在执行微任务的过程中，产生了新的微任务，同样会将该微任务添加到微任务队列中，V8 引擎一直循环执行微任务队列中的任务，直到队列为空才算执行结束。也就是说在执行微任务过程中产生的新的微任务并不会推迟到下个宏任务中执行，而是在当前的宏任务中继续执行。</p>\n<p>为了直观地理解什么是微任务，你可以参考下面我画的示意图（由于内容比较多，我将其分为了两张）：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-06-17-58-03-916d1ee0ce7a4f58a92960abc8e3ead3-62dab.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 47.447447447447445%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAIAAAC9o5sfAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABxUlEQVQoz1VR30/aUBjlrxsxPvtAptPs2Sdf92I0ZsmSZS8+sGQuRigiiGgGBqPZFEdCIkqBgtoSNbZ3/UF7W/qLtvT2rkCIevIl934599zvyzkRPEUQBBij8Jx04zt+zfpvgRCKTBiM/Hsgn3dhmZYu7oUyo1S6smFa4SN3DMd1oKpa9sC07ElpmhYJlb5tY8/O1EAsxy6mqPkdciHDLBcB1HTXcQAAiqIgf+i5zutdDMMIxci3bKwreZKfI+iFRONDqh1LtFYKj5puBgESBDGcPHC9XFNKNCBByskmTLX1Bx6OJ5smVqXkFb9R1b9V/n0pc5t1Y/mkJ8iq1deUXs+zDFZU187Yg7r485zOX4Ovl2KpI47EKFzb1gsVmjn7LR1leqVf4lH283EXyH3sOchx8NBlebh92qKJHSqdftgjDoniKa2MDENjn4uU+CnbWCP+ru9VV3er6ydPat+cshiag/nUbTR+MxuvzX6/iW7dXtwJE/HI8RzJv8+Dj/vMUrq9dPi8UhoZ9iLWrdguE92m38WvZ340o8nnPx0QwdNkWyzMNqR8nc3Vng5IvtCWwmCm+WNvOOxwkOJUilUoDrY4NfzuP6NF0aqXxnOsAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 06 17 58 03"\n        title=""\n        src="/static/2021-07-06-17-58-03-916d1ee0ce7a4f58a92960abc8e3ead3-fee1c.png"\n        srcset="/static/2021-07-06-17-58-03-916d1ee0ce7a4f58a92960abc8e3ead3-a67b7.png 200w,\n/static/2021-07-06-17-58-03-916d1ee0ce7a4f58a92960abc8e3ead3-0b187.png 400w,\n/static/2021-07-06-17-58-03-916d1ee0ce7a4f58a92960abc8e3ead3-fee1c.png 800w,\n/static/2021-07-06-17-58-03-916d1ee0ce7a4f58a92960abc8e3ead3-b1a91.png 1200w,\n/static/2021-07-06-17-58-03-916d1ee0ce7a4f58a92960abc8e3ead3-62dab.png 1332w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>该示意图是在执行一个 ParseHTML 的宏任务，在执行过程中，遇到了 JavaScript 脚本，那么就暂停解析流程，进入到 JavaScript 的执行环境。从图中可以看到，全局上下文中包含了微任务列表。</p>\n<p>在 JavaScript 脚本的后续执行过程中，分别通过 Promise 和 removeChild 创建了两个微任务，并被添加到微任务列表中。接着 JavaScript 执行结束，准备退出全局执行上下文，这时候就到了检查点了，JavaScript 引擎会检查微任务列表，发现微任务列表中有微任务，那么接下来，依次执行这两个微任务。等微任务队列清空之后，就退出全局执行上下文。</p>\n<p>以上就是微任务的工作流程，从上面分析我们可以得出如下几个结论：</p>\n<ul>\n<li>微任务和宏任务是绑定的，每个宏任务在执行时，会创建自己的微任务队列。</li>\n<li>微任务的执行时长会影响到当前宏任务的时长。比如一个宏任务在执行过程中，产生了 100 个微任务，执行每个微任务的时间是 10 毫秒，那么执行这 100 个微任务的时间就是 1000 毫秒，也可以说这 100 个微任务让宏任务的执行时间延长了 1000 毫秒。所以你在写代码的时候一定要注意控制微任务的执行时长。</li>\n<li>在一个宏任务中，分别创建一个用于回调的宏任务和微任务，无论什么情况下，微任务都早于宏任务执行。</li>\n</ul>\n<h2 id="监听-dom-变化方法演变"><a href="#%E7%9B%91%E5%90%AC-dom-%E5%8F%98%E5%8C%96%E6%96%B9%E6%B3%95%E6%BC%94%E5%8F%98" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>监听 DOM 变化方法演变</h2>\n<p>现在知道了微任务是怎么工作的，那接下来我们再来看看微任务是如何应用在 MutationObserver 中的。MutationObserver 是用来监听 DOM 变化的一套方法，而监听 DOM 变化一直是前端工程师一项非常核心的需求。</p>\n<p>比如许多 Web 应用都利用 HTML 与 JavaScript 构建其自定义控件，与一些内置控件不同，这些控件不是固有的。为了与内置控件一起良好地工作，这些控件必须能够适应内容更改、响应事件和用户交互。因此，Web 应用需要监视 DOM 变化并及时地做出响应。</p>\n<p>虽然监听 DOM 的需求是如此重要，不过早期页面并没有提供对监听的支持，所以那时要观察 DOM 是否变化，唯一能做的就是轮询检测，比如使用 setTimeout 或者 setInterval 来定时检测 DOM 是否有改变。这种方式简单粗暴，但是会遇到两个问题：如果时间间隔设置过长，DOM 变化响应不够及时；反过来如果时间间隔设置过短，又会浪费很多无用的工作量去检查 DOM，会让页面变得低效。</p>\n<p>直到 2000 年的时候引入了 Mutation Event，Mutation Event 采用了观察者的设计模式，当 DOM 有变动时就会立刻触发相应的事件，这种方式属于同步回调。</p>\n<p>采用 Mutation Event 解决了实时性的问题，因为 DOM 一旦发生变化，就会立即调用 JavaScript 接口。但也正是这种实时性造成了严重的性能问题，因为每次 DOM 变动，渲染引擎都会去调用 JavaScript，这样会产生较大的性能开销。比如利用 JavaScript 动态创建或动态修改 50 个节点内容，就会触发 50 次回调，而且每个回调函数都需要一定的执行时间，这里我们假设每次回调的执行时间是 4 毫秒，那么 50 次回调的执行时间就是 200 毫秒，若此时浏览器正在执行一个动画效果，由于 Mutation Event 触发回调事件，就会导致动画的卡顿。</p>\n<p>也正是因为使用 Mutation Event 会导致页面性能问题，所以 Mutation Event 被反对使用，并逐步从 Web 标准事件中删除了。</p>\n<p>为了解决了 Mutation Event 由于同步调用 JavaScript 而造成的性能问题，从 DOM4 开始，推荐使用 MutationObserver 来代替 Mutation Event。MutationObserver API 可以用来监视 DOM 的变化，包括属性的变化、节点的增减、内容的变化等。</p>\n<p>那么相比较 Mutation Event，MutationObserver 到底做了哪些改进呢？</p>\n<p>首先，MutationObserver 将响应函数改成异步调用，可以不用在每次 DOM 变化都触发异步调用，而是等多次 DOM 变化后，一次触发异步调用，并且还会使用一个数据结构来记录这期间所有的 DOM 变化。这样即使频繁地操纵 DOM，也不会对性能造成太大的影响。</p>\n<p>我们通过异步调用和减少触发次数来缓解了性能问题，那么如何保持消息通知的及时性呢？如果采用 setTimeout 创建宏任务来触发回调的话，那么实时性就会大打折扣，因为上面我们分析过，在两个任务之间，可能会被渲染进程插入其他的事件，从而影响到响应的实时性。</p>\n<p>这时候，微任务就可以上场了，在每次 DOM 节点发生变化的时候，渲染引擎将变化记录封装成微任务，并将微任务添加进当前的微任务队列中。这样当执行到检查点的时候，V8 引擎就会按照顺序执行微任务了。</p>\n<p>综上所述， MutationObserver 采用了“异步 + 微任务”的策略。</p>\n<ul>\n<li>通过异步操作解决了同步操作的性能问题；</li>\n<li>通过微任务解决了实时性的问题。</li>\n</ul>\n<h2 id="总结-3"><a href="#%E6%80%BB%E7%BB%93-3" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总结</h2>\n<p>首先我们回顾了宏任务，然后在宏任务的基础之上，我们分析了异步回调函数的两种形式，其中最后一种回调的方式就是通过微任务来实现的。</p>\n<p>接下来我们详细分析了浏览器是如何实现微任务的，包括微任务队列、检查点等概念。</p>\n<p>最后我们介绍了监听 DOM 变化技术方案的演化史，从轮询到 Mutation Event 再到最新使用的 MutationObserver。MutationObserver 方案的核心就是采用了微任务机制，有效地权衡了实时性和执行效率的问题。</p>\n<h1 id="使用-promise-告别回调函数"><a href="#%E4%BD%BF%E7%94%A8-promise-%E5%91%8A%E5%88%AB%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>使用 Promise 告别回调函数</h1>\n<p>在上一篇文章中我们聊到了微任务是如何工作的，并介绍了 MutationObserver 是如何利用微任务来权衡性能和效率的。今天我们就接着来聊聊微任务的另外一个应用 Promise，DOM/BOM API 中新加入的 API 大多数都是建立在 Promise 上的，而且新的前端框架也使用了大量的 Promise。可以这么说，Promise 已经成为现代前端的“水”和“电”，很是关键，所以深入学习 Promise 势在必行。</p>\n<p>不过，Promise 的知识点有那么多，而我们只有一篇文章来介绍，那应该怎么讲解呢？具体讲解思路是怎样的呢？</p>\n<p>如果你想要学习一门新技术，最好的方式是先了解这门技术是如何诞生的，以及它所解决的问题是什么。了解了这些后，你才能抓住这门技术的本质。所以本文我们就来重点聊聊 JavaScript 引入 Promise 的动机，以及解决问题的几个核心关键点。</p>\n<p>要谈动机，我们一般都是先从问题切入，那么 Promise 到底解决了什么问题呢？在正式开始介绍之前，我想有必要明确下，Promise 解决的是异步编码风格的问题，而不是一些其他的问题，所以接下来我们聊的话题都是围绕编码风格展开的</p>\n<h2 id="异步编程的问题：代码逻辑不连续"><a href="#%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9A%E4%BB%A3%E7%A0%81%E9%80%BB%E8%BE%91%E4%B8%8D%E8%BF%9E%E7%BB%AD" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>异步编程的问题：代码逻辑不连续</h2>\n<p>首先我们来回顾下 JavaScript 的异步编程模型，你应该已经非常熟悉页面的事件循环系统了，也知道页面中任务都是执行在主线程之上的，相对于页面来说，主线程就是它整个的世界，所以在执行一项耗时的任务时，比如下载网络文件任务、获取摄像头等设备信息任务，这些任务都会放到页面主线程之外的进程或者线程中去执行，这样就避免了耗时任务“霸占”页面主线程的情况。你可以结合下图来看看这个处理过程：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-07-09-21-26-007246b0e3bebe20095091d4e5b51a4e-2cdbf.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 68.9041095890411%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAIAAACgpqunAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACfUlEQVQoz21SS08TURTuf/E3GF249JEY/RdudEPcuNCd0YgxcSE+CljjQjEElAWKTUtfUKGUtrYUpICdGdppKe2087jPmbkz1zsFGxP5cnJy7jn3O/ecLzfk+T7FyLeRR09NxNyB3Pk3iYdJRBlzXVtUHYIEMcQ9Vu8Ya02cG9pGE2UUEJfgsgTTCsipKKcGyfQhTkqwU93ZqTW/yc6OqnOfhTj3lna1jzk5WVWiW41ktfEgpV+cdy7MufdSZrIifS9J2V+N+7HW9XdKeezOxLOZc5/oVL4riMHLcg/8UMB6vb+m0mxlO7k8+zX+eTH+JRH9kFtPzK/V3sc238ZKC5tyv7a/d9CKq17tyAxedl0XIcQFHBr4UsQdP289uYaeXmXjl/hqRFKUleXv2US0Ud8Tdd/3hIcQCmJISAAgYsyzCWGck3YVZGb1zGInPncUnelV8l3dMAGEmBDbEddc5jGfWwCyIZkhhEVHzpxhY184WT5IJGMrq+mVTCKfTROM/pZOIYYVRCEYi9d6Lzb60xvdcNEIFwZT653nmeaj6MFEqv4qLT2OSy9zvcmi8aaghwv6ZFGfyBuZ/Z4gCrLf6KNSwywfDootWFJBUdLKbbR1TPc1+rtPt49JpQ3LLXBilTYoqqCli2F5iHkeApaLLAYN7hHOMMeG8L6DbQwphg6GLkEjcwhkFFmGHowtRBPbizY/D83bi827se7YknprQQ5vaiLp+fxk0dG6J8FIbdYf6EKtVK17+XXhZmTrxnTpSmT3YfqYuxQJkf8DpXQwGARk0ca2bXEm1LaIbeHAAHUxdUawh6BDjAI/+NtnwaYEQWAYhmmamqaJIc+89gdS6e5pSRHYswAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 07 09 21 26"\n        title=""\n        src="/static/2021-07-07-09-21-26-007246b0e3bebe20095091d4e5b51a4e-fee1c.png"\n        srcset="/static/2021-07-07-09-21-26-007246b0e3bebe20095091d4e5b51a4e-a67b7.png 200w,\n/static/2021-07-07-09-21-26-007246b0e3bebe20095091d4e5b51a4e-0b187.png 400w,\n/static/2021-07-07-09-21-26-007246b0e3bebe20095091d4e5b51a4e-fee1c.png 800w,\n/static/2021-07-07-09-21-26-007246b0e3bebe20095091d4e5b51a4e-b1a91.png 1200w,\n/static/2021-07-07-09-21-26-007246b0e3bebe20095091d4e5b51a4e-2cdbf.png 1460w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>上图展示的是一个标准的异步编程模型，页面主线程发起了一个耗时的任务，并将任务交给另外一个进程去处理，这时页面主线程会继续执行消息队列中的任务。等该进程处理完这个任务后，会将该任务添加到渲染进程的消息队列中，并排队等待循环系统的处理。排队结束之后，循环系统会取出消息队列中的任务进行处理，并触发相关的回调操作。</p>\n<p>这就是页面编程的一大特点：异步回调。</p>\n<p>Web 页面的单线程架构决定了异步回调，而异步回调影响到了我们的编码方式，到底是如何影响的呢？</p>\n<p>假设有一个下载的需求，使用 XMLHttpRequest 来实现，具体的实现方式你可以参考下面这段代码：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="68489788457813746000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// 执行状态\nfunction onResolve(response) {\n  console.log(response);\n}\nfunction onReject(error) {\n  console.log(error);\n}\n\nlet xhr = new XMLHttpRequest();\nxhr.ontimeout = function(e) {\n  onReject(e);\n};\nxhr.onerror = function(e) {\n  onReject(e);\n};\nxhr.onreadystatechange = function() {\n  onResolve(xhr.response);\n};\n\n// 设置请求类型，请求 URL，是否同步信息\nlet URL = \'https://time.geekbang.com\';\nxhr.open(\'Get\', URL, true);\n\n// 设置参数\nxhr.timeout = 3000; // 设置 xhr 请求的超时时间\nxhr.responseType = \'text\'; // 设置响应返回的数据格式\nxhr.setRequestHeader(\'X_TEST\', \'time.geekbang\');\n\n// 发出请求\nxhr.send();`, `68489788457813746000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">// 执行状态</span>\n<span class="token keyword">function</span> <span class="token function">onResolve</span><span class="token punctuation">(</span><span class="token parameter">response</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">function</span> <span class="token function">onReject</span><span class="token punctuation">(</span><span class="token parameter">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">let</span> xhr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nxhr<span class="token punctuation">.</span><span class="token function-variable function">ontimeout</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token function">onReject</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\nxhr<span class="token punctuation">.</span><span class="token function-variable function">onerror</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token function">onReject</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\nxhr<span class="token punctuation">.</span><span class="token function-variable function">onreadystatechange</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token function">onResolve</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>response<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n<span class="token comment">// 设置请求类型，请求 URL，是否同步信息</span>\n<span class="token keyword">let</span> <span class="token constant">URL</span> <span class="token operator">=</span> <span class="token string">\'https://time.geekbang.com\'</span><span class="token punctuation">;</span>\nxhr<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">\'Get\'</span><span class="token punctuation">,</span> <span class="token constant">URL</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token comment">// 设置参数</span>\nxhr<span class="token punctuation">.</span>timeout <span class="token operator">=</span> <span class="token number">3000</span><span class="token punctuation">;</span> <span class="token comment">// 设置 xhr 请求的超时时间</span>\nxhr<span class="token punctuation">.</span>responseType <span class="token operator">=</span> <span class="token string">\'text\'</span><span class="token punctuation">;</span> <span class="token comment">// 设置响应返回的数据格式</span>\nxhr<span class="token punctuation">.</span><span class="token function">setRequestHeader</span><span class="token punctuation">(</span><span class="token string">\'X_TEST\'</span><span class="token punctuation">,</span> <span class="token string">\'time.geekbang\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token comment">// 发出请求</span>\nxhr<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>我们执行上面这段代码，可以正常输出结果的。但是，这短短的一段代码里面竟然出现了五次回调，这么多的回调会导致代码的逻辑不连贯、不线性，非常不符合人的直觉，这就是异步回调影响到我们的编码方式。</p>\n<p>那有什么方法可以解决这个问题吗？当然有，我们可以封装这堆凌乱的代码，降低处理异步回调的次数。</p>\n<h2 id="封装异步代码，让处理流程变得线性"><a href="#%E5%B0%81%E8%A3%85%E5%BC%82%E6%AD%A5%E4%BB%A3%E7%A0%81%EF%BC%8C%E8%AE%A9%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B%E5%8F%98%E5%BE%97%E7%BA%BF%E6%80%A7" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>封装异步代码，让处理流程变得线性</h2>\n<p>由于我们重点关注的是输入内容（请求信息）和输出内容（回复信息），至于中间的异步请求过程，我们不想在代码里面体现太多，因为这会干扰核心的代码逻辑。整体思路如下图所示：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-07-09-22-21-653caa17dff3967dd4c65dbe4f8088d3-abd93.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 49.36886395511922%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABW0lEQVQoz5WRTU7CQBiGuZlbV17CC7jwAC5deAU2LkwgGE2MIcaGUBPUtKGmJE1LQdvOtNDfYaydIrRTnBZJ1MDCN5nNfO/z/dZWu5XTFXgvnLjYZaixV/xW9VPGwrQ4uFgcXi/oH5yFK0dta8rlMmNKyKIppzdKmi2ZMkrplsoYY9u2w0pxHDPj1AbmSAWWEdiGBw3rbWy9aniG8jxPCEk8d64MaEpKGELIcZxQSR9qISbjTl043dOFO32oW8BRWifi2f7E0JzJNJ4hNFTDq2aGohJ2HKfb7fb7fVmWIQTsB+gD5fEWAMv0PzoPPb7d0kWOxJg1jzAONTW4bORrmFXmeV4URUmSLFDCEEBlZKrPbfn86L5V7wkvhgmSJGEhNvl6qd8zE0IQYhlxFEVrBwr8ieubEjduHLvqk+tH3tT5nM83y/4Bb9fmbrT4552r9oog8H3fY03twr8AklwuG3/VCaAAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 07 09 22 21"\n        title=""\n        src="/static/2021-07-07-09-22-21-653caa17dff3967dd4c65dbe4f8088d3-fee1c.png"\n        srcset="/static/2021-07-07-09-22-21-653caa17dff3967dd4c65dbe4f8088d3-a67b7.png 200w,\n/static/2021-07-07-09-22-21-653caa17dff3967dd4c65dbe4f8088d3-0b187.png 400w,\n/static/2021-07-07-09-22-21-653caa17dff3967dd4c65dbe4f8088d3-fee1c.png 800w,\n/static/2021-07-07-09-22-21-653caa17dff3967dd4c65dbe4f8088d3-b1a91.png 1200w,\n/static/2021-07-07-09-22-21-653caa17dff3967dd4c65dbe4f8088d3-abd93.png 1426w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从图中你可以看到，我们将 XMLHttpRequest 请求过程的代码封装起来了，重点关注输入数据和输出结果。</p>\n<p>那我们就按照这个思路来改造代码。首先，我们把输入的 HTTP 请求信息全部保存到一个 request 的结构中，包括请求地址、请求头、请求方式、引用地址、同步请求还是异步请求、安全设置等信息。request 结构如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="65931521719030290000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`//makeRequest 用来构造 request 对象\nfunction makeRequest(request_url) {\n  let request = {\n    method: \'Get\',\n    url: request_url,\n    headers: \'\',\n    body: \'\',\n    credentials: false,\n    sync: true,\n    responseType: \'text\',\n    referrer: \'\'\n  };\n  return request;\n}`, `65931521719030290000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">//makeRequest 用来构造 request 对象</span>\n<span class="token keyword">function</span> <span class="token function">makeRequest</span><span class="token punctuation">(</span><span class="token parameter">request_url</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">let</span> request <span class="token operator">=</span> <span class="token punctuation">{</span>\n    method<span class="token punctuation">:</span> <span class="token string">\'Get\'</span><span class="token punctuation">,</span>\n    url<span class="token punctuation">:</span> request_url<span class="token punctuation">,</span>\n    headers<span class="token punctuation">:</span> <span class="token string">\'\'</span><span class="token punctuation">,</span>\n    body<span class="token punctuation">:</span> <span class="token string">\'\'</span><span class="token punctuation">,</span>\n    credentials<span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>\n    sync<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>\n    responseType<span class="token punctuation">:</span> <span class="token string">\'text\'</span><span class="token punctuation">,</span>\n    referrer<span class="token punctuation">:</span> <span class="token string">\'\'</span>\n  <span class="token punctuation">}</span><span class="token punctuation">;</span>\n  <span class="token keyword">return</span> request<span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>然后就可以封装请求过程了，这里我们将所有的请求细节封装进 XFetch 函数，XFetch 代码如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="5809508707555322000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`//[in] request，请求信息，请求头，延时值，返回类型等\n//[out] resolve, 执行成功，回调该函数\n//[out] reject  执行失败，回调该函数\nfunction XFetch(request, resolve, reject) {\n  let xhr = new XMLHttpRequest();\n  xhr.ontimeout = function(e) {\n    reject(e);\n  };\n  xhr.onerror = function(e) {\n    reject(e);\n  };\n  xhr.onreadystatechange = function() {\n    if ((xhr.status = 200)) resolve(xhr.response);\n  };\n  xhr.open(request.method, URL, request.sync);\n  xhr.timeout = request.timeout;\n  xhr.responseType = request.responseType;\n  // 补充其他请求信息\n  //...\n  xhr.send();\n}`, `5809508707555322000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">//[in] request，请求信息，请求头，延时值，返回类型等</span>\n<span class="token comment">//[out] resolve, 执行成功，回调该函数</span>\n<span class="token comment">//[out] reject  执行失败，回调该函数</span>\n<span class="token keyword">function</span> <span class="token function">XFetch</span><span class="token punctuation">(</span><span class="token parameter">request<span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">let</span> xhr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  xhr<span class="token punctuation">.</span><span class="token function-variable function">ontimeout</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token function">reject</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">;</span>\n  xhr<span class="token punctuation">.</span><span class="token function-variable function">onerror</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token function">reject</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">;</span>\n  xhr<span class="token punctuation">.</span><span class="token function-variable function">onreadystatechange</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>status <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">resolve</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>response<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">;</span>\n  xhr<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span>request<span class="token punctuation">.</span>method<span class="token punctuation">,</span> <span class="token constant">URL</span><span class="token punctuation">,</span> request<span class="token punctuation">.</span>sync<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  xhr<span class="token punctuation">.</span>timeout <span class="token operator">=</span> request<span class="token punctuation">.</span>timeout<span class="token punctuation">;</span>\n  xhr<span class="token punctuation">.</span>responseType <span class="token operator">=</span> request<span class="token punctuation">.</span>responseType<span class="token punctuation">;</span>\n  <span class="token comment">// 补充其他请求信息</span>\n  <span class="token comment">//...</span>\n  xhr<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>这个 XFetch 函数需要一个 request 作为输入，然后还需要两个回调函数 resolve 和 reject，当请求成功时回调 resolve 函数，当请求出现问题时回调 reject 函数。</p>\n<p>有了这些后，我们就可以来实现业务代码了，具体的实现方式如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="96379613649906060000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`XFetch(\n  makeRequest(\'https://time.geekbang.org\'),\n  function resolve(data) {\n    console.log(data);\n  },\n  function reject(e) {\n    console.log(e);\n  }\n);`, `96379613649906060000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token function">XFetch</span><span class="token punctuation">(</span>\n  <span class="token function">makeRequest</span><span class="token punctuation">(</span><span class="token string">\'https://time.geekbang.org\'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n  <span class="token keyword">function</span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token keyword">function</span> <span class="token function">reject</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h2 id="新的问题：回调地狱"><a href="#%E6%96%B0%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9A%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>新的问题：回调地狱</h2>\n<p>上面的示例代码已经比较符合人的线性思维了，在一些简单的场景下运行效果也是非常好的，不过一旦接触到稍微复杂点的项目时，你就会发现，如果嵌套了太多的回调函数就很容易使得自己陷入了回调地狱，不能自拔。你可以参考下面这段让人凌乱的代码：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="4146038213688485400"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`XFetch(makeRequest(\'https://time.geekbang.org/?category\'),\n  function resolve(response) {\n      console.log(response)\n      XFetch(makeRequest(\'https://time.geekbang.org/column\'),\n          function resolve(response) {\n              console.log(response)\n              XFetch(makeRequest(\'https://time.geekbang.org\')\n                  function resolve(response) {\n                      console.log(response)\n                  }, function reject(e) {\n                      console.log(e)\n                  })\n          }, function reject(e) {\n              console.log(e)\n          })\n  }, function reject(e) {\n      console.log(e)\n  })`, `4146038213688485400`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token function">XFetch</span><span class="token punctuation">(</span><span class="token function">makeRequest</span><span class="token punctuation">(</span><span class="token string">\'https://time.geekbang.org/?category\'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n  <span class="token keyword">function</span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token parameter">response</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span>\n      <span class="token function">XFetch</span><span class="token punctuation">(</span><span class="token function">makeRequest</span><span class="token punctuation">(</span><span class="token string">\'https://time.geekbang.org/column\'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n          <span class="token keyword">function</span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token parameter">response</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n              console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span>\n              <span class="token function">XFetch</span><span class="token punctuation">(</span><span class="token function">makeRequest</span><span class="token punctuation">(</span><span class="token string">\'https://time.geekbang.org\'</span><span class="token punctuation">)</span>\n                  <span class="token keyword">function</span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token parameter">response</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span>\n                  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token function">reject</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>\n                  <span class="token punctuation">}</span><span class="token punctuation">)</span>\n          <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token function">reject</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n              console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>\n          <span class="token punctuation">}</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token function">reject</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>这段代码是先请求 time.geekbang.org/?category，如果请求成功的话，那么再请求 time.geekbang.org/column，如果再次请求成功的话，就继续请求 time.geekbang.org。也就是说这段代码用了三层嵌套请求，就已经让代码变得混乱不堪，所以，我们还需要解决这种嵌套调用后混乱的代码结构。</p>\n<p>这段代码之所以看上去很乱，归结其原因有两点：</p>\n<ul>\n<li>第一是嵌套调用，下面的任务依赖上个任务的请求结果，并在上个任务的回调函数内部执行新的业务逻辑，这样当嵌套层次多了之后，代码的可读性就变得非常差了。</li>\n<li>第二是任务的不确定性，执行每个任务都有两种可能的结果（成功或者失败），所以体现在代码中就需要对每个任务的执行结果做两次判断，这种对每个任务都要进行一次额外的错误处理的方式，明显增加了代码的混乱程度。</li>\n</ul>\n<p>原因分析出来后，那么问题的解决思路就很清晰了：</p>\n<ul>\n<li>第一是消灭嵌套调用；</li>\n<li>第二是合并多个任务的错误处理。</li>\n</ul>\n<p>这么讲可能有点抽象，不过 Promise 已经帮助我们解决了这两个问题。那么接下来我们就来看看 Promise 是怎么消灭嵌套调用和合并多个任务的错误处理的。</p>\n<h2 id="promise：消灭嵌套调用和多次错误处理"><a href="#promise%EF%BC%9A%E6%B6%88%E7%81%AD%E5%B5%8C%E5%A5%97%E8%B0%83%E7%94%A8%E5%92%8C%E5%A4%9A%E6%AC%A1%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Promise：消灭嵌套调用和多次错误处理</h2>\n<p>首先，我们使用 Promise 来重构 XFetch 的代码，示例代码如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="51937466637395530000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function XFetch(request) {\n  function executor(resolve, reject) {\n    let xhr = new XMLHttpRequest();\n    xhr.open(\'GET\', request.url, true);\n    xhr.ontimeout = function(e) {\n      reject(e);\n    };\n    xhr.onerror = function(e) {\n      reject(e);\n    };\n    xhr.onreadystatechange = function() {\n      if (this.readyState === 4) {\n        if (this.status === 200) {\n          resolve(this.responseText, this);\n        } else {\n          let error = {\n            code: this.status,\n            response: this.response\n          };\n          reject(error, this);\n        }\n      }\n    };\n    xhr.send();\n  }\n  return new Promise(executor);\n}`, `51937466637395530000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span> <span class="token function">XFetch</span><span class="token punctuation">(</span><span class="token parameter">request</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">function</span> <span class="token function">executor</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">let</span> xhr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    xhr<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">\'GET\'</span><span class="token punctuation">,</span> request<span class="token punctuation">.</span>url<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    xhr<span class="token punctuation">.</span><span class="token function-variable function">ontimeout</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token function">reject</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span><span class="token punctuation">;</span>\n    xhr<span class="token punctuation">.</span><span class="token function-variable function">onerror</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token function">reject</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span><span class="token punctuation">;</span>\n    xhr<span class="token punctuation">.</span><span class="token function-variable function">onreadystatechange</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>readyState <span class="token operator">===</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">===</span> <span class="token number">200</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n          <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>responseText<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n          <span class="token keyword">let</span> error <span class="token operator">=</span> <span class="token punctuation">{</span>\n            code<span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>status<span class="token punctuation">,</span>\n            response<span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>response\n          <span class="token punctuation">}</span><span class="token punctuation">;</span>\n          <span class="token function">reject</span><span class="token punctuation">(</span>error<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n      <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span><span class="token punctuation">;</span>\n    xhr<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span>executor<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>接下来，我们再利用 XFetch 来构造请求流程，代码如下：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="52160263593709930000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`var x1 = XFetch(makeRequest(\'https://time.geekbang.org/?category\'));\nvar x2 = x1.then((value) => {\n  console.log(value);\n  return XFetch(makeRequest(\'https://www.geekbang.org/column\'));\n});\nvar x3 = x2.then((value) => {\n  console.log(value);\n  return XFetch(makeRequest(\'https://time.geekbang.org\'));\n});\nx3.catch((error) => {\n  console.log(error);\n});`, `52160263593709930000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">var</span> x1 <span class="token operator">=</span> <span class="token function">XFetch</span><span class="token punctuation">(</span><span class="token function">makeRequest</span><span class="token punctuation">(</span><span class="token string">\'https://time.geekbang.org/?category\'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">var</span> x2 <span class="token operator">=</span> x1<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">return</span> <span class="token function">XFetch</span><span class="token punctuation">(</span><span class="token function">makeRequest</span><span class="token punctuation">(</span><span class="token string">\'https://www.geekbang.org/column\'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">var</span> x3 <span class="token operator">=</span> x2<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">return</span> <span class="token function">XFetch</span><span class="token punctuation">(</span><span class="token function">makeRequest</span><span class="token punctuation">(</span><span class="token string">\'https://time.geekbang.org\'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nx3<span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">error</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>你可以观察上面这两段代码，重点关注下 Promise 的使用方式。</p>\n<ul>\n<li>首先我们引入了 Promise，在调用 XFetch 时，会返回一个 Promise 对象。</li>\n<li>构建 Promise 对象时，需要传入一个 executor 函数，XFetch 的主要业务流程都在 executor 函数中执行。</li>\n<li>如果运行在 excutor 函数中的业务执行成功了，会调用 resolve 函数；如果执行失败了，则调用 reject 函数。</li>\n<li>在 excutor 函数中调用 resolve 函数时，会触发 promise.then 设置的回调函数；而调用 reject 函数时，会触发 promise.catch 设置的回调函数</li>\n</ul>\n<p>以上简单介绍了 Promise 一些主要的使用方法，通过引入 Promise，上面这段代码看起来就非常线性了，也非常符合人的直觉，是不是很酷？基于这段代码，我们就可以来分析 Promise 是如何消灭嵌套回调和合并多个错误处理了。</p>\n<p>我们先来看看 Promise 是怎么消灭嵌套回调的。产生嵌套函数的一个主要原因是在发起任务请求时会带上回调函数，这样当任务处理结束之后，下个任务就只能在回调函数中来处理了。</p>\n<p>Promise 主要通过下面两步解决嵌套回调问题的。</p>\n<p>首先，Promise 实现了回调函数的延时绑定。回调函数的延时绑定在代码上体现就是先创建 Promise 对象 x1，通过 Promise 的构造函数 executor 来执行业务逻辑；创建好 Promise 对象 x1 之后，再使用 x1.then 来设置回调函数。示范代码如下：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="50028437679240140000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// 创建 Promise 对象 x1，并在 executor 函数中执行业务逻辑\nfunction executor(resolve, reject) {\n  resolve(100);\n}\nlet x1 = new Promise(executor);\n\n//x1 延迟绑定回调函数 onResolve\nfunction onResolve(value) {\n  console.log(value);\n}\nx1.then(onResolve);`, `50028437679240140000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">// 创建 Promise 对象 x1，并在 executor 函数中执行业务逻辑</span>\n<span class="token keyword">function</span> <span class="token function">executor</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">let</span> x1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span>executor<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token comment">//x1 延迟绑定回调函数 onResolve</span>\n<span class="token keyword">function</span> <span class="token function">onResolve</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\nx1<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>onResolve<span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>其次，需要将回调函数 onResolve 的返回值穿透到最外层。因为我们会根据 onResolve 函数的传入值来决定创建什么类型的 Promise 任务，创建好的 Promise 对象需要返回到最外层，这样就可以摆脱嵌套循环了。你可以先看下面的代码：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-07-09-26-17-4eedf9f9ac4ef89eccb3ce4b18a2644d-311f8.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 86.61971830985915%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAIAAABSJhvpAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABzUlEQVQ4y6WS224TMRCG86aIq3IDXFXc8CaIG3rTt0CqQKBIiFYKqGqU0j0kbLIeez1rr49r47RN2RwqKvHLsrSr+Twz/8wobsv3Dg3TXnW2S8d63TmZ7tZwrnmr26ZjfejvgkcPWAjrG6WZFaSslvnialHnixXJq6oCOisLQIIaqYS+97vwnaxNSY1sOeMEZRt8TGn6dHyIYSd2D1YqaBWsDUpF5XrRGd5oRBU2pQ7f2IW1tRVblXSekyyHbMmrZVNra4atbcEuu+Yn79vTk/bDO5xc/uaxIpxAQci8WlECzDobD2kNy/Nv5y+ef3919PPomRp/liEWC04Bshs2KyjhSJlgrBPCAJVd540ZGKYmF9M3r6/eHv86fonjL6k5Z60xRgjFUXc6teJ8mk9y2acrhE31azhI0d9ch3mhvn6yANgs62yC1SVvWDI/Pq6/hjnvAZEwquYXavpRFmNrlHMp2ybdQAM4faQf3itlIP8B0zNERnnXUFjVAkAYY2+jDsJbo/KNkOsloc2DMf8u+37DTC8FUo41IGsk5yoZ9VQ4tYjKlKwFWi/KeZpN3F/LRzOnzQwhPk2j+B86AKfBEELqugaA+laUUufcfuQf9J7Wa/K5hOwAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 07 09 26 17"\n        title=""\n        src="/static/2021-07-07-09-26-17-4eedf9f9ac4ef89eccb3ce4b18a2644d-fee1c.png"\n        srcset="/static/2021-07-07-09-26-17-4eedf9f9ac4ef89eccb3ce4b18a2644d-a67b7.png 200w,\n/static/2021-07-07-09-26-17-4eedf9f9ac4ef89eccb3ce4b18a2644d-0b187.png 400w,\n/static/2021-07-07-09-26-17-4eedf9f9ac4ef89eccb3ce4b18a2644d-fee1c.png 800w,\n/static/2021-07-07-09-26-17-4eedf9f9ac4ef89eccb3ce4b18a2644d-b1a91.png 1200w,\n/static/2021-07-07-09-26-17-4eedf9f9ac4ef89eccb3ce4b18a2644d-311f8.png 1420w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>现在我们知道了 Promise 通过回调函数延迟绑定和回调函数返回值穿透的技术，解决了循环嵌套。</p>\n<p>那接下来我们再来看看 Promise 是怎么处理异常的，你可以回顾上篇文章思考题留的那段代码，我把这段代码也贴在文中了，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="23868784034069602000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function executor(resolve, reject) {\n  let rand = Math.random();\n  console.log(1);\n  console.log(rand);\n  if (rand > 0.5) resolve();\n  else reject();\n}\nvar p0 = new Promise(executor);\n\nvar p1 = p0.then((value) => {\n  console.log(\'succeed-1\');\n  return new Promise(executor);\n});\n\nvar p3 = p1.then((value) => {\n  console.log(\'succeed-2\');\n  return new Promise(executor);\n});\n\nvar p4 = p3.then((value) => {\n  console.log(\'succeed-3\');\n  return new Promise(executor);\n});\n\np4.catch((error) => {\n  console.log(\'error\');\n});\nconsole.log(2);`, `23868784034069602000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span> <span class="token function">executor</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">let</span> rand <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>rand<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>rand <span class="token operator">></span> <span class="token number">0.5</span><span class="token punctuation">)</span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">else</span> <span class="token function">reject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">var</span> p0 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span>executor<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token keyword">var</span> p1 <span class="token operator">=</span> p0<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'succeed-1\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span>executor<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token keyword">var</span> p3 <span class="token operator">=</span> p1<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'succeed-2\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span>executor<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token keyword">var</span> p4 <span class="token operator">=</span> p3<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'succeed-3\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span>executor<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\np4<span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">error</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'error\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>这段代码有四个 Promise 对象：p0 ～ p4。无论哪个对象里面抛出异常，都可以通过最后一个对象 p4.catch 来捕获异常，通过这种方式可以将所有 Promise 对象的错误合并到一个函数来处理，这样就解决了每个任务都需要单独处理异常的问题。</p>\n<p>之所以可以使用最后一个对象来捕获所有异常，是因为 Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被 onReject 函数处理或 catch 语句捕获为止。具备了这样“冒泡”的特性后，就不需要在每个 Promise 对象中单独捕获异常了。至于 Promise 错误的“冒泡”性质是怎么实现的，就留给你课后思考了。</p>\n<p>通过这种方式，我们就消灭了嵌套调用和频繁的错误处理，这样使得我们写出来的代码更加优雅，更加符合人的线性思维。</p>\n<h2 id="promise-与微任务"><a href="#promise-%E4%B8%8E%E5%BE%AE%E4%BB%BB%E5%8A%A1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Promise 与微任务</h2>\n<p>讲了这么多，我们似乎还没有将微任务和 Promise 关联起来，那么 Promise 和微任务的关系到底体现哪里呢？</p>\n<p>我们可以结合下面这个简单的 Promise 代码来回答这个问题：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="45475635347123640000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function executor(resolve, reject) {\n  resolve(100);\n}\nlet demo = new Promise(executor);\n\nfunction onResolve(value) {\n  console.log(value);\n}\ndemo.then(onResolve);`, `45475635347123640000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span> <span class="token function">executor</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">let</span> demo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span>executor<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token keyword">function</span> <span class="token function">onResolve</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\ndemo<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>onResolve<span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>对于上面这段代码，我们需要重点关注下它的执行顺序。</p>\n<p>首先执行 new Promise 时，Promise 的构造函数会被执行，不过由于 Promise 是 V8 引擎提供的，所以暂时看不到 Promise 构造函数的细节。</p>\n<p>接下来，Promise 的构造函数会调用 Promise 的参数 executor 函数。然后在 executor 中执行了 resolve，resolve 函数也是在 V8 内部实现的，那么 resolve 函数到底做了什么呢？我们知道，执行 resolve 函数，会触发 demo.then 设置的回调函数 onResolve，所以可以推测，resolve 函数内部调用了通过 demo.then 设置的 onResolve 函数。</p>\n<p>不过这里需要注意一下，由于 Promise 采用了回调函数延迟绑定技术，所以在执行 resolve 函数的时候，回调函数还没有绑定，那么只能推迟回调函数的执行。</p>\n<p>这样按顺序陈述可能把你绕晕了，下面来模拟实现一个 Promise，我们会实现它的构造函数、resolve 方法以及 then 方法，以方便你能看清楚 Promise 的背后都发生了什么。这里我们就把这个对象称为 Bromise，下面就是 Bromise 的实现代码：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="37930356298877710000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function Bromise(executor) {\n  var onResolve_ = null;\n  var onReject_ = null;\n  // 模拟实现 resolve 和 then，暂不支持 rejcet\n  this.then = function(onResolve, onReject) {\n    onResolve_ = onResolve;\n  };\n  function resolve(value) {\n    //setTimeout(()=>{\n    onResolve_(value);\n    // },0)\n  }\n  executor(resolve, null);\n}`, `37930356298877710000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Bromise</span><span class="token punctuation">(</span><span class="token parameter">executor</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">var</span> onResolve_ <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n  <span class="token keyword">var</span> onReject_ <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n  <span class="token comment">// 模拟实现 resolve 和 then，暂不支持 rejcet</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">then</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">onResolve<span class="token punctuation">,</span> onReject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    onResolve_ <span class="token operator">=</span> onResolve<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">;</span>\n  <span class="token keyword">function</span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">//setTimeout(()=>{</span>\n    <span class="token function">onResolve_</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token comment">// },0)</span>\n  <span class="token punctuation">}</span>\n  <span class="token function">executor</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>观察上面这段代码，我们实现了自己的构造函数、resolve、then 方法。接下来我们使用 Bromise 来实现我们的业务代码，实现后的代码如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="85671273354143330000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function executor(resolve, reject) {\n  resolve(100);\n}\n// 将 Promise 改成我们自己的 Bromsie\nlet demo = new Bromise(executor);\n\nfunction onResolve(value) {\n  console.log(value);\n}\ndemo.then(onResolve);`, `85671273354143330000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span> <span class="token function">executor</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token comment">// 将 Promise 改成我们自己的 Bromsie</span>\n<span class="token keyword">let</span> demo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Bromise</span><span class="token punctuation">(</span>executor<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token keyword">function</span> <span class="token function">onResolve</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\ndemo<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>onResolve<span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>执行这段代码，我们发现执行出错，输出的内容是：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="79712731180619840000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`Uncaught TypeError: onResolve_ is not a function\n    at resolve (<anonymous>:10:13)\n    at executor (<anonymous>:17:5)\n    at new Bromise (<anonymous>:13:5)\n    at <anonymous>:19:12`, `79712731180619840000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">Uncaught TypeError: onResolve_ is not a function\n    at resolve (&lt;anonymous&gt;:10:13)\n    at executor (&lt;anonymous&gt;:17:5)\n    at new Bromise (&lt;anonymous&gt;:13:5)\n    at &lt;anonymous&gt;:19:12</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>之所以出现这个错误，是由于 Bromise 的延迟绑定导致的，在调用到 onResolve* 函数的时候，Bromise.then 还没有执行，所以执行上述代码的时候，当然会报“onResolve* is not a function“的错误了。</p>\n<p>也正是因为此，我们要改造 Bromise 中的 resolve 方法，让 resolve 延迟调用 onResolve_。</p>\n<p>要让 resolve 中的 onResolve* 函数延后执行，可以在 resolve 函数里面加上一个定时器，让其延时执行 onResolve* 函数，你可以参考下面改造后的代码：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="1675128057104702200"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function resolve(value) {\n  setTimeout(() => {\n    onResolve_(value);\n  }, 0);\n}`, `1675128057104702200`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n    <span class="token function">onResolve_</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>上面采用了定时器来推迟 onResolve 的执行，不过使用定时器的效率并不是太高，好在我们有微任务，所以 Promise 又把这个定时器改造成了微任务了，这样既可以让 onResolve_ 延时被调用，又提升了代码的执行效率。这就是 Promise 中使用微任务的原因了</p>\n<h2 id="总结-4"><a href="#%E6%80%BB%E7%BB%93-4" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总结</h2>\n<p>首先，我们回顾了 Web 页面是单线程架构模型，这种模型决定了我们编写代码的形式——异步编程。基于异步编程模型写出来的代码会把一些关键的逻辑点打乱，所以这种风格的代码不符合人的线性思维方式。接下来我们试着把一些不必要的回调接口封装起来，简单封装取得了一定的效果，不过，在稍微复杂点的场景下依然存在着回调地狱的问题。然后我们分析了产生回调地狱的原因：</p>\n<ul>\n<li>多层嵌套的问题；</li>\n<li>每种任务的处理结果存在两种可能性（成功或失败），那么需要在每种任务执行结束后分别处理这两种可能性。</li>\n</ul>\n<p>Promise 通过回调函数延迟绑定、回调函数返回值穿透和错误“冒泡”技术解决了上面的两个问题。</p>\n<p>最后，我们还分析了 Promise 之所以要使用微任务是由 Promise 回调函数延迟绑定技术导致的。</p>\n<h1 id="async-await-使用同步方式写异步代码"><a href="#async-await-%E4%BD%BF%E7%94%A8%E5%90%8C%E6%AD%A5%E6%96%B9%E5%BC%8F%E5%86%99%E5%BC%82%E6%AD%A5%E4%BB%A3%E7%A0%81" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>async await 使用同步方式写异步代码</h1>\n<p>在上篇文章中，我们介绍了怎么使用 Promise 来实现回调操作，使用 Promise 能很好地解决回调地狱的问题，但是这种方式充满了 Promise 的 then() 方法，如果处理流程比较复杂的话，那么整段代码将充斥着 then，语义化不明显，代码不能很好地表示执行流程。</p>\n<p>比如下面这样一个实际的使用场景：我先请求极客邦的内容，等返回信息之后，我再请求极客邦的另外一个资源。下面代码展示的是使用 fetch 来实现这样的需求，fetch 被定义在 window 对象中，可以用它来发起对远程资源的请求，该方法返回的是一个 Promise 对象，这和我们上篇文章中讲的 XFetch 很像，只不过 fetch 是浏览器原生支持的，没有利用 XMLHttpRequest 来封装。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="83552829925782500000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`fetch(\'https://www.geekbang.org\')\n  .then((response) => {\n    console.log(response);\n    return fetch(\'https://www.geekbang.org/test\');\n  })\n  .then((response) => {\n    console.log(response);\n  })\n  .catch((error) => {\n    console.log(error);\n  });`, `83552829925782500000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">\'https://www.geekbang.org\'</span><span class="token punctuation">)</span>\n  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">response</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">return</span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">\'https://www.geekbang.org/test\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span>\n  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">response</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span>\n  <span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">error</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>从这段 Promise 代码可以看出来，使用 promise.then 也是相当复杂，虽然整个请求流程已经线性化了，但是代码里面包含了大量的 then 函数，使得代码依然不是太容易阅读。基于这个原因，ES7 引入了 async/await，这是 JavaScript 异步编程的一个重大改进，提供了在不阻塞主线程的情况下使用同步代码实现异步访问资源的能力，并且使得代码逻辑更加清晰。你可以参考下面这段代码：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="2458778871204381000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`async function foo() {\n  try {\n    let response1 = await fetch(\'https://www.geekbang.org\');\n    console.log(\'response1\');\n    console.log(response1);\n    let response2 = await fetch(\'https://www.geekbang.org/test\');\n    console.log(\'response2\');\n    console.log(response2);\n  } catch (err) {\n    console.error(err);\n  }\n}\nfoo();`, `2458778871204381000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">try</span> <span class="token punctuation">{</span>\n    <span class="token keyword">let</span> response1 <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">\'https://www.geekbang.org\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'response1\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>response1<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">let</span> response2 <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">\'https://www.geekbang.org/test\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'response2\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>response2<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>通过上面代码，你会发现整个异步处理的逻辑都是使用同步代码的方式来实现的，而且还支持 try catch 来捕获异常，这就是完全在写同步代码，所以是非常符合人的线性思维的。但是很多人都习惯了异步回调的编程思维，对于这种采用同步代码实现异步逻辑的方式，还需要一个转换的过程，因为这中间隐藏了一些容易让人迷惑的细节。</p>\n<p>那么本篇文章我们继续深入，看看 JavaScript 引擎是如何实现 async/await 的。如果上来直接介绍 async/await 的使用方式的话，那么你可能会有点懵，所以我们就从其最底层的技术点一步步往上讲解，从而带你彻底弄清楚 async 和 await 到底是怎么工作的。</p>\n<p>本文我们首先介绍生成器（Generator）是如何工作的，接着讲解 Generator 的底层实现机制——协程（Coroutine）；又因为 async/await 使用了 Generator 和 Promise 两种技术，所以紧接着我们就通过 Generator 和 Promise 来分析 async/await 到底是如何以同步的方式来编写异步代码的。</p>\n<h2 id="生成器-vs-协程"><a href="#%E7%94%9F%E6%88%90%E5%99%A8-vs-%E5%8D%8F%E7%A8%8B" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>生成器 VS 协程</h2>\n<p>我们先来看看什么是生成器函数？</p>\n<p>生成器函数是一个带星号函数，而且是可以暂停执行和恢复执行的。我们可以看下面这段代码：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="97547176847940930000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function* genDemo() {\n  console.log(\' 开始执行第一段 \');\n  yield \'generator 2\';\n\n  console.log(\' 开始执行第二段 \');\n  yield \'generator 2\';\n\n  console.log(\' 开始执行第三段 \');\n  yield \'generator 2\';\n\n  console.log(\' 执行结束 \');\n  return \'generator 2\';\n}\n\nconsole.log(\'main 0\');\nlet gen = genDemo();\nconsole.log(gen.next().value);\nconsole.log(\'main 1\');\nconsole.log(gen.next().value);\nconsole.log(\'main 2\');\nconsole.log(gen.next().value);\nconsole.log(\'main 3\');\nconsole.log(gen.next().value);\nconsole.log(\'main 4\');`, `97547176847940930000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">genDemo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\' 开始执行第一段 \'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">yield</span> <span class="token string">\'generator 2\'</span><span class="token punctuation">;</span>\n\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\' 开始执行第二段 \'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">yield</span> <span class="token string">\'generator 2\'</span><span class="token punctuation">;</span>\n\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\' 开始执行第三段 \'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">yield</span> <span class="token string">\'generator 2\'</span><span class="token punctuation">;</span>\n\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\' 执行结束 \'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">return</span> <span class="token string">\'generator 2\'</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'main 0\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">let</span> gen <span class="token operator">=</span> <span class="token function">genDemo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>gen<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'main 1\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>gen<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'main 2\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>gen<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'main 3\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>gen<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'main 4\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>执行上面这段代码，观察输出结果，你会发现函数 genDemo 并不是一次执行完的，全局代码和 genDemo 函数交替执行。其实这就是生成器函数的特性，可以暂停执行，也可以恢复执行。下面我们就来看看生成器函数的具体使用方式：</p>\n<ul>\n<li>在生成器函数内部执行一段代码，如果遇到 yield 关键字，那么 JavaScript 引擎将返回关键字后面的内容给外部，并暂停该函数的执行。</li>\n<li>外部函数可以通过 next 方法恢复函数的执行</li>\n</ul>\n<p>关于函数的暂停和恢复，相信你一定很好奇这其中的原理，那么接下来我们就来简单介绍下 JavaScript 引擎 V8 是如何实现一个函数的暂停和恢复的，这也会有助于你理解后面要介绍的 async/await。</p>\n<p>要搞懂函数为何能暂停和恢复，那你首先要了解协程的概念。协程是一种比线程更加轻量级的存在。你可以把协程看成是跑在线程上的任务，一个线程上可以存在多个协程，但是在线程上同时只能执行一个协程，比如当前执行的是 A 协程，要启动 B 协程，那么 A 协程就需要将主线程的控制权交给 B 协程，这就体现在 A 协程暂停执行，B 协程恢复执行；同样，也可以从 B 协程中启动 A 协程。通常，如果从 A 协程启动 B 协程，我们就把 A 协程称为 B 协程的父协程。</p>\n<p>正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程。最重要的是，协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）。这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。</p>\n<p>为了让你更好地理解协程是怎么执行的，我结合上面那段代码的执行过程，画出了下面的“协程执行流程图”，你可以对照着代码来分析：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-07-09-33-10-f9e23b8a93102e501743b8445cce4c3d-205ae.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 53.648648648648646%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABTElEQVQoz6WSO04DMRCG9y4cB07ADXIHbgAIJPpUIKF0FHQIGkRExSsSBSKkQEDIbrJr7449Mx6H2c0KBQkQElP4+X/ze2wn839EsjyJsW5HOW2ej/cuU4tSL/4FlhgpBO3vxn51f7jee5xYXGQkDkQk9W4tC3VoH5NmOwZEACwKY02u8zfjUh0XBSGpc+l8aS16r2JktqUtK5AWro0psxV4ZGLNRZ7AWu8gSBAWV1auqtRcdcaANZYJ22PfT7B7nZ+NIOgaoqYUEfSoVhxYJDIF7xw28OmwXDt42r7IWvhwkK9s3XavpnNBcE510PhoAIDTejQLMzivR7p5zjdOXnqDaQsDiXH4kGHn+HWnn6o/OSfNnSjDSiJqLRyCjoXpy21/vlDnaLTbf//9bWOjXyDJTyJ19l7rRq3iT59kORTLsmw2m6VpGuP3P+UDbAl6la0gdsQAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 07 09 33 10"\n        title=""\n        src="/static/2021-07-07-09-33-10-f9e23b8a93102e501743b8445cce4c3d-fee1c.png"\n        srcset="/static/2021-07-07-09-33-10-f9e23b8a93102e501743b8445cce4c3d-a67b7.png 200w,\n/static/2021-07-07-09-33-10-f9e23b8a93102e501743b8445cce4c3d-0b187.png 400w,\n/static/2021-07-07-09-33-10-f9e23b8a93102e501743b8445cce4c3d-fee1c.png 800w,\n/static/2021-07-07-09-33-10-f9e23b8a93102e501743b8445cce4c3d-b1a91.png 1200w,\n/static/2021-07-07-09-33-10-f9e23b8a93102e501743b8445cce4c3d-205ae.png 1480w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从图中可以看出来协程的四点规则：</p>\n<ul>\n<li>通过调用生成器函数 genDemo 来创建一个协程 gen，创建之后，gen 协程并没有立即执行。</li>\n<li>要让 gen 协程执行，需要通过调用 gen.next。</li>\n<li>当协程正在执行的时候，可以通过 yield 关键字来暂停 gen 协程的执行，并返回主要信息给父协程。</li>\n<li>如果协程在执行期间，遇到了 return 关键字，那么 JavaScript 引擎会结束当前协程，并将 return 后面的内容返回给父协程。</li>\n</ul>\n<p>不过，对于上面这段代码，你可能又有这样疑问：父协程有自己的调用栈，gen 协程时也有自己的调用栈，当 gen 协程通过 yield 把控制权交给父协程时，V8 是如何切换到父协程的调用栈？当父协程通过 gen.next 恢复 gen 协程时，又是如何切换 gen 协程的调用栈？</p>\n<p>要搞清楚上面的问题，你需要关注以下两点内容。</p>\n<p>第一点：gen 协程和父协程是在主线程上交互执行的，并不是并发执行的，它们之前的切换是通过 yield 和 gen.next 来配合完成的。</p>\n<p>第二点：当在 gen 协程中调用了 yield 方法时，JavaScript 引擎会保存 gen 协程当前的调用栈信息，并恢复父协程的调用栈信息。同样，当在父协程中执行 gen.next 时，JavaScript 引擎会保存父协程的调用栈信息，并恢复 gen 协程的调用栈信息。</p>\n<p>为了直观理解父协程和 gen 协程是如何切换调用栈的，你可以参考下图</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-07-09-33-58-971ddbb92ba939af1476f008fd2421e0-ea453.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 88.32335329341318%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAIAAADUsmlHAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACbElEQVQ4y6VTW2sTQRTOv/AHSIv4YqE1oD6oD76If8CCQh+KiReqtKCiDyYq1TZpQCI21ggiFFqkVqitCFIopU0rFHpP1Nzaprltdje7O7M7OzM7zm6qraWaBw+HgTmH75xvzvnGxf7DXHsvlmVhE1HG0PoYmArCmTCMRagu13J1wBDCTCoJCGPjXhw8RMINJHKMyRkHTA8AW47VLqIoplIpwzDeRvo6rly+3eG93+kVittOY3pwZ2oxk1jcDUy588jMcmZoMv5u6tvodELRdB7iWZ7hJyIWoTvNXOVyWZUFp7bJCGREp6ZGMfpdHiOdBxkGzML7OxtQm1hT+mPg9bwandcG5sDwCqlqBiUUE8oIXsnp/bNqdE6JfgVvFowXs9p0GtX42rQffAGN3Wl3KNMSTDUF0udeiVmRD40R55mDC2qDb/14INkS2nSHsof9cf+nspO1bPC9sUKjf83dm3AHfjT1JM+/3BK0XfDoknL0afZkON/8ZO3Es40j3elHn4Vd8OCS2T5cuvlB6HhfvjZS9k3qCsT2cuwtkNiGefUj7hwHN0aKXRPQM2YOLeMd2pIkyWJl3ySAjnSTD9+CiCDT/KvCqtUqh9ujoXYryymJKmkjv2oU4np+FUGFOCRttxj3X5v6U2FcHoqiIgMKI9c3w2dyAxdyz0/j/GIdhdVExlkkvicpqPT1PG713PF0PbzU1p5PLtkvpPRf2uZ4WZa2tgtYKdz19Ta3+k+19Zy9eCubWKwP3vu7uMi3i0K+JBaKJf7PasH6YIyxoqqqoiAd6FA1dChKkqZp9f9zjR4fm2YbsB3YhhA6EPwTvWbTJh66KZgAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 07 09 33 58"\n        title=""\n        src="/static/2021-07-07-09-33-58-971ddbb92ba939af1476f008fd2421e0-fee1c.png"\n        srcset="/static/2021-07-07-09-33-58-971ddbb92ba939af1476f008fd2421e0-a67b7.png 200w,\n/static/2021-07-07-09-33-58-971ddbb92ba939af1476f008fd2421e0-0b187.png 400w,\n/static/2021-07-07-09-33-58-971ddbb92ba939af1476f008fd2421e0-fee1c.png 800w,\n/static/2021-07-07-09-33-58-971ddbb92ba939af1476f008fd2421e0-b1a91.png 1200w,\n/static/2021-07-07-09-33-58-971ddbb92ba939af1476f008fd2421e0-ea453.png 1336w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>到这里相信你已经弄清楚了协程是怎么工作的，其实在 JavaScript 中，生成器就是协程的一种实现方式，这样相信你也就理解什么是生成器了。那么接下来，我们使用生成器和 Promise 来改造开头的那段 Promise 代码。改造后的代码如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="42239123261874225000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`//foo 函数\nfunction* foo() {\n  let response1 = yield fetch(\'https://www.geekbang.org\');\n  console.log(\'response1\');\n  console.log(response1);\n  let response2 = yield fetch(\'https://www.geekbang.org/test\');\n  console.log(\'response2\');\n  console.log(response2);\n}\n\n// 执行 foo 函数的代码\nlet gen = foo();\nfunction getGenPromise(gen) {\n  return gen.next().value;\n}\ngetGenPromise(gen)\n  .then((response) => {\n    console.log(\'response1\');\n    console.log(response);\n    return getGenPromise(gen);\n  })\n  .then((response) => {\n    console.log(\'response2\');\n    console.log(response);\n  });`, `42239123261874225000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">//foo 函数</span>\n<span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">let</span> response1 <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">\'https://www.geekbang.org\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'response1\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>response1<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">let</span> response2 <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">\'https://www.geekbang.org/test\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'response2\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>response2<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// 执行 foo 函数的代码</span>\n<span class="token keyword">let</span> gen <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">function</span> <span class="token function">getGenPromise</span><span class="token punctuation">(</span><span class="token parameter">gen</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> gen<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token function">getGenPromise</span><span class="token punctuation">(</span>gen<span class="token punctuation">)</span>\n  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">response</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'response1\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">return</span> <span class="token function">getGenPromise</span><span class="token punctuation">(</span>gen<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span>\n  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">response</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'response2\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>从图中可以看到，foo 函数是一个生成器函数，在 foo 函数里面实现了用同步代码形式来实现异步操作；但是在 foo 函数外部，我们还需要写一段执行 foo 函数的代码，如上述代码的后半部分所示，那下面我们就来分析下这段代码是如何工作的。</p>\n<ul>\n<li>首先执行的是 let gen = foo()，创建了 gen 协程。</li>\n<li>然后在父协程中通过执行 gen.next 把主线程的控制权交给 gen 协程。</li>\n<li>gen 协程获取到主线程的控制权后，就调用 fetch 函数创建了一个 Promise 对象 response1，然后通过 yield 暂停 gen 协程的执行，并将 response1 返回给父协程。</li>\n<li>父协程恢复执行后，调用 response1.then 方法等待请求结果。</li>\n<li>等通过 fetch 发起的请求完成之后，会调用 then 中的回调函数，then 中的回调函数拿到结果之后，通过调用 gen.next 放弃主线程的控制权，将控制权交 gen 协程继续执行下个请求。</li>\n</ul>\n<p>以上就是协程和 Promise 相互配合执行的一个大致流程。不过通常，我们把执行生成器的代码封装成一个函数，并把这个执行生成器代码的函数称为执行器（可参考著名的 co 框架），如下面这种方式：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="18355360287429634000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function* foo() {\n  let response1 = yield fetch(\'https://www.geekbang.org\');\n  console.log(\'response1\');\n  console.log(response1);\n  let response2 = yield fetch(\'https://www.geekbang.org/test\');\n  console.log(\'response2\');\n  console.log(response2);\n}\nco(foo());`, `18355360287429634000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">let</span> response1 <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">\'https://www.geekbang.org\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'response1\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>response1<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">let</span> response2 <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">\'https://www.geekbang.org/test\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'response2\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>response2<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token function">co</span><span class="token punctuation">(</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>通过使用生成器配合执行器，就能实现使用同步的方式写出异步代码了，这样也大大加强了代码的可读性。</p>\n<h2 id="asyncawait"><a href="#asyncawait" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>async/await</h2>\n<p>虽然生成器已经能很好地满足我们的需求了，但是程序员的追求是无止境的，这不又在 ES7 中引入了 async/await，这种方式能够彻底告别执行器和生成器，实现更加直观简洁的代码。其实 async/await 技术背后的秘密就是 Promise 和生成器应用，往底层说就是微任务和协程应用。要搞清楚 async 和 await 的工作原理，我们就得对 async 和 await 分开分析。</p>\n<h3 id="async"><a href="#async" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>async</h3>\n<p>我们先来看看 async 到底是什么？根据 MDN 定义，async 是一个通过异步执行并隐式返回 Promise 作为结果的函数。</p>\n<p>对 async 函数的理解，这里需要重点关注两个词：异步执行和隐式返回 Promise。</p>\n<p>关于异步执行的原因，我们一会儿再分析。这里我们先来看看是如何隐式返回 Promise 的，你可以参考下面的代码：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="8339754391815357000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`async function foo() {\n  return 2;\n}\n\nconsole.log(foo()); // Promise {<resolved>: 2}`, `8339754391815357000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token number">2</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Promise {&lt;resolved>: 2}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>执行这段代码，我们可以看到调用 async 声明的 foo 函数返回了一个 Promise 对象，状态是 resolved，返回结果如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="5949174852437733000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`Promise {<resolved>: 2}`, `5949174852437733000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">Promise {&lt;resolved&gt;: 2}</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<h3 id="await"><a href="#await" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>await</h3>\n<p>我们知道了 async 函数返回的是一个 Promise 对象，那下面我们再结合文中这段代码来看看 await 到底是什么。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="13191699624244068000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`async function foo() {\n  console.log(1);\n  let a = await 100;\n  console.log(a);\n  console.log(2);\n}\nconsole.log(0);\nfoo();\nconsole.log(3);`, `13191699624244068000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token number">100</span><span class="token punctuation">;</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>观察上面这段代码，你能判断出打印出来的内容是什么吗？这得先来分析 async 结合 await 到底会发生什么。在详细介绍之前，我们先站在协程的视角来看看这段代码的整体执行流程图：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-07-09-37-14-71c0b4b2a21afa0107815d2005fccec4-a368f.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 56.89149560117303%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABhklEQVQoz42SSUvDQBTH+w31Lorgh/As3rx60VtPIgpuB0HxIHhwt+0kTVpBROwiaZI22+zzxpdaFaWCj19m/zPv/yYVOyXgL4SybIwy5bmK/UfAuDVgV8/V0r5Y3OObd+pbDIB7UHY4ljnQCFgMfILhseWxpMPlkwKVc7ti4/ZTLKQEUCxPBOc41WlHBUQNPPbm0p7D+3XWq5mAyM5D/OoImjJtpS6vqWAjGCVdfuTklAlcUmmXB66N/NYjWTm8Xzu+vyK19dMHHOxc3Gkaf1mpjDO1Z09m29UWyjpA3lehZ5N2vd2cqTbmt8hJzVvYIrNVsnzQUCz5FuOXZZnWpQdKGWWchs95t057ZPBKrpvOrUt6L+5N07l0nYZPslEwSjJWFBOxMRoAsJgc3UvJhx0Us7cm2sbkbeBC5NmRb4eIJ4thwbgUYvpTyaSfdupZt5FjtQJfRS0VtlTULgl9EOmPtH+HEVazCYaXgABFJxj9dXD6T8K5SLMcQXthFAfBAD4K+zPeAbGralM4bwnIAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 07 09 37 14"\n        title=""\n        src="/static/2021-07-07-09-37-14-71c0b4b2a21afa0107815d2005fccec4-fee1c.png"\n        srcset="/static/2021-07-07-09-37-14-71c0b4b2a21afa0107815d2005fccec4-a67b7.png 200w,\n/static/2021-07-07-09-37-14-71c0b4b2a21afa0107815d2005fccec4-0b187.png 400w,\n/static/2021-07-07-09-37-14-71c0b4b2a21afa0107815d2005fccec4-fee1c.png 800w,\n/static/2021-07-07-09-37-14-71c0b4b2a21afa0107815d2005fccec4-b1a91.png 1200w,\n/static/2021-07-07-09-37-14-71c0b4b2a21afa0107815d2005fccec4-a368f.png 1364w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>结合上图，我们来一起分析下 async/await 的执行流程。</p>\n<p>首先，执行 console.log(0)这个语句，打印出来 0。</p>\n<p>紧接着就是执行 foo 函数，由于 foo 函数是被 async 标记过的，所以当进入该函数的时候，JavaScript 引擎会保存当前的调用栈等信息，然后执行 foo 函数中的 console.log(1)语句，并打印出 1。</p>\n<p>接下来就执行到 foo 函数中的 await 100 这个语句了，这里是我们分析的重点，因为在执行 await 100 这个语句时，JavaScript 引擎在背后为我们默默做了太多的事情，那么下面我们就把这个语句拆开，来看看 JavaScript 到底都做了哪些事情。</p>\n<p>当执行到 await 100 时，会默认创建一个 Promise 对象，代码如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="24792995128972284000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`let promise_ = new Promise((resolve,reject){\n  resolve(100)\n})`, `24792995128972284000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">let</span> promise_ <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span>reject<span class="token punctuation">)</span><span class="token punctuation">{</span>\n  <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span></span></pre></div>\n<p>在这个 promise_ 对象创建的过程中，我们可以看到在 executor 函数中调用了 resolve 函数，JavaScript 引擎会将该任务提交给微任务队列（上一篇文章中我们讲解过）。</p>\n<p>然后 JavaScript 引擎会暂停当前协程的执行，将主线程的控制权转交给父协程执行，同时会将 promise_ 对象返回给父协程。</p>\n<p>主线程的控制权已经交给父协程了，这时候父协程要做的一件事是调用 promise_.then 来监控 promise 状态的改变。</p>\n<p>接下来继续执行父协程的流程，这里我们执行 console.log(3)，并打印出来 3。随后父协程将执行结束，在结束之前，会进入微任务的检查点，然后执行微任务队列，微任务队列中有 resolve(100)的任务等待执行，执行到这里的时候，会触发 promise_.then 中的回调函数，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="10351872503478954000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`promise_.then((value) => {\n  // 回调函数被激活后\n  // 将主线程控制权交给 foo 协程，并将 value 值传给协程\n});`, `10351872503478954000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js">promise_<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  <span class="token comment">// 回调函数被激活后</span>\n  <span class="token comment">// 将主线程控制权交给 foo 协程，并将 value 值传给协程</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>该回调函数被激活以后，会将主线程的控制权交给 foo 函数的协程，并同时将 value 值传给该协程。</p>\n<p>foo 协程激活之后，会把刚才的 value 值赋给了变量 a，然后 foo 协程继续执行后续语句，执行完成之后，将控制权归还给父协程。</p>\n<p>以上就是 await/async 的执行流程。正是因为 async 和 await 在背后为我们做了大量的工作，所以我们才能用同步的方式写出异步代码来</p>\n<h2 id="总结-5"><a href="#%E6%80%BB%E7%BB%93-5" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总结</h2>\n<ul>\n<li>Promise 的编程模型依然充斥着大量的 then 方法，虽然解决了回调地狱的问题，但是在语义方面依然存在缺陷，代码中充斥着大量的 then 函数，这就是 async/await 出现的原因。</li>\n<li>使用 async/await 可以实现用同步代码的风格来编写异步代码，这是因为 async/await 的基础技术使用了生成器和 Promise，生成器是协程的实现，利用生成器能实现生成器函数的暂停和恢复。</li>\n<li>另外，V8 引擎还为 async/await 做了大量的语法层面包装，所以了解隐藏在背后的代码有助于加深你对 async/await 的理解。</li>\n<li>async/await 无疑是异步编程领域非常大的一个革新，也是未来的一个主流的编程风格。其实，除了 JavaScript，Python、Dart、C# 等语言也都引入了 async/await，使用它不仅能让代码更加整洁美观，而且还能确保该函数始终都能返回 Promise</li>\n</ul>',
id:"/github/workspace/blog/浏览器工作原理与实践——页面循环系统/index.md absPath of file >>> MarkdownRemark",timeToRead:32,frontmatter:{date:"2021-07-05 15:32:26",path:"/browser-working-principle-cycle-system/",tags:"前端, 浏览器, 高级前端",title:"浏览器工作原理与实践——页面循环系统",draft:null}},{excerpt:"栈空间和堆空间：数据是如何存储的 对于前端开发者来说，JavaScript 的内存机制是一个不被经常提及的概念，因此很容易被忽视。特别是一些非计算机专业的同学，对内存机制可能没有非常清晰的认识，甚至有些同学根本就不知道 JavaScript 的内存机制是什么。 但是如果你想成为行业专家，并打造高性能前端应用，那么你就必须要搞清楚 JavaScript 的内存机制了。 其实，要搞清楚 JavaScript 的内存机制并不是一件很困难的事，在接下来的三篇文章（数据在内存中的存放、JavaScript…",html:'<h1 id="栈空间和堆空间：数据是如何存储的"><a href="#%E6%A0%88%E7%A9%BA%E9%97%B4%E5%92%8C%E5%A0%86%E7%A9%BA%E9%97%B4%EF%BC%9A%E6%95%B0%E6%8D%AE%E6%98%AF%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E7%9A%84" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>栈空间和堆空间：数据是如何存储的</h1>\n<p>对于前端开发者来说，JavaScript 的内存机制是一个不被经常提及的概念，因此很容易被忽视。特别是一些非计算机专业的同学，对内存机制可能没有非常清晰的认识，甚至有些同学根本就不知道 JavaScript 的内存机制是什么。</p>\n<p>但是如果你想成为行业专家，并打造高性能前端应用，那么你就必须要搞清楚 JavaScript 的内存机制了。</p>\n<p>其实，要搞清楚 JavaScript 的内存机制并不是一件很困难的事，在接下来的三篇文章（数据在内存中的存放、JavaScript 处理垃圾回收以及 V8 执行代码）中，我们将通过内存机制的介绍，循序渐进带你走进 JavaScript 内存的世界。</p>\n<p>今天我们讲述第一部分的内容——JavaScript 中的数据是如何存储在内存中的。虽然 JavaScript 并不需要直接去管理内存，但是在实际项目中为了能避开一些不必要的坑，你还是需要了解数据在内存中的存储方式的</p>\n<h2 id="让人疑惑的代码"><a href="#%E8%AE%A9%E4%BA%BA%E7%96%91%E6%83%91%E7%9A%84%E4%BB%A3%E7%A0%81" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>让人疑惑的代码</h2>\n<p>首先，我们先看下面这两段代码：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="82989175208770670000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function foo() {\n  var a = 1;\n  var b = a;\n  a = 2;\n  console.log(a);\n  console.log(b);\n}\nfoo();`, `82989175208770670000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>\n  <span class="token keyword">var</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span>\n  a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="15846359569236013000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function foo() {\n  var a = { name: \'极客时间\' };\n  var b = a;\n  a.name = \'极客邦\';\n  console.log(a);\n  console.log(b);\n}\nfoo();`, `15846359569236013000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">\'极客时间\'</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>\n  <span class="token keyword">var</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span>\n  a<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">\'极客邦\'</span><span class="token punctuation">;</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>若执行上述这两段代码，你知道它们输出的结果是什么吗？下面我们就来一个一个分析下。</p>\n<p>执行第一段代码，打印出来 a 的值是 2，b 的值是 1，这没什么难以理解的。</p>\n<p>接着，再执行第二段代码，你会发现，仅仅改变了 a 中 name 的属性值，但是最终 a 和 b 打印出来的值都是 <code class="language-text">{name: &quot;极客邦&quot;}</code>。这就和我们预期的不一致了，因为我们想改变的仅仅是 a 的内容，但 b 的内容也同时被改变了。</p>\n<p>要彻底弄清楚这个问题，我们就得先从“JavaScript 是什么类型的语言”讲起。</p>\n<h2 id="javascript-是什么类型的语言"><a href="#javascript-%E6%98%AF%E4%BB%80%E4%B9%88%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%AF%AD%E8%A8%80" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>JavaScript 是什么类型的语言</h2>\n<p>每种编程语言都具有内建的数据类型，但它们的数据类型常有不同之处，使用方式也很不一样，比如 C 语言在定义变量之前，就需要确定变量的类型，你可以看下面这段 C 代码：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="64022978401538520000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`int main()\n{\n   int a = 1;\n   char* b = &quot;极客时间&quot;;\n   bool c = true;\n   return 0;\n}`, `64022978401538520000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                cpp 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="cpp"><pre style="counter-reset: linenumber NaN" class="language-cpp line-numbers"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n<span class="token punctuation">{</span>\n   <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>\n   <span class="token keyword">char</span><span class="token operator">*</span> b <span class="token operator">=</span> <span class="token string">"极客时间"</span><span class="token punctuation">;</span>\n   <span class="token keyword">bool</span> c <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n   <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>上述代码声明变量的特点是：在声明变量之前需要先定义变量类型，我们把这种在使用之前就需要确认其变量数据类型的称为静态语言。</p>\n<p>相反地，我们把在运行过程中需要检查数据类型的语言称为动态语言。比如我们所讲的 JavaScript 就是动态语言，因为在声明变量之前并不需要确认其数据类型。</p>\n<p>虽然 C 语言是静态，但是在 C 语言中，我们可以把其他类型数据赋予给一个声明好的变量，如：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="93292007379876070000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`c = a`, `93292007379876070000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">c = a</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>前面代码中，我们把 int 型的变量 a 赋值给了 bool 型的变量 c，这段代码也是可以编译执行的，因为在赋值过程中，C 编译器会把 int 型的变量悄悄转换为 bool 型的变量，我们通常把这种偷偷转换的操作称为隐式类型转换。而支持隐式类型转换的语言称为弱类型语言，不支持隐式类型转换的语言称为强类型语言。在这点上，C 和 JavaScript 都是弱类型语言。</p>\n<p>对于各种语言的类型，你可以参考下图</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-05-11-32-53-de9b1a6002d33cb8f31dff4fcf8163e4-74b93.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 85.39493293591654%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAIAAABSJhvpAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABf0lEQVQ4y5WTS04DMQyGewrWXITTIHEHlpyBK8CiIMGCRTccABZIILVIICRoKaWddh6ZPCaZ2A6ZTIXa0imtpZGi2J9/2/G0XLMhOYuOmgNaa29rIJI4YAC4I1ybBkoLcs3am2ADTpQb/MswBfMHAEiSWGjLDbIspeDaVhkRkzhmyuSGJOdEm5WDXwr+ORgopeo7UVJS9ex8FWmarIG9kxn0s8mNyzUyVWpLyjoFbiyoz6qzL14aLMCP0MmSpCWmMcDkMo0GiBnndb5ikclyyvXbcDLi+M4oK8DnVSGjh7Wt+KyGVyrJWWpL48vx+rwq24EpqKHp1u9KhJFW+fJeZ3h+OG4ffd+3BdWb5lRR+CmubNGSMgLMklTH/ejhKro7m/W7eTmPFEIswn+fqgoq2Cx/7oinC9u9lORiha55xRbgUHOZfLye7PeO90anB7mUkZqz/y5J6M8I3r3JHq/ly22sYMgRaPcfwyuFZcV6itvChOA//2DRNBpPJlLKJvgH2GDiSc51JmIAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 05 11 32 53"\n        title=""\n        src="/static/2021-07-05-11-32-53-de9b1a6002d33cb8f31dff4fcf8163e4-fee1c.png"\n        srcset="/static/2021-07-05-11-32-53-de9b1a6002d33cb8f31dff4fcf8163e4-a67b7.png 200w,\n/static/2021-07-05-11-32-53-de9b1a6002d33cb8f31dff4fcf8163e4-0b187.png 400w,\n/static/2021-07-05-11-32-53-de9b1a6002d33cb8f31dff4fcf8163e4-fee1c.png 800w,\n/static/2021-07-05-11-32-53-de9b1a6002d33cb8f31dff4fcf8163e4-b1a91.png 1200w,\n/static/2021-07-05-11-32-53-de9b1a6002d33cb8f31dff4fcf8163e4-74b93.png 1342w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<h2 id="javascript-的数据类型"><a href="#javascript-%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>JavaScript 的数据类型</h2>\n<p>现在我们知道了，JavaScript 是一种弱类型的、动态的语言。那这些特点意味着什么呢？</p>\n<ul>\n<li>弱类型，意味着你不需要告诉 JavaScript 引擎这个或那个变量是什么数据类型，JavaScript 引擎在运行代码的时候自己会计算出来。</li>\n<li>动态，意味着你可以使用同一个变量保存不同类型的数据</li>\n</ul>\n<p>那么接下来，我们再来看看 JavaScript 的数据类型，你可以看下面这段代码：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="54514291969405560000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`var bar;\nbar = 12;\nbar = \'极客时间\';\nbar = true;\nbar = null;\nbar = { name: \'极客时间\' };`, `54514291969405560000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">var</span> bar<span class="token punctuation">;</span>\nbar <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">;</span>\nbar <span class="token operator">=</span> <span class="token string">\'极客时间\'</span><span class="token punctuation">;</span>\nbar <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\nbar <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\nbar <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">\'极客时间\'</span> <span class="token punctuation">}</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>从上述代码中你可以看出，我们声明了一个 bar 变量，然后可以使用各种类型的数据值赋予给该变量。</p>\n<p>在 JavaScript 中，如果你想要查看一个变量到底是什么类型，可以使用“typeof”运算符。具体使用方式如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="32750134946004030000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`var bar;\nconsole.log(typeof bar); // undefined\nbar = 12;\nconsole.log(typeof bar); // number\nbar = \'极客时间\';\nconsole.log(typeof bar); // string\nbar = true;\nconsole.log(typeof bar); // boolean\nbar = null;\nconsole.log(typeof bar); // object\nbar = { name: \'极客时间\' };\nconsole.log(typeof bar); // object`, `32750134946004030000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">var</span> bar<span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> bar<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined</span>\nbar <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> bar<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// number</span>\nbar <span class="token operator">=</span> <span class="token string">\'极客时间\'</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> bar<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// string</span>\nbar <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> bar<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// boolean</span>\nbar <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> bar<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// object</span>\nbar <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">\'极客时间\'</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> bar<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// object</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>执行这段代码，你可以看到打印出来了不同的数据类型，有 undefined、number、boolean、object 等。那么接下来我们就来谈谈 JavaScript 到底有多少种数据类型。</p>\n<p>其实 JavaScript 中的数据类型一种有 8 种，它们分别是：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-05-11-34-28-f4de02d367abf9d7ef48b6f92606322c-ed3f4.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 55.74534161490683%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAB3UlEQVQoz0VRy24TQRD0VyMhwBEinDggEEJc4DMQ2FKSgyPFShQT2/uY9a5n57lPj3fdg2NfbHrWUZBKre7SVFd3T8/e/tiOPrWDMxi8toihi/D71Qn2+jNcvIdfL58ZfAY/X8D1l+Px2DPj783o4/ryfDV4sx6emUHfDPtw9e4EO/4Kow9w+faZgatzuOhvxt+cmCsuMmbAyFLLQqlS121t9xb21u4Atg08brC0e+hiR+5gs90cDyimnuZeqUku/HRxr9KZKeIqi06oi3jlSvKfyRemXDQ1d86FTthyuippmUUi9UQ6l8zTMtQi0CJ0kCFbznjqcYpxjkkmQ2i0E0tOOtbz52NvejOdjIh/S+OHYD5OogmjM1QqHkjuc+r6LuM/SXSfq+RJXGYLaCS+QLdMEadZznIdCeY5cWdY6KgqknWdFhofi93f6nA49DIV10VSZnEcTdAQY7KYEP+O0TlORJMHEtzhUNgokwQHRv26po2RzllworhnqtTZSsz9Ko/RFss6j3FnJHNFcGxMuhnFZs1bo7qvYoHAC1cUr4UTYm9cjKezNJliI3RGvusbtoY9grattK14OpjgsRSkKlIlcMkw14lghC49ztDNJYwGq4o3RmE8oS6ZWTnnf5oeOk1ATy/iAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 05 11 34 28"\n        title=""\n        src="/static/2021-07-05-11-34-28-f4de02d367abf9d7ef48b6f92606322c-fee1c.png"\n        srcset="/static/2021-07-05-11-34-28-f4de02d367abf9d7ef48b6f92606322c-a67b7.png 200w,\n/static/2021-07-05-11-34-28-f4de02d367abf9d7ef48b6f92606322c-0b187.png 400w,\n/static/2021-07-05-11-34-28-f4de02d367abf9d7ef48b6f92606322c-fee1c.png 800w,\n/static/2021-07-05-11-34-28-f4de02d367abf9d7ef48b6f92606322c-b1a91.png 1200w,\n/static/2021-07-05-11-34-28-f4de02d367abf9d7ef48b6f92606322c-ed3f4.png 1288w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>了解这些类型之后，还有三点需要你注意一下。</p>\n<p>第一点，使用 typeof 检测 Null 类型时，返回的是 Object。这是当初 JavaScript 语言的一个 Bug，一直保留至今，之所以一直没修改过来，主要是为了兼容老的代码。</p>\n<p>第二点，Object 类型比较特殊，它是由上述 7 种类型组成的一个包含了 key-value 对的数据类型。如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="50943526835316800000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`let myObj = {\n  name: \'极客时间\',\n  update: function() {....}\n}`, `50943526835316800000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">let</span> myObj <span class="token operator">=</span> <span class="token punctuation">{</span>\n  name<span class="token punctuation">:</span> <span class="token string">\'极客时间\'</span><span class="token punctuation">,</span>\n  <span class="token function-variable function">update</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">.</span><span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>从中你可以看出来，Object 是由 key-value 组成的，其中的 vaule 可以是任何类型，包括函数，这也就意味着你可以通过 Object 来存储函数，Object 中的函数又称为方法，比如上述代码中的 update 方法。</p>\n<p>第三点，我们把前面的 7 种数据类型称为原始类型，把最后一个对象类型称为引用类型，之所以把它们区分为两种不同的类型，是因为它们在内存中存放的位置不一样。到底怎么个不一样法呢？接下来，我们就来讲解一下 JavaScript 的原始类型和引用类型到底是怎么储存的。</p>\n<h2 id="内存空间"><a href="#%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>内存空间</h2>\n<p>要理解 JavaScript 在运行过程中数据是如何存储的，你就得先搞清楚其存储空间的种类。下面是我画的 JavaScript 的内存模型，你可以参考下：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-05-11-35-12-736885d7c0436c33374eb14a3c7c9f69-4c847.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 618px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 200.32362459546925%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAoCAIAAABxU02MAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACJUlEQVRIx+2STU8TURSG7x9yU4EiJmL4EGpFEsHowgUxLnShRlZ2aAvtFIoffBja0slQqEiNSctURQJJQWKMJq7cGP+BO5k75047xp3nTtF0ZkDI1SXJk5Nz33nfnHtuhvz8oglDjCcnhCGQPeVGaYNsGyineaPYTV3kusNJYN7vINNi0wyZJl7TTZD28WbeFp1mV7gV1HaW6+A8DbI8EqiWb7JcJ8t1saVebjg47K8Wh6rrw2ZpyHr3uLYZMguDVmUUcp3WhmRtyaCebZzvuTaitsNCh7ncZ65cwoXNwgAugpU96+dvgfdvCLc68dsLN0PKZ6R8XEmf5BV7fvQ3msme1U1Lw8s1Kg4bYYtdwhBjOiwMoXLETSJKE5F9dA+ETkTcyBKNh+h4mPfJKG8SyIjXSeh4xIE8AqmpavG5MTPJFrNmIW88ktmSAplZ/OQyO8MTURqXQJmzdiqgphC2vGDMJGtvXpp5VcfroOHA8N5wiSZHbcbogxgPYJ0c8zoJyNI+xO9DPPQbCWL20WMj3+ZmhSED5e/CkJ5VKgw5v6oLcxz+j+GeEgebwNHDvXYmUNIHX+lX1igqQY2Lh4SD9rTrG0b2c214B+5uQ/g9u7pGEx/Ne2+hu8gNf5uME66tG7EP7FYFbmwad7bh8mv68JN5ewvOHRqu53EI1oua3l/mC3cXd4+6M254QeND/rxT/Xj8h/17uE/ThSFnXuwKQ1a+/hDmF2gO/Y3zkq/GAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 05 11 35 12"\n        title=""\n        src="/static/2021-07-05-11-35-12-736885d7c0436c33374eb14a3c7c9f69-4c847.png"\n        srcset="/static/2021-07-05-11-35-12-736885d7c0436c33374eb14a3c7c9f69-9882a.png 200w,\n/static/2021-07-05-11-35-12-736885d7c0436c33374eb14a3c7c9f69-ecdcc.png 400w,\n/static/2021-07-05-11-35-12-736885d7c0436c33374eb14a3c7c9f69-4c847.png 618w"\n        sizes="(max-width: 618px) 100vw, 618px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从图中可以看出， 在 JavaScript 的执行过程中， 主要有三种类型内存空间，分别是代码空间、栈空间和堆空间。</p>\n<p>其中的代码空间主要是存储可执行代码的，这个我们后面再做介绍，今天主要来说说栈空间和堆空间。</p>\n<h2 id="栈空间和堆空间"><a href="#%E6%A0%88%E7%A9%BA%E9%97%B4%E5%92%8C%E5%A0%86%E7%A9%BA%E9%97%B4" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>栈空间和堆空间</h2>\n<p>这里的栈空间就是我们之前反复提及的调用栈，是用来存储执行上下文的。为了搞清楚栈空间是如何存储数据的，我们还是先看下面这段代码：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="97183158737899030000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function foo() {\n  var a = \'极客时间\';\n  var b = a;\n  var c = { name: \'极客时间\' };\n  var d = c;\n}\nfoo();`, `97183158737899030000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token string">\'极客时间\'</span><span class="token punctuation">;</span>\n  <span class="token keyword">var</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span>\n  <span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">\'极客时间\'</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>\n  <span class="token keyword">var</span> d <span class="token operator">=</span> c<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>前面文章我们已经讲解过了，当执行一段代码时，需要先编译，并创建执行上下文，然后再按照顺序执行代码。那么下面我们来看看，当执行到第 3 行代码时，其调用栈的状态，你可以参考下面这张调用栈状态图：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-05-13-36-42-768172f068757544caf5d7cdc266d812-b1a91.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 84.83333333333333%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAIAAABSJhvpAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACr0lEQVQ4y3WTW08TURDH+RDGd76CoA2Y+EVMjN/ERCJECliIDwoSHtpK0RcIGB6kINcWuYQWkLLbG91Lt3vfs/funnM8LVVbgpPJyZyz88vM/jPTh3sNQhgEYRCGrfP/AUKIJPd1k81mU9c05NnQs6BrQc9GvgOJt4LOI/Ks0LV0XSd8Dxz4nqAYm1Vnq2ITTxeN7wVpg1LTtJ6mtXTZSlfsjbKVZR3DAKTHvt6mm+esHklIkYQcScpPFrjB2eLAbGlwrjrwqTqcEJ+l1Edx9eU3xQRGB0Zta8Fh84pT32Wkz5dm/BzMHUkzu8z8qRq/sBLnYCqjvNpgP+zdjG5xim6iv3CnchhQjFjiOWzxvs5iVw5VxpdvoMFjDCiGOaAbGDvLeYFTAEZtmOgEAAghxDAs1OqFmqAqEl8XgiDwPKdcLlE05TvmRZndLcokf+WXxslGB2ZZNp/Pi5JE7gSmOZEErutBhIHt0BWmdMPbjltgxA58qbCy3oLJf5Oytm2TE8PguiYUmEbY9E03cJkT5UeMWhun1qLGzvTZ9pedskHg5Uv1X+UutcPrWr1YFzH0fYTDw/fm6IPqSH/ldb/39uHF/Iu9mkeyVq9UlsC4S210KxgrrZ/SZ3TliOaO9tcPlka2Fsc2F8d+fh1ZWY4v5eQCrydPxYYK7laGgV+TjIkDZXxfju5L0awxceJPttyLHvtTx04sI7/ZbiRzmgnuG5Ico0WSynBKG07pQwlx8CNF5uTxfDWywAwl5acpbSCpPV9VgGHchYlOFUGNHarTHVdiGanlWXk6q5CXmUN1MqMkchqZ7bsw2Rhg6Ngze93CvnUbIxdgF4QOME3z7lbdGlGOrFxAhoYIDlEAUTOEQTtA7a9/5vE+mPSjqirHcaQ3WZYFQSBxvV7ned73/e7M336AjgEMvgWjAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 05 13 36 42"\n        title=""\n        src="/static/2021-07-05-13-36-42-768172f068757544caf5d7cdc266d812-fee1c.png"\n        srcset="/static/2021-07-05-13-36-42-768172f068757544caf5d7cdc266d812-a67b7.png 200w,\n/static/2021-07-05-13-36-42-768172f068757544caf5d7cdc266d812-0b187.png 400w,\n/static/2021-07-05-13-36-42-768172f068757544caf5d7cdc266d812-fee1c.png 800w,\n/static/2021-07-05-13-36-42-768172f068757544caf5d7cdc266d812-b1a91.png 1200w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从图中可以看出来，当执行到第 3 行时，变量 a 和变量 b 的值都被保存在执行上下文中，而执行上下文又被压入到栈中，所以你也可以认为变量 a 和变量 b 的值都是存放在栈中的。</p>\n<p>接下来继续执行第 4 行代码，由于 JavaScript 引擎判断右边的值是一个引用类型，这时候处理的情况就不一样了，JavaScript 引擎并不是直接将该对象存放到变量环境中，而是将它分配到堆空间里面，分配后该对象会有一个在“堆”中的地址，然后再将该数据的地址写进 c 的变量值，最终分配好内存的示意图如下所示：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-05-13-36-59-da3fe5fbe645301d7ca272c4a9b64128-f0bde.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 56.77154582763338%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAB10lEQVQoz3WRz2vUQBTH93/x5J8gPQpeehIUvIiCRy8WFLx6Ubx4FxHcuqUt2GqR/hDRthd/dLut3U3bFFu3uj+SSTPJTJLJJjOZN04SSN2DXx7D8GY+3zfvTQ0AMpEqxYsQeUC+FyIFUKVAchBJvmY6UgVZma8pJTsD2jDYTNt/3bIbu+6cQettalo0xwoDtv6ENq6R+mTQuEpeXo536qWlhtVW110ynNUDZ6mNPh0H07v4xXf7yy9PH0mQeg03p7z5S+G3Z/HeTNR8nvS3Cxhy+HSIWOCrLGLoJBqa3eHQIrE58IvCeeVw56G3MZmEP/VzBcRC8urZ6qRnManE0XLv6cXe4wvG4qM+kQe/HZUwcYYkS4PmA+/jFYaaceRE5JQn9Bw+/GN3BsT8sdmcvrf96u7nD7Nf+4nOKD7KiC+TLGjd99YmIqcVUJvgLk+DCoYV07vxzrm9jG++x7dWgjtr9PpbZ/3Yr3qmW1N4dWJ01hKc8tgag/cHdL5DFvf9BQO/6eAFw5tr+0cWqabNvb3U3hAjLPhIcCazf3quPjP2kSpKlVilMiOEcF0sJVRIrbin9BgTLmgYpiLTe6nGpR1BgrbnvPIaq3x+E8B1XYSQV4hSqv6jv4osWckfUujXAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 05 13 36 59"\n        title=""\n        src="/static/2021-07-05-13-36-59-da3fe5fbe645301d7ca272c4a9b64128-fee1c.png"\n        srcset="/static/2021-07-05-13-36-59-da3fe5fbe645301d7ca272c4a9b64128-a67b7.png 200w,\n/static/2021-07-05-13-36-59-da3fe5fbe645301d7ca272c4a9b64128-0b187.png 400w,\n/static/2021-07-05-13-36-59-da3fe5fbe645301d7ca272c4a9b64128-fee1c.png 800w,\n/static/2021-07-05-13-36-59-da3fe5fbe645301d7ca272c4a9b64128-b1a91.png 1200w,\n/static/2021-07-05-13-36-59-da3fe5fbe645301d7ca272c4a9b64128-f0bde.png 1462w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从上图你可以清晰地观察到，对象类型是存放在堆空间的，在栈空间中只是保留了对象的引用地址，当 JavaScript 需要访问该数据的时候，是通过栈中的引用地址来访问的，相当于多了一道转手流程。</p>\n<p>好了，现在你应该知道了原始类型的数据值都是直接保存在“栈”中的，引用类型的值是存放在“堆”中的。不过你也许会好奇，为什么一定要分“堆”和“栈”两个存储空间呢？所有数据直接存放在“栈”中不就可以了吗？</p>\n<p>答案是不可以的。这是因为 JavaScript 引擎需要用栈来维护程序执行期间上下文的状态，如果栈空间大了话，所有的数据都存放在栈空间里面，那么会影响到上下文切换的效率，进而又影响到整个程序的执行效率。比如文中的 foo 函数执行结束了，JavaScript 引擎需要离开当前的执行上下文，只需要将指针下移到上个执行上下文的地址就可以了，foo 函数执行上下文栈区空间全部回收，具体过程你可以参考下图：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-05-13-37-18-08fb519b5e63747634c74613b337bd19-6b9f0.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 60.83086053412463%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABs0lEQVQoz6VSzW4TMRDOQ3HhEXgbJJ4FceAAZ1Cgl003ahSgIMgKRQ3bZFvRHBAUsl571hvba3u9/sFNhUihnPhkjzQafzPjmW8Q/gODfwWMMXmez+fzxWIRrZSSNs0sy6oKex+sdddk742JXqe1MqazVps+2vh0nKaj0Wg8HidJgjF2WqLLL70SwRmjpbNuEGm23HhcSSCmoYpgBcQ2FMry1esrTKfTyWRSA1lTe4LMEuxJZYtKOWsHsfDVCUFxBkfp1xfPIU3KgyE9P5NdB4QQSrlUwXYPjqq7T7/de1bdeXJ5//B7bHn35x1ZCsGKFV+dimLF8gX7EcOh73sDJGwb37LDM/rwA378ET/KICkgePd7YHEkojOUt1RIZR0Trd8lda3wnBvB+/NlP3ujs2OfvTWfC+v3pi3alm7ZlrdSdYwLGqvtyNfona/fHVcHwzodVS+HMHvvwk0yqjDUTbwIA9T1/uasc/X6ApZ5Xazg9BNZXzjvb+y5lbJEaLPZEADn3B+b18ZA0yBCMG1apW4RSdSG1nq/4X3EjL0x/lfe2xXGGEMIAUDUBuc8upTSv3v5CZczorFUmDZ+AAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 05 13 37 18"\n        title=""\n        src="/static/2021-07-05-13-37-18-08fb519b5e63747634c74613b337bd19-fee1c.png"\n        srcset="/static/2021-07-05-13-37-18-08fb519b5e63747634c74613b337bd19-a67b7.png 200w,\n/static/2021-07-05-13-37-18-08fb519b5e63747634c74613b337bd19-0b187.png 400w,\n/static/2021-07-05-13-37-18-08fb519b5e63747634c74613b337bd19-fee1c.png 800w,\n/static/2021-07-05-13-37-18-08fb519b5e63747634c74613b337bd19-b1a91.png 1200w,\n/static/2021-07-05-13-37-18-08fb519b5e63747634c74613b337bd19-6b9f0.png 1348w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>所以通常情况下，栈空间都不会设置太大，主要用来存放一些原始类型的小数据。而引用类型的数据占用的空间都比较大，所以这一类数据会被存放到堆中，堆空间很大，能存放很多大的数据，不过缺点是分配内存和回收内存都会占用一定的时间。</p>\n<p>解释了程序在执行过程中为什么需要堆和栈两种数据结构后，我们还是回到示例代码那里，看看它最后一步将变量 c 赋值给变量 d 是怎么执行的？</p>\n<p>在 JavaScript 中，赋值操作和其他语言有很大的不同，原始类型的赋值会完整复制变量值，而引用类型的赋值是复制引用地址。</p>\n<p>所以 <code class="language-text">d=c</code> 的操作就是把 c 的引用地址赋值给 d，你可以参考下图</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-05-13-37-35-27cda4d94677a23c74bbb5ba13eb9ec1-22802.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 59.25925925925925%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAB+klEQVQoz32Sz2sTQRzF+5/4H3gRxHoUpWervfagIoLgHyBeLBRBL15q6UE8CqI2mphoi1YkSQstoWotSZM0jXE3s9nZmZ2dnZmd7I9xNtm2KtLHO8wM38/Mg3kTSqlEK45TJ4fOtok6URN6gnGOfYGowJQjjyHKCQu0hRBHc8ODalAvyt23sl6QO6+HB5UU1g/XgTdfcefL+N5Kb+6zNffFubvmPChD4LI01igafTWLF8/gpfPk2SW8eJbm72Rws48MAAaDgWV2f3UahtHbbIGvXdSxiFJpeM2T9dvO+4u8Xw2oKdyW9PvJCFYtE1LqBWTgvZjtL031nl7e+7H9c8A7PUsJFvtUm1RvoY9TAdqOIh5KOJREX5nCTdPmQoTUhguT7funuo9O7+3UuijcN6CKZCxlzBgpX0erF3xr0yMA2e2Awyx2G+BKE2w0umu5Jx+eP1x9+bhQa3/a9w3kp38xsrt+0ylNMrvGmcNITwong78Z3kwOXl2G08voyhs8k/enc+hGCfbxIZwot3INFs9xe2soXclNDY9jJ4bjvau72qUGLjZwYRfm63il6WLKjr4qxN+lvRFKN4pkFIo4Go5fPhbHlmTkz5N/ehJFsW3DMAyzkoyDRYkK48Tzmc+FXo/9l5JYpeVLdHN0BY/h/0rPWZYFADihpL8B15yM3HlDkKoAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 05 13 37 35"\n        title=""\n        src="/static/2021-07-05-13-37-35-27cda4d94677a23c74bbb5ba13eb9ec1-fee1c.png"\n        srcset="/static/2021-07-05-13-37-35-27cda4d94677a23c74bbb5ba13eb9ec1-a67b7.png 200w,\n/static/2021-07-05-13-37-35-27cda4d94677a23c74bbb5ba13eb9ec1-0b187.png 400w,\n/static/2021-07-05-13-37-35-27cda4d94677a23c74bbb5ba13eb9ec1-fee1c.png 800w,\n/static/2021-07-05-13-37-35-27cda4d94677a23c74bbb5ba13eb9ec1-b1a91.png 1200w,\n/static/2021-07-05-13-37-35-27cda4d94677a23c74bbb5ba13eb9ec1-22802.png 1404w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从图中你可以看到，变量 c 和变量 d 都指向了同一个堆中的对象，所以这就很好地解释了文章开头的那个问题，通过 c 修改 name 的值，变量 d 的值也跟着改变，归根结底它们是同一个对象。</p>\n<h2 id="再谈闭包"><a href="#%E5%86%8D%E8%B0%88%E9%97%AD%E5%8C%85" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>再谈闭包</h2>\n<p>现在你知道了作用域内的原始类型数据会被存储到栈空间，引用类型会被存储到堆空间，基于这两点的认知，我们再深入一步，探讨下闭包的内存模型。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="40410138012239450000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function foo() {\n  var myName = \'极客时间\';\n  let test1 = 1;\n  const test2 = 2;\n  var innerBar = {\n    setName: function(newName) {\n      myName = newName;\n    },\n    getName: function() {\n      console.log(test1);\n      return myName;\n    }\n  };\n  return innerBar;\n}\nvar bar = foo();\nbar.setName(\'极客邦\');\nbar.getName();\nconsole.log(bar.getName());`, `40410138012239450000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">var</span> myName <span class="token operator">=</span> <span class="token string">\'极客时间\'</span><span class="token punctuation">;</span>\n  <span class="token keyword">let</span> test1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>\n  <span class="token keyword">const</span> test2 <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>\n  <span class="token keyword">var</span> innerBar <span class="token operator">=</span> <span class="token punctuation">{</span>\n    <span class="token function-variable function">setName</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">newName</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      myName <span class="token operator">=</span> newName<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n    <span class="token function-variable function">getName</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>test1<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token keyword">return</span> myName<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span><span class="token punctuation">;</span>\n  <span class="token keyword">return</span> innerBar<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">var</span> bar <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nbar<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">\'极客邦\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nbar<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>bar<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>当执行这段代码的时候，你应该有过这样的分析：由于变量 myName、test1、test2 都是原始类型数据，所以在执行 foo 函数的时候，它们会被压入到调用栈中；当 foo 函数执行结束之后，调用栈中 foo 函数的执行上下文会被销毁，其内部变量 myName、test1、test2 也应该一同被销毁。</p>\n<p>要解释这个现象，我们就得站在内存模型的角度来分析这段代码的执行流程。</p>\n<ul>\n<li>当 JavaScript 引擎执行到 foo 函数时，首先会编译，并创建一个空执行上下文。</li>\n<li>在编译过程中，遇到内部函数 setName，JavaScript 引擎还要对内部函数做一次快速的词法扫描，发现该内部函数引用了 foo</li>\n<li>函数中的 myName 变量，由于是内部函数引用了外部函数的变量，所以 JavaScript 引擎判断这是一个闭包，于是在堆空间创建换一个“closure(foo)”的对象（这是一个内部对象，JavaScript 是无法访问的），用来保存 myName 变量。</li>\n<li>接着继续扫描到 getName 方法时，发现该函数内部还引用变量 test1，于是 JavaScript 引擎又将 test1 添加到“closure(foo)”对象中。这时候堆中的“closure(foo)”对象中就包含了 myName 和 test1 两个变量了。</li>\n<li>由于 test2 并没有被内部函数引用，所以 test2 依然保存在调用栈中</li>\n</ul>\n<p>通过上面的分析，我们可以画出执行到 foo 函数中 <code class="language-text">return innerBar</code> 语句时的调用栈状态，如下图所示：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-05-13-39-10-f46ac0461abfac3011858d9136484ef6-9131e.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 61.18980169971672%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAB+ElEQVQoz32Sz2/TMBTHe+bf4MiFExcQCHGaBIed+Ce4cAahIQ6cuCEktlUIGIKJCiqGaMcvqRMcWDXYQKUtrGyjaeK2Tu3EyXMSxzF2skogjT09P8n2+/g9631LSqnMmFTalfbMxHxrDg+1kl5xFI28sE/AJmC5TLtDwaaceEw/bFypxNqA9UVoLvLmPF+/yz/fl3FgYAAob7g3PtK5N/1rtd7NhnPl3fDyKnrbdfWtTFMdw0+33TvHJuUz9NEsfXiBPrmYBmMDEwY79jjycOARFgAH/vU33kb0yy42sMzh7QfuqxNBbylJghicmGMphYEnfriHXIAQwsBfu8VeXNr8UB2EaqtfVE4M/OOeWzvJNCwgClEE4ynM+I5lAxkF2PLmT/tzRzYr1wdMbf20lIhT5qlUhd8X3JfHcWsBu4iMez6xMpkaOORRo4vqLft1a1B/X1+tLVfWms/bRdu6a5FXLuPqUdopA/fi0IlhtF85ieBqg5x7Ss9X8MwzOlOF2RU4u4xXOlTfpvmfobc0qZ8Kfj1OU0g4ivm07SRJdsd+B7G2Tb/tjboO7SK/jdiQMJXP3UQRCEBSBHEcCRHrfrQ2Sn8PHZiH0UD9RxtZPnCEhoyxYrsPZ4WyCq3lWXpJmcncioNpE/8q7EDTf8EYe55HCBFCHJjzB95/kOu7c+UVAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 05 13 39 10"\n        title=""\n        src="/static/2021-07-05-13-39-10-f46ac0461abfac3011858d9136484ef6-fee1c.png"\n        srcset="/static/2021-07-05-13-39-10-f46ac0461abfac3011858d9136484ef6-a67b7.png 200w,\n/static/2021-07-05-13-39-10-f46ac0461abfac3011858d9136484ef6-0b187.png 400w,\n/static/2021-07-05-13-39-10-f46ac0461abfac3011858d9136484ef6-fee1c.png 800w,\n/static/2021-07-05-13-39-10-f46ac0461abfac3011858d9136484ef6-b1a91.png 1200w,\n/static/2021-07-05-13-39-10-f46ac0461abfac3011858d9136484ef6-9131e.png 1412w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从上图你可以清晰地看出，当执行到 foo 函数时，闭包就产生了；当 foo 函数执行结束之后，返回的 getName 和 setName 方法都引用 <code class="language-text">clourse(foo)</code> 对象，所以即使 foo 函数退出了，<code class="language-text">clourse(foo)</code> 依然被其内部的 getName 和 setName 方法引用。所以在下次调用 bar.setName 或者 bar.getName 时，创建的执行上下文中就包含了 <code class="language-text">clourse(foo)</code>。</p>\n<p>总的来说，产生闭包的核心有两步：第一步是需要预扫描内部函数；第二步是把内部函数引用的外部变量保存到堆中。</p>\n<h2 id="总结"><a href="#%E6%80%BB%E7%BB%93" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总结</h2>\n<p>好了，今天就讲到这里，下面我来简单总结下今天的要点。</p>\n<p>我们介绍了 JavaScript 中的 8 种数据类型，它们可以分为两大类——原始类型和引用类型。</p>\n<p>其中，原始类型的数据是存放在栈中，引用类型的数据是存放在堆中的。堆中的数据是通过引用和变量关联起来的。也就是说，JavaScript 的变量是没有数据类型的，值才有数据类型，变量可以随时持有任何类型的数据。</p>\n<p>然后我们分析了，在 JavaScript 中将一个原始类型的变量 a 赋值给 b，那么 a 和 b 会相互独立、互不影响；但是将引用类型的变量 a 赋值给变量 b，那会导致 a、b 两个变量都同时指向了堆中的同一块数据。</p>\n<p>最后，我们还站在内存模型的视角分析了闭包的产生过程。</p>\n<h2 id="思考时间"><a href="#%E6%80%9D%E8%80%83%E6%97%B6%E9%97%B4" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>思考时间</h2>\n<p>在实际的项目中，经常需要完整地拷贝一个对象，也就是说拷贝完成之后两个对象之间就不能互相影响。那该如何实现呢？</p>\n<p>结合下面这段代码，你可以分析下它是如何将对象 jack 拷贝给 jack2，然后在完成拷贝操作时两个 jack 还互不影响的呢。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="82707112011065080000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`let jack = {\n  name: \'jack.ma\',\n  age: 40,\n  like: {\n    dog: {\n      color: \'black\',\n      age: 3\n    },\n    cat: {\n      color: \'white\',\n      age: 2\n    }\n  }\n};\nfunction copy(src) {\n  let dest;\n  // 实现拷贝代码，将 src 的值完整地拷贝给 dest\n  // 在这里实现\n  return dest;\n}\nlet jack2 = copy(jack);\n\n// 比如修改 jack2 中的内容，不会影响到 jack 中的值\njack2.like.dog.color = \'green\';\nconsole.log(jack.like.dog.color); // 打印出来的应该是 &quot;black&quot;`, `82707112011065080000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">let</span> jack <span class="token operator">=</span> <span class="token punctuation">{</span>\n  name<span class="token punctuation">:</span> <span class="token string">\'jack.ma\'</span><span class="token punctuation">,</span>\n  age<span class="token punctuation">:</span> <span class="token number">40</span><span class="token punctuation">,</span>\n  like<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n    dog<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n      color<span class="token punctuation">:</span> <span class="token string">\'black\'</span><span class="token punctuation">,</span>\n      age<span class="token punctuation">:</span> <span class="token number">3</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n    cat<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n      color<span class="token punctuation">:</span> <span class="token string">\'white\'</span><span class="token punctuation">,</span>\n      age<span class="token punctuation">:</span> <span class="token number">2</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token keyword">function</span> <span class="token function">copy</span><span class="token punctuation">(</span><span class="token parameter">src</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">let</span> dest<span class="token punctuation">;</span>\n  <span class="token comment">// 实现拷贝代码，将 src 的值完整地拷贝给 dest</span>\n  <span class="token comment">// 在这里实现</span>\n  <span class="token keyword">return</span> dest<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">let</span> jack2 <span class="token operator">=</span> <span class="token function">copy</span><span class="token punctuation">(</span>jack<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token comment">// 比如修改 jack2 中的内容，不会影响到 jack 中的值</span>\njack2<span class="token punctuation">.</span>like<span class="token punctuation">.</span>dog<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token string">\'green\'</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>jack<span class="token punctuation">.</span>like<span class="token punctuation">.</span>dog<span class="token punctuation">.</span>color<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 打印出来的应该是 "black"</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>关于 foo 函数执行上下文销毁过程：foo 函数执行结束之后，当前执行状态的指针下移到栈中的全局执行上下文的位置，foo 函数的执行上下文的那块数据就挪出来，这也就是 foo 函数执行上下文的销毁过程，这个文中有提到，你可以参考“调用栈中切换执行上下文状态“图。</p>\n<p>第二个问题：innerBar 返回后，含有 setName 和 getName 对象，这两个对象里面包含了堆中的 closure(foo) 的引用。虽然 foo 执行上下文销毁了，foo 函数中的对 closure(foo) 的引用也断开了，但是 setName 和 getName 里面又重新建立起来了对 closure(foo) 引用。</p>\n<p>你可以：</p>\n<ul>\n<li>打开开发者工具</li>\n<li>在控制台执行上述代码</li>\n<li>然后选择 Memory 标签，点击 take snapshot 获取 V8 的堆内存快照。</li>\n<li>然后 <code class="language-text">command+f(mac)</code> 或者 <code class="language-text">ctrl+f(win)</code>，搜索 setName，然后你就会发现 setName 对象下面包含了 raw<em>outer</em>scope<em>info</em>or<em>feedback</em>metadata，对闭包的引用数据就在这里面。</li>\n</ul>\n<h1 id="垃圾回收：垃圾数据如何自动回收"><a href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%9A%E5%9E%83%E5%9C%BE%E6%95%B0%E6%8D%AE%E5%A6%82%E4%BD%95%E8%87%AA%E5%8A%A8%E5%9B%9E%E6%94%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>垃圾回收：垃圾数据如何自动回收</h1>\n<p>有些数据被使用之后，可能就不再需要了，我们把这种数据称为垃圾数据。如果这些垃圾数据一直保存在内存中，那么内存会越用越多，所以我们需要对这些垃圾数据进行回收，以释放有限的内存空间</p>\n<h2 id="不同语言的垃圾回收策略"><a href="#%E4%B8%8D%E5%90%8C%E8%AF%AD%E8%A8%80%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>不同语言的垃圾回收策略</h2>\n<p>通常情况下，垃圾数据回收分为手动回收和自动回收两种策略。</p>\n<p>如 C/C++ 就是使用手动回收策略，何时分配内存、何时销毁内存都是由代码控制的，你可以参考下面这段 C 代码：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="11162347571627106000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// 在堆中分配内存\n// 在堆空间中分配 2048 字节的空间，并将分配后的引用地址保存到 p 中\nchar* p = (char*)malloc(2048);\n\n// 使用 p 指向的内存\n{\n  //....\n}\n\n// 使用结束后，销毁这段内存\nfree(p)；\np = NULL；`, `11162347571627106000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                cpp 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="cpp"><pre style="counter-reset: linenumber NaN" class="language-cpp line-numbers"><code class="language-cpp"><span class="token comment">// 在堆中分配内存</span>\n<span class="token comment">// 在堆空间中分配 2048 字节的空间，并将分配后的引用地址保存到 p 中</span>\n<span class="token keyword">char</span><span class="token operator">*</span> p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">2048</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token comment">// 使用 p 指向的内存</span>\n<span class="token punctuation">{</span>\n  <span class="token comment">//....</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// 使用结束后，销毁这段内存</span>\n<span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span>；\np <span class="token operator">=</span> <span class="token constant">NULL</span>；</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>从上面这段 C 代码可以看出来，要使用堆中的一块空间，我们需要先调用 mallco 函数分配内存，然后再使用；当不再需要这块数据的时候，就要手动调用 free 函数来释放内存。如果这段数据已经不再需要了，但是又没有主动调用 free 函数来销毁，那么这种情况就被称为内存泄漏。</p>\n<p>另外一种使用的是自动垃圾回收的策略，如 JavaScript、Java、Python 等语言，产生的垃圾数据是由垃圾回收器来释放的，并不需要手动通过代码来释放。</p>\n<p>对于 JavaScript 而言，也正是这个“自动”释放资源的特性带来了很多困惑，也让一些 JavaScript 开发者误以为可以不关心内存管理，这是一个很大的误解。</p>\n<p>那么在本文，我们将围绕“JavaScript 的数据是如何回收的”这个话题来展开探讨。因为数据是存储在栈和堆两种内存空间中的，所以接下来我们就来分别介绍“栈中的垃圾数据”和“堆中的垃圾数据”是如何回收的。</p>\n<h2 id="调用栈中的数据是如何回收的"><a href="#%E8%B0%83%E7%94%A8%E6%A0%88%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%98%AF%E5%A6%82%E4%BD%95%E5%9B%9E%E6%94%B6%E7%9A%84" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>调用栈中的数据是如何回收的</h2>\n<p>首先是调用栈中的数据，我们还是通过一段示例代码的执行流程来分析其回收机制，具体如下：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="15842334915695133000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function foo() {\n  var a = 1;\n  var b = { name: \'极客邦\' };\n  function showName() {\n    var c = 1;\n    var d = { name: \'极客时间\' };\n  }\n  showName();\n}\nfoo();`, `15842334915695133000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>\n  <span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">\'极客邦\'</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>\n  <span class="token keyword">function</span> <span class="token function">showName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>\n    <span class="token keyword">var</span> d <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">\'极客时间\'</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token function">showName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>当执行到第 6 行代码时，其调用栈和堆空间状态图如下所示：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-05-14-13-12-61833b6271a6466b1560d09e3c39099e-205ae.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 68.10810810810811%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAIAAACgpqunAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACdElEQVQoz22S30/TUBTH9/f4H/igD+qLr775YOIf4JsJia8+KLQlG6BPBAMDUdFIOn5FQjAKDBljQOlWmNbZru3W9de9XbvSn9euq2YYvzk5ybn3fs45956b8T0Podj8IfOiyA3DACWKPDswuMDgE9+3yHcGWxkFWO8YO3+s5Q+lvpVbixR4S5uaacdgfMJlt+CrO8bMbTBzC87eBdM3ffEoyRpmOKU7d9R5U2nPVrSFU/i6epktKrldqaFaA9gTt2Dhenf/sScdesKeJ+yGjjHoKSNpsAvUyAGIXux9HrX2pjiW4TWLb2kocOMjsLlTL9xji4TQagrCj6bAOo6dti1qkPrV/i606aWRs5kH5emHX0vlA84SFICSa5/TZy+nci+mJggcJwh8nCCaPN+vG0WZNrCzJYAV9edf5NGdDlY0sG8Q31NlmKY/v6hjeDabnSTG+yIIguO4FOYUc7Xa2a4r6zV1sw4+sc5cRc2X2w2lO4B1fr+ydJ/awhiGYqrlGl22ujC9s6BCoCuBraODHFx+BNZGGvVTXnN4SUVhPEIUyNv2xjW39jR+eBTqKAIo8v+MyjAvBOWn1LlYx5j3I2dLT0oUfdS0JM1EXn+etrTTJG9IpWe61tKVhqY0XLeXwmynO0+Z+VOQr17ma/7CeThfc5YZ2Lt0kd+vzFAnk9mxidw4jmNjY6Ox5/8+GCvD5ZpRYMCHY/HjSYuk1TjcrOs9J/1GoiiShdW19Q2SLJAkubKyoihKCscu+Qwh6Eg9M51+shWhqzIMAwAwvJJJ0Qj5QRQE4b/EkMJEV+DhwPd9TdNM04QQxl6WZV3X4ybjmv9N9xvm9+Bj8RurGwAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 05 14 13 12"\n        title=""\n        src="/static/2021-07-05-14-13-12-61833b6271a6466b1560d09e3c39099e-fee1c.png"\n        srcset="/static/2021-07-05-14-13-12-61833b6271a6466b1560d09e3c39099e-a67b7.png 200w,\n/static/2021-07-05-14-13-12-61833b6271a6466b1560d09e3c39099e-0b187.png 400w,\n/static/2021-07-05-14-13-12-61833b6271a6466b1560d09e3c39099e-fee1c.png 800w,\n/static/2021-07-05-14-13-12-61833b6271a6466b1560d09e3c39099e-b1a91.png 1200w,\n/static/2021-07-05-14-13-12-61833b6271a6466b1560d09e3c39099e-205ae.png 1480w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从图中可以看出，原始类型的数据被分配到栈中，引用类型的数据会被分配到堆中。当 foo 函数执行结束之后，foo 函数的执行上下文会从堆中被销毁掉，那么它是怎么被销毁的呢？下面我们就来分析一下。</p>\n<p>在上篇文章中，我们简单介绍过了，如果执行到 showName 函数时，那么 JavaScript 引擎会创建 showName 函数的执行上下文，并将 showName 函数的执行上下文压入到调用栈中，最终执行到 showName 函数时，其调用栈就如上图所示。与此同时，还有一个记录当前执行状态的指针（称为 ESP），指向调用栈中 showName 函数的执行上下文，表示当前正在执行 showName 函数。</p>\n<p>接着，当 showName 函数执行完成之后，函数执行流程就进入了 foo 函数，那这时就需要销毁 showName 函数的执行上下文了。ESP 这时候就帮上忙了，JavaScript 会将 ESP 下移到 foo 函数的执行上下文，这个下移操作就是销毁 showName 函数执行上下文的过程。</p>\n<p>你可能会有点懵，ESP 指针向下移动怎么就能把 showName 的执行上下文销毁了呢？具体你可以看下面这张移动 ESP 前后的对比图</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-05-14-13-27-61a4d68f73d41fb85c9268ac972f1816-5e571.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 62.41426611796982%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACVElEQVQoz2VSXU/TUBjez/M/kGjif/DGG29MMGJClGgwMAfsAgVUSGAwUAYRHHV0Wx377ifQbe3Wdm3P+nFOe46nQ8OFT56Lkzzv836eFCEkooAhQSGJEYkgiUJKjMI4jqmKKZIHJiT+x4hgRIUUjjHxwTFvv2Ls+bPB/Ln+hjFf/jQ+162ba6XVaiuKLCmD/e9chtUzpf4qq69WzHVuZE+CFEEImkaN719KQ05UK2252O0dNrVTwSqz5cLRUaN82RL7Fye/8m0j1xgdi+5aefipMlBML0UbCyBUtaE/AbC4YGceXK/NKDdSZxTygigJwqDXk3TL8wGRC+7GI/fjDM+dyk4sDt0UToYOz8TxYmn0oVBe3vu2dPBjkdF32w6CkIp0EYI6Omybh6Vqbiezt53eKTXzPDCcaWW6mxPRWamY2RrINqNsFy8wxgY3DCHCQUA8wAr6XNGcK45fMOHrGnl2Np4t3PZtPzH7IexpOnRN3PoS5J5oB88V9bapezbwk8JxLGiW7xhEb0yYtMcsd7pXshWKQ5CYaXuKbvE64Iubna9Pue1ZTlKvBr7nB0lfcSxrRrdvidWj+srjq/TDC+a0qsFbc2oOg2C3Zb9jraWK+77qp+voLeucSza9ebIRHP3ugfW6s9UEmy1/qwM32sFBx0YwTMwRQl0dlBSTlUclQaM3q6jOjQFwHJFp6fbAznesfEPbr6n5ej9X14uSGSGYmO+AoU+QHwUeJfkf9Eshj0CPhJPYc8g0718zxvdhEMLx2HZd15sCADCZeHfz36eaxv8BsrB/8eJEn6AAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 05 14 13 27"\n        title=""\n        src="/static/2021-07-05-14-13-27-61a4d68f73d41fb85c9268ac972f1816-fee1c.png"\n        srcset="/static/2021-07-05-14-13-27-61a4d68f73d41fb85c9268ac972f1816-a67b7.png 200w,\n/static/2021-07-05-14-13-27-61a4d68f73d41fb85c9268ac972f1816-0b187.png 400w,\n/static/2021-07-05-14-13-27-61a4d68f73d41fb85c9268ac972f1816-fee1c.png 800w,\n/static/2021-07-05-14-13-27-61a4d68f73d41fb85c9268ac972f1816-b1a91.png 1200w,\n/static/2021-07-05-14-13-27-61a4d68f73d41fb85c9268ac972f1816-5e571.png 1458w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从图中可以看出，当 showName 函数执行结束之后，ESP 向下移动到 foo 函数的执行上下文中，上面 showName 的执行上下文虽然保存在栈内存中，但是已经是无效内存了。比如当 foo 函数再次调用另外一个函数时，这块内容会被直接覆盖掉，用来存放另外一个函数的执行上下文。</p>\n<p>所以说，当一个函数执行结束之后，JavaScript 引擎会通过向下移动 ESP 来销毁该函数保存在栈中的执行上下文。</p>\n<h2 id="堆中的数据是如何回收的"><a href="#%E5%A0%86%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%98%AF%E5%A6%82%E4%BD%95%E5%9B%9E%E6%94%B6%E7%9A%84" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>堆中的数据是如何回收的</h2>\n<p>通过上面的讲解，我想现在你应该已经知道，当上面那段代码的 foo 函数执行结束之后，ESP 应该是指向全局执行上下文的，那这样的话，showName 函数和 foo 函数的执行上下文就处于无效状态了，不过保存在堆中的两个对象依然占用着空间，如下图所示</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-05-14-13-55-a9d092b8620c531f9704f0f11d718e85-6ea2c.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 83.11306901615274%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAIAAABSJhvpAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACFElEQVQ4y6WTT28SQRjG+TxGk8abF+PFb+BHMDFeDEYPeuMAJKCFsMSCQICmKi0kSCXgn8SjB1Ej2mhDUizCbtnl37A7M53Z2Z3FabdWiCYl8Tns7Eye37zPTOb1zP5DHnfgnCOEDo9FCDn9wRjbti0MdO8tbRYOm8/I5yfk6yb5tE53qyewcAif4zh8TmJqmialVBj08vXp2sVxfGX6aEVPXwaxc0bh2h9Y1Pk7mG1ZLgwbd/XaJdgMsuk+G31jo+8M/DgDtn7Dkw/3B6+vjndimBgYahhpGI+WhauVzUxyNZWMJRJryWQiHpdKxa1l4a3i89ADaTUi+QP+YDDo8/my2eyycKVciEcDjxNSOp3KpFOifqlUXBYeN+6p9SujLxEIRxB0IeghQz0TZi6MPnr1+nm8G+Uc2+aAm0POwLKVQePOYPsC2IlQMiXogKA+xcMj2KHEMak2gTLiisFkncmGpUBLhtwgjJlH8JvqRiHj38hK+Xwul8tk0snqi4pn5jg2ADOKnr7v3Xg59Na6t7bb3lrv9quDm3X13T6YcXZ82+Xww1gkKoVC4VA47PcH8vn1k9jiJYp4lklti2FkQB3YzBRTkxLxToVhMNC63Z+KIrfbe61WS5ZlTdM8Ljp/TrHa6XTcfnD3deYMomEmk8lCV83LtTqLO562yrw8/2xUcQRVVUU28VUURWTp9/tAXM2ifgGJ3J+m/MWuBAAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 05 14 13 55"\n        title=""\n        src="/static/2021-07-05-14-13-55-a9d092b8620c531f9704f0f11d718e85-fee1c.png"\n        srcset="/static/2021-07-05-14-13-55-a9d092b8620c531f9704f0f11d718e85-a67b7.png 200w,\n/static/2021-07-05-14-13-55-a9d092b8620c531f9704f0f11d718e85-0b187.png 400w,\n/static/2021-07-05-14-13-55-a9d092b8620c531f9704f0f11d718e85-fee1c.png 800w,\n/static/2021-07-05-14-13-55-a9d092b8620c531f9704f0f11d718e85-b1a91.png 1200w,\n/static/2021-07-05-14-13-55-a9d092b8620c531f9704f0f11d718e85-6ea2c.png 1362w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从图中可以看出，1003 和 1050 这两块内存依然被占用。要回收堆中的垃圾数据，就需要用到 JavaScript 中的垃圾回收器了。</p>\n<p>所以，接下来我们就来通过 Chrome 的 JavaScript 引擎 V8 来分析下堆中的垃圾数据是如何回收的。</p>\n<h2 id="代际假说和分代收集"><a href="#%E4%BB%A3%E9%99%85%E5%81%87%E8%AF%B4%E5%92%8C%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>代际假说和分代收集</h2>\n<p>不过在正式介绍 V8 是如何实现回收之前，你需要先学习下代际假说（The Generational Hypothesis）的内容，这是垃圾回收领域中一个重要的术语，后续垃圾回收的策略都是建立在该假说的基础之上的，所以很是重要。</p>\n<p>代际假说有以下两个特点：</p>\n<ul>\n<li>第一个是大部分对象在内存中存在的时间很短，简单来说，就是很多对象一经分配内存，很快就变得不可访问；</li>\n<li>第二个是不死的对象，会活得更久。</li>\n</ul>\n<p>其实这两个特点不仅仅适用于 JavaScript，同样适用于大多数的动态语言，如 Java、Python 等。</p>\n<p>有了代际假说的基础，我们就可以来探讨 V8 是如何实现垃圾回收的了。</p>\n<p>通常，垃圾回收算法有很多种，但是并没有哪一种能胜任所有的场景，你需要权衡各种场景，根据对象的生存周期的不同而使用不同的算法，以便达到最好的效果。</p>\n<p>所以，在 V8 中会把堆分为新生代和老生代两个区域，新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象。</p>\n<p>新生区通常只支持 1 ～ 8M 的容量，而老生区支持的容量就大很多了。对于这两块区域，V8 分别使用两个不同的垃圾回收器，以便更高效地实施垃圾回收。</p>\n<ul>\n<li>副垃圾回收器，主要负责新生代的垃圾回收。</li>\n<li>主垃圾回收器，主要负责老生代的垃圾回收。</li>\n</ul>\n<h2 id="垃圾回收器的工作流程"><a href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>垃圾回收器的工作流程</h2>\n<p>现在你知道了 V8 把堆分成两个区域——新生代和老生代，并分别使用两个不同的垃圾回收器。其实不论什么类型的垃圾回收器，它们都有一套共同的执行流程。</p>\n<p>第一步是标记空间中活动对象和非活动对象。所谓活动对象就是还在使用的对象，非活动对象就是可以进行垃圾回收的对象。</p>\n<p>第二步是回收非活动对象所占据的内存。其实就是在所有的标记完成之后，统一清理内存中所有被标记为可回收的对象。</p>\n<p>第三步是做内存整理。一般来说，频繁回收对象后，内存中就会存在大量不连续空间，我们把这些不连续的内存空间称为内存碎片。当内存中出现了大量的内存碎片之后，如果需要分配较大连续内存的时候，就有可能出现内存不足的情况。所以最后一步需要整理这些内存碎片，但这步其实是可选的，因为有的垃圾回收器不会产生内存碎片，比如接下来我们要介绍的副垃圾回收器。</p>\n<p>那么接下来，我们就按照这个流程来分析新生代垃圾回收器（副垃圾回收器）和老生代垃圾回收器（主垃圾回收器）是如何处理垃圾回收的。</p>\n<h2 id="副垃圾回收器"><a href="#%E5%89%AF%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>副垃圾回收器</h2>\n<p>副垃圾回收器主要负责新生区的垃圾回收。而通常情况下，大多数小的对象都会被分配到新生区，所以说这个区域虽然不大，但是垃圾回收还是比较频繁的。</p>\n<p>新生代中用 Scavenge 算法来处理。所谓 Scavenge 算法，是把新生代空间对半划分为两个区域，一半是对象区域，一半是空闲区域，如下图所示</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-05-14-15-22-e32f50e2eb152a5b001ac254262fa90b-574e5.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 59.45558739255014%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABGklEQVQoz41SaW+DMAzl///AqtuHIsa2klYQyH3ZqQl0PZH2ZCm25eczVb4DIuZ3wIJXf/Wneec+P/bd8fiaTgqx3+2UlO/JFNKPU/vz27Tf2rqEOcIqpJ97XjfNME5X/9pFtbzcgkroqYhPOqKJyFQSHlWYxaTsMOuUF3OwsPDXyjrmScjgHUBy1hqtVczwMOdNNwFDupGRsnbsZI0BgEkIzjl5YGN/msh3lefGutNZK0XGOI7D0P+fTKNiKrb3HhEonZxfpHVn3CavC3PAHcqA3EThgRSmgcam+jJk2tzkUVylt5DuK5eTrgLluNTC4VCTDJyTCeWb4GMrVd5GDMF5TyvcCngmU2jXdXVdt23LGPsqaAtCCE/BF3JCwHoMaWtPAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 05 14 15 22"\n        title=""\n        src="/static/2021-07-05-14-15-22-e32f50e2eb152a5b001ac254262fa90b-fee1c.png"\n        srcset="/static/2021-07-05-14-15-22-e32f50e2eb152a5b001ac254262fa90b-a67b7.png 200w,\n/static/2021-07-05-14-15-22-e32f50e2eb152a5b001ac254262fa90b-0b187.png 400w,\n/static/2021-07-05-14-15-22-e32f50e2eb152a5b001ac254262fa90b-fee1c.png 800w,\n/static/2021-07-05-14-15-22-e32f50e2eb152a5b001ac254262fa90b-b1a91.png 1200w,\n/static/2021-07-05-14-15-22-e32f50e2eb152a5b001ac254262fa90b-574e5.png 1396w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>新加入的对象都会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作。</p>\n<p>在垃圾回收过程中，首先要对对象区域中的垃圾做标记；标记完成之后，就进入垃圾清理阶段，副垃圾回收器会把这些存活的对象复制到空闲区域中，同时它还会把这些对象有序地排列起来，所以这个复制过程，也就相当于完成了内存整理操作，复制后空闲区域就没有内存碎片了。</p>\n<p>完成复制后，对象区域与空闲区域进行角色翻转，也就是原来的对象区域变成空闲区域，原来的空闲区域变成了对象区域。这样就完成了垃圾对象的回收操作，同时这种角色翻转的操作还能让新生代中的这两块区域无限重复使用下去。</p>\n<p>由于新生代中采用的 Scavenge 算法，所以每次执行清理操作时，都需要将存活的对象从对象区域复制到空闲区域。但复制操作需要时间成本，如果新生区空间设置得太大了，那么每次清理的时间就会过久，所以为了执行效率，一般新生区的空间会被设置得比较小。</p>\n<p>也正是因为新生区的空间不大，所以很容易被存活的对象装满整个区域。为了解决这个问题，JavaScript 引擎采用了对象晋升策略，也就是经过两次垃圾回收依然还存活的对象，会被移动到老生区中。</p>\n<h2 id="主垃圾回收器"><a href="#%E4%B8%BB%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>主垃圾回收器</h2>\n<p>主垃圾回收器主要负责老生区中的垃圾回收。除了新生区中晋升的对象，一些大的对象会直接被分配到老生区。因此老生区中的对象有两个特点，一个是对象占用空间大，另一个是对象存活时间长。</p>\n<p>由于老生区的对象比较大，若要在老生区中使用 Scavenge 算法进行垃圾回收，复制这些大的对象将会花费比较多的时间，从而导致回收执行效率不高，同时还会浪费一半的空间。因而，主垃圾回收器是采用标记 - 清除（Mark-Sweep）的算法进行垃圾回收的。下面我们来看看该算法是如何工作的。</p>\n<p>首先是标记过程阶段。标记阶段就是从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素称为活动对象，没有到达的元素就可以判断为垃圾数据。</p>\n<p>比如最开始的那段代码，当 showName 函数执行退出之后，这段代码的调用栈和堆空间如下图所示：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-05-14-15-47-89072468db6e7b2a97e7198cec310d4d-5fe3e.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 57.34265734265735%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAB3UlEQVQoz3VSy27TQBTtX/UrWCOx5A+gC5AQG0RhQUFR0qaIVqgESsVDKAixaClRUZo2sUlSK3Zj2iTYctrYDnb8mkfw2MNkAhQQPTqauSPdM+do7sxQjjRNY5JwEs5pnaQc9BzMTDeMUBJjmowpjWn6nTGd1MS2zINmUzlUw/YWrq+B/TwUVkAli9X3E/HkWhBFtrUuedkGzFTMzJ6VE5yM6K9KkXz8dae0vVut26U59/WsvzePDl+B5grqbXMxD+V6waYyqHSHpSNGp2qAZw27qDgHPfNE72mnpv38nnv7krVw3Xhwq3/nmv92YyqeqB0/6PVPExRSIWsXLqI3l5VWVfNJS7NoErOO0csF68aF4f25Yebm8O5Vv1j4FZvSEMC2YXeskVotKltL7Q8Pa4oqDdCJE7C3YGogz7ubs9ipEYoJcWISMtOfsZ0ALte93GdvsYEWJbLUorkGfKEECAKMcQRQ6d3jjfyV9SfLTwtrq4/yn3Y+njlHENd0TzTCyrG1+2UgaO6+5skm6Ha7giBIknTU0dROX2ZxJKnVkg2jfzaq3wC+G42+TSfPVl3Xy+WyKIoQQnYkhERR9O+ceTcn5eQ1w3g89n0/CAImS//Gf5z/BFMi9nmS5LyGH4XIT95I6xwYAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 05 14 15 47"\n        title=""\n        src="/static/2021-07-05-14-15-47-89072468db6e7b2a97e7198cec310d4d-fee1c.png"\n        srcset="/static/2021-07-05-14-15-47-89072468db6e7b2a97e7198cec310d4d-a67b7.png 200w,\n/static/2021-07-05-14-15-47-89072468db6e7b2a97e7198cec310d4d-0b187.png 400w,\n/static/2021-07-05-14-15-47-89072468db6e7b2a97e7198cec310d4d-fee1c.png 800w,\n/static/2021-07-05-14-15-47-89072468db6e7b2a97e7198cec310d4d-b1a91.png 1200w,\n/static/2021-07-05-14-15-47-89072468db6e7b2a97e7198cec310d4d-5fe3e.png 1430w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从上图你可以大致看到垃圾数据的标记过程，当 showName 函数执行结束之后，ESP 向下移动，指向了 foo 函数的执行上下文，这时候如果遍历调用栈，是不会找到引用 1003 地址的变量，也就意味着 1003 这块数据为垃圾数据，被标记为红色。由于 1050 这块数据被变量 b 引用了，所以这块数据会被标记为活动对象。这就是大致的标记过程。</p>\n<p>接下来就是垃圾的清除过程。它和副垃圾回收器的垃圾清除过程完全不同，你可以理解这个过程是清除掉红色标记数据的过程，可参考下图大致理解下其清除过程：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-05-14-16-00-e7097f5d5eb869f0198529da34626d3c-03014.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 60.6628242074928%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABkUlEQVQoz31R30vCUBT2D+y9lx4jeq//oQiiHuyhPRUFQRDiQzmXmCvXyFwSEqhjUyYquiZs7Yfeu107u3O5JPvYLvfce79zzved1CxGQEjg+wRjEsCWzBKAMKAgMaLzFPyfmSttZ5PYVvhuRrDvI4TgafQCYTyZTqPQp1cAjFBIhiTTquheMkWp9pLN9He33I93uPiyLNu2g7gLURTz+bzneRD6QYAxnldual3uqXyzvva8veGcnSCtDYf9Xk9VVdM0ZVlmWZbn+UqlgmhByIgW5EbzgWWnF6fD7HWpIavnjMEcQ/ORWkVROI6zTBNCQRBqtVqkhbZNfYJO3pT242uVKxRa6QMjvR+Rozqw1ut1vlTi7m4lSQIKmmsmYDAGMflc7k2S5t7Sb24YNU8ol++LReSHiSDvQnMSoUMwsLjsz6zCq27HZo5MXe9omus4v8jJAS4B+oBVV+Ti4Z45HvcHA+j0j8oryOFqe16rN3BcdzQaTiaT/8gBHSYI9pckJLCSDLkNw9B13aHyFo4k1H0DpKGjyMpxZJwAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 05 14 16 00"\n        title=""\n        src="/static/2021-07-05-14-16-00-e7097f5d5eb869f0198529da34626d3c-fee1c.png"\n        srcset="/static/2021-07-05-14-16-00-e7097f5d5eb869f0198529da34626d3c-a67b7.png 200w,\n/static/2021-07-05-14-16-00-e7097f5d5eb869f0198529da34626d3c-0b187.png 400w,\n/static/2021-07-05-14-16-00-e7097f5d5eb869f0198529da34626d3c-fee1c.png 800w,\n/static/2021-07-05-14-16-00-e7097f5d5eb869f0198529da34626d3c-b1a91.png 1200w,\n/static/2021-07-05-14-16-00-e7097f5d5eb869f0198529da34626d3c-03014.png 1388w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>上面的标记过程和清除过程就是标记 - 清除算法，不过对一块内存多次执行标记 - 清除算法后，会产生大量不连续的内存碎片。而碎片过多会导致大对象无法分配到足够的连续内存，于是又产生了另外一种算法——标记 - 整理（Mark-Compact），这个标记过程仍然与标记 - 清除算法里的是一样的，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。你可以参考下图</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-05-14-16-15-8b9ca980923f8eaba0c102b31f37df52-22802.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 49.71509971509971%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABE0lEQVQoz3VRy4qEMBD0/3/GdWdwFg8qIshoVg96FgRBRETRg49N4lYSd8Z5bBFD26nqVHe0TYJzzrAkuMQtv/0PDR+ldFkWyBBj//mDYiBj2/aHYZzO55OE8WlYlgWCECtenue6rtd1rcqt6zoMQ9d1wzimaRqGV0JIRATCKEqSBBwh7vveNE3HcYIgAFu5hRfk8du2LQo9GeYb322P4+j7flVViL8J+bpcwEZh1TACWKOMioDuAAGnD7bRj+d5cRwfxegZMeP3Waq53MWUsaIoXNeFVWTWw8BAwvmK6ymd5mmeZyGWpbWnZtRrvb6KcoFpZVnWNE1ZlnvPt+PjC7/FNImblfMH8asFzBlTxP7WC/ALx7A7GqZJCyYAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 05 14 16 15"\n        title=""\n        src="/static/2021-07-05-14-16-15-8b9ca980923f8eaba0c102b31f37df52-fee1c.png"\n        srcset="/static/2021-07-05-14-16-15-8b9ca980923f8eaba0c102b31f37df52-a67b7.png 200w,\n/static/2021-07-05-14-16-15-8b9ca980923f8eaba0c102b31f37df52-0b187.png 400w,\n/static/2021-07-05-14-16-15-8b9ca980923f8eaba0c102b31f37df52-fee1c.png 800w,\n/static/2021-07-05-14-16-15-8b9ca980923f8eaba0c102b31f37df52-b1a91.png 1200w,\n/static/2021-07-05-14-16-15-8b9ca980923f8eaba0c102b31f37df52-22802.png 1404w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<h2 id="全停顿"><a href="#%E5%85%A8%E5%81%9C%E9%A1%BF" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>全停顿</h2>\n<p>现在你知道了 V8 是使用副垃圾回收器和主垃圾回收器处理垃圾回收的，不过由于 JavaScript 是运行在主线程之上的，一旦执行垃圾回收算法，都需要将正在执行的 JavaScript 脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。我们把这种行为叫做全停顿（Stop-The-World）。</p>\n<p>比如堆中的数据有 1.5GB，V8 实现一次完整的垃圾回收需要 1 秒以上的时间，这也是由于垃圾回收而引起 JavaScript 线程暂停执行的时间，若是这样的时间花销，那么应用的性能和响应能力都会直线下降。主垃圾回收器执行一次完整的垃圾回收流程如下图所示：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-05-14-16-40-e971aec8ff9d9e307046a00b0e265563-4a030.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 40.78374455732946%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAIAAAB2/0i6AAAACXBIWXMAAA7DAAAOwwHHb6hkAAABGElEQVQY06WQsUvDQBTG+x85OTm4iUt1UheHunboIrgKUrsIxeJi7ebg5hIQFyeXKlnU1HCxaRASjtKkNr0Ec5e7e/FuUDtYHfzBHQ/e+977+ErFPyipBwASQBWvE+j68BCwd8dmyKLI4k4vQ5ZwnqZ918Rw78swBa34EiuE1P/hLV/oiHInNHc27e1VVFm721pBlfXHjeWram3pvFg8o5e2HhXwKcYYuwMP8uzCHNeMyYERPJ8cDVr1/nEDNesvrYbb3O+etveu411jfNOLsjT+tp2mKSFECuVdqKVC5kzIN0LwaORjHAyHjAvKOQDXXcEVxaztWVQElFLGWBRFnudN4zhnmp8Dm4faog79kfY8kiQJw/CXgQ8EMrmBWgskLgAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 05 14 16 40"\n        title=""\n        src="/static/2021-07-05-14-16-40-e971aec8ff9d9e307046a00b0e265563-fee1c.png"\n        srcset="/static/2021-07-05-14-16-40-e971aec8ff9d9e307046a00b0e265563-a67b7.png 200w,\n/static/2021-07-05-14-16-40-e971aec8ff9d9e307046a00b0e265563-0b187.png 400w,\n/static/2021-07-05-14-16-40-e971aec8ff9d9e307046a00b0e265563-fee1c.png 800w,\n/static/2021-07-05-14-16-40-e971aec8ff9d9e307046a00b0e265563-b1a91.png 1200w,\n/static/2021-07-05-14-16-40-e971aec8ff9d9e307046a00b0e265563-4a030.png 1378w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>在 V8 新生代的垃圾回收中，因其空间较小，且存活对象较少，所以全停顿的影响不大，但老生代就不一样了。如果在执行垃圾回收的过程中，占用主线程时间过久，就像上面图片展示的那样，花费了 200 毫秒，在这 200 毫秒内，主线程是不能做其他事情的。比如页面正在执行一个 JavaScript 动画，因为垃圾回收器在工作，就会导致这个动画在这 200 毫秒内无法执行的，这将会造成页面的卡顿现象。</p>\n<p>为了降低老生代的垃圾回收而造成的卡顿，V8 将标记过程分为一个个的子标记过程，同时让垃圾回收标记和 JavaScript 应用逻辑交替进行，直到标记阶段完成，我们把这个算法称为增量标记（Incremental Marking）算法。如下图所示：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-05-14-16-53-e6492934c0f0f4ec2d00fbd7e3ffd66d-39487.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 44.47476125511596%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAIAAAC9o5sfAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABEklEQVQoz5WRz0oDMRDG+2T6AOJF0FPVYz2ot/oMngTpSQUtta2lVER8hh704kX2JNoKW7ZrTLLZdrfZZCYmW6kHK9qPYfgI82P+pGDmCRHNP1T4+aSUYoxZQym1fmGYR9waf+DLLPsbns6ZKgwTEwoZDIYkNR/vdChUansjAGc64myswzGOJJq8/gvW4PK1p5dqWKwGp4dXK23TOGqtnpGbF2NE6JU2HkrFzXN/+RIr924XwBy2bXv9tyQid0/xWp3t1l+rx+2tjmhWWtsXvVsvkUH/sbzTPdjbrz2vN/lJlyaCfcOEECGEc6BdIOTZzQYAWmvrXKCeFkwmcv7BZsqUGsWxRRe49kxSSvtb2e8H/wRrNvpsX4BLjwAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 05 14 16 53"\n        title=""\n        src="/static/2021-07-05-14-16-53-e6492934c0f0f4ec2d00fbd7e3ffd66d-fee1c.png"\n        srcset="/static/2021-07-05-14-16-53-e6492934c0f0f4ec2d00fbd7e3ffd66d-a67b7.png 200w,\n/static/2021-07-05-14-16-53-e6492934c0f0f4ec2d00fbd7e3ffd66d-0b187.png 400w,\n/static/2021-07-05-14-16-53-e6492934c0f0f4ec2d00fbd7e3ffd66d-fee1c.png 800w,\n/static/2021-07-05-14-16-53-e6492934c0f0f4ec2d00fbd7e3ffd66d-b1a91.png 1200w,\n/static/2021-07-05-14-16-53-e6492934c0f0f4ec2d00fbd7e3ffd66d-39487.png 1466w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>使用增量标记算法，可以把一个完整的垃圾回收任务拆分为很多小的任务，这些小的任务执行时间比较短，可以穿插在其他的 JavaScript 任务中间执行，这样当执行上述动画效果时，就不会让用户因为垃圾回收任务而感受到页面的卡顿了。</p>\n<h2 id="总结-1"><a href="#%E6%80%BB%E7%BB%93-1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总结</h2>\n<p>首先我们介绍了不同语言的垃圾回收策略，然后又说明了栈中的数据是如何回收的，最后重点讲解了 JavaScript 中的垃圾回收器是如何工作的。</p>\n<p>从上面的分析你也能看出来，无论是垃圾回收的策略，还是处理全停顿的策略，往往都没有一个完美的解决方案，你需要花一些时间来做权衡，而这需要牺牲当前某几方面的指标来换取其他几个指标的提升。</p>\n<p>其实站在工程师的视角，我们经常需要在满足需求的前提下，权衡各个指标的得失，把系统设计得尽可能适应最核心的需求。</p>\n<p>生活中处理事情的原则也与之类似，古人很早就说过“两害相权取其轻，两利相权取其重”，所以与其患得患失，不如冷静地分析哪些才是核心诉求，然后果断决策牺牲哪些以使得利益最大化。</p>\n<h1 id="编译器和解析器：v8-如何执行一段-javascript-代码的"><a href="#%E7%BC%96%E8%AF%91%E5%99%A8%E5%92%8C%E8%A7%A3%E6%9E%90%E5%99%A8%EF%BC%9Av8-%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E4%B8%80%E6%AE%B5-javascript-%E4%BB%A3%E7%A0%81%E7%9A%84" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>编译器和解析器：V8 如何执行一段 JavaScript 代码的</h1>\n<p>前面我们已经花了很多篇幅来介绍 JavaScript 是如何工作的，了解这些内容能帮助你从底层理解 JavaScript 的工作机制，从而能帮助你更好地理解和应用 JavaScript。</p>\n<p>今天这篇文章我们就继续“向下”分析，站在 JavaScript 引擎 V8 的视角，来分析 JavaScript 代码是如何被执行的。</p>\n<p>前端工具和框架的自身更新速度非常快，而且还不断有新的出现。要想追赶上前端工具和框架的更新速度，你就需要抓住那些本质的知识，然后才能更加轻松地理解这些上层应用。比如我们接下来要介绍的 V8 执行机制，能帮助你从底层了解 JavaScript，也能帮助你深入理解语言转换器 Babel、语法检查工具 ESLint、前端框架 Vue 和 React 的一些底层实现机制。因此，了解 V8 的编译流程能让你对语言以及相关工具有更加充分的认识。</p>\n<p>要深入理解 V8 的工作原理，你需要搞清楚一些概念和原理，比如接下来我们要详细讲解的编译器（Compiler）、解释器（Interpreter）、抽象语法树（AST）、字节码（Bytecode）、即时编译器（JIT）等概念，都是你需要重点关注的。</p>\n<h2 id="编译器和解释器"><a href="#%E7%BC%96%E8%AF%91%E5%99%A8%E5%92%8C%E8%A7%A3%E9%87%8A%E5%99%A8" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>编译器和解释器</h2>\n<p>之所以存在编译器和解释器，是因为机器不能直接理解我们所写的代码，所以在执行程序之前，需要将我们所写的代码“翻译”成机器能读懂的机器语言。按语言的执行流程，可以把语言划分为编译型语言和解释型语言。</p>\n<p>编译型语言在程序执行之前，需要经过编译器的编译过程，并且编译之后会直接保留机器能读懂的二进制文件，这样每次运行程序时，都可以直接运行该二进制文件，而不需要再次重新编译了。比如 C/C++、GO 等都是编译型语言。</p>\n<p>而由解释型语言编写的程序，在每次运行时都需要通过解释器对程序进行动态解释和执行。比如 Python、JavaScript 等都属于解释型语言。</p>\n<p>那编译器和解释器是如何“翻译”代码的呢？具体流程你可以参考下图</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-05-14-17-59-b2dc07e44bcdda21710e54d53790c2bc-fc057.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 53.46260387811634%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABn0lEQVQoz2VSS2sUQRDe/yje/QEBr4LBf5CDRy96FAJJIGAOYhAJhARcTNSQiMRE17g7O9M7uzv9qEc/Ut27K4l+9AwfVd1V9VVVL6UUM0KKYYHM05L/JWIsR36ZFFfqee+ValSH1QwcACNcNzBQQtzcwLcKtHUE9pfKRme1tjC3aK2VOD1AHN4MNg7D2htq1GTWqsd7+GwfEkw/XNoHm/5kYEi3T97y+jukrjm4NM+PAiFI+p5kB3DXir43XmsD1pz8ofPKp+Qnhg+uWEPmn4f8ZciionPcmOCcC4vHWQFT9MQFKbL3hEieKUXKQIohn4Ux+GzLmuUT2cFDipivZTcKZy43IoaQgwbGyHgXq4Y19cff/P4HzeYd2e6iwten1M463XVbZ3x8pd1cXYzgbMSricRl2QB4M/j5oh+f7nOtWm/a3XN6uMkTjQju0Q6/7EsSt/2VXn0KZa6ptAmWmqUGY8E6lHhidYBTjaLNM08NGhB+v2JcjerukpQFKCvAIh4lkOgv2in8h2XD/oE46roej8fVaDSu62lBXJR7H7cw9nMkHYofLAAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 05 14 17 59"\n        title=""\n        src="/static/2021-07-05-14-17-59-b2dc07e44bcdda21710e54d53790c2bc-fee1c.png"\n        srcset="/static/2021-07-05-14-17-59-b2dc07e44bcdda21710e54d53790c2bc-a67b7.png 200w,\n/static/2021-07-05-14-17-59-b2dc07e44bcdda21710e54d53790c2bc-0b187.png 400w,\n/static/2021-07-05-14-17-59-b2dc07e44bcdda21710e54d53790c2bc-fee1c.png 800w,\n/static/2021-07-05-14-17-59-b2dc07e44bcdda21710e54d53790c2bc-b1a91.png 1200w,\n/static/2021-07-05-14-17-59-b2dc07e44bcdda21710e54d53790c2bc-fc057.png 1444w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从图中你可以看出这二者的执行流程，大致可阐述为如下：</p>\n<ul>\n<li>在编译型语言的编译过程中，编译器首先会依次对源代码进行词法分析、语法分析，生成抽象语法树（AST），然后是优化代码，最后再生成处理器能够理解的机器码。如果编译成功，将会生成一个可执行的文件。但如果编译过程发生了语法或者其他的错误，那么编译器就会抛出异常，最后的二进制文件也不会生成成功</li>\n<li>在解释型语言的解释过程中，同样解释器也会对源代码进行词法分析、语法分析，并生成抽象语法树（AST），不过它会再基于抽象语法树生成字节码，最后再根据字节码来执行程序、输出结果。</li>\n</ul>\n<h2 id="v8-是如何执行一段-javascript-代码的"><a href="#v8-%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E4%B8%80%E6%AE%B5-javascript-%E4%BB%A3%E7%A0%81%E7%9A%84" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>V8 是如何执行一段 JavaScript 代码的</h2>\n<p>通过上面的介绍，相信你已经了解编译器和解释器了。那接下来，我们就重点分析下 V8 是如何执行一段 JavaScript 代码的。你可以先来“一览全局”，参考下图：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-05-14-18-38-2ed8ee16a1f022fed83c2811bd01ea77-7a87e.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 61.07692307692307%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACMklEQVQoz22SS4/SUBTH+Ux+BxO/gVvd6M7EGBfOzseYmKjRhQs3JmZGRZnhJeUhA0NHRkIpDEJ5BfpgKC20ZSh99/ZxLahRx7n55Z67OL/8T25OCELo++eBPrQcXzY9A3jwouNv7lBQzLOxMfmms5jJVgP0SRXOKx+PiEvPp3eip+akIg1QicIkUhy9eHZy42rj1nW2hNmWs5EFAlJhf7zvUklnA6Sjsw5SrhxmC3m1+d5ovbNHmWECbW5t09tP+EePJaRiqGYoSFfng1f5wcsCIxAJ8fsna7D/ptS/h8z5RsTCX1fwys3ootVvCzmUCRfKxen9LEDyU1dR1vJqNrib4G5/XjL4HlvdFRu7T3PktT2VbmXhMJw8rl/ZsctNgkXxbrh4GG8/iC2Q3MRV1PXYltD1yKhLpwCVsqm0S8bb9XwRw30m5TJZtR8b1SI+h4rYcJJriUVCPmgu0I6haBtZ7Hlk3KXTgArIQCa5leIv73hMpwhPkUUrIp+89bkjERtxX9pcgeDybb7U/SMDMgHoDKDTNp2G41S5XvvwtauTWW+cFrpID0uYbFmqjaaBXOxwBwSP9n7JptABoxigkGDsn/hMAjIxm0xBOn5cxx6mWWqIK/hgkv0reaWtPwwYsi2z9oqzlQ3rB2+rc6DwrjpztbmnzYAm6NJKmy21+QZh6QAQunCBXA8almM7nmEB3bA1w3I9//+20O9t+wfHAbK8NHRdkVdni4UkikHO+UYIfwACYHTKWvHKHgAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 05 14 18 38"\n        title=""\n        src="/static/2021-07-05-14-18-38-2ed8ee16a1f022fed83c2811bd01ea77-fee1c.png"\n        srcset="/static/2021-07-05-14-18-38-2ed8ee16a1f022fed83c2811bd01ea77-a67b7.png 200w,\n/static/2021-07-05-14-18-38-2ed8ee16a1f022fed83c2811bd01ea77-0b187.png 400w,\n/static/2021-07-05-14-18-38-2ed8ee16a1f022fed83c2811bd01ea77-fee1c.png 800w,\n/static/2021-07-05-14-18-38-2ed8ee16a1f022fed83c2811bd01ea77-b1a91.png 1200w,\n/static/2021-07-05-14-18-38-2ed8ee16a1f022fed83c2811bd01ea77-7a87e.png 1300w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从图中可以清楚地看到，V8 在执行过程中既有解释器 Ignition，又有编译器 TurboFan，那么它们是如何配合去执行一段 JavaScript 代码的呢? 下面我们就按照上图来一一分解其执行流程。</p>\n<h3 id="生成抽象语法树（ast）和执行上下文"><a href="#%E7%94%9F%E6%88%90%E6%8A%BD%E8%B1%A1%E8%AF%AD%E6%B3%95%E6%A0%91%EF%BC%88ast%EF%BC%89%E5%92%8C%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>生成抽象语法树（AST）和执行上下文</h3>\n<p>将源代码转换为抽象语法树，并生成执行上下文，而执行上下文我们在前面的文章中已经介绍过很多了，主要是代码在执行过程中的环境信息。</p>\n<p>那么下面我们就得重点讲解下抽象语法树（下面表述中就直接用它的简称 AST 了），看看什么是 AST 以及 AST 的生成过程是怎样的。</p>\n<p>高级语言是开发者可以理解的语言，但是让编译器或者解释器来理解就非常困难了。对于编译器或者解释器来说，它们可以理解的就是 AST 了。所以无论你使用的是解释型语言还是编译型语言，在编译过程中，它们都会生成一个 AST。这和渲染引擎将 HTML 格式文件转换为计算机可以理解的 DOM 树的情况类似。</p>\n<p>你可以结合下面这段代码来直观地感受下什么是 AST：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="14911442154232035000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`var myName = \'极客时间\';\nfunction foo() {\n  return 23;\n}\nmyName = \'geektime\';\nfoo();`, `14911442154232035000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">var</span> myName <span class="token operator">=</span> <span class="token string">\'极客时间\'</span><span class="token punctuation">;</span>\n<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token number">23</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\nmyName <span class="token operator">=</span> <span class="token string">\'geektime\'</span><span class="token punctuation">;</span>\n<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>这段代码经过 javascript-ast 站点处理后，生成的 AST 结构如下：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-05-14-19-46-44c46d8ae0c32eb24edf18b902ae31c3-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 143.95796847635728%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAdCAIAAAAl5NuSAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAC5UlEQVQ4y6WU/U+SURTH+ydbq1yguLbSSAgwLX+r6GUtZyoymJQb6BLNmdAKzRAiKMg2J2zIW0rES8oDCPjw3JcOXHJGgLTOD/d5dnc/95x7zvecM/Q/7Az78DxvMBh0Op12amp2drZTmBACn2Kx2NPTIxKJxSKxQqH4N89gGGNY7Xa7UqlUqVT9/f0bGxvH+6fApGbBYHC5Zlqt1uFwpFKp+O4uqlTgDlqLsTkMVqkZ/CCEJjUamUwmlclU99T7+Ty7vR0sCALAmBlCPCGl8A7Va6hphuomqfM9i7AdXHdCCLz1KBYWpsfKL6aP9E+QY7UdDCTw9RTQ6qEQtz0RGzTGH2piQ+v7C8f7TeDq6VB4bW3N6XRardbQTqjEFyKZzUQhGM/7s+Uf9WubZhvWFYtFIpEMyORS6TW3+2O9VOQk0jphLGwQ3OjoqFx+Qy6Xj4zc5jiuo2wzGEpls62azWaTyTg+/jQQCERjkXQmBXEggo6f3RwGJ0xYfr+/t7e3u7v7/Nkug3amQXDNYXYIDOLnclyeO/wQXX4VmrAnTKt7z3J8mqW9Ccx0SjD8ILiE0Kqrz+mVheiD5ejYYuTRwVGiEWbxWCxWsVh8ta/v4qXLr99WGwNhTE5tDGbJZNLr9brdbtcbfdL/knKfcMZNhTIWBIx4TBBulTBUs1rRMQ3fwb5zyHsBBQcw4sif8mgOw5vrjUEIpK4c2aMTGmrQ0bHH9J2tnbYZzPwjgYeSHu6G8ovavG0ut6QvbzpPgeth/26AcHZrMqwwfruviSjXM/MtG4OpD1RhNs/DJIExCMLCVMjkYtlS4qAYL/LcKTMM+gkG4NDw8KBK5fF4Op1hJ/0DoFaroeBdIpHkujSdzVY32zcGw+DZMBV8Pp/T5XLZbJ7nhvLXL3R7iyS+t0vY3zGQWJjevUnVt+jgFbo01ymMqlqqhDP5mUBhKVIyBkvuVKVBKC1hdihRqJhjvDVeXX0/hQb4Fwh4QJV0syU+AAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 05 14 19 46"\n        title=""\n        src="/static/2021-07-05-14-19-46-44c46d8ae0c32eb24edf18b902ae31c3-fee1c.png"\n        srcset="/static/2021-07-05-14-19-46-44c46d8ae0c32eb24edf18b902ae31c3-a67b7.png 200w,\n/static/2021-07-05-14-19-46-44c46d8ae0c32eb24edf18b902ae31c3-0b187.png 400w,\n/static/2021-07-05-14-19-46-44c46d8ae0c32eb24edf18b902ae31c3-fee1c.png 800w,\n/static/2021-07-05-14-19-46-44c46d8ae0c32eb24edf18b902ae31c3-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从图中可以看出，AST 的结构和代码的结构非常相似，其实你也可以把 AST 看成代码的结构化的表示，编译器或者解释器后续的工作都需要依赖于 AST，而不是源代码。</p>\n<p>AST 是非常重要的一种数据结构，在很多项目中有着广泛的应用。其中最著名的一个项目是 Babel。Babel 是一个被广泛使用的代码转码器，可以将 ES6 代码转为 ES5 代码，这意味着你可以现在就用 ES6 编写程序，而不用担心现有环境是否支持 ES6。Babel 的工作原理就是先将 ES6 源码转换为 AST，然后再将 ES6 语法的 AST 转换为 ES5 语法的 AST，最后利用 ES5 的 AST 生成 JavaScript 源代码。</p>\n<p>除了 Babel 外，还有 ESLint 也使用 AST。ESLint 是一个用来检查 JavaScript 编写规范的插件，其检测流程也是需要将源码转换为 AST，然后再利用 AST 来检查代码规范化的问题。</p>\n<p>现在你知道了什么是 AST 以及它的一些应用，那接下来我们再来看下 AST 是如何生成的。通常，生成 AST 需要经过两个阶段。</p>\n<p>第一阶段是分词（tokenize），又称为词法分析，其作用是将一行行的源码拆解成一个个 token。所谓 token，指的是语法上不可能再分的、最小的单个字符或字符串。你可以参考下图来更好地理解什么 token。</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-05-14-20-00-ccfce4dcfb994f03af63d60a1cd0b5d1-e3990.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 60.36484245439468%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABmElEQVQoz41Su0oDQRTN14ifYJHW0s5CELQTCysbtbYXhUiIKQVFS1HER8BGUQmahQ3ZRx5m3SS7STaPnexjdmYnzuzKGo0GL1PM45x7zr13YsOx8H1fkiSO4xRFGU6M2PgVIaRUKmUymYIghsdJZPoMEaJrFOe6Tq1aHHoWgQMK+ZNcaeorqeRyYu8uz9Mjxohisal10rPgeAEczROnH1jyWRLylYqRVaO9epBcSuw+iEJYM0NC07nZBCeL1sU6QXZY0C/KEHmPoiA0GkipuAXezmXtlycnz7myiFsi6hum3DDlel9QrWrLrndAWYM965PsYZwtSorRJlrd5jlXKjg85/A5m3sl0BoSPHhrWu+M5pmOZ9q9gkqwP9LtoFUEukZqR9veoLJBjX5k1oeoenov7V+CYj0aQSyaLWtVu1mei8szU93DNEN4MIAxnKP3ruNb59NrcuqKPX1TDuUxdmXqOYc7RmQnVMaup91y6tkzKGk/lccDY0ztUBBCiO7/98PYMH1ara7r3W4XAFCr1egmbAEJ0kXYDyj0obVDwqusAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 05 14 20 00"\n        title=""\n        src="/static/2021-07-05-14-20-00-ccfce4dcfb994f03af63d60a1cd0b5d1-fee1c.png"\n        srcset="/static/2021-07-05-14-20-00-ccfce4dcfb994f03af63d60a1cd0b5d1-a67b7.png 200w,\n/static/2021-07-05-14-20-00-ccfce4dcfb994f03af63d60a1cd0b5d1-0b187.png 400w,\n/static/2021-07-05-14-20-00-ccfce4dcfb994f03af63d60a1cd0b5d1-fee1c.png 800w,\n/static/2021-07-05-14-20-00-ccfce4dcfb994f03af63d60a1cd0b5d1-b1a91.png 1200w,\n/static/2021-07-05-14-20-00-ccfce4dcfb994f03af63d60a1cd0b5d1-e3990.png 1206w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从图中可以看出，通过 var myName = “极客时间”简单地定义了一个变量，其中关键字“var”、标识符“myName” 、赋值运算符“=”、字符串“极客时间”四个都是 token，而且它们代表的属性还不一样。</p>\n<p>第二阶段是解析（parse），又称为语法分析，其作用是将上一步生成的 token 数据，根据语法规则转为 AST。如果源码符合语法规则，这一步就会顺利完成。但如果源码存在语法错误，这一步就会终止，并抛出一个“语法错误”。</p>\n<p>这就是 AST 的生成过程，先分词，再解析。</p>\n<p>有了 AST 后，那接下来 V8 就会生成该段代码的执行上下文。至于执行上下文的具体内容，你可以参考前面几篇文章的讲解。</p>\n<h3 id="生成字节码"><a href="#%E7%94%9F%E6%88%90%E5%AD%97%E8%8A%82%E7%A0%81" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>生成字节码</h3>\n<p>有了 AST 和执行上下文后，那接下来的第二步，解释器 Ignition 就登场了，它会根据 AST 生成字节码，并解释执行字节码。</p>\n<p>其实一开始 V8 并没有字节码，而是直接将 AST 转换为机器码，由于执行机器码的效率是非常高效的，所以这种方式在发布后的一段时间内运行效果是非常好的。但是随着 Chrome 在手机上的广泛普及，特别是运行在 512M 内存的手机上，内存占用问题也暴露出来了，因为 V8 需要消耗大量的内存来存放转换后的机器码。为了解决内存占用问题，V8 团队大幅重构了引擎架构，引入字节码，并且抛弃了之前的编译器，最终花了将进四年的时间，实现了现在的这套架构。</p>\n<p>那什么是字节码呢？为什么引入字节码就能解决内存占用问题呢？</p>\n<p>字节码就是介于 AST 和机器码之间的一种代码。但是与特定类型的机器码无关，字节码需要通过解释器将其转换为机器码后才能执行。</p>\n<p>理解了什么是字节码，我们再来对比下高级代码、字节码和机器码，你可以参考下图</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-05-14-20-28-a51833171add1250d3cdc4af5ca00a04-3adf4.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 40.779610194902546%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAIAAAB2/0i6AAAACXBIWXMAAA7DAAAOwwHHb6hkAAAA0ElEQVQY06VQ0Y6DIBDs//9jY04EFBRlqQgUuJuqyeWuSdOk8wLLzOwOe/n+AJc3dTFFWmkN65a2dE+/5lrrC9vBLXZd6MY6NU42pvSw1HpOziU7f/NxC9EfvXzYDC3k3VE6F8iFayvkYKz1pdRz8jzPejSdULIfZPulh56IGJMtk6MxYK21vVRDr4VQoFAqpWKMDzMOY4zgfNS6lJJzTghWCmyMsRDCfQeUQoimaZAFj1CesXEDDdv/D/9dBzTo+2rbaDRNU7dD7uCcI+qz8gfZoNI9AIQfcwAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 05 14 20 28"\n        title=""\n        src="/static/2021-07-05-14-20-28-a51833171add1250d3cdc4af5ca00a04-fee1c.png"\n        srcset="/static/2021-07-05-14-20-28-a51833171add1250d3cdc4af5ca00a04-a67b7.png 200w,\n/static/2021-07-05-14-20-28-a51833171add1250d3cdc4af5ca00a04-0b187.png 400w,\n/static/2021-07-05-14-20-28-a51833171add1250d3cdc4af5ca00a04-fee1c.png 800w,\n/static/2021-07-05-14-20-28-a51833171add1250d3cdc4af5ca00a04-b1a91.png 1200w,\n/static/2021-07-05-14-20-28-a51833171add1250d3cdc4af5ca00a04-3adf4.png 1334w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从图中可以看出，机器码所占用的空间远远超过了字节码，所以使用字节码可以减少系统的内存使用。</p>\n<h3 id="执行代码"><a href="#%E6%89%A7%E8%A1%8C%E4%BB%A3%E7%A0%81" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>执行代码</h3>\n<p>生成字节码之后，接下来就要进入执行阶段了。</p>\n<p>通常，如果有一段第一次执行的字节码，解释器 Ignition 会逐条解释执行。在执行字节码的过程中，如果发现有热点代码（HotSpot），比如一段代码被重复执行多次，这种就称为热点代码，那么后台的编译器 TurboFan 就会把该段热点的字节码编译为高效的机器码，然后当再次执行这段被优化的代码时，只需要执行编译后的机器码就可以了，这样就大大提升了代码的执行效率。</p>\n<p>V8 的解释器和编译器的取名也很有意思。解释器 Ignition 是点火器的意思，编译器 TurboFan 是涡轮增压的意思，寓意着代码启动时通过点火器慢慢发动，一旦启动，涡轮增压介入，其执行效率随着执行时间越来越高效率，因为热点代码都被编译器 TurboFan 转换了机器码，直接执行机器码就省去了字节码“翻译”为机器码的过程。</p>\n<p>其实字节码配合解释器和编译器是最近一段时间很火的技术，比如 Java 和 Python 的虚拟机也都是基于这种技术实现的，我们把这种技术称为即时编译（JIT）。具体到 V8，就是指解释器 Ignition 在解释执行字节码的同时，收集代码信息，当它发现某一部分代码变热了之后，TurboFan 编译器便闪亮登场，把热点的字节码转换为机器码，并把转换后的机器码保存起来，以备下次使用。</p>\n<p>对于 JavaScript 工作引擎，除了 V8 使用了“字节码 +JIT”技术之外，苹果的 SquirrelFish Extreme 和 Mozilla 的 SpiderMonkey 也都使用了该技术。</p>\n<p>这么多语言的工作引擎都使用了“字节码 +JIT”技术，因此理解 JIT 这套工作机制还是很有必要的。你可以结合下图看看 JIT 的工作过程：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-05-14-20-54-8045c545088f5f05a98e2208382f5db2-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 108.66900175131349%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAWCAIAAABPIytRAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACTElEQVQ4y6WTS09TQRTHZ+VCXeHGlRt3Ji40fAuXJvoJdOUnIDFujImG8Igu1IUQsYHEmACiiY/EBlRQEKgRKKb0hX1R7mPu9La9987M37mdaik0tomzuDn3zPnNOfOfcwj+Y5GjLinD75aNyA4mk5jJIBA9wzr0dgzkCU48w+kpML9xaC+waES9zeP6JzHw1R9Ya3q6Z9ZhLMCKgW8lbyHtrJr4SWVPsE6yboCM49Qkzr4AGcOVaGurO7xaxvEJnHkewicncPVDb7AOsD3M7uJ1xp9NuMpYLsteBZONpYxKzcsbjn48zrl2doGTqRS1LMfH5SguzCFhc0ixFY9Xq9V/wep40zRt6vguXcx7fVOhbOPbAWqORR1K6aHkbXAQ+C4L6+SNoOkMhje1VOEvo7YQojOs3AXH286bpg9fNBXSiWpcphnWs0aSck+0w83nMdA/Jy+9E/2vsFBq9qlu1aU9nJvG+RlcfKmUb1xQ/oG1tbgHMmqRwV0ysv8m14zQW9GcIENFMlwgo6X5Am+DdW2Gh7EN93GMRhKiWG2OlxboV0Xei/l3ltlgzM+78u/kte4shajv533XaY1le+8EVeaaZXlAsxbMhdhJpU3bkeFtZZ2jLqDkqfFQP1UrZZVkOhMEQSeY82w2yxjTTXao58KGq1TK5bLomFkt13VNy1byLxX9G19waw13v+PaZ7zPhQB1WLFYVDk6wyqD7TDU6NCKQx7i2FP0RSR5gJsfXbiWYVGV/GBRnUfyh4WRDTyK4/5maKh3DgU9Mla/AbcF1nHyw70qAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 05 14 20 54"\n        title=""\n        src="/static/2021-07-05-14-20-54-8045c545088f5f05a98e2208382f5db2-fee1c.png"\n        srcset="/static/2021-07-05-14-20-54-8045c545088f5f05a98e2208382f5db2-a67b7.png 200w,\n/static/2021-07-05-14-20-54-8045c545088f5f05a98e2208382f5db2-0b187.png 400w,\n/static/2021-07-05-14-20-54-8045c545088f5f05a98e2208382f5db2-fee1c.png 800w,\n/static/2021-07-05-14-20-54-8045c545088f5f05a98e2208382f5db2-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<h2 id="javascript-的性能优化"><a href="#javascript-%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>JavaScript 的性能优化</h2>\n<p>到这里相信你现在已经了解 V8 是如何执行一段 JavaScript 代码的了。在过去几年中，JavaScript 的性能得到了大幅提升，这得益于 V8 团队对解释器和编译器的不断改进和优化。</p>\n<p>虽然在 V8 诞生之初，也出现过一系列针对 V8 而专门优化 JavaScript 性能的方案，比如隐藏类、内联缓存等概念都是那时候提出来的。不过随着 V8 的架构调整，你越来越不需要这些微优化策略了，相反，对于优化 JavaScript 执行效率，你应该将优化的中心聚焦在单次脚本的执行时间和脚本的网络下载上，主要关注以下三点内容</p>\n<ul>\n<li>提升单次脚本的执行速度，避免 JavaScript 的长任务霸占主线程，这样可以使得页面快速响应交互；</li>\n<li>避免大的内联脚本，因为在解析 HTML 的过程中，解析和编译也会占用主线程；</li>\n<li>减少 JavaScript 文件的容量，因为更小的文件会提升下载速度，并且占用更低的内存</li>\n</ul>\n<h2 id="总结-2"><a href="#%E6%80%BB%E7%BB%93-2" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总结</h2>\n<ul>\n<li>首先我们介绍了编译器和解释器的区别。</li>\n<li>紧接着又详细分析了 V8 是如何执行一段 JavaScript 代码的：V8 依据 JavaScript 代码生成 AST 和执行上下文，再基于 AST 生成字节码，然后通过解释器执行字节码，通过编译器来优化编译字节码。</li>\n<li>基于字节码和编译器，我们又介绍了 JIT 技术。</li>\n<li>最后我们延伸说明了下优化 JavaScript 性能的一些策略。</li>\n</ul>\n<p>之所以在本专栏里讲 V8 的执行流程，是因为我觉得编译器和解释器的相关概念和理论对于程序员来说至关重要，向上能让你充分理解一些前端应用的本质，向下能打开计算机编译原理的大门。通过这些知识的学习能让你将很多模糊的概念关联起来，使其变得更加清楚，从而拓宽视野，上升到更高的层次。</p>',
id:"/github/workspace/blog/浏览器工作原理与实践——V8工作原理/index.md absPath of file >>> MarkdownRemark",timeToRead:15,frontmatter:{date:"2021-07-05 11:30:26",path:"/browser-working-principle-v8/",tags:"前端, 浏览器, 高级前端",title:"浏览器工作原理与实践——V8工作原理",draft:null}},{excerpt:"背景 在浏览器中，我们可以同时打开多个 Tab 页，每个 Tab 页可以粗略理解为一个“独立”的运行环境，即使是全局对象也不会在多个 Tab 间共享。然而有些时候，我们希望能在这些“独立”的 Tab…",html:'<h1 id="背景"><a href="#%E8%83%8C%E6%99%AF" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>背景</h1>\n<p>在浏览器中，我们可以同时打开多个 Tab 页，每个 Tab 页可以粗略理解为一个“独立”的运行环境，即使是全局对象也不会在多个 Tab 间共享。然而有些时候，我们希望能在这些“独立”的 Tab 页面之间同步页面的数据、信息或状态。</p>\n<p>正如下面这个例子：我在列表页点击“收藏”后，对应的详情页按钮会自动更新为“已收藏”状态；类似的，在详情页点击“收藏”后，列表页中按钮也会更新。</p>\n<p><img src="/static/cross-page-message-95ffa84567dab8bfd85806efe647b5a3.gif"></p>\n<h1 id="同源页面间的跨页面通信"><a href="#%E5%90%8C%E6%BA%90%E9%A1%B5%E9%9D%A2%E9%97%B4%E7%9A%84%E8%B7%A8%E9%A1%B5%E9%9D%A2%E9%80%9A%E4%BF%A1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>同源页面间的跨页面通信</h1>\n<p>浏览器的同源策略在下述的一些跨页面通信方法中依然存在限制。因此我们先来看看，在满足同源策略的情况下，都有哪些技术可以用来实现跨页面通信。</p>\n<h2 id="broadcast-channel"><a href="#broadcast-channel" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>BroadCast Channel</h2>\n<p>BroadCast Channel 可以帮我们创建一个用于广播的通信频道，当所有页面都监听同一频道的消息时，其中某一个页面通过它发送的消息就会被其他所有页面收到，它的 API 和用法都非常简单。</p>\n<p>下面的方式就可以创建一个标识为 AlienZHOU 的频道：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="65761195724586320000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`const bc = new BroadcastChannel(\'AlienZHOU\');`, `65761195724586320000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">const</span> bc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BroadcastChannel</span><span class="token punctuation">(</span><span class="token string">\'AlienZHOU\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>各个页面可以通过 onmessage 来监听被广播的消息：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="47350786839267720000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`bc.onmessage = function(e) {\n  const data = e.data;\n  const text = \'[receive] \' + data.msg + \' —— tab \' + data.from;\n  console.log(\'[BroadcastChannel] receive message:\', text);\n};`, `47350786839267720000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js">bc<span class="token punctuation">.</span><span class="token function-variable function">onmessage</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> data <span class="token operator">=</span> e<span class="token punctuation">.</span>data<span class="token punctuation">;</span>\n  <span class="token keyword">const</span> text <span class="token operator">=</span> <span class="token string">\'[receive] \'</span> <span class="token operator">+</span> data<span class="token punctuation">.</span>msg <span class="token operator">+</span> <span class="token string">\' —— tab \'</span> <span class="token operator">+</span> data<span class="token punctuation">.</span>from<span class="token punctuation">;</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'[BroadcastChannel] receive message:\'</span><span class="token punctuation">,</span> text<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>要发送消息时只需要调用实例上的 postMessage 方法即可：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="3537114983616729000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`bc.postMessage(mydata);`, `3537114983616729000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js">bc<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span>mydata<span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<h2 id="service-worker"><a href="#service-worker" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Service Worker</h2>\n<p>Service Worker 是一个可以长期运行在后台的 Worker，能够实现与页面的双向通信。多页面共享间的 Service Worker 可以共享，将 Service Worker 作为消息的处理中心（中央站）即可实现广播效果。</p>\n<p>首先，需要在页面注册 Service Worker：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="95634393271517710000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`/* 页面逻辑 */\nnavigator.serviceWorker.register(\'../util.sw.js\').then(function() {\n  console.log(\'Service Worker 注册成功\');\n});`, `95634393271517710000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">/* 页面逻辑 */</span>\nnavigator<span class="token punctuation">.</span>serviceWorker<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span><span class="token string">\'../util.sw.js\'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'Service Worker 注册成功\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>其中../util.sw.js 是对应的 Service Worker 脚本。Service Worker 本身并不自动具备“广播通信”的功能，需要我们添加些代码，将其改造成消息中转站：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="52721505266036200000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`/* ../util.sw.js Service Worker 逻辑 */\nself.addEventListener(\'message\', function(e) {\n  console.log(\'service worker receive message\', e.data);\n  e.waitUntil(\n    self.clients.matchAll().then(function(clients) {\n      if (!clients || clients.length === 0) {\n        return;\n      }\n      clients.forEach(function(client) {\n        client.postMessage(e.data);\n      });\n    })\n  );\n});`, `52721505266036200000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">/* ../util.sw.js Service Worker 逻辑 */</span>\nself<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">\'message\'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'service worker receive message\'</span><span class="token punctuation">,</span> e<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  e<span class="token punctuation">.</span><span class="token function">waitUntil</span><span class="token punctuation">(</span>\n    self<span class="token punctuation">.</span>clients<span class="token punctuation">.</span><span class="token function">matchAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">clients</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>clients <span class="token operator">||</span> clients<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">return</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n      clients<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">client</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        client<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span>\n  <span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>我们在 Service Worker 中监听了 message 事件，获取页面（从 Service Worker 的角度叫 client）发送的信息。然后通过 self.clients.matchAll() 获取当前注册了该 Service Worker 的所有页面，通过调用每个 client（即页面）的 postMessage 方法，向页面发送消息。这样就把从一处（某个 Tab 页面）收到的消息通知给了其他页面。</p>\n<p>处理完 Service Worker，我们需要在页面监听 Service Worker 发送来的消息：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="80698296875672910000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`/* 页面逻辑 */\nnavigator.serviceWorker.addEventListener(\'message\', function(e) {\n  const data = e.data;\n  const text = \'[receive] \' + data.msg + \' —— tab \' + data.from;\n  console.log(\'[Service Worker] receive message:\', text);\n});`, `80698296875672910000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">/* 页面逻辑 */</span>\nnavigator<span class="token punctuation">.</span>serviceWorker<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">\'message\'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> data <span class="token operator">=</span> e<span class="token punctuation">.</span>data<span class="token punctuation">;</span>\n  <span class="token keyword">const</span> text <span class="token operator">=</span> <span class="token string">\'[receive] \'</span> <span class="token operator">+</span> data<span class="token punctuation">.</span>msg <span class="token operator">+</span> <span class="token string">\' —— tab \'</span> <span class="token operator">+</span> data<span class="token punctuation">.</span>from<span class="token punctuation">;</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'[Service Worker] receive message:\'</span><span class="token punctuation">,</span> text<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>最后，当需要同步消息时，可以调用 Service Worker 的 postMessage 方法：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="26063990054815190000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`/* 页面逻辑 */\nnavigator.serviceWorker.controller.postMessage(mydata);`, `26063990054815190000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">/* 页面逻辑 */</span>\nnavigator<span class="token punctuation">.</span>serviceWorker<span class="token punctuation">.</span>controller<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span>mydata<span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span></span></pre></div>\n<h2 id="localstorage"><a href="#localstorage" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>LocalStorage</h2>\n<p>LocalStorage 作为前端最常用的本地存储，大家应该已经非常熟悉了；但 StorageEvent 这个与它相关的事件有些同学可能会比较陌生。</p>\n<p>当 LocalStorage 变化时，会触发 storage 事件。利用这个特性，我们可以在发送消息时，把消息写入到某个 LocalStorage 中；然后在各个页面内，通过监听 storage 事件即可收到通知。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="24849006019204657000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`window.addEventListener(\'storage\', function(e) {\n  if (e.key === \'ctc-msg\') {\n    const data = JSON.parse(e.newValue);\n    const text = \'[receive] \' + data.msg + \' —— tab \' + data.from;\n    console.log(\'[Storage I] receive message:\', text);\n  }\n});`, `24849006019204657000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js">window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">\'storage\'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>key <span class="token operator">===</span> <span class="token string">\'ctc-msg\'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>newValue<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">const</span> text <span class="token operator">=</span> <span class="token string">\'[receive] \'</span> <span class="token operator">+</span> data<span class="token punctuation">.</span>msg <span class="token operator">+</span> <span class="token string">\' —— tab \'</span> <span class="token operator">+</span> data<span class="token punctuation">.</span>from<span class="token punctuation">;</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'[Storage I] receive message:\'</span><span class="token punctuation">,</span> text<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>在各个页面添加如上的代码，即可监听到 LocalStorage 的变化。当某个页面需要发送消息时，只需要使用我们熟悉的 setItem 方法即可：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="90433842965335430000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`mydata.st = +new Date();\nwindow.localStorage.setItem(\'ctc-msg\', JSON.stringify(mydata));`, `90433842965335430000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js">mydata<span class="token punctuation">.</span>st <span class="token operator">=</span> <span class="token operator">+</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nwindow<span class="token punctuation">.</span>localStorage<span class="token punctuation">.</span><span class="token function">setItem</span><span class="token punctuation">(</span><span class="token string">\'ctc-msg\'</span><span class="token punctuation">,</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>mydata<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span></span></pre></div>\n<p>注意这里有一个细节：我们在 mydata 上添加了一个取当前毫秒时间戳的 .st 属性。这是因为 storage 事件只有在值真正改变时才会触发。举个例子：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="1987759806555922200"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`window.localStorage.setItem(\'test\', \'123\');\nwindow.localStorage.setItem(\'test\', \'123\');`, `1987759806555922200`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js">window<span class="token punctuation">.</span>localStorage<span class="token punctuation">.</span><span class="token function">setItem</span><span class="token punctuation">(</span><span class="token string">\'test\'</span><span class="token punctuation">,</span> <span class="token string">\'123\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nwindow<span class="token punctuation">.</span>localStorage<span class="token punctuation">.</span><span class="token function">setItem</span><span class="token punctuation">(</span><span class="token string">\'test\'</span><span class="token punctuation">,</span> <span class="token string">\'123\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span></span></pre></div>\n<p>由于第二次的值 123 与第一次的值相同，所以以上的代码只会在第一次 setItem 时触发 storage 事件。因此我们通过设置 st 来保证每次调用时一定会触发 storage 事件。</p>\n<h2 id="阶段性总结-1"><a href="#%E9%98%B6%E6%AE%B5%E6%80%A7%E6%80%BB%E7%BB%93-1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>阶段性总结-1</h2>\n<p>上面我们看到了三种实现跨页面通信的方式，不论是建立广播频道的 Broadcast Channel，还是使用 Service Worker 的消息中转站，抑或是有一些 tricky 的 storage 事件，其都是“广播模式”：一个页面将消息通知给一个“中央站”，再由“中央站”通知给各个页面</p>\n<p>下面我们会看到另外两种跨页面通信方式，我把它称为“共享存储+轮询模式”。</p>\n<h2 id="shared-worker"><a href="#shared-worker" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Shared Worker</h2>\n<p>Shared Worker 是 Worker 家族的另一个成员。普通的 Worker 之间是独立运行、数据互不相通；而多个 Tab 注册的 Shared Worker 则可以实现数据共享。</p>\n<p>Shared Worker 在实现跨页面通信时的问题在于，它无法主动通知所有页面，因此我们会使用轮询的方式，来拉取最新的数据。思路如下：</p>\n<p>让 Shared Worker 支持两种消息。一种是 post，Shared Worker 收到后会将该数据保存下来；另一种是 get，Shared Worker 收到该消息后会将保存的数据通过 postMessage 传给注册它的页面。也就是让页面通过 get 来主动获取（同步）最新消息。具体实现如下：</p>\n<p>首先，我们会在页面中启动一个 Shared Worker，启动方式非常简单：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="11320734074715100000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// 构造函数的第二个参数是 Shared Worker 名称，也可以留空\nconst sharedWorker = new SharedWorker(\'../util.shared.js\', \'ctc\');`, `11320734074715100000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">// 构造函数的第二个参数是 Shared Worker 名称，也可以留空</span>\n<span class="token keyword">const</span> sharedWorker <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SharedWorker</span><span class="token punctuation">(</span><span class="token string">\'../util.shared.js\'</span><span class="token punctuation">,</span> <span class="token string">\'ctc\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span></span></pre></div>\n<p>然后，在该 Shared Worker 中支持 get 与 post 形式的消息：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="71720345450400450000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`/* ../util.shared.js: Shared Worker 代码 */\nlet data = null;\nself.addEventListener(\'connect\', function(e) {\n  const port = e.ports[0];\n  port.addEventListener(\'message\', function(event) {\n    if (event.data.get) {\n      // get 指令则返回存储的消息数据\n      data && port.postMessage(data);\n    } else {\n      // 非 get 指令则存储该消息数据\n      data = event.data;\n    }\n  });\n  port.start();\n});`, `71720345450400450000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">/* ../util.shared.js: Shared Worker 代码 */</span>\n<span class="token keyword">let</span> data <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\nself<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">\'connect\'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> port <span class="token operator">=</span> e<span class="token punctuation">.</span>ports<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n  port<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">\'message\'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>event<span class="token punctuation">.</span>data<span class="token punctuation">.</span>get<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token comment">// get 指令则返回存储的消息数据</span>\n      data <span class="token operator">&amp;&amp;</span> port<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n      <span class="token comment">// 非 get 指令则存储该消息数据</span>\n      data <span class="token operator">=</span> event<span class="token punctuation">.</span>data<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  port<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>之后，页面定时发送 get 指令的消息给 Shared Worker，轮询最新的消息数据，并在页面监听返回信息：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="80305376498233260000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// 定时轮询，发送 get 指令的消息\nsetInterval(function() {\n  sharedWorker.port.postMessage({ get: true });\n}, 1000);\n\n// 监听 get 消息的返回数据\nsharedWorker.port.addEventListener(\n  \'message\',\n  (e) => {\n    const data = e.data;\n    const text = \'[receive] \' + data.msg + \' —— tab \' + data.from;\n    console.log(\'[Shared Worker] receive message:\', text);\n  },\n  false\n);\nsharedWorker.port.start();`, `80305376498233260000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">// 定时轮询，发送 get 指令的消息</span>\n<span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  sharedWorker<span class="token punctuation">.</span>port<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token keyword">get</span><span class="token punctuation">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token comment">// 监听 get 消息的返回数据</span>\nsharedWorker<span class="token punctuation">.</span>port<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span>\n  <span class="token string">\'message\'</span><span class="token punctuation">,</span>\n  <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n    <span class="token keyword">const</span> data <span class="token operator">=</span> e<span class="token punctuation">.</span>data<span class="token punctuation">;</span>\n    <span class="token keyword">const</span> text <span class="token operator">=</span> <span class="token string">\'[receive] \'</span> <span class="token operator">+</span> data<span class="token punctuation">.</span>msg <span class="token operator">+</span> <span class="token string">\' —— tab \'</span> <span class="token operator">+</span> data<span class="token punctuation">.</span>from<span class="token punctuation">;</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'[Shared Worker] receive message:\'</span><span class="token punctuation">,</span> text<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token boolean">false</span>\n<span class="token punctuation">)</span><span class="token punctuation">;</span>\nsharedWorker<span class="token punctuation">.</span>port<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>最后，当要跨页面通信时，只需给 Shared Worker postMessage 即可：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="4101323203322171400"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`sharedWorker.port.postMessage(mydata);`, `4101323203322171400`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js">sharedWorker<span class="token punctuation">.</span>port<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span>mydata<span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<blockquote>\n<p>注意，如果使用 addEventListener 来添加 Shared Worker 的消息监听，需要显式调用 MessagePort.start 方法，即上文中的 sharedWorker.port.start()；如果使用 onmessage 绑定监听则不需要。</p>\n</blockquote>\n<h2 id="indexeddb"><a href="#indexeddb" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>IndexedDB</h2>\n<p>除了可以利用 Shared Worker 来共享存储数据，还可以使用其他一些“全局性”（支持跨页面）的存储方案。例如 IndexedDB 或 cookie。</p>\n<blockquote>\n<p>鉴于大家对 cookie 已经很熟悉，加之作为“互联网最早期的存储方案之一”，cookie 已经在实际应用中承受了远多于其设计之初的责任，我们下面会使用 IndexedDB 来实现。</p>\n</blockquote>\n<p>其思路很简单：与 Shared Worker 方案类似，消息发送方将消息存至 IndexedDB 中；接收方（例如所有页面）则通过轮询去获取最新的信息。在这之前，我们先简单封装几个 IndexedDB 的工具方法。</p>\n<p>打开数据库连接</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="40254117280329330000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function openStore() {\n  const storeName = \'ctc_aleinzhou\';\n  return new Promise(function(resolve, reject) {\n    if (!(\'indexedDB\' in window)) {\n      return reject(&quot;don\'t support indexedDB&quot;);\n    }\n    const request = indexedDB.open(\'CTC_DB\', 1);\n    request.onerror = reject;\n    request.onsuccess = (e) => resolve(e.target.result);\n    request.onupgradeneeded = function(e) {\n      const db = e.srcElement.result;\n      if (e.oldVersion === 0 && !db.objectStoreNames.contains(storeName)) {\n        const store = db.createObjectStore(storeName, { keyPath: \'tag\' });\n        store.createIndex(storeName + \'Index\', \'tag\', { unique: false });\n      }\n    };\n  });\n}`, `40254117280329330000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span> <span class="token function">openStore</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> storeName <span class="token operator">=</span> <span class="token string">\'ctc_aleinzhou\'</span><span class="token punctuation">;</span>\n  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span><span class="token string">\'indexedDB\'</span> <span class="token keyword">in</span> window<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">return</span> <span class="token function">reject</span><span class="token punctuation">(</span><span class="token string">"don\'t support indexedDB"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n    <span class="token keyword">const</span> request <span class="token operator">=</span> indexedDB<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">\'CTC_DB\'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    request<span class="token punctuation">.</span>onerror <span class="token operator">=</span> reject<span class="token punctuation">;</span>\n    request<span class="token punctuation">.</span><span class="token function-variable function">onsuccess</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">resolve</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>target<span class="token punctuation">.</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    request<span class="token punctuation">.</span><span class="token function-variable function">onupgradeneeded</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">const</span> db <span class="token operator">=</span> e<span class="token punctuation">.</span>srcElement<span class="token punctuation">.</span>result<span class="token punctuation">;</span>\n      <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>oldVersion <span class="token operator">===</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>db<span class="token punctuation">.</span>objectStoreNames<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>storeName<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">const</span> store <span class="token operator">=</span> db<span class="token punctuation">.</span><span class="token function">createObjectStore</span><span class="token punctuation">(</span>storeName<span class="token punctuation">,</span> <span class="token punctuation">{</span> keyPath<span class="token punctuation">:</span> <span class="token string">\'tag\'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        store<span class="token punctuation">.</span><span class="token function">createIndex</span><span class="token punctuation">(</span>storeName <span class="token operator">+</span> <span class="token string">\'Index\'</span><span class="token punctuation">,</span> <span class="token string">\'tag\'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> unique<span class="token punctuation">:</span> <span class="token boolean">false</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>存储数据</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="60634978703313870000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function saveData(db, data) {\n  return new Promise(function(resolve, reject) {\n    const STORE_NAME = \'ctc_aleinzhou\';\n    const tx = db.transaction(STORE_NAME, \'readwrite\');\n    const store = tx.objectStore(STORE_NAME);\n    const request = store.put({ tag: \'ctc_data\', data });\n    request.onsuccess = () => resolve(db);\n    request.onerror = reject;\n  });\n}`, `60634978703313870000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span> <span class="token function">saveData</span><span class="token punctuation">(</span><span class="token parameter">db<span class="token punctuation">,</span> data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">const</span> <span class="token constant">STORE_NAME</span> <span class="token operator">=</span> <span class="token string">\'ctc_aleinzhou\'</span><span class="token punctuation">;</span>\n    <span class="token keyword">const</span> tx <span class="token operator">=</span> db<span class="token punctuation">.</span><span class="token function">transaction</span><span class="token punctuation">(</span><span class="token constant">STORE_NAME</span><span class="token punctuation">,</span> <span class="token string">\'readwrite\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">const</span> store <span class="token operator">=</span> tx<span class="token punctuation">.</span><span class="token function">objectStore</span><span class="token punctuation">(</span><span class="token constant">STORE_NAME</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">const</span> request <span class="token operator">=</span> store<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token punctuation">{</span> tag<span class="token punctuation">:</span> <span class="token string">\'ctc_data\'</span><span class="token punctuation">,</span> data <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    request<span class="token punctuation">.</span><span class="token function-variable function">onsuccess</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">resolve</span><span class="token punctuation">(</span>db<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    request<span class="token punctuation">.</span>onerror <span class="token operator">=</span> reject<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>查询/读取数据</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="81937156695886540000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function query(db) {\n  const STORE_NAME = \'ctc_aleinzhou\';\n  return new Promise(function(resolve, reject) {\n    try {\n      const tx = db.transaction(STORE_NAME, \'readonly\');\n      const store = tx.objectStore(STORE_NAME);\n      const dbRequest = store.get(\'ctc_data\');\n      dbRequest.onsuccess = (e) => resolve(e.target.result);\n      dbRequest.onerror = reject;\n    } catch (err) {\n      reject(err);\n    }\n  });\n}`, `81937156695886540000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span> <span class="token function">query</span><span class="token punctuation">(</span><span class="token parameter">db</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> <span class="token constant">STORE_NAME</span> <span class="token operator">=</span> <span class="token string">\'ctc_aleinzhou\'</span><span class="token punctuation">;</span>\n  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">try</span> <span class="token punctuation">{</span>\n      <span class="token keyword">const</span> tx <span class="token operator">=</span> db<span class="token punctuation">.</span><span class="token function">transaction</span><span class="token punctuation">(</span><span class="token constant">STORE_NAME</span><span class="token punctuation">,</span> <span class="token string">\'readonly\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token keyword">const</span> store <span class="token operator">=</span> tx<span class="token punctuation">.</span><span class="token function">objectStore</span><span class="token punctuation">(</span><span class="token constant">STORE_NAME</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token keyword">const</span> dbRequest <span class="token operator">=</span> store<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">\'ctc_data\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      dbRequest<span class="token punctuation">.</span><span class="token function-variable function">onsuccess</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">resolve</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>target<span class="token punctuation">.</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      dbRequest<span class="token punctuation">.</span>onerror <span class="token operator">=</span> reject<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token function">reject</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>剩下的工作就非常简单了。首先打开数据连接，并初始化数据：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="56182662320742450000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`openStore().then((db) => saveData(db, null));`, `56182662320742450000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token function">openStore</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">db</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">saveData</span><span class="token punctuation">(</span>db<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>对于消息读取，可以在连接与初始化后轮询：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="77446233961557340000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`openStore()\n  .then((db) => saveData(db, null))\n  .then(function(db) {\n    setInterval(function() {\n      query(db).then(function(res) {\n        if (!res || !res.data) {\n          return;\n        }\n        const data = res.data;\n        const text = \'[receive] \' + data.msg + \' —— tab \' + data.from;\n        console.log(\'[Storage I] receive message:\', text);\n      });\n    }, 1000);\n  });`, `77446233961557340000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token function">openStore</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">db</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">saveData</span><span class="token punctuation">(</span>db<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">db</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token function">query</span><span class="token punctuation">(</span>db<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">res</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>res <span class="token operator">||</span> <span class="token operator">!</span>res<span class="token punctuation">.</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n          <span class="token keyword">return</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n        <span class="token keyword">const</span> data <span class="token operator">=</span> res<span class="token punctuation">.</span>data<span class="token punctuation">;</span>\n        <span class="token keyword">const</span> text <span class="token operator">=</span> <span class="token string">\'[receive] \'</span> <span class="token operator">+</span> data<span class="token punctuation">.</span>msg <span class="token operator">+</span> <span class="token string">\' —— tab \'</span> <span class="token operator">+</span> data<span class="token punctuation">.</span>from<span class="token punctuation">;</span>\n        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'[Storage I] receive message:\'</span><span class="token punctuation">,</span> text<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>最后，要发送消息时，只需向 IndexedDB 存储数据即可：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="57389224594665140000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`openStore()\n  .then((db) => saveData(db, null))\n  .then(function(db) {\n    // …… 省略上面的轮询代码\n    // 触发 saveData 的方法可以放在用户操作的事件监听内\n    saveData(db, mydata);\n  });`, `57389224594665140000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token function">openStore</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">db</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">saveData</span><span class="token punctuation">(</span>db<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">db</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// …… 省略上面的轮询代码</span>\n    <span class="token comment">// 触发 saveData 的方法可以放在用户操作的事件监听内</span>\n    <span class="token function">saveData</span><span class="token punctuation">(</span>db<span class="token punctuation">,</span> mydata<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h2 id="阶段性总结-2"><a href="#%E9%98%B6%E6%AE%B5%E6%80%A7%E6%80%BB%E7%BB%93-2" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>阶段性总结-2</h2>\n<p>在“广播模式”外，我们又了解了“共享存储+长轮询”这种模式。也许你会认为长轮询没有监听模式优雅，但实际上，有些时候使用“共享存储”的形式时，不一定要搭配长轮询。</p>\n<p>例如，在多 Tab 场景下，我们可能会离开 Tab A 到另一个 Tab B 中操作；过了一会我们从 Tab B 切换回 Tab A 时，希望将之前在 Tab B 中的操作的信息同步回来。这时候，其实只用在 Tab A 中监听 visibilitychange 这样的事件，来做一次信息同步即可。</p>\n<p>下面，我会再介绍一种通信方式，我把它称为“口口相传”模式。</p>\n<h2 id="windowopen--windowopener"><a href="#windowopen--windowopener" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>window.open + window.opener</h2>\n<p>当我们使用 window.open 打开页面时，方法会返回一个被打开页面 window 的引用。而在未显示指定 noopener 时，被打开的页面可以通过 window.opener 获取到打开它的页面的引用 —— 通过这种方式我们就将这些页面建立起了联系（一种树形结构）。</p>\n<p>首先，我们把 window.open 打开的页面的 window 对象收集起来：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="82284855242479300000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`let childWins = [];\ndocument.getElementById(\'btn\').addEventListener(\'click\', function() {\n  const win = window.open(\'./some/sample\');\n  childWins.push(win);\n});`, `82284855242479300000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">let</span> childWins <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\ndocument<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">\'btn\'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">\'click\'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> win <span class="token operator">=</span> window<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">\'./some/sample\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  childWins<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>win<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>然后，当我们需要发送消息的时候，作为消息的发起方，一个页面需要同时通知它打开的页面与打开它的页面：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="77027278402472150000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// 向下传递消息，打开的窗口传递消息给它打开的页面\nchildWins = childWins.filter((w) => !w.closed);\nif (childWins.length > 0) {\n  mydata.fromOpenner = false;\n  childWins.forEach((w) => w.postMessage(mydata));\n}\n\n// 向上传递消息，打开的窗口传递消息给打开它的页面\nif (window.opener && !window.opener.closed) {\n  mydata.fromOpenner = true;\n  window.opener.postMessage(mydata);\n}`, `77027278402472150000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">// 向下传递消息，打开的窗口传递消息给它打开的页面</span>\nchildWins <span class="token operator">=</span> childWins<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">w</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token operator">!</span>w<span class="token punctuation">.</span>closed<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">if</span> <span class="token punctuation">(</span>childWins<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  mydata<span class="token punctuation">.</span>fromOpenner <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>\n  childWins<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">w</span><span class="token punctuation">)</span> <span class="token operator">=></span> w<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span>mydata<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// 向上传递消息，打开的窗口传递消息给打开它的页面</span>\n<span class="token keyword">if</span> <span class="token punctuation">(</span>window<span class="token punctuation">.</span>opener <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>window<span class="token punctuation">.</span>opener<span class="token punctuation">.</span>closed<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  mydata<span class="token punctuation">.</span>fromOpenner <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n  window<span class="token punctuation">.</span>opener<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span>mydata<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>注意，我这里先用 .closed 属性过滤掉已经被关闭的 Tab 窗口。这样，作为消息发送方的任务就完成了。下面看看，作为消息接收方，它需要做什么。</p>\n<p>此时，一个收到消息的页面就不能那么自私了，除了展示收到的消息，它还需要将消息再传递给它所“知道的人”（打开与被它打开的页面）:</p>\n<blockquote>\n<p>需要注意的是，我这里通过判断消息来源，避免将消息回传给发送方，防止消息在两者间死循环的传递。（该方案会有些其他小问题，实际中可以进一步优化）</p>\n</blockquote>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="61903694591480504000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`window.addEventListener(\'message\', function(e) {\n  const data = e.data;\n  const text = \'[receive] \' + data.msg + \' —— tab \' + data.from;\n  console.log(\'[Cross-document Messaging] receive message:\', text);\n  // 向上传递消息，避免消息回传\n  if (window.opener && !window.opener.closed && data.fromOpenner) {\n    window.opener.postMessage(data);\n  }\n  // 过滤掉已经关闭的窗口\n  childWins = childWins.filter((w) => !w.closed);\n  // 避免消息回传\n  if (childWins && !data.fromOpenner) {\n    // 向下传递消息\n    childWins.forEach((w) => w.postMessage(data));\n  }\n});`, `61903694591480504000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js">window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">\'message\'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> data <span class="token operator">=</span> e<span class="token punctuation">.</span>data<span class="token punctuation">;</span>\n  <span class="token keyword">const</span> text <span class="token operator">=</span> <span class="token string">\'[receive] \'</span> <span class="token operator">+</span> data<span class="token punctuation">.</span>msg <span class="token operator">+</span> <span class="token string">\' —— tab \'</span> <span class="token operator">+</span> data<span class="token punctuation">.</span>from<span class="token punctuation">;</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'[Cross-document Messaging] receive message:\'</span><span class="token punctuation">,</span> text<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token comment">// 向上传递消息，避免消息回传</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>window<span class="token punctuation">.</span>opener <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>window<span class="token punctuation">.</span>opener<span class="token punctuation">.</span>closed <span class="token operator">&amp;&amp;</span> data<span class="token punctuation">.</span>fromOpenner<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    window<span class="token punctuation">.</span>opener<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token comment">// 过滤掉已经关闭的窗口</span>\n  childWins <span class="token operator">=</span> childWins<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">w</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token operator">!</span>w<span class="token punctuation">.</span>closed<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token comment">// 避免消息回传</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>childWins <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>data<span class="token punctuation">.</span>fromOpenner<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 向下传递消息</span>\n    childWins<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">w</span><span class="token punctuation">)</span> <span class="token operator">=></span> w<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>这样，每个节点（页面）都肩负起了传递消息的责任，也就是我说的“口口相传”，而消息就在这个树状结构中流转了起来。</p>\n<h2 id="阶段性总结-3"><a href="#%E9%98%B6%E6%AE%B5%E6%80%A7%E6%80%BB%E7%BB%93-3" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>阶段性总结-3</h2>\n<p>显然，“口口相传”的模式存在一个问题：如果页面不是通过在另一个页面内的 window.open 打开的（例如直接在地址栏输入，或从其他网站链接过来），这个联系就被打破了。</p>\n<p>除了上面这六个常见方法，其实还有一种（第七种）做法是通过 WebSocket 这类的“服务器推”技术来进行同步。这好比将我们的“中央站”从前端移到了后端，比如说 Polling/COMET/SSE/WebSocket。</p>\n<h1 id="非同源页面之间的通信"><a href="#%E9%9D%9E%E5%90%8C%E6%BA%90%E9%A1%B5%E9%9D%A2%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>非同源页面之间的通信</h1>\n<p>上面我们介绍了七种前端跨页面通信的方法，但它们大都受到同源策略的限制。然而有时候，我们有两个不同域名的产品线，也希望它们下面的所有页面之间能无障碍地通信。那该怎么办呢？</p>\n<p>要实现该功能，可以使用一个用户不可见的 iframe 作为“桥”。由于 iframe 与父页面间可以通过指定 origin 来忽略同源限制，因此可以在每个页面中嵌入一个 iframe （例如：<a href="http://sample.com/bridge.html%EF%BC%89%EF%BC%8C%E8%80%8C%E8%BF%99%E4%BA%9B" target="_blank" rel="nofollow noreferrer noopener">http://sample.com/bridge.html），而这些</a> iframe 由于使用的是一个 url，因此属于同源页面，其通信方式可以复用上面第一部分提到的各种方式。</p>\n<p>页面与 iframe 通信非常简单，首先需要在页面中监听 iframe 发来的消息，做相应的业务处理：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="76189456476988100000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`/* 业务页面代码 */\nwindow.addEventListener(\'message\', function(e) {\n  // …… do something\n});`, `76189456476988100000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">/* 业务页面代码 */</span>\nwindow<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">\'message\'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// …… do something</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>然后，当页面要与其他的同源或非同源页面通信时，会先给 iframe 发送消息：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="58027238401762780000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`/* 业务页面代码 */\nwindow.frames[0].window.postMessage(mydata, \'*\');`, `58027238401762780000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">/* 业务页面代码 */</span>\nwindow<span class="token punctuation">.</span>frames<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>window<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span>mydata<span class="token punctuation">,</span> <span class="token string">\'*\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span></span></pre></div>\n<p>其中为了简便此处将 postMessage 的第二个参数设为了 *，你也可以设为 iframe 的 URL。iframe 收到消息后，会使用某种跨页面消息通信技术在所有 iframe 间同步消息，例如下面使用的 Broadcast Channel：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="10587994635749020000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`/* iframe 内代码 */\nconst bc = new BroadcastChannel(\'AlienZHOU\');\n// 收到来自页面的消息后，在 iframe 间进行广播\nwindow.addEventListener(\'message\', function(e) {\n  bc.postMessage(e.data);\n});`, `10587994635749020000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">/* iframe 内代码 */</span>\n<span class="token keyword">const</span> bc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BroadcastChannel</span><span class="token punctuation">(</span><span class="token string">\'AlienZHOU\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token comment">// 收到来自页面的消息后，在 iframe 间进行广播</span>\nwindow<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">\'message\'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  bc<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>其他 iframe 收到通知后，则会将该消息同步给所属的页面：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="7978278750649359000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`/* iframe 内代码 */\n// 对于收到的（iframe）广播消息，通知给所属的业务页面\nbc.onmessage = function(e) {\n  window.parent.postMessage(e.data, \'*\');\n};`, `7978278750649359000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">/* iframe 内代码 */</span>\n<span class="token comment">// 对于收到的（iframe）广播消息，通知给所属的业务页面</span>\nbc<span class="token punctuation">.</span><span class="token function-variable function">onmessage</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  window<span class="token punctuation">.</span>parent<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>data<span class="token punctuation">,</span> <span class="token string">\'*\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>下图就是使用 iframe 作为“桥”的非同源页面间通信模式图。</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-06-30-11-37-20-bcab03162a3d07b9021b67604ee7a0ec-d6910.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 568px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 48.767605633802816%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACCklEQVQoz2PYf+DPkqU39u7/lZRU39CwbPeeb8uW396z97uDXRADKwO3Fh+HMienOhebLAcXB+elhYteb9p8b8XKDzt26KmoMGzf+XXK1GNbtr7PzOxoaV23fuPLqTNO7tj11dU5koGFgVODm1WejU2ZnVWajYeT6+qixXeXLjk3cybQCEM1NYZDR/4vXXoXSKaltTY3r92z9++KlY+AXCfHMAZmBmZZFgYJBgZJBiYxZh4u7huLFn3euvXZqtU/d+021tBguHv3586d5x49/puZWT9hwspr19/v3Xvp/sO/9vb+vKJcLVNaq9qqu2Z0OgU6MzMwXN+16/GZM7eOHP5y9aqjhQXD69evt2zZ8ObN84KChhkzljx+fH/bto3v3n2wtfWUUZJ6++bt8SPH3756U9FYycDAcPnUybOXL+/av//lo8cO5uYMDx4+27fvwL17DzMzKiZPWXL7zr39Bw7eufvU3t5XUl781NnTu/fsPnH6ZHphBlDzid27r1y6dPTI4QdXLjtbWTEcOvxty5ZHhw5/jY4uKS+ffvDQ502bH2ze8sjOxp+Bg0HNXl3NTk3dSVNYVYSdlfXonNnv9ux5vn37s23b7ExNGQQFxfn5RQUExLi5+YCIn18MyBUUFGNn52RkYmRgZIAgRmZGFmZmEaC0gIAomOTi5GTAD5iZmCGIkZGRgboAAP0M5FJj0X+RAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 06 30 11 37 20"\n        title=""\n        src="/static/2021-06-30-11-37-20-bcab03162a3d07b9021b67604ee7a0ec-d6910.png"\n        srcset="/static/2021-06-30-11-37-20-bcab03162a3d07b9021b67604ee7a0ec-487ad.png 200w,\n/static/2021-06-30-11-37-20-bcab03162a3d07b9021b67604ee7a0ec-1cefb.png 400w,\n/static/2021-06-30-11-37-20-bcab03162a3d07b9021b67604ee7a0ec-d6910.png 568w"\n        sizes="(max-width: 568px) 100vw, 568px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>其中“同源跨域通信方案”可以使用文章第一部分提到的某种技术。</p>\n<h1 id="总结"><a href="#%E6%80%BB%E7%BB%93" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总结</h1>\n<p>对于同源页面，常见的方式包括：</p>\n<ul>\n<li>广播模式：Broadcast Channe / Service Worker / LocalStorage + StorageEvent</li>\n<li>共享存储模式：Shared Worker / IndexedDB / cookie</li>\n<li>口口相传模式：window.open + window.opener</li>\n<li>基于服务端：Websocket / Comet / SSE 等</li>\n</ul>\n<p>而对于非同源页面，则可以通过嵌入同源 iframe 作为“桥”，将非同源页面通信转换为同源页面通信。</p>',
id:"/github/workspace/blog/浏览器跨页面通信/index.md absPath of file >>> MarkdownRemark",timeToRead:8,frontmatter:{date:"2021-06-30 11:17:28",path:"/browser-cross-page-message/",tags:"前端, 浏览器, 高级前端",title:"浏览器跨页面通信",draft:null}}],length:4,tag:"浏览器",pagesSum:1,page:1}}}});