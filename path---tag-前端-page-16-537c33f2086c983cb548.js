webpackJsonp([21818679219157],{1344:function(n,a){n.exports={data:{site:{siteMetadata:{title:"女王控的博客",description:'前端工程师，黑猫女王控，欢迎勾搭，技术相关<a href="https://github.com/towavephone" target="_blank">@towavephone</a>，QQ闲聊<a href="tencent://AddContact/?fromId=45&fromSubId=1&subcmd=all&uin=634407147&website=www.oicqzone.com">@towave</a>，bili关注<a href="https://space.bilibili.com/11507708#/" target="_blank">@towave</a>',siteUrl:"https://blog.towavephone.com"}}},pathContext:{posts:[{excerpt:"ES…",html:'<h1 id="es5-继承"><a href="#es5-%E7%BB%A7%E6%89%BF" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>ES5 继承</h1>\n<p>先定义一个父类</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="84950634998720560000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function SuperType() {\n  // 属性\n  this.name = \'SuperType\';\n}\n// 原型方法\nSuperType.prototype.sayName = function() {\n  return this.name;\n};`, `84950634998720560000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span> <span class="token function">SuperType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 属性</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">\'SuperType\'</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token comment">// 原型方法</span>\n<span class="token class-name">SuperType</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h2 id="原型链继承"><a href="#%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%BB%A7%E6%89%BF" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>原型链继承</h2>\n<p><strong>将父类的实例作为子类的原型</strong></p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="19477100429484140000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// 父类\nfunction SuperType() {\n  this.name = \'SuperType\'; // 父类属性\n}\nSuperType.prototype.sayName = function() {\n  // 父类原型方法\n  return this.name;\n};\n\n// 子类\nfunction SubType() {\n  this.subName = \'SubType\'; // 子类属性\n}\n\nSubType.prototype = new SuperType(); // 重写原型对象，代之以一个新类型的实例\n// 这里实例化一个 SuperType 时， 实际上执行了两步\n// 1，新创建的对象复制了父类构造函数内的所有属性及方法\n// 2，并将原型 __proto__ 指向了父类的原型对象\n\nSubType.prototype.saySubName = function() {\n  // 子类原型方法\n  return this.subName;\n};\n\n// 子类实例\nlet instance = new SubType();\n\n// instanceof 通过判断对象的 prototype 链来确定对象是否是某个类的实例\ninstance instanceof SubType; // true\ninstance instanceof SuperType; // true\n\n// 注意\nSubType instanceof SuperType; // false\nSubType.prototype instanceof SuperType; // true`, `19477100429484140000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">// 父类</span>\n<span class="token keyword">function</span> <span class="token function">SuperType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">\'SuperType\'</span><span class="token punctuation">;</span> <span class="token comment">// 父类属性</span>\n<span class="token punctuation">}</span>\n<span class="token class-name">SuperType</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 父类原型方法</span>\n  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n<span class="token comment">// 子类</span>\n<span class="token keyword">function</span> <span class="token function">SubType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>subName <span class="token operator">=</span> <span class="token string">\'SubType\'</span><span class="token punctuation">;</span> <span class="token comment">// 子类属性</span>\n<span class="token punctuation">}</span>\n\n<span class="token class-name">SubType</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SuperType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 重写原型对象，代之以一个新类型的实例</span>\n<span class="token comment">// 这里实例化一个 SuperType 时， 实际上执行了两步</span>\n<span class="token comment">// 1，新创建的对象复制了父类构造函数内的所有属性及方法</span>\n<span class="token comment">// 2，并将原型 __proto__ 指向了父类的原型对象</span>\n\n<span class="token class-name">SubType</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">saySubName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 子类原型方法</span>\n  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>subName<span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n<span class="token comment">// 子类实例</span>\n<span class="token keyword">let</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token comment">// instanceof 通过判断对象的 prototype 链来确定对象是否是某个类的实例</span>\ninstance <span class="token keyword">instanceof</span> <span class="token class-name">SubType</span><span class="token punctuation">;</span> <span class="token comment">// true</span>\ninstance <span class="token keyword">instanceof</span> <span class="token class-name">SuperType</span><span class="token punctuation">;</span> <span class="token comment">// true</span>\n\n<span class="token comment">// 注意</span>\nSubType <span class="token keyword">instanceof</span> <span class="token class-name">SuperType</span><span class="token punctuation">;</span> <span class="token comment">// false</span>\n<span class="token class-name">SubType</span><span class="token punctuation">.</span>prototype <span class="token keyword">instanceof</span> <span class="token class-name">SuperType</span><span class="token punctuation">;</span> <span class="token comment">// true</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2019-09-21-02-55-32-650497183e53bdda43d578b83b47b2ff-83743.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 738px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 73.71273712737127%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAIAAABr+ngCAAAACXBIWXMAAAsSAAALEgHS3X78AAABv0lEQVQoz4VSi26cMBDk/z+sVZsmpEnJ8cgBBwJjfPgBfnFg6F6inGhF2hGWjFezO7O7nrW2qtGpKCuElmVZP7A4t95+t4ENvGmayrIMD2EUxi1uy6JIogjVtWVMx7FOYpVEjAqu98iQFIqf0y7/esIR4Yx1cUgefRaGknOIOWtnt7i90h6c8TJaYUXeD1helCZFHv30yyhK4ngG8Z/DW99SamHQA26PHQky4T+LrOieniRj74Y/J6+rc46fBT/156gjB9aVQho3KDPN87VVH9gnQ2AE4U3fvhB6pINQvbRGq/V/8N6ErdM80YqRQ0dTKpqBE0mZPHc0y7KqqtI0Ze8WdsjrOs/zaEbLrenspCbBeHjtV4wxNsZwzsdx3CHDnFpCUIObGjPKqwrhhsDaoKa5XC5bqw4G5pYtPKXHU4lfj1leFHlRFlXNhJBKg5Ztkf2GwSAJoc/BS5qfvt/7NWqE6CEXaEmOKdgW/SClhPuXb3cIt9tEHmgDVyDIzTN8cCBmjIV3cATLC0+gFi7Wjn/J8ZRSZd0UCFcNbhkPDlGYvOKWbNXeSi1/wtNa8yDgP+6G4Bd99EHFtdI/t/KG3xqYXbU55onmAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2019 09 21 02 55 32"\n        title=""\n        src="/static/2019-09-21-02-55-32-650497183e53bdda43d578b83b47b2ff-83743.png"\n        srcset="/static/2019-09-21-02-55-32-650497183e53bdda43d578b83b47b2ff-1800c.png 200w,\n/static/2019-09-21-02-55-32-650497183e53bdda43d578b83b47b2ff-4ad31.png 400w,\n/static/2019-09-21-02-55-32-650497183e53bdda43d578b83b47b2ff-83743.png 738w"\n        sizes="(max-width: 738px) 100vw, 738px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<ul>\n<li>\n<p><strong>特点</strong>：利用原型，让一个引用类型继承另一个引用类型的属性及方法</p>\n</li>\n<li>\n<p><strong>优点</strong>：<strong>继承了父类的模板，又继承了父类的原型对象</strong></p>\n</li>\n<li>\n<p><strong>缺点</strong>：</p>\n<ul>\n<li>\n<p>可以在子类构造函数中，为子类实例增加实例属性。如果要<strong>新增原型属性和方法</strong>，则必须放在 <code class="language-text">SubType.prototype = new SuperType(&#39;SubType&#39;);</code> 这样的语句<strong>之后</strong>执行。</p>\n</li>\n<li>\n<p>无法实现多继承</p>\n</li>\n<li>\n<p>来自原型对象的所有属性被<strong>所有实例共享</strong></p>\n</li>\n</ul>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="48007346745994090000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// 父类\nfunction SuperType() {\n  this.colors = [\'red\', \'blue\', \'green\'];\n  this.name = \'SuperType\';\n}\n// 子类\nfunction SubType() {}\n\n// 原型链继承\nSubType.prototype = new SuperType();\n\n// 实例1\nvar instance1 = new SubType();\ninstance1.colors.push(\'blcak\');\ninstance1.name = \'change-super-type-name\';\nconsole.log(instance1.colors); // [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;blcak&quot;]\nconsole.log(instance1.name); // change-super-type-name\n// 实例2\nvar instance2 = new SubType();\nconsole.log(instance2.colors); // [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;blcak&quot;]\nconsole.log(instance2.name); // SuperType`, `48007346745994090000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">// 父类</span>\n<span class="token keyword">function</span> <span class="token function">SuperType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>colors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">\'red\'</span><span class="token punctuation">,</span> <span class="token string">\'blue\'</span><span class="token punctuation">,</span> <span class="token string">\'green\'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">\'SuperType\'</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token comment">// 子类</span>\n<span class="token keyword">function</span> <span class="token function">SubType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n\n<span class="token comment">// 原型链继承</span>\n<span class="token class-name">SubType</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SuperType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token comment">// 实例1</span>\n<span class="token keyword">var</span> instance1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\ninstance1<span class="token punctuation">.</span>colors<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">\'blcak\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\ninstance1<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">\'change-super-type-name\'</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance1<span class="token punctuation">.</span>colors<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ["red", "blue", "green", "blcak"]</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance1<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// change-super-type-name</span>\n<span class="token comment">// 实例2</span>\n<span class="token keyword">var</span> instance2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance2<span class="token punctuation">.</span>colors<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ["red", "blue", "green", "blcak"]</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance2<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// SuperType</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2019-09-21-03-12-19-05a308af2c534a0d56dae7c10f32d8cb-41127.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 68.76267748478702%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAIAAACgpqunAAAACXBIWXMAAAsSAAALEgHS3X78AAABnElEQVQoz5VS7XLcIAy893+8pkkvl1wuYLANBgzG5kMGXNx20rq9H+nOiBHMrFitdCqlSKWMMZExP46BsyBE0DpQEu0EUnpKo3PbtpV/cKqBcENp2yMkGO8QpgipQSRjUgzZOajJupZ7ONWSXc8455aQqLVnzIkhahMphdmCkr6l0fvtHk4pJUJbTMgg5cdrrfpL5125Hz8DQM9Y1/fjqLf/xCnnXBt+fHgihDJKrVKpbePbW8DII+QxrvodfjfWr2mXcSDXgADDVRhpLMby5SKen9X1NRBSDXct3fWtkH628NfPNVJJY6PlyzhJQzFqz+fuclmtrcNbfYhdG5Xar6RxQhzJPwrOw6KQXthg32/D06NTu3k5xpJzqWcdVUoF9uTodk5mmgYujJoKlBCCkDICfNawpmm+nc+UEjP7CLmUnHL+FHk3DMAwM3WTNQvtWd2wum3JuWSnFEKyds+9T5OBeb7Ts7qp/is3pDXXV/nwZW5wDiEOQyUDZ6D1GjxwHq09kOsIcslhCW700YZJKnS7zcvye9GO+HPDvgPlaiiAYy8MvwAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2019 09 21 03 12 19"\n        title=""\n        src="/static/2019-09-21-03-12-19-05a308af2c534a0d56dae7c10f32d8cb-fee1c.png"\n        srcset="/static/2019-09-21-03-12-19-05a308af2c534a0d56dae7c10f32d8cb-a67b7.png 200w,\n/static/2019-09-21-03-12-19-05a308af2c534a0d56dae7c10f32d8cb-0b187.png 400w,\n/static/2019-09-21-03-12-19-05a308af2c534a0d56dae7c10f32d8cb-fee1c.png 800w,\n/static/2019-09-21-03-12-19-05a308af2c534a0d56dae7c10f32d8cb-41127.png 986w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p><strong>注意</strong>：更改 <code class="language-text">SuperType</code> <strong>引用类型属性</strong>时，会使 <code class="language-text">SubType</code> 所有实例共享这一更新。基础类型属性更新则不会。</p>\n<ul>\n<li><strong>创建子类实例时，无法向父类构造函数传参</strong>，或者说是，没办法在不影响所有对象实例的情况下，向超类的构造函数传递参数</li>\n</ul>\n</li>\n</ul>\n<h2 id="构造继承"><a href="#%E6%9E%84%E9%80%A0%E7%BB%A7%E6%89%BF" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>构造继承</h2>\n<p><strong>基本思想</strong>：在子类型的构造函数内部调用父类型构造函数。</p>\n<p><strong>注意</strong>：函数只不过是在特定环境中执行代码的对象，所以这里使用 apply/call 来实现。</p>\n<p><strong>使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型）</strong></p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="16204558560796990000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// 父类\nfunction SuperType(name) {\n  this.name = name; // 父类属性\n}\nSuperType.prototype.sayName = function() {\n  // 父类原型方法\n  return this.name;\n};\n\n// 子类\nfunction SubType() {\n  // 调用 SuperType 构造函数\n  SuperType.call(this, \'SuperType\'); // 在子类构造函数中，向父类构造函数传参\n  // 为了保证子父类的构造函数不会重写子类的属性，需要在调用父类构造函数后，定义子类的属性\n  this.subName = \'SubType\'; // 子类属性\n}\n// 子类实例\nlet instance = new SubType(); // 运行子类构造函数，并在子类构造函数中运行父类构造函数，this绑定到子类`, `16204558560796990000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">// 父类</span>\n<span class="token keyword">function</span> <span class="token function">SuperType</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span> <span class="token comment">// 父类属性</span>\n<span class="token punctuation">}</span>\n<span class="token class-name">SuperType</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 父类原型方法</span>\n  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n<span class="token comment">// 子类</span>\n<span class="token keyword">function</span> <span class="token function">SubType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 调用 SuperType 构造函数</span>\n  <span class="token function">SuperType</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token string">\'SuperType\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 在子类构造函数中，向父类构造函数传参</span>\n  <span class="token comment">// 为了保证子父类的构造函数不会重写子类的属性，需要在调用父类构造函数后，定义子类的属性</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>subName <span class="token operator">=</span> <span class="token string">\'SubType\'</span><span class="token punctuation">;</span> <span class="token comment">// 子类属性</span>\n<span class="token punctuation">}</span>\n<span class="token comment">// 子类实例</span>\n<span class="token keyword">let</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 运行子类构造函数，并在子类构造函数中运行父类构造函数，this绑定到子类</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2019-09-21-03-12-49-aaefd94e92f026e95abae5b59cecb4d2-b855b.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 47.767857142857146%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAAsSAAALEgHS3X78AAABOUlEQVQoz4WSDW+DIBCG/f//bGuWtFs/tYoVFG0ryFcREB3N1mxJu+7N5UJeeMLd5SJUVqAouo6N0+S8H0M4N1ob8jSG5Ky1/mZ6awc/hpdfinCF402Ca4xzUCNkMJZJ3COoi8JoXZYlREgr2UOos1QiRIX1NzryzsOXst4eGcj5+4LPXjnIrjfjzw/fujMiY0yHGEmpYr0RwgthpbTuqlDt9FRR6FIxpc+6b7VmmjJ1gBiADEKolPoHVhdFWspOnDQdJTTZ74vQrTHXIf3SYzgvyiQFzemEm+bcEi6kMfau2T/glnbzxXL2Ngd5UUCE6waVeLFc5wc4DINzw7Oy6+a43SW7JP1YbVKQhwiHfQZW2ziswDZOlusNofQxzIVgjIclqXDNuTDWEkJbQtTlEgYupUIVDv5D+BNVbjykTj2skQAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2019 09 21 03 12 49"\n        title=""\n        src="/static/2019-09-21-03-12-49-aaefd94e92f026e95abae5b59cecb4d2-fee1c.png"\n        srcset="/static/2019-09-21-03-12-49-aaefd94e92f026e95abae5b59cecb4d2-a67b7.png 200w,\n/static/2019-09-21-03-12-49-aaefd94e92f026e95abae5b59cecb4d2-0b187.png 400w,\n/static/2019-09-21-03-12-49-aaefd94e92f026e95abae5b59cecb4d2-fee1c.png 800w,\n/static/2019-09-21-03-12-49-aaefd94e92f026e95abae5b59cecb4d2-b855b.png 896w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<ul>\n<li><strong>优点</strong>：<strong>解决了 1 中子类实例共享父类引用对象的问题，实现多继承，创建子类实例时，可以向父类传递参数</strong></li>\n<li>\n<p><strong>缺点</strong>：</p>\n<ul>\n<li>实例并不是父类的实例，只是子类的实例</li>\n<li><strong>只能</strong>继承父类的实例属性和方法，<strong>不能</strong>继承原型属性/方法</li>\n<li><strong>无法实现函数复用</strong>，每个子类都有父类实例函数的副本，影响性能</li>\n</ul>\n</li>\n</ul>\n<h2 id="组合继承"><a href="#%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>组合继承</h2>\n<p>顾名思义，组合继承就是将原型链继承与构造函数继承组合在一起，从而发挥两者之长的一种继承模式。</p>\n<p><strong>基本思想</strong>：使用<strong>原型链</strong>继承使用对原型属性和方法的继承，通过<strong>构造函数</strong>继承来实现对实例属性的继承。这样既能通过在原型上定义方法实现函数复用，又能保证每个实例都有自己的属性。</p>\n<p><strong>通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用</strong></p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="80157281430741200000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// 父类\nfunction SuperType(name) {\n  this.colors = [\'red\', \'blue\', \'green\'];\n  this.name = name; // 父类属性\n}\nSuperType.prototype.sayName = function() {\n  // 父类原型方法\n  return this.name;\n};\n\n// 子类\nfunction SubType(name, subName) {\n  // 调用 SuperType 构造函数\n  SuperType.call(this, name); // ----第二次调用 SuperType----\n  this.subName = subName;\n}\n\n// ----第一次调用 SuperType----\nSubType.prototype = new SuperType(); // 重写原型对象，代之以一个新类型的实例\n\nSubType.prototype.constructor = SubType; // 组合继承需要修复构造函数指向，不修复的话会指向SuperType\nSubType.prototype.saySubName = function() {\n  // 子类原型方法\n  return this.subName;\n};\n\n// 子类实例\nlet instance = new SubType(\'An\', \'sisterAn\');\ninstance.colors.push(\'black\');\nconsole.log(instance.colors); // [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;black&quot;]\ninstance.sayName(); // An\ninstance.saySubName(); // sisterAn\n\nlet instance1 = new SubType(\'An1\', \'sisterAn1\');\nconsole.log(instance1.colors); //  [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]\ninstance1.sayName(); // An1\ninstance1.saySubName(); // sisterAn1`, `80157281430741200000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">// 父类</span>\n<span class="token keyword">function</span> <span class="token function">SuperType</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>colors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">\'red\'</span><span class="token punctuation">,</span> <span class="token string">\'blue\'</span><span class="token punctuation">,</span> <span class="token string">\'green\'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span> <span class="token comment">// 父类属性</span>\n<span class="token punctuation">}</span>\n<span class="token class-name">SuperType</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 父类原型方法</span>\n  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n<span class="token comment">// 子类</span>\n<span class="token keyword">function</span> <span class="token function">SubType</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> subName</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 调用 SuperType 构造函数</span>\n  <span class="token function">SuperType</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ----第二次调用 SuperType----</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>subName <span class="token operator">=</span> subName<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// ----第一次调用 SuperType----</span>\n<span class="token class-name">SubType</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SuperType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 重写原型对象，代之以一个新类型的实例</span>\n\n<span class="token class-name">SubType</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> SubType<span class="token punctuation">;</span> <span class="token comment">// 组合继承需要修复构造函数指向，不修复的话会指向SuperType</span>\n<span class="token class-name">SubType</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">saySubName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 子类原型方法</span>\n  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>subName<span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n<span class="token comment">// 子类实例</span>\n<span class="token keyword">let</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubType</span><span class="token punctuation">(</span><span class="token string">\'An\'</span><span class="token punctuation">,</span> <span class="token string">\'sisterAn\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\ninstance<span class="token punctuation">.</span>colors<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">\'black\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance<span class="token punctuation">.</span>colors<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ["red", "blue", "green", "black"]</span>\ninstance<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// An</span>\ninstance<span class="token punctuation">.</span><span class="token function">saySubName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// sisterAn</span>\n\n<span class="token keyword">let</span> instance1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubType</span><span class="token punctuation">(</span><span class="token string">\'An1\'</span><span class="token punctuation">,</span> <span class="token string">\'sisterAn1\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance1<span class="token punctuation">.</span>colors<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//  ["red", "blue", "green"]</span>\ninstance1<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// An1</span>\ninstance1<span class="token punctuation">.</span><span class="token function">saySubName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// sisterAn1</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2019-09-21-03-25-03-ece5d09e2ee8087f8f723614aa00244b-94c27.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 616px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 67.20779220779221%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAAsSAAALEgHS3X78AAACIUlEQVQ4y42TyW7bQBBE9dFODkEOMRLAzhclyNl2YlteJe+WZC3Uwp0j7iLnpSkaFoX4EALF5hDdPdU1NS2NxjVc7IGJbS5Y2g6RaRHOZoS2TTydklsWStb+ZMIqTSmXIaskIS80SL3WEivI06pekZ3iPLikgSKaz4kch/999NZC1w3jlxHewQ3Luz7m1RXzwyP8TodIkD49EpydkQ1fIAzRwlAncR2zDLIqptsM094Q80cb8+AK67yL0+3i3XTwrq8JH+6xLs5Jnh7A99BLVUclcbkUqBrNhomvsE+esY+fCUYGpRSQ57BabSDrNaNKs9dRt6BrLdcNUQHerwOCn39YHh4zO2mzGAxwDANzPCYLAtk1QVfMqo1eD+HtMPRGyVYuCSqKUGFEWQiZosQXrXJJKiWhbAi/zWbDqolWLAL3HnsYwwmO6+CJVZTAE7t4pokSlvnEQIlmC3FAJrqt5H+FMEwpSt7Yvo2sZgnmjU0wX5BYNqnjrn1WFAVFIkUyRfmebu/aRuaMX8a47T7RYMzi8gLr9JRsaoAw0mLqQlhqx4bAl91VjTgWXePaSoLNKYuHkk4X93KEezvA7Y9w7h+x7m6xOteo3jNGu00ot4RBX2yzbDRM5FaENZoNs+kceyRjD31mpo+f1SMWDazTF/PtEf+5NtXIskv27SvxzmfyT7vYOx9wP36A/X3Y25Mo+C7fu1/Qv4/qwsoOTcs0rPMXY6ngqMroMT4AAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2019 09 21 03 25 03"\n        title=""\n        src="/static/2019-09-21-03-25-03-ece5d09e2ee8087f8f723614aa00244b-94c27.png"\n        srcset="/static/2019-09-21-03-25-03-ece5d09e2ee8087f8f723614aa00244b-64932.png 200w,\n/static/2019-09-21-03-25-03-ece5d09e2ee8087f8f723614aa00244b-2fd6e.png 400w,\n/static/2019-09-21-03-25-03-ece5d09e2ee8087f8f723614aa00244b-94c27.png 616w"\n        sizes="(max-width: 616px) 100vw, 616px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>第一次调用 <code class="language-text">SuperType</code> 构造函数时，<code class="language-text">SubType.prototype</code> 会得到两个属性<code class="language-text">name</code>和<code class="language-text">colors</code>；当调用 <code class="language-text">SubType</code> 构造函数时，第二次调用 <code class="language-text">SuperType</code> 构造函数，这一次又在新对象属性上创建了 <code class="language-text">name</code>和<code class="language-text">colors</code>，这两个属性就会屏蔽原型对象上的同名属性。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="42936321558742204000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// instanceof：instance 的原型链是针对 SuperType.prototype 进行检查的\ninstance instanceof SuperType; // true\ninstance instanceof SubType; // true\n\n// isPrototypeOf：instance 的原型链是针对 SuperType 本身进行检查的\nSuperType.prototype.isPrototypeOf(instance); // true\nSubType.prototype.isPrototypeOf(instance); // true`, `42936321558742204000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">// instanceof：instance 的原型链是针对 SuperType.prototype 进行检查的</span>\ninstance <span class="token keyword">instanceof</span> <span class="token class-name">SuperType</span><span class="token punctuation">;</span> <span class="token comment">// true</span>\ninstance <span class="token keyword">instanceof</span> <span class="token class-name">SubType</span><span class="token punctuation">;</span> <span class="token comment">// true</span>\n\n<span class="token comment">// isPrototypeOf：instance 的原型链是针对 SuperType 本身进行检查的</span>\n<span class="token class-name">SuperType</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">isPrototypeOf</span><span class="token punctuation">(</span>instance<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>\n<span class="token class-name">SubType</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">isPrototypeOf</span><span class="token punctuation">(</span>instance<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2019-09-21-03-35-46-893a961d45f9af88f9053d69b2f2c0f7-9d536.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 543px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 29.65009208103131%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAAsSAAALEgHS3X78AAAAxElEQVQY042R627DIAyF+/5vuanJ1CZgwNxikpwZWu3XlM2SxZGRP47NLcaMaV6xrAZCBWVi1GeCsYTHc4FzHj3O8/xX3mIquM92NO4skCWjUYUPAZYcfotroDq8Ty9g5oxIEclHBOYBTCkhZ3Veip4Z+75fA5k70Izm7soFD3IOzBHeBx3d6h0NbXUNddsuXSow4ePzAWNoQI15AbrjVXXfLWl9NWY88ufIKVXMX/oRdUNrDZs6EJG3lpEi7ad2HMdlfgMXxNNkPHqbvwAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2019 09 21 03 35 46"\n        title=""\n        src="/static/2019-09-21-03-35-46-893a961d45f9af88f9053d69b2f2c0f7-9d536.png"\n        srcset="/static/2019-09-21-03-35-46-893a961d45f9af88f9053d69b2f2c0f7-cdad1.png 200w,\n/static/2019-09-21-03-35-46-893a961d45f9af88f9053d69b2f2c0f7-5653c.png 400w,\n/static/2019-09-21-03-35-46-893a961d45f9af88f9053d69b2f2c0f7-9d536.png 543w"\n        sizes="(max-width: 543px) 100vw, 543px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<ul>\n<li><strong>优点</strong>：<strong>弥补了方式 2 的缺陷，可以继承实例属性/方法，也可以继承原型属性/方法，不存在引用属性共享问题，可传参，可复用</strong></li>\n<li>\n<p><strong>缺点</strong>：</p>\n<ul>\n<li>调用了两次父类构造函数，生成了<strong>两份实例</strong>（子类实例将子类原型上的那份屏蔽了）</li>\n</ul>\n</li>\n</ul>\n<h2 id="寄生组合继承"><a href="#%E5%AF%84%E7%94%9F%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>寄生组合继承</h2>\n<p>在组合继承中，调用了两次父类构造函数，这里 <strong>通过通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性，避免的组合继承的缺点</strong></p>\n<p><strong>主要思想</strong>：借用 <strong>构造函数</strong> 继承 <strong>属性</strong> ，通过 <strong>原型链的混成形式</strong> 来继承 <strong>方法</strong></p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="86090822968578130000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// 父类\nfunction SuperType(name) {\n  this.colors = [\'red\', \'blue\', \'green\'];\n  this.name = name; // 父类属性\n}\nSuperType.prototype.sayName = function() {\n  // 父类原型方法\n  return this.name;\n};\n\n// 子类\nfunction SubType(name, subName) {\n  // 调用 SuperType 构造函数\n  SuperType.call(this, name); // ----第二次调用 SuperType，继承实例属性----\n  this.subName = subName;\n}\n\n// ----第一次调用 SuperType，继承原型属性----\nSubType.prototype = Object.create(SuperType.prototype);\n\nSubType.prototype.constructor = SubType; // 注意：增强对象\n\nlet instance = new SubType(\'An\', \'sisterAn\');`, `86090822968578130000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">// 父类</span>\n<span class="token keyword">function</span> <span class="token function">SuperType</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>colors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">\'red\'</span><span class="token punctuation">,</span> <span class="token string">\'blue\'</span><span class="token punctuation">,</span> <span class="token string">\'green\'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span> <span class="token comment">// 父类属性</span>\n<span class="token punctuation">}</span>\n<span class="token class-name">SuperType</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 父类原型方法</span>\n  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n<span class="token comment">// 子类</span>\n<span class="token keyword">function</span> <span class="token function">SubType</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> subName</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 调用 SuperType 构造函数</span>\n  <span class="token function">SuperType</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ----第二次调用 SuperType，继承实例属性----</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>subName <span class="token operator">=</span> subName<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// ----第一次调用 SuperType，继承原型属性----</span>\n<span class="token class-name">SubType</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token class-name">SuperType</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token class-name">SubType</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> SubType<span class="token punctuation">;</span> <span class="token comment">// 注意：增强对象</span>\n\n<span class="token keyword">let</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubType</span><span class="token punctuation">(</span><span class="token string">\'An\'</span><span class="token punctuation">,</span> <span class="token string">\'sisterAn\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2019-09-21-03-42-49-aec6a13e2423869db22b2aea5bc5e57c-4c6f5.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 607px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 31.960461285008236%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAAsSAAALEgHS3X78AAAA5UlEQVQY032QbW+EIBCE7///un7sl9b0TEB8Q09BBeQp6LVJe71uMkyWbGZn57IsC1JV9IPGe38iBDbncIlzH33ApT7PBufZ15WQ4FwgxvgDF+cd8kNSFRVNXdM3DaNS6LJEC8GQeLteGceRtm1x1hISe62xa+CsyFdd8jOLmfpFMdcNSxKxQkK4D6etB57Ug8P8aSaDfh+4iRtNWVG8FchKovXAbAxNdp0c/iVw7vslmHPqi47+tcMal/ILR14midl04pHd3XH8x+33yXvcmdoJowxmtAihqOvTVdd1bNv2xN0jPgFTndNHZSY6/wAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2019 09 21 03 42 49"\n        title=""\n        src="/static/2019-09-21-03-42-49-aec6a13e2423869db22b2aea5bc5e57c-4c6f5.png"\n        srcset="/static/2019-09-21-03-42-49-aec6a13e2423869db22b2aea5bc5e57c-3bd24.png 200w,\n/static/2019-09-21-03-42-49-aec6a13e2423869db22b2aea5bc5e57c-52f0c.png 400w,\n/static/2019-09-21-03-42-49-aec6a13e2423869db22b2aea5bc5e57c-4c6f5.png 607w"\n        sizes="(max-width: 607px) 100vw, 607px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p><strong>优点</strong>：</p>\n<ul>\n<li>只调用一次 <code class="language-text">SuperType</code> 构造函数，只创建一份父类属性</li>\n<li>原型链保持不变</li>\n<li>能够正常使用 <code class="language-text">instanceof</code> 与 <code class="language-text">isPrototypeOf</code></li>\n</ul>\n<h2 id="原型式继承"><a href="#%E5%8E%9F%E5%9E%8B%E5%BC%8F%E7%BB%A7%E6%89%BF" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>原型式继承</h2>\n<p><strong>实现思路就是将子类的原型设置为父类的原型</strong></p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="69669864165665960000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// 父类\nfunction SuperType(name) {\n  this.colors = [\'red\', \'blue\', \'green\'];\n  this.name = name; // 父类属性\n}\nSuperType.prototype.sayName = function() {\n  // 父类原型方法\n  return this.name;\n};\n\n/** 第一步 */\n// 子类，通过 call 继承父类的实例属性和方法，不能继承原型属性/方法\nfunction SubType(name, subName) {\n  SuperType.call(this, name); // 调用 SuperType 的构造函数，并向其传参\n  this.subName = subName;\n}\n\n/** 第二步 */\n// 解决 call 无法继承父类原型属性/方法的问题\n// Object.create 方法接受传入一个作为新创建对象的原型的对象，创建一个拥有指定原型和若干个指定属性的对象\n// 通过这种方法指定的任何属性都会覆盖原型对象上的同名属性\nSubType.prototype = Object.create(SuperType.prototype, {\n  constructor: {\n    // 注意指定 SubType.prototype.constructor = SubType\n    value: SubType,\n    enumerable: false,\n    writable: true,\n    configurable: true\n  },\n  run: {\n    value: function() {\n      // override\n      SuperType.prototype.run.apply(this, arguments);\n      // call super\n      // ...\n    },\n    enumerable: true,\n    configurable: true,\n    writable: true\n  }\n});\n\n/** 第三步 */\n// 最后：解决 SubType.prototype.constructor === SuperType 的问题\n// 这里，在上一步已经指定，这里不需要再操作\n// SubType.prototype.constructor = SubType;\n\nvar instance = new SubType(\'An\', \'sistenAn\');`, `69669864165665960000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">// 父类</span>\n<span class="token keyword">function</span> <span class="token function">SuperType</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>colors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">\'red\'</span><span class="token punctuation">,</span> <span class="token string">\'blue\'</span><span class="token punctuation">,</span> <span class="token string">\'green\'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span> <span class="token comment">// 父类属性</span>\n<span class="token punctuation">}</span>\n<span class="token class-name">SuperType</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 父类原型方法</span>\n  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n<span class="token comment">/** 第一步 */</span>\n<span class="token comment">// 子类，通过 call 继承父类的实例属性和方法，不能继承原型属性/方法</span>\n<span class="token keyword">function</span> <span class="token function">SubType</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> subName</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token function">SuperType</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 调用 SuperType 的构造函数，并向其传参</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>subName <span class="token operator">=</span> subName<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">/** 第二步 */</span>\n<span class="token comment">// 解决 call 无法继承父类原型属性/方法的问题</span>\n<span class="token comment">// Object.create 方法接受传入一个作为新创建对象的原型的对象，创建一个拥有指定原型和若干个指定属性的对象</span>\n<span class="token comment">// 通过这种方法指定的任何属性都会覆盖原型对象上的同名属性</span>\n<span class="token class-name">SubType</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token class-name">SuperType</span><span class="token punctuation">.</span>prototype<span class="token punctuation">,</span> <span class="token punctuation">{</span>\n  constructor<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 注意指定 SubType.prototype.constructor = SubType</span>\n    value<span class="token punctuation">:</span> SubType<span class="token punctuation">,</span>\n    enumerable<span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>\n    writable<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>\n    configurable<span class="token punctuation">:</span> <span class="token boolean">true</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  run<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n    <span class="token function-variable function">value</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token comment">// override</span>\n      <span class="token class-name">SuperType</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token comment">// call super</span>\n      <span class="token comment">// ...</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n    enumerable<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>\n    configurable<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>\n    writable<span class="token punctuation">:</span> <span class="token boolean">true</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token comment">/** 第三步 */</span>\n<span class="token comment">// 最后：解决 SubType.prototype.constructor === SuperType 的问题</span>\n<span class="token comment">// 这里，在上一步已经指定，这里不需要再操作</span>\n<span class="token comment">// SubType.prototype.constructor = SubType;</span>\n\n<span class="token keyword">var</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubType</span><span class="token punctuation">(</span><span class="token string">\'An\'</span><span class="token punctuation">,</span> <span class="token string">\'sistenAn\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2019-09-21-03-57-16-01f2f7a428b20c128919080569d83c63-68fa4.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 641px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 32.137285491419654%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAAsSAAALEgHS3X78AAAA2ElEQVQY042Q6W7DIBCE/f4vWPVfLPXAjg+uxZgCk8FpoiiKqq40WnYFH7Pbee9x6nuM5zMkBAQROGMQ2Bdq1waZfd16zMU5/CwLtpBQKxiV+Tgc0RUUrJ8a47vCrBTCPCMQ7ocBwofx6xuRME9Y2neUbUPhpynl10CWkEkwvU3Y6EbTrSXsf1HxwPoFshNsgBs87Cow2mKmM6012jramAvrnPMVUeuDnut6BaaUsJ5WmN4cu4kxwnFXwtFuKqXcgX9F1y42WWXhPhxdeig1Hg5vug/45OaVLtdO1DxmdhEFAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2019 09 21 03 57 16"\n        title=""\n        src="/static/2019-09-21-03-57-16-01f2f7a428b20c128919080569d83c63-68fa4.png"\n        srcset="/static/2019-09-21-03-57-16-01f2f7a428b20c128919080569d83c63-ea38f.png 200w,\n/static/2019-09-21-03-57-16-01f2f7a428b20c128919080569d83c63-bb505.png 400w,\n/static/2019-09-21-03-57-16-01f2f7a428b20c128919080569d83c63-68fa4.png 641w"\n        sizes="(max-width: 641px) 100vw, 641px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>如果希望能 <strong>多继承</strong> ，可使用 <strong>混入</strong> 的方式</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="85067391492735430000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// 父类 SuperType\nfunction SuperType() {}\n// 父类 OtherSuperType\nfunction OtherSuperType() {}\n\n// 多继承子类\nfunction AnotherType() {\n  SuperType.call(this); // 继承 SuperType 的实例属性和方法\n  OtherSuperType.call(this); // 继承 OtherSuperType 的实例属性和方法\n}\n\n// 继承一个类\nAnotherType.prototype = Object.create(SuperType.prototype);\n\n// 使用 Object.assign 混合其它\nObject.assign(AnotherType.prototype, OtherSuperType.prototype);\n// Object.assign 会把  OtherSuperType 原型上的函数拷贝到 AnotherType 原型上，使 AnotherType 的所有实例都可用 OtherSuperType 的方法\n\n// 重新指定 constructor\nAnotherType.prototype.constructor = AnotherType;\n\nAnotherType.prototype.myMethod = function() {\n  // do a thing\n};\n\nlet instance = new AnotherType();`, `85067391492735430000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">// 父类 SuperType</span>\n<span class="token keyword">function</span> <span class="token function">SuperType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n<span class="token comment">// 父类 OtherSuperType</span>\n<span class="token keyword">function</span> <span class="token function">OtherSuperType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n\n<span class="token comment">// 多继承子类</span>\n<span class="token keyword">function</span> <span class="token function">AnotherType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token function">SuperType</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 继承 SuperType 的实例属性和方法</span>\n  <span class="token function">OtherSuperType</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 继承 OtherSuperType 的实例属性和方法</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// 继承一个类</span>\n<span class="token class-name">AnotherType</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token class-name">SuperType</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token comment">// 使用 Object.assign 混合其它</span>\nObject<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token class-name">AnotherType</span><span class="token punctuation">.</span>prototype<span class="token punctuation">,</span> <span class="token class-name">OtherSuperType</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token comment">// Object.assign 会把  OtherSuperType 原型上的函数拷贝到 AnotherType 原型上，使 AnotherType 的所有实例都可用 OtherSuperType 的方法</span>\n\n<span class="token comment">// 重新指定 constructor</span>\n<span class="token class-name">AnotherType</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> AnotherType<span class="token punctuation">;</span>\n\n<span class="token class-name">AnotherType</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">myMethod</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// do a thing</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n<span class="token keyword">let</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AnotherType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p><strong>最重要的部分是</strong>：</p>\n<ul>\n<li><code class="language-text">SuperType.call</code> 继承实例属性方法</li>\n<li>用 <code class="language-text">Object.create()</code> 来继承原型属性与方法</li>\n<li>修改 <code class="language-text">SubType.prototype.constructor</code>的指向</li>\n</ul>\n<h1 id="es6-继承"><a href="#es6-%E7%BB%A7%E6%89%BF" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>ES6 继承</h1>\n<p>首先，实现一个简单的 ES6 继承：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="70307642366743675000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`class People {\n  constructor(name) {\n    this.name = name;\n  }\n  run() {}\n}\n\n// extends 相当于方法的继承\n// 替换了上面的3行代码\nclass Man extends People {\n  constructor(name) {\n    // super 相当于属性的继承\n    // 替换了 People.call(this, name)\n    super(name);\n    this.gender = \'男\';\n  }\n  fight() {}\n}`, `70307642366743675000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">People</span> <span class="token punctuation">{</span>\n  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// extends 相当于方法的继承</span>\n<span class="token comment">// 替换了上面的3行代码</span>\n<span class="token keyword">class</span> <span class="token class-name">Man</span> <span class="token keyword">extends</span> <span class="token class-name">People</span> <span class="token punctuation">{</span>\n  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// super 相当于属性的继承</span>\n    <span class="token comment">// 替换了 People.call(this, name)</span>\n    <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>gender <span class="token operator">=</span> <span class="token string">\'男\'</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token function">fight</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h2 id="核心代码"><a href="#%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>核心代码</h2>\n<p><code class="language-text">extends</code> 继承的核心代码如下，其实现和上述的寄生组合式继承方式一样</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="80637538772691600000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function _inherits(subType, superType) {\n    // 创建对象，Object.create 创建父类原型的一个副本\n    // 增强对象，弥补因重写原型而失去的默认的 constructor 属性\n    // 指定对象，将新创建的对象赋值给子类的原型 subType.prototype\n    subType.prototype = Object.create(superType && superType.prototype, {\n        constructor: { // 重写 constructor\n            value: subType,\n            enumerable: false,\n            writable: true,\n            configurable: true\n        }\n    });\n    if (superType) {\n        Object.setPrototypeOf\n            ? Object.setPrototypeOf(subType, superType)\n            : subType.__proto__ = superType;\n    }\n}`, `80637538772691600000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                Js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span> <span class="token function">_inherits</span><span class="token punctuation">(</span><span class="token parameter">subType<span class="token punctuation">,</span> superType</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 创建对象，Object.create 创建父类原型的一个副本</span>\n    <span class="token comment">// 增强对象，弥补因重写原型而失去的默认的 constructor 属性</span>\n    <span class="token comment">// 指定对象，将新创建的对象赋值给子类的原型 subType.prototype</span>\n    subType<span class="token punctuation">.</span>prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>superType <span class="token operator">&amp;&amp;</span> superType<span class="token punctuation">.</span>prototype<span class="token punctuation">,</span> <span class="token punctuation">{</span>\n        constructor<span class="token punctuation">:</span> <span class="token punctuation">{</span> <span class="token comment">// 重写 constructor</span>\n            value<span class="token punctuation">:</span> subType<span class="token punctuation">,</span>\n            enumerable<span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>\n            writable<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>\n            configurable<span class="token punctuation">:</span> <span class="token boolean">true</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>superType<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        Object<span class="token punctuation">.</span>setPrototypeOf\n            <span class="token operator">?</span> Object<span class="token punctuation">.</span><span class="token function">setPrototypeOf</span><span class="token punctuation">(</span>subType<span class="token punctuation">,</span> superType<span class="token punctuation">)</span>\n            <span class="token punctuation">:</span> subType<span class="token punctuation">.</span>__proto__ <span class="token operator">=</span> superType<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h1 id="继承的使用场景"><a href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>继承的使用场景</h1>\n<ul>\n<li>不要仅仅为了使用而使用它们，这只是在浪费时间而已。</li>\n<li>当需要创建 <strong>一系列拥有相似特性的对象</strong> 时，那么创建一个包含所有共有功能的通用对象，然后在更特殊的对象类型中继承这些特性。</li>\n<li>应避免多继承，造成混乱。</li>\n</ul>\n<p><strong>注:</strong> 考虑到 JavaScript 的工作方式，由于原型链等特性的存在，在不同对象之间功能的共享通常被叫做 <strong>委托</strong> - 特殊的对象将功能委托给通用的对象类型完成。这也许比将其称之为继承更为贴切，因为“被继承”了的功能并没有被拷贝到正在“进行继承”的对象中，相反它仍存在于通用的对象中。</p>\n<h2 id="扩展：new"><a href="#%E6%89%A9%E5%B1%95%EF%BC%9Anew" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>扩展：new</h2>\n<p><strong>new 关键字</strong>创建的对象<strong>实际上是对新对象 this 的不断赋值，并将 prototype 指向类的 prototype 所指向的对象</strong>。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="39003996177210690000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`var SuperType = function(name) {\n  var nose = \'nose\'; // 私有属性\n  function say() {} // 私有方法\n\n  // 特权方法\n  this.getName = function() {};\n  this.setName = function() {};\n\n  this.mouse = \'mouse\'; // 对象公有属性\n  this.listen = function() {}; // 对象公有方法\n\n  // 构造器\n  this.setName(name);\n};\n\nSuperType.age = 10; // 类静态公有属性（对象不能访问）\nSuperType.read = function() {}; // 类静态公有方法（对象无法访问）\n\nSuperType.prototype = {\n  // 对象赋值（也可以一一赋值）\n  isMan: \'true\', // 公有属性\n  write: function() {} // 公有方法\n};\n\nvar instance = new SuperType();`, `39003996177210690000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">var</span> <span class="token function-variable function">SuperType</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">var</span> nose <span class="token operator">=</span> <span class="token string">\'nose\'</span><span class="token punctuation">;</span> <span class="token comment">// 私有属性</span>\n  <span class="token keyword">function</span> <span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// 私有方法</span>\n\n  <span class="token comment">// 特权方法</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">getName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">setName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n  <span class="token keyword">this</span><span class="token punctuation">.</span>mouse <span class="token operator">=</span> <span class="token string">\'mouse\'</span><span class="token punctuation">;</span> <span class="token comment">// 对象公有属性</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">listen</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 对象公有方法</span>\n\n  <span class="token comment">// 构造器</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n\nSuperType<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment">// 类静态公有属性（对象不能访问）</span>\nSuperType<span class="token punctuation">.</span><span class="token function-variable function">read</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 类静态公有方法（对象无法访问）</span>\n\n<span class="token class-name">SuperType</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 对象赋值（也可以一一赋值）</span>\n  isMan<span class="token punctuation">:</span> <span class="token string">\'true\'</span><span class="token punctuation">,</span> <span class="token comment">// 公有属性</span>\n  <span class="token function-variable function">write</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// 公有方法</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n<span class="token keyword">var</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SuperType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/2019-09-21-04-20-04-6eb5875c171f52d6633fd7e6b8e3bea1-51685.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 550px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 32.72727272727273%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAAsSAAALEgHS3X78AAAA3klEQVQoz52RyW7DMAxE/f8f10PRWwvUSGLDVl0tXiRZojWdKEHvDgGCAEm8GYnNre/RXi9YtxUp7di2Dfu+I+cM731NyYIQAiL7B6twRziPMdbdPWWIFJRS0IzDiPajRf/Voxt+0FFgnucKmqap5h1mtIZjX7RBGgbEe89a7jq4JSAJGATGNUK9jTCthelGpGXBa/F0GEgf3xXMxcDdBniq1nEpJ/PpMKUES3f6U8MvKzKf9a95GkogS3Vnvy3cr8OsFBI/vDwkT0cjwguuvKDlxXyGpUNF6CHHSw7/AIQhIzLPVvPsAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px #fafafa;"\n        alt="2019 09 21 04 20 04"\n        title=""\n        src="/static/2019-09-21-04-20-04-6eb5875c171f52d6633fd7e6b8e3bea1-51685.png"\n        srcset="/static/2019-09-21-04-20-04-6eb5875c171f52d6633fd7e6b8e3bea1-b4476.png 200w,\n/static/2019-09-21-04-20-04-6eb5875c171f52d6633fd7e6b8e3bea1-1367e.png 400w,\n/static/2019-09-21-04-20-04-6eb5875c171f52d6633fd7e6b8e3bea1-51685.png 550w"\n        sizes="(max-width: 550px) 100vw, 550px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>所以类的构造函数内定义的 <strong>私有变量或方法</strong> ，以及类定义的 <strong>静态公有属性及方法</strong> ，在 <strong>new</strong> 的实例对象中都将 <strong>无法访问</strong> 。</p>\n<h3 id="扩展：继承机制的设计思想··"><a href="#%E6%89%A9%E5%B1%95%EF%BC%9A%E7%BB%A7%E6%89%BF%E6%9C%BA%E5%88%B6%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%C2%B7%C2%B7" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>扩展：继承机制的设计思想··</h3>\n<p>关于继承机制的设计思想，请参见 <a href="http://www.ruanyifeng.com/blog/2011/06/designing_ideas_of_inheritance_mechanism_in_javascript.html" target="_blank" rel="nofollow noreferrer noopener">Javascript 继承机制的设计思想</a> 。</p>',
id:"/github/workspace/blog/JS基础之继承/index.md absPath of file >>> MarkdownRemark",timeToRead:8,frontmatter:{date:"2019-09-21 02:26:30",path:"/js-basic-of-extend/",tags:"前端, JS, 继承",title:"JS基础之继承",draft:null}},{excerpt:"引言 本篇从 React Refs 的使用场景、使用方式、注意事项，到   与 Hook   的对比使用，最后以 React   源码结束，剖析整个 React Refs，关于   会在下一篇文章深入探讨。 Refs React 的 核心思想 是每次对于界面 state 的改动，都会重新渲染整个 Virtual DOM，然后新老的两个 Virtual DOM 树进行 diff（ 协调算法 ），对比出变化的地方，然后通过 render 渲染到实际的 UI 界面， 使用 Refs…",html:'<h1 id="引言"><a href="#%E5%BC%95%E8%A8%80" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>引言</h1>\n<p>本篇从 React Refs 的使用场景、使用方式、注意事项，到 <code class="language-text">createRef</code> 与 Hook <code class="language-text">useRef</code> 的对比使用，最后以 React <code class="language-text">createRef</code> 源码结束，剖析整个 React Refs，关于 <code class="language-text">React.forwardRef</code> 会在下一篇文章深入探讨。</p>\n<h1 id="refs"><a href="#refs" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Refs</h1>\n<p>React 的<strong>核心思想</strong>是每次对于界面 state 的改动，都会重新渲染整个 Virtual DOM，然后新老的两个 Virtual DOM 树进行 diff（<strong>协调算法</strong>），对比出变化的地方，然后通过 render 渲染到实际的 UI 界面，</p>\n<p>使用 Refs 为我们提供了一种绕过状态更新和重新渲染时访问元素的方法；这在某些用例中很有用，但不应该作为 <code class="language-text">props</code> 和 <code class="language-text">state</code> 的替代方法。</p>\n<p>在项目开发中，如果我们可以使用 声明式 或 提升 state 所在的组件层级（状态提升） 的方法来更新组件，最好不要使用 refs。</p>\n<h2 id="使用场景"><a href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>使用场景</h2>\n<ul>\n<li>\n<p><strong>管理焦点（如文本选择）或处理表单数据：</strong> Refs 将管理文本框当前焦点选中，或文本框其它属性。</p>\n<p>在大多数情况下，我们推荐使用受控组件来处理表单数据。在一个受控组件中，表单数据是由 React 组件来管理的，每个状态更新都编写数据处理函数。另一种替代方案是使用非受控组件，这时表单数据将交由 DOM 节点来处理。要编写一个非受控组件，就需要使用 Refs 来从 DOM 节点中获取表单数据。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="37580577684124350000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`class NameForm extends React.Component {\nconstructor(props) {\n  super(props);\n  this.input = React.createRef();\n}\n\nhandleSubmit = (e) => {\n  console.log(\'A name was submitted: \' + this.input.current.value);\n  e.preventDefault();\n};\n\nrender() {\n  return (\n    <form onSubmit={this.handleSubmit}>\n      <label>\n        Name:\n        <input type=\'text\' ref={this.input} />\n      </label>\n      <input type=\'submit\' value=\'Submit\' />\n    </form>\n  );\n}\n}`, `37580577684124350000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">NameForm</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>\n<span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>input <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">createRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token function-variable function">handleSubmit</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'A name was submitted: \'</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>input<span class="token punctuation">.</span>current<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  e<span class="token punctuation">.</span><span class="token function">preventDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n<span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token punctuation">(</span>\n    <span class="token operator">&lt;</span>form onSubmit<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>handleSubmit<span class="token punctuation">}</span><span class="token operator">></span>\n      <span class="token operator">&lt;</span>label<span class="token operator">></span>\n        Name<span class="token punctuation">:</span>\n        <span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">\'text\'</span> ref<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>input<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span>\n      <span class="token operator">&lt;</span><span class="token operator">/</span>label<span class="token operator">></span>\n      <span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">\'submit\'</span> value<span class="token operator">=</span><span class="token string">\'Submit\'</span> <span class="token operator">/</span><span class="token operator">></span>\n    <span class="token operator">&lt;</span><span class="token operator">/</span>form<span class="token operator">></span>\n  <span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>因为非受控组件将真实数据储存在 DOM 节点中，所以在使用非受控组件时，有时候反而更容易同时集成 React 和非 React 代码。如果你不介意代码美观性，并且希望快速编写代码，使用非受控组件往往可以减少你的代码量。否则，你应该使用受控组件。</p>\n</li>\n<li>\n<p><strong>媒体播放：</strong>基于 React 的音乐或视频播放器可以利用 Refs 来管理其当前状态（播放/暂停），或管理播放进度等。这些更新不需要进行状态管理。</p>\n</li>\n<li>\n<p><strong>触发强制动画：</strong>如果要在元素上触发过强制动画时，可以使用 Refs 来执行此操作。</p>\n</li>\n<li>\n<p><strong>集成第三方 DOM 库</strong></p>\n</li>\n</ul>\n<h2 id="使用方式"><a href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>使用方式</h2>\n<p>Refs 有 三种实现：</p>\n<h3 id="方法一：通过-createref-实现"><a href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E9%80%9A%E8%BF%87-createref-%E5%AE%9E%E7%8E%B0" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>方法一：通过 createRef 实现</h3>\n<p><code class="language-text">createRef</code> 是 <strong>React v16.3</strong> 新增的 API，允许我们访问 DOM 节点或在 render 方法中创建的 React 元素。</p>\n<p>Refs 是使用 <code class="language-text">React.createRef()</code> 创建的，并通过 <code class="language-text">ref</code> 属性附加到 React 元素。</p>\n<p>Refs 通常在 React 组件的构造函数中定义，或者作为函数组件顶层的变量定义，然后附加到 <code class="language-text">render()</code> 函数中的元素。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="94380447436540530000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`export default class Hello extends React.Component {\n  constructor(props) {\n    super(props);\n    // 创建 ref 存储 textRef DOM 元素\n    this.textRef = React.createRef();\n  }\n  componentDidMount() {\n    // 注意：通过 &quot;current&quot; 取得 DOM 节点\n    // 直接使用原生 API 使 text 输入框获得焦点\n    this.textRef.current.focus();\n  }\n  render() {\n    // 把 <input> ref 关联到构造器里创建的 textRef 上\n    return <input ref={this.textRef} />;\n  }\n}`, `94380447436540530000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">class</span> <span class="token class-name">Hello</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>\n  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token comment">// 创建 ref 存储 textRef DOM 元素</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>textRef <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">createRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 注意：通过 "current" 取得 DOM 节点</span>\n    <span class="token comment">// 直接使用原生 API 使 text 输入框获得焦点</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>textRef<span class="token punctuation">.</span>current<span class="token punctuation">.</span><span class="token function">focus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 把 &lt;input> ref 关联到构造器里创建的 textRef 上</span>\n    <span class="token keyword">return</span> <span class="token operator">&lt;</span>input ref<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>textRef<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>使用 <code class="language-text">React.createRef()</code> 给组件创建了 Refs 对象。在上面的示例中，ref 被命名 <code class="language-text">textRef</code>，然后将其附加到 <code class="language-text">&lt;input&gt;</code> DOM 元素。</p>\n<p>其中， <code class="language-text">textRef</code> 的属性 <code class="language-text">current</code> 指的是当前附加到 ref 的元素，并广泛用于访问和修改我们的附加元素。事实上，如果我们通过登录 <code class="language-text">myRef</code> 控制台进一步扩展我们的示例，我们将看到该 <code class="language-text">current</code> 属性确实是<em>唯一</em>可用的属性：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="30951788481816035000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`componentDidMount = () => {\n  // myRef 仅仅有一个 current 属性\n  console.log(this.textRef);\n  // myRef.current\n  console.log(this.textRef.current);\n  // component 渲染完成后，使 text 输入框获得焦点\n  this.textRef.current.focus();\n};`, `30951788481816035000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token function-variable function">componentDidMount</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  <span class="token comment">// myRef 仅仅有一个 current 属性</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>textRef<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token comment">// myRef.current</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>textRef<span class="token punctuation">.</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token comment">// component 渲染完成后，使 text 输入框获得焦点</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>textRef<span class="token punctuation">.</span>current<span class="token punctuation">.</span><span class="token function">focus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>在 <code class="language-text">componentDidMount</code> 生命周期阶段，<code class="language-text">myRef.current</code> 将按预期分配给我们的 <code class="language-text">&lt;input&gt;</code> 元素; <code class="language-text">componentDidMount</code> 通常是使用 refs 处理一些初始设置的安全位置。</p>\n<p>我们不能在 <code class="language-text">componentWillMount</code> 中更新 Refs，因为此时，组件还没渲染完成， Refs 还为 <code class="language-text">null</code>。</p>\n<h3 id="方法二：回调-refs"><a href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E5%9B%9E%E8%B0%83-refs" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>方法二：回调 Refs</h3>\n<p>不同于传递 <code class="language-text">createRef()</code> 创建的 <code class="language-text">ref</code> 属性，你会传递一个函数。这个函数中接受 React 组件实例或 HTML DOM 元素作为参数，以使它们能在其他地方被存储和访问。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="94819647361664090000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`import React from \'react\';\nexport default class Hello extends React.Component {\n  constructor(props) {\n    super(props);\n    this.textRef = null; // 创建 ref 为 null\n  }\n  componentDidMount() {\n    // 注意：这里没有使用 &quot;current&quot;\n    // 直接使用原生 API 使 text 输入框获得焦点\n    this.textRef.focus();\n  }\n  render() {\n    // 把 <input> ref 关联到构造器里创建的 textRef 上\n    return <input ref={(node) => (this.textRef = node)} />;\n  }\n}`, `94819647361664090000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">import</span> React <span class="token keyword">from</span> <span class="token string">\'react\'</span><span class="token punctuation">;</span>\n<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">class</span> <span class="token class-name">Hello</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>\n  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>textRef <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 创建 ref 为 null</span>\n  <span class="token punctuation">}</span>\n  <span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 注意：这里没有使用 "current"</span>\n    <span class="token comment">// 直接使用原生 API 使 text 输入框获得焦点</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>textRef<span class="token punctuation">.</span><span class="token function">focus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 把 &lt;input> ref 关联到构造器里创建的 textRef 上</span>\n    <span class="token keyword">return</span> <span class="token operator">&lt;</span>input ref<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token parameter">node</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>textRef <span class="token operator">=</span> node<span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>React 将在组件挂载时将 DOM 元素传入<code class="language-text">ref</code> 回调函数并调用，当卸载时传入 <code class="language-text">null</code> 并调用它。在 <code class="language-text">componentDidMount</code> 或 <code class="language-text">componentDidUpdate</code> 触发前，React 会保证 refs 一定是最新的。</p>\n<p>像上例， <code class="language-text">ref</code> 回调函数是以内联函数的方式定义的，在更新过程中它会被执行两次，第一次传入参数 <code class="language-text">null</code>，然后第二次会传入参数 DOM 元素。</p>\n<p>这是因为在每次渲染时会创建一个新的函数实例，所以 React 清空旧的 ref 并且设置新的。我们可以通过将 ref 的回调函数定义成 class 的绑定函数的方式可以避免上述问题，但是大多数情况下它是无关紧要的。</p>\n<h3 id="方法三：通过-stringref-实现"><a href="#%E6%96%B9%E6%B3%95%E4%B8%89%EF%BC%9A%E9%80%9A%E8%BF%87-stringref-%E5%AE%9E%E7%8E%B0" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>方法三：通过 stringRef 实现</h3>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="5978375114897072000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`export default class Hello extends React.Component {\n  constructor(props) {\n    super(props);\n  }\n  componentDidMount() {\n    // 通过 this.refs 调用\n    // 直接使用原生 API 使 text 输入框获得焦点\n    this.refs.textRef.focus();\n  }\n  render() {\n    // 把 <input> ref 关联到构造器里创建的 textRef 上\n    return <input ref=\'textRef\' />;\n  }\n}`, `5978375114897072000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">class</span> <span class="token class-name">Hello</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>\n  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 通过 this.refs 调用</span>\n    <span class="token comment">// 直接使用原生 API 使 text 输入框获得焦点</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>refs<span class="token punctuation">.</span>textRef<span class="token punctuation">.</span><span class="token function">focus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 把 &lt;input> ref 关联到构造器里创建的 textRef 上</span>\n    <span class="token keyword">return</span> <span class="token operator">&lt;</span>input ref<span class="token operator">=</span><span class="token string">\'textRef\'</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>尽管字符串 stringRef 使用更方便，但是它有<a href="https://github.com/facebook/react/issues/1373" target="_blank" rel="nofollow noreferrer noopener">一些缺点</a>，因此严格模式使用 stringRef 会报警告。官方推荐采用回调 Refs。</p>\n<h2 id="注意"><a href="#%E6%B3%A8%E6%84%8F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>注意</h2>\n<ul>\n<li>当 <code class="language-text">ref</code> 属性被用于一个普通的 HTML 元素时，<code class="language-text">React.createRef()</code> 将接收底层 DOM 元素作为它的 <code class="language-text">current</code> 属性以创建 <code class="language-text">ref</code> ，我们可以通过 Refs 访问 DOM 元素属性。</li>\n<li>当 <code class="language-text">ref</code> 属性被用于一个自定义 class 组件时，<code class="language-text">ref</code> 对象将接收该组件已挂载的实例作为它的 <code class="language-text">current</code>，与 <code class="language-text">ref</code> 用于 HTML 元素不同的是，我们能够通过 <code class="language-text">ref</code> 访问该组件的 props，state，方法以及它的整个原型 。</li>\n<li>ref 是为了获取某个节点是实例，所以 <strong>你不能在函数式组件上使用 ref 属性</strong>，因为它们没有实例。</li>\n<li>推荐使用 <strong>回调形式的 refs</strong>， <code class="language-text">stringRef</code> 将会废弃（严格模式下使用会报警告），<code class="language-text">React.createRef()</code> API 是 React v16.3 引入的更新。</li>\n<li>避免使用 refs 来做任何可以通过 <strong>声明式</strong> 实现来完成的事情</li>\n</ul>\n<h1 id="createref-与-hook-useref"><a href="#createref-%E4%B8%8E-hook-useref" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>createRef 与 Hook useRef</h1>\n<h2 id="useref"><a href="#useref" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>useRef</h2>\n<p><code class="language-text">useRef</code> 返回一个可变的 ref 对象，其 <code class="language-text">.current</code> 属性被初始化为传入的值。返回的 ref 对象在组件的整个生命周期内保持不变。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="44625149094152380000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function Hello() {\n  const textRef = useRef(null);\n  const onButtonClick = () => {\n    // 注意：通过 &quot;current&quot; 取得 DOM 节点\n    textRef.current.focus();\n  };\n  return (\n    <>\n      <input ref={textRef} type=\'text\' />\n      <button onClick={onButtonClick}>Focus the input</button>\n    </>\n  );\n}`, `44625149094152380000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> textRef <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">const</span> <span class="token function-variable function">onButtonClick</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n    <span class="token comment">// 注意：通过 "current" 取得 DOM 节点</span>\n    textRef<span class="token punctuation">.</span>current<span class="token punctuation">.</span><span class="token function">focus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">;</span>\n  <span class="token keyword">return</span> <span class="token punctuation">(</span>\n    <span class="token operator">&lt;</span><span class="token operator">></span>\n      <span class="token operator">&lt;</span>input ref<span class="token operator">=</span><span class="token punctuation">{</span>textRef<span class="token punctuation">}</span> type<span class="token operator">=</span><span class="token string">\'text\'</span> <span class="token operator">/</span><span class="token operator">></span>\n      <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span>onButtonClick<span class="token punctuation">}</span><span class="token operator">></span>Focus the input<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span>\n    <span class="token operator">&lt;</span><span class="token operator">/</span><span class="token operator">></span>\n  <span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h2 id="区别"><a href="#%E5%8C%BA%E5%88%AB" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>区别</h2>\n<p><code class="language-text">useRef()</code> 比 <code class="language-text">ref</code> 属性更有用。<code class="language-text">useRef()</code> Hook 不仅可以用于 DOM refs， <code class="language-text">useRef()</code> 创建的 <code class="language-text">ref</code> 对象是一个 <code class="language-text">current</code> 属性可变且可以容纳任意值的通用容器，类似于一个 class 的实例属性。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="42575800173571630000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function Timer() {\n  const intervalRef = useRef();\n\n  useEffect(() => {\n    const id = setInterval(() => {\n      // ...\n    });\n    intervalRef.current = id;\n    return () => {\n      clearInterval(intervalRef.current);\n    };\n  });\n\n  // ...\n}`, `42575800173571630000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Timer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> intervalRef <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n    <span class="token keyword">const</span> id <span class="token operator">=</span> <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n      <span class="token comment">// ...</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    intervalRef<span class="token punctuation">.</span>current <span class="token operator">=</span> id<span class="token punctuation">;</span>\n    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n      <span class="token function">clearInterval</span><span class="token punctuation">(</span>intervalRef<span class="token punctuation">.</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token comment">// ...</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>这是因为它创建的是一个普通 Javascript 对象。而 <code class="language-text">useRef()</code> 和自建一个 <code class="language-text">{current: ...}</code>对象的唯一区别是，<code class="language-text">useRef</code> 会在每次渲染时返回同一个 ref 对象。</p>\n<p>请记住，当 ref 对象内容发生变化时，<code class="language-text">useRef</code> 并<em>不会</em>通知你。变更 <code class="language-text">.current</code> 属性不会引发组件重新渲染。如果想要在 React 绑定或解绑 DOM 节点的 ref 时运行某些代码，则需要使用回调 ref 来实现。</p>\n<h1 id="createref-源码解析"><a href="#createref-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>createRef 源码解析</h1>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="43285518552798990000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// ReactCreateRef.js 文件\nimport type { RefObject } from \'shared/ReactTypes\';\n\n// an immutable object with a single mutable value\nexport function createRef(): RefObject {\n  const refObject = {\n    current: null\n  };\n  if (__DEV__) {\n    // 封闭对象，阻止添加新属性并将所有现有属性标记为不可配置。当前属性的值只要可写就可以改变。\n    Object.seal(refObject);\n  }\n  return refObject;\n}`, `43285518552798990000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">// ReactCreateRef.js 文件</span>\n<span class="token keyword">import</span> type <span class="token punctuation">{</span> RefObject <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">\'shared/ReactTypes\'</span><span class="token punctuation">;</span>\n\n<span class="token comment">// an immutable object with a single mutable value</span>\n<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">createRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> RefObject <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> refObject <span class="token operator">=</span> <span class="token punctuation">{</span>\n    current<span class="token punctuation">:</span> <span class="token keyword">null</span>\n  <span class="token punctuation">}</span><span class="token punctuation">;</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>__DEV__<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 封闭对象，阻止添加新属性并将所有现有属性标记为不可配置。当前属性的值只要可写就可以改变。</span>\n    Object<span class="token punctuation">.</span><span class="token function">seal</span><span class="token punctuation">(</span>refObject<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token keyword">return</span> refObject<span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>其中 <code class="language-text">RefObject</code> 为：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="27149364426876387000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`export type RefObject = {\n  current: any\n};`, `27149364426876387000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">export</span> type RefObject <span class="token operator">=</span> <span class="token punctuation">{</span>\n  current<span class="token punctuation">:</span> any\n<span class="token punctuation">}</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span></span></pre></div>\n<p>这就是的 createRef 源码，实现很简单，但具体的它如何使用，如何挂载，将在后面的 React 渲染中介绍，敬请期待。</p>',
id:"/github/workspace/blog/React之createRef入门学习/index.md absPath of file >>> MarkdownRemark",timeToRead:5,frontmatter:{date:"2019-09-20 14:56:20",path:"/react-createRef-practice-learn/",tags:"前端, React, createRef",title:"React之createRef入门学习",draft:null}},{excerpt:"forwardRef 在   中已经介绍过，有三种方式可以使用 React 元素的 ref ref 是为了获取某个节点的实例，但是 函数式组件（PureComponent） 是没有实例的，不存在 this 的，这种时候是拿不到函数式组件的 ref 的。 为了解决这个问题，由此引入  ，   允许某些组件接收 ref，并将其向下传递给 子组件 只在使用   定义组件时， 第二个参数 ref…",html:'<h1 id="forwardref"><a href="#forwardref" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>forwardRef</h1>\n<p>在 <code class="language-text">React.createRef</code> 中已经介绍过，有三种方式可以使用 React 元素的 ref</p>\n<p>ref 是为了获取某个节点的实例，但是 函数式组件（PureComponent） 是没有实例的，不存在 this 的，这种时候是拿不到函数式组件的 ref 的。</p>\n<p>为了解决这个问题，由此引入 <code class="language-text">React.forwardRef</code>， <strong><code class="language-text">React.forwardRef</code> 允许某些组件接收 ref，并将其向下传递给 子组件</strong></p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="44912476439511015000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`const ForwardInput = React.forwardRef((props, ref) => (\n  <input ref={ref} />\n));\n\nclass TestComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.inputRef = React.createRef(); // 创建 ref 存储 textRef DOM 元素\n  }\n  componentDidMount() {\n    this.inputRef.current.value = \'forwardRef\'\n  }\n  render() {\n    return ( // 可以直接获取到 ForwardInput input 的 ref：\n      <ForwardInput ref={this.inputRef}>\n    )\n  }\n}`, `44912476439511015000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">const</span> ForwardInput <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">forwardRef</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">props<span class="token punctuation">,</span> ref</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span>\n  <span class="token operator">&lt;</span>input ref<span class="token operator">=</span><span class="token punctuation">{</span>ref<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span>\n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token keyword">class</span> <span class="token class-name">TestComponent</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>\n  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>inputRef <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">createRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 创建 ref 存储 textRef DOM 元素</span>\n  <span class="token punctuation">}</span>\n  <span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>inputRef<span class="token punctuation">.</span>current<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token string">\'forwardRef\'</span>\n  <span class="token punctuation">}</span>\n  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token punctuation">(</span> <span class="token comment">// 可以直接获取到 ForwardInput input 的 ref：</span>\n      <span class="token operator">&lt;</span>ForwardInput ref<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>inputRef<span class="token punctuation">}</span><span class="token operator">></span>\n    <span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<ul>\n<li>\n<p>只在使用 <code class="language-text">React.forwardRef</code> 定义组件时，<strong>第二个参数 ref</strong> 才存在</p>\n</li>\n<li>\n<p>在项目中组件库中尽量不要使用 <code class="language-text">React.forwardRef</code> ，因为它可能会导致子组件被 <strong>破坏性更改</strong></p>\n</li>\n<li>\n<p><strong>函数组件 和 class 组件均不接收 <code class="language-text">ref</code> 参数</strong> ，即 props 中不存在 <code class="language-text">ref</code>，<strong>ref 必须独立 props</strong> 出来，否则会被 React 特殊处理掉。</p>\n</li>\n<li>\n<p><strong>通常在 高阶组件（HOC） 中使用 <code class="language-text">React.forwardRef</code></strong></p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="97589624386226000000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function enhance(WrappedComponent) {\nclass Enhance extends React.Component {\n  componentWillReceiveProps(nextProps) {\n    console.log(\'Current props: \', this.props);\n    console.log(\'Next props: \', nextProps);\n  }\n  render() {\n    const { forwardedRef, ...others } = this.props;\n    // 将自定义的 prop 属性 “forwardedRef” 定义为 ref\n    return <WrappedComponent ref={forwardedRef} {...others} />;\n  }\n}\n// 注意 React.forwardRef 回调的第二个参数 “ref”。\n// 我们可以将其作为常规 prop 属性传递给 Enhance，例如 “forwardedRef”\n// 然后它就可以被挂载到被 Enhance 包裹的子组件上。\nreturn React.forwardRef((props, ref) => {\n  return <Enhance {...props} forwardedRef={ref} />;\n});\n}\n\n// 子组件\nclass MyComponent extends React.Component {\nfocus() {\n  // ...\n}\n// ...\n}\n\n// EnhancedComponent 会渲染一个高阶组件 enhance(MyComponent)\nconst EnhancedComponent = enhance(MyComponent);\n\nconst ref = React.createRef();\n\n// 我们导入的 EnhancedComponent 组件是高阶组件（HOC）Enhance。\n// 通过React.forwardRef 将 ref 将指向了 Enhance 内部的 MyComponent 组件\n// 这意味着我们可以直接调用 ref.current.focus() 方法\n<EnhancedComponent label=\'Click Me\' handleClick={handleClick} ref={ref} />;`, `97589624386226000000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span> <span class="token function">enhance</span><span class="token punctuation">(</span><span class="token parameter">WrappedComponent</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n<span class="token keyword">class</span> <span class="token class-name">Enhance</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>\n  <span class="token function">componentWillReceiveProps</span><span class="token punctuation">(</span><span class="token parameter">nextProps</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'Current props: \'</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'Next props: \'</span><span class="token punctuation">,</span> nextProps<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">const</span> <span class="token punctuation">{</span> forwardedRef<span class="token punctuation">,</span> <span class="token operator">...</span>others <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">;</span>\n    <span class="token comment">// 将自定义的 prop 属性 “forwardedRef” 定义为 ref</span>\n    <span class="token keyword">return</span> <span class="token operator">&lt;</span>WrappedComponent ref<span class="token operator">=</span><span class="token punctuation">{</span>forwardedRef<span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token operator">...</span>others<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n<span class="token comment">// 注意 React.forwardRef 回调的第二个参数 “ref”。</span>\n<span class="token comment">// 我们可以将其作为常规 prop 属性传递给 Enhance，例如 “forwardedRef”</span>\n<span class="token comment">// 然后它就可以被挂载到被 Enhance 包裹的子组件上。</span>\n<span class="token keyword">return</span> React<span class="token punctuation">.</span><span class="token function">forwardRef</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">props<span class="token punctuation">,</span> ref</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token operator">&lt;</span>Enhance <span class="token punctuation">{</span><span class="token operator">...</span>props<span class="token punctuation">}</span> forwardedRef<span class="token operator">=</span><span class="token punctuation">{</span>ref<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// 子组件</span>\n<span class="token keyword">class</span> <span class="token class-name">MyComponent</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>\n<span class="token function">focus</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// ...</span>\n<span class="token punctuation">}</span>\n<span class="token comment">// ...</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// EnhancedComponent 会渲染一个高阶组件 enhance(MyComponent)</span>\n<span class="token keyword">const</span> EnhancedComponent <span class="token operator">=</span> <span class="token function">enhance</span><span class="token punctuation">(</span>MyComponent<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token keyword">const</span> ref <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">createRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token comment">// 我们导入的 EnhancedComponent 组件是高阶组件（HOC）Enhance。</span>\n<span class="token comment">// 通过React.forwardRef 将 ref 将指向了 Enhance 内部的 MyComponent 组件</span>\n<span class="token comment">// 这意味着我们可以直接调用 ref.current.focus() 方法</span>\n<span class="token operator">&lt;</span>EnhancedComponent label<span class="token operator">=</span><span class="token string">\'Click Me\'</span> handleClick<span class="token operator">=</span><span class="token punctuation">{</span>handleClick<span class="token punctuation">}</span> ref<span class="token operator">=</span><span class="token punctuation">{</span>ref<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n</li>\n</ul>\n<h1 id="forwardref-与-hook-useimperativehandle"><a href="#forwardref-%E4%B8%8E-hook-useimperativehandle" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>forwardRef 与 Hook useImperativeHandle</h1>\n<p><code class="language-text">useImperativeHandle</code> 可以让你在使用 <code class="language-text">ref</code> 时自定义暴露给父组件的实例值。在大多数情况下，应当避免使用 ref 这样的命令式代码。<code class="language-text">useImperativeHandle</code> 应当与 <code class="language-text">forwardRef</code>一起使用：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="28951754972798116000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function FancyInput(props, ref) {\n  const inputRef = useRef();\n  useImperativeHandle(ref, () => ({\n    focus: () => {\n      inputRef.current.focus();\n    }\n  }));\n  return <input ref={inputRef} ... />;\n}\nFancyInput = forwardRef(FancyInput);`, `28951754972798116000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span> <span class="token function">FancyInput</span><span class="token punctuation">(</span><span class="token parameter">props<span class="token punctuation">,</span> ref</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> inputRef <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token function">useImperativeHandle</span><span class="token punctuation">(</span>ref<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span>\n    <span class="token function-variable function">focus</span><span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n      inputRef<span class="token punctuation">.</span>current<span class="token punctuation">.</span><span class="token function">focus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">return</span> <span class="token operator">&lt;</span>input ref<span class="token operator">=</span><span class="token punctuation">{</span>inputRef<span class="token punctuation">}</span> <span class="token operator">...</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\nFancyInput <span class="token operator">=</span> <span class="token function">forwardRef</span><span class="token punctuation">(</span>FancyInput<span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>在本例中，渲染 <code class="language-text">&lt;FancyInput ref={fancyInputRef} /&gt;</code> 的父组件可以调用 <code class="language-text">fancyInputRef.current.focus()</code>。</p>\n<h1 id="源码解读"><a href="#%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>源码解读</h1>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="75695866928988980000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`export default function forwardRef<Props, ElementType: React\\$ElementType>(\n  render: (props: Props, ref: React\\$Ref<ElementType>) => React\\$Node\n) {\n  if (__DEV__) {\n    if (render != null && render.\\$\\$typeof === REACT_MEMO_TYPE) {\n      warningWithoutStack(\n        false,\n        \'forwardRef requires a render function but received a \\`memo\\` \' +\n          \'component. Instead of forwardRef(memo(...)), use \' +\n          \'memo(forwardRef(...)).\'\n      );\n    } else if (typeof render !== \'function\') {\n      warningWithoutStack(\n        false,\n        \'forwardRef requires a render function but was given %s.\',\n        render === null ? \'null\' : typeof render\n      );\n    } else {\n      warningWithoutStack(\n        // Do not warn for 0 arguments because it could be due to usage of the \'arguments\' object\n        render.length === 0 || render.length === 2,\n        \'forwardRef render functions accept exactly two parameters: props and ref. %s\',\n        render.length === 1 ? \'Did you forget to use the ref parameter?\' : \'Any additional parameter will be undefined.\'\n      );\n    }\n\n    if (render != null) {\n      warningWithoutStack(\n        render.defaultProps == null && render.propTypes == null,\n        \'forwardRef render functions do not support propTypes or defaultProps. \' +\n          \'Did you accidentally pass a React component?\'\n      );\n    }\n  }\n\n  /**\n   * REACT_FORWARD_REF_TYPE 并不是 React.forwardRef 创建的实例的 \\$\\$typeof\n   * React.forwardRef 返回的是一个对象，而 ref 是通过实例的参数形式传递进去的，\n   * 实际上，React.forwardRef 返回的是一个 ReactElement，它的 \\$\\$typeof 也就是 REACT_ELEMENT_TYPE\n   * 而 返回的对象 是作为 ReactElement 的 type 存在\n   */\n  return {\n    // 返回一个对象\n    \\$\\$typeof: REACT_FORWARD_REF_TYPE, // 并不是 React.forwardRef 创建的实例的 \\$\\$typeof\n    render // 函数组件\n  };\n}`, `75695866928988980000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> forwardRef<span class="token operator">&lt;</span>Props<span class="token punctuation">,</span> ElementType<span class="token punctuation">:</span> React$ElementType<span class="token operator">></span><span class="token punctuation">(</span>\n  <span class="token function-variable function">render</span><span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token parameter">props<span class="token punctuation">:</span> Props<span class="token punctuation">,</span> ref<span class="token punctuation">:</span> React$Ref<span class="token operator">&lt;</span>ElementType<span class="token operator">></span></span><span class="token punctuation">)</span> <span class="token operator">=></span> React$Node\n<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>__DEV__<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>render <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> render<span class="token punctuation">.</span>$$<span class="token keyword">typeof</span> <span class="token operator">===</span> <span class="token constant">REACT_MEMO_TYPE</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token function">warningWithoutStack</span><span class="token punctuation">(</span>\n        <span class="token boolean">false</span><span class="token punctuation">,</span>\n        <span class="token string">\'forwardRef requires a render function but received a `memo` \'</span> <span class="token operator">+</span>\n          <span class="token string">\'component. Instead of forwardRef(memo(...)), use \'</span> <span class="token operator">+</span>\n          <span class="token string">\'memo(forwardRef(...)).\'</span>\n      <span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> render <span class="token operator">!==</span> <span class="token string">\'function\'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token function">warningWithoutStack</span><span class="token punctuation">(</span>\n        <span class="token boolean">false</span><span class="token punctuation">,</span>\n        <span class="token string">\'forwardRef requires a render function but was given %s.\'</span><span class="token punctuation">,</span>\n        render <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">?</span> <span class="token string">\'null\'</span> <span class="token punctuation">:</span> <span class="token keyword">typeof</span> render\n      <span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n      <span class="token function">warningWithoutStack</span><span class="token punctuation">(</span>\n        <span class="token comment">// Do not warn for 0 arguments because it could be due to usage of the \'arguments\' object</span>\n        render<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">0</span> <span class="token operator">||</span> render<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">2</span><span class="token punctuation">,</span>\n        <span class="token string">\'forwardRef render functions accept exactly two parameters: props and ref. %s\'</span><span class="token punctuation">,</span>\n        render<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">1</span> <span class="token operator">?</span> <span class="token string">\'Did you forget to use the ref parameter?\'</span> <span class="token punctuation">:</span> <span class="token string">\'Any additional parameter will be undefined.\'</span>\n      <span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>render <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token function">warningWithoutStack</span><span class="token punctuation">(</span>\n        render<span class="token punctuation">.</span>defaultProps <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> render<span class="token punctuation">.</span>propTypes <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">,</span>\n        <span class="token string">\'forwardRef render functions do not support propTypes or defaultProps. \'</span> <span class="token operator">+</span>\n          <span class="token string">\'Did you accidentally pass a React component?\'</span>\n      <span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token comment">/**\n   * REACT_FORWARD_REF_TYPE 并不是 React.forwardRef 创建的实例的 $$typeof\n   * React.forwardRef 返回的是一个对象，而 ref 是通过实例的参数形式传递进去的，\n   * 实际上，React.forwardRef 返回的是一个 ReactElement，它的 $$typeof 也就是 REACT_ELEMENT_TYPE\n   * 而 返回的对象 是作为 ReactElement 的 type 存在\n   */</span>\n  <span class="token keyword">return</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 返回一个对象</span>\n    $$<span class="token keyword">typeof</span><span class="token punctuation">:</span> <span class="token constant">REACT_FORWARD_REF_TYPE</span><span class="token punctuation">,</span> <span class="token comment">// 并不是 React.forwardRef 创建的实例的 $$typeof</span>\n    render <span class="token comment">// 函数组件</span>\n  <span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>',id:"/github/workspace/blog/React之forwardRef入门学习/index.md absPath of file >>> MarkdownRemark",timeToRead:3,frontmatter:{date:"2019-09-20 14:35:44",path:"/react-forwardRef-practice-learn/",tags:"前端, React, forwardRef",title:"React之forwardRef入门学习",draft:null}},{excerpt:"组件 纯组件  ，和   类似，都是定义一个组件类。不同是   没有实现  ，而   通过   和   的 浅比较 实现了。 在下一节中将会详细介绍。 函数组件 定义 React 组件的 最简单 方式就是定义一个函数组件，它接受单一的 props 并返回一个 React 元素。 在 函数组件 中，它的输入输出全部由 props 决定，且不会产生任何副作用，这说明  函数组件 也是 无状态组件 。 在函数组件中，无法修改 props，无法使用 state…",html:'<h1 id="组件"><a href="#%E7%BB%84%E4%BB%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>组件</h1>\n<h2 id="纯组件"><a href="#%E7%BA%AF%E7%BB%84%E4%BB%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>纯组件</h2>\n<p><code class="language-text">React.PureComponent</code> ，和 <code class="language-text">React.Component</code> 类似，都是定义一个组件类。不同是 <code class="language-text">React.Component</code> 没有实现 <code class="language-text">shouldComponentUpdate()</code>，而 <code class="language-text">React.PureComponent</code> 通过 <code class="language-text">props</code> 和 <code class="language-text">state</code> 的<strong>浅比较</strong>实现了。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="22035142809946472000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// React.PureComponent 纯组件\nclass Counter extends React.PureComponent {\n  constructor(props) {\n    super(props);\n    this.state = { count: 0 };\n  }\n  render() {\n    return (\n      <button onClick={() => this.setState((state) => ({ count: state.count + 1 }))}>Count: {this.state.count}</button>\n    );\n  }\n}`, `22035142809946472000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">// React.PureComponent 纯组件</span>\n<span class="token keyword">class</span> <span class="token class-name">Counter</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>PureComponent</span> <span class="token punctuation">{</span>\n  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span> count<span class="token punctuation">:</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token punctuation">(</span>\n      <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">state</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span> count<span class="token punctuation">:</span> state<span class="token punctuation">.</span>count <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">></span>Count<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>count<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span>\n    <span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>在下一节中将会详细介绍。</p>\n<h2 id="函数组件"><a href="#%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>函数组件</h2>\n<p>定义 React 组件的<strong>最简单</strong>方式就是定义一个函数组件，它接受单一的 props 并返回一个 React 元素。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="5996852947568354000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// 函数组件\nfunction Counter(props) {\n  return <div>Counter: {props.count}</div>;\n}\n// 类组件\nclass Counter extends React.Component {\n  render() {\n    return <div>Counter: {this.props.count}</div>;\n  }\n}`, `5996852947568354000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">// 函数组件</span>\n<span class="token keyword">function</span> <span class="token function">Counter</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token operator">&lt;</span>div<span class="token operator">></span>Counter<span class="token punctuation">:</span> <span class="token punctuation">{</span>props<span class="token punctuation">.</span>count<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token comment">// 类组件</span>\n<span class="token keyword">class</span> <span class="token class-name">Counter</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>\n  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token operator">&lt;</span>div<span class="token operator">></span>Counter<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>count<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<ul>\n<li>在 函数组件 中，它的输入输出全部由 props 决定，且不会产生任何副作用，这说明 <strong>函数组件 也是 无状态组件</strong>。</li>\n<li>在函数组件中，无法修改 props，无法使用 state 及组件的生命周期，说明 <strong>函数组件 也是 展示组件</strong>。</li>\n<li>函数组件 的功能只是接收 props，渲染页面，它不执行与 UI 无关的逻辑处理，它只是一个<strong>纯函数</strong>。</li>\n<li>函数组件，相对于类组件来说，更加简洁。无论是复用性还是性能，都<strong>优于类组件</strong>。</li>\n</ul>\n<h2 id="受控组件与非受控组件"><a href="#%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6%E4%B8%8E%E9%9D%9E%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>受控组件与非受控组件</h2>\n<p><strong>受控和非受控主要是取决于组件是否受父级传入的 props 控制</strong></p>\n<p>用 props 传入数据的话，组件可以被认为是<strong>受控</strong>（因为组件被父级传入的 props 控制）。</p>\n<p>数据只保存在组件内部的 state 的话，是<strong>非受控</strong>组件（因为外部没办法直接控制 state）。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="85575841119979980000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`export default class AnForm extends React.Component {\n  state = {\n    name: \'\'\n  };\n  handleSubmitClick = () => {\n    console.log(\'非受控组件: \', this._name.value);\n    console.log(\'受控组件: \', this.state.name);\n  };\n  handleChange = (e) => {\n    this.setState({\n      name: e.target.value\n    });\n  };\n\n  render() {\n    return (\n      <form onSubmit={this.handleSubmitClick}>\n        <label>\n          非受控组件:\n          <input type=\'text\' defaultValue=\'default\' ref={(input) => (this._name = input)} />\n        </label>\n        <label>\n          受控组件:\n          <input type=\'text\' value={this.state.name} onChange={this.handleChange} />\n        </label>\n        <input type=\'submit\' value=\'Submit\' />\n      </form>\n    );\n  }\n}`, `85575841119979980000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">class</span> <span class="token class-name">AnForm</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>\n  state <span class="token operator">=</span> <span class="token punctuation">{</span>\n    name<span class="token punctuation">:</span> <span class="token string">\'\'</span>\n  <span class="token punctuation">}</span><span class="token punctuation">;</span>\n  <span class="token function-variable function">handleSubmitClick</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'非受控组件: \'</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_name<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'受控组件: \'</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">;</span>\n  <span class="token function-variable function">handleChange</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n      name<span class="token punctuation">:</span> e<span class="token punctuation">.</span>target<span class="token punctuation">.</span>value\n    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token punctuation">(</span>\n      <span class="token operator">&lt;</span>form onSubmit<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>handleSubmitClick<span class="token punctuation">}</span><span class="token operator">></span>\n        <span class="token operator">&lt;</span>label<span class="token operator">></span>\n          非受控组件<span class="token punctuation">:</span>\n          <span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">\'text\'</span> defaultValue<span class="token operator">=</span><span class="token string">\'default\'</span> ref<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token parameter">input</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>_name <span class="token operator">=</span> input<span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span>\n        <span class="token operator">&lt;</span><span class="token operator">/</span>label<span class="token operator">></span>\n        <span class="token operator">&lt;</span>label<span class="token operator">></span>\n          受控组件<span class="token punctuation">:</span>\n          <span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">\'text\'</span> value<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>name<span class="token punctuation">}</span> onChange<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>handleChange<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span>\n        <span class="token operator">&lt;</span><span class="token operator">/</span>label<span class="token operator">></span>\n        <span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">\'submit\'</span> value<span class="token operator">=</span><span class="token string">\'Submit\'</span> <span class="token operator">/</span><span class="token operator">></span>\n      <span class="token operator">&lt;</span><span class="token operator">/</span>form<span class="token operator">></span>\n    <span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h3 id="受控组件"><a href="#%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>受控组件</h3>\n<p>与 html 不同的是，在 React 中，<code class="language-text">&lt;input&gt;</code>或<code class="language-text">&lt;select&gt;</code>、<code class="language-text">&lt;textarea&gt;</code>等这类组件，不会主动维持自身状态，并根据用户输入进行更新。它们都要绑定一个<code class="language-text">onChange</code>事件；每当状态发生变化时，都要写入组件的 state 中，在 React 中被称为<strong>受控组件</strong>。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="95186830658498890000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`export default class AnForm extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { value: \'\' };\n    this.handleChange = this.handleChange.bind(this);\n  }\n  handleChange(event) {\n    this.setState({ value: event.target.value });\n  }\n  render() {\n    return <input type=\'text\' value={this.state.value} onChange={this.handleChange} />;\n  }\n}`, `95186830658498890000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">class</span> <span class="token class-name">AnForm</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>\n  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span> value<span class="token punctuation">:</span> <span class="token string">\'\'</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>handleChange <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">handleChange</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token function">handleChange</span><span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span> value<span class="token punctuation">:</span> event<span class="token punctuation">.</span>target<span class="token punctuation">.</span>value <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">\'text\'</span> value<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>value<span class="token punctuation">}</span> onChange<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>handleChange<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<ul>\n<li>\n<p><strong>onChange &#x26; value 模式</strong>（单选按钮和复选按钮对应的是 checked props）</p>\n</li>\n<li>\n<p>react 通过这种方式<strong>消除了组件的局部状态，</strong>使得应用的整个<strong>状态可控</strong>。</p>\n</li>\n<li>\n<p>注意 <code class="language-text">&lt;input type=&quot;file&quot; /&gt;</code>，它是一个<strong>非受控组件</strong>。</p>\n</li>\n<li>\n<p>可以使用计算属性名将多个相似的操作组合成一个。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="57804292214286600000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`this.setState({\n[name]: value\n});`, `57804292214286600000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n<span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token punctuation">:</span> value\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span></span></pre></div>\n</li>\n</ul>\n<h3 id="非受控组件"><a href="#%E9%9D%9E%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>非受控组件</h3>\n<p>非受控组件不再将数据保存在 state，而使用 refs，将真实数据保存在 DOM 中。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="78631833895699320000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`export default class AnForm extends Component {\n  handleSubmitClick = () => {\n    const name = this._name.value;\n  };\n\n  render() {\n    return (\n      <div>\n        <input type=\'text\' ref={(input) => (this._name = input)} />\n        <button onClick={this.handleSubmitClick}>Sign up</button>\n      </div>\n    );\n  }\n}`, `78631833895699320000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">class</span> <span class="token class-name">AnForm</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>\n  <span class="token function-variable function">handleSubmitClick</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n    <span class="token keyword">const</span> name <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_name<span class="token punctuation">.</span>value<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token punctuation">(</span>\n      <span class="token operator">&lt;</span>div<span class="token operator">></span>\n        <span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">\'text\'</span> ref<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token parameter">input</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>_name <span class="token operator">=</span> input<span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span>\n        <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>handleSubmitClick<span class="token punctuation">}</span><span class="token operator">></span>Sign up<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span>\n      <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>\n    <span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<ul>\n<li>\n<p><strong>非受控组件是最简单快速</strong>的实现方式，项目中出现极简的表单时，使用它，但<strong>受控组件才是是最权威的</strong>。</p>\n</li>\n<li>\n<p>通常指定一个 <strong>defaultValue/defaultChecked</strong> 默认值来控制初始状态，不使用 value。</p>\n</li>\n<li>\n<p>非受控组件相比于受控组件，更容易同时集成 React 和非 React 代码。</p>\n</li>\n<li>\n<p>使用场景</p>\n<p>| 特征 | 非受控组件 | 受控组件 |\n| --- | --- | --- |\n| one-time value retrieval (e.g. on submit) | ✅ | ✅ |\n| <a href="https://goshakkk.name/submit-time-validation-react/" target="_blank" rel="nofollow noreferrer noopener">validating on submit</a> | ✅ | ✅ |\n| <a href="https://goshakkk.name/instant-form-fields-validation-react/" target="_blank" rel="nofollow noreferrer noopener">instant field validation</a> | ❌ | ✅ |\n| <a href="https://goshakkk.name/form-recipe-disable-submit-button-react/" target="_blank" rel="nofollow noreferrer noopener">conditionally disabling submit button</a> | ❌ | ✅ |\n| enforcing input format | ❌ | ✅ |\n| several inputs for one piece of data | ❌ | ✅ |\n| <a href="https://goshakkk.name/array-form-inputs/" target="_blank" rel="nofollow noreferrer noopener">dynamic inputs</a> | ❌ | ✅ |</p>\n</li>\n</ul>\n<h2 id="有状态组件与无状态组件"><a href="#%E6%9C%89%E7%8A%B6%E6%80%81%E7%BB%84%E4%BB%B6%E4%B8%8E%E6%97%A0%E7%8A%B6%E6%80%81%E7%BB%84%E4%BB%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>有状态组件与无状态组件</h2>\n<h3 id="有状态组件"><a href="#%E6%9C%89%E7%8A%B6%E6%80%81%E7%BB%84%E4%BB%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>有状态组件</h3>\n<p>通过 state 管理状态</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="92620840961120780000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`export default class Counter extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { clicks: 0 };\n    this.handleClick = this.handleClick.bind(this);\n  }\n  handleClick() {\n    this.setState((state) => ({ clicks: state.clicks + 1 }));\n  }\n  render() {\n    return <Button onClick={this.handleClick} text={\\`You\'ve clicked me \\${this.state.clicks} times!\\`} />;\n  }\n}`, `92620840961120780000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">class</span> <span class="token class-name">Counter</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>\n  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span> clicks<span class="token punctuation">:</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>handleClick <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">handleClick</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token function">handleClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">state</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span> clicks<span class="token punctuation">:</span> state<span class="token punctuation">.</span>clicks <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token operator">&lt;</span>Button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>handleClick<span class="token punctuation">}</span> text<span class="token operator">=</span><span class="token punctuation">{</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">You\'ve clicked me </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>clicks<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> times!</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h3 id="无状态组件"><a href="#%E6%97%A0%E7%8A%B6%E6%80%81%E7%BB%84%E4%BB%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>无状态组件</h3>\n<p>输入输出数据完全由 props 决定，而且不会产生任何副作用。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="35366258450903820000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`const Button = (props) => <button onClick={props.onClick}>{props.text}</button>;`, `35366258450903820000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">const</span> <span class="token function-variable function">Button</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span>props<span class="token punctuation">.</span>onClick<span class="token punctuation">}</span><span class="token operator">></span><span class="token punctuation">{</span>props<span class="token punctuation">.</span>text<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<ul>\n<li>无状态组件一般会搭配高阶组件（简称：HOC）一起使用，高阶组件用来托管 state，Redux 框架就是通过 store 管理数据源和所有状态，其中所有负责展示的组件都使用无状态函数式的写法。</li>\n<li>一个简单的 无状态(stateless) 按钮组件，仅依赖于 props(属性) ，这也称为<strong>函数式组件</strong>。</li>\n</ul>\n<h2 id="展示组件与容器组件"><a href="#%E5%B1%95%E7%A4%BA%E7%BB%84%E4%BB%B6%E4%B8%8E%E5%AE%B9%E5%99%A8%E7%BB%84%E4%BB%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>展示组件与容器组件</h2>\n<h3 id="展示组件"><a href="#%E5%B1%95%E7%A4%BA%E7%BB%84%E4%BB%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>展示组件</h3>\n<p>展示组件指不关心数据是怎么加载和变动的，只关注于页面展示效果的组件。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="2948148724506438700"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`class TodoList extends React.Component {\n  constructor(props) {\n    super(props);\n  }\n  render() {\n    const { todos } = this.props;\n    return (\n      <div>\n        <ul>\n          {todos.map((item, index) => {\n            return <li key={item.id}>{item.name}</li>;\n          })}\n        </ul>\n      </div>\n    );\n  }\n}`, `2948148724506438700`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">TodoList</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>\n  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">const</span> <span class="token punctuation">{</span> todos <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">;</span>\n    <span class="token keyword">return</span> <span class="token punctuation">(</span>\n      <span class="token operator">&lt;</span>div<span class="token operator">></span>\n        <span class="token operator">&lt;</span>ul<span class="token operator">></span>\n          <span class="token punctuation">{</span>todos<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">item<span class="token punctuation">,</span> index</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n            <span class="token keyword">return</span> <span class="token operator">&lt;</span>li key<span class="token operator">=</span><span class="token punctuation">{</span>item<span class="token punctuation">.</span>id<span class="token punctuation">}</span><span class="token operator">></span><span class="token punctuation">{</span>item<span class="token punctuation">.</span>name<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">></span><span class="token punctuation">;</span>\n          <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span>\n        <span class="token operator">&lt;</span><span class="token operator">/</span>ul<span class="token operator">></span>\n      <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>\n    <span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<ul>\n<li>只能通过 <strong>props</strong> 的方式<strong>接收数据和进行回调</strong>(callback)操作。</li>\n<li><strong>很少拥有自己的状态</strong>，即使有也是用于展示 UI 状态的。</li>\n<li>通常允许通过 <strong>this.props.children</strong> 方式来包含其他组件。</li>\n<li><strong>内部可以包含展示组件和容器组件</strong>，通常会包含一些自己的 DOM 标记和样式(style)</li>\n<li>对应用程序的其他部分没有依赖关系，例如 Flux 操作或 store。</li>\n<li>会被写成函数式组件除非该组件需要自己的状态，生命周期或者做一些性能优化。</li>\n</ul>\n<h3 id="容器组件"><a href="#%E5%AE%B9%E5%99%A8%E7%BB%84%E4%BB%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>容器组件</h3>\n<p>容器组件只关心数据是怎么加载和变动的，而不关注于页面展示效果。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="73951075043797610000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`//容器组件\nclass TodoListContainer extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      todos: []\n    };\n    this.fetchData = this.fetchData.bind(this);\n  }\n  componentDidMount() {\n    this.fetchData();\n  }\n  fetchData() {\n    fetch(\'/api/todos\').then((data) => {\n      this.setState({\n        todos: data\n      });\n    });\n  }\n  render() {\n    return (\n      <div>\n        <TodoList todos={this.state.todos} />\n      </div>\n    );\n  }\n}`, `73951075043797610000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">//容器组件</span>\n<span class="token keyword">class</span> <span class="token class-name">TodoListContainer</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>\n  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span>\n      todos<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>\n    <span class="token punctuation">}</span><span class="token punctuation">;</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>fetchData <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">fetchData</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">fetchData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token function">fetchData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">\'/api/todos\'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n        todos<span class="token punctuation">:</span> data\n      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token punctuation">(</span>\n      <span class="token operator">&lt;</span>div<span class="token operator">></span>\n        <span class="token operator">&lt;</span>TodoList todos<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>todos<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span>\n      <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>\n    <span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<ul>\n<li><strong>内部可以包含容器组件和展示组件</strong>，但通常没有任何自己的 DOM 标记，除了一些包装 divs，并且从不具有任何样式。</li>\n<li>提供数据和行为给其他的展示组件或容器组件。</li>\n<li>可以调用 Flux 操作并将它们作为回调函数（callback）提供给展示组件。</li>\n<li>往往是<strong>有状态</strong>的，因为它们倾向于<strong>作为数据源</strong></li>\n<li>通常使用<strong>高阶组件</strong>生成，例如 React Redux 的 connect()</li>\n</ul>\n<h2 id="高阶组件"><a href="#%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>高阶组件</h2>\n<p><strong>高阶函数</strong>的定义：接收函数作为输入，或者输出另一个函数的一类函数，被称作高阶函数。</p>\n<p>对于<strong>高阶组件</strong>，它描述的便是接受 React 组件作为输入，输出一个新的 React 组件的组件。</p>\n<p>更通俗的描述为，高阶组件通过包裹（wrapped）被传入的 React 组件，经过一系列处理，最终返回一个<strong>相对增强（enhanced）的 React 组件</strong>，供其他组件调用。使我们的代码更具有复用性、逻辑性和抽象特性，它可以对 render 方法做劫持，也<strong>可以控制 props 、state</strong>。</p>\n<p>实现高阶组件的方法有以下两种：</p>\n<ul>\n<li><strong>属性代理（props proxy）</strong>，高阶组件通过被包裹的 React 组件来操作 props。</li>\n<li><strong>反向继承（inheritance inversion）</strong>，高阶组件继承于被包裹的 React 组件。</li>\n</ul>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="82565711590991720000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// 属性代理\nexport default function withHeader(WrappedComponent) {\n  return class HOC extends React.Component { // 继承与 React.component\n    render() {\n      const newProps = {\n        test:\'hoc\'\n      }\n      // 透传props，并且传递新的newProps\n      return <div>\n        <WrappedComponent {...this.props} {...newProps}/>\n      </div>\n    }\n  }\n}\n\n// 反向继承\nexport default function (WrappedComponent) {\n  return class Inheritance extends WrappedComponent { // 继承于被包裹的 React 组件\n    componentDidMount() {\n      // 可以方便地得到state，做一些更深入的修改。\n      console.log(this.state);\n    }\n    render() {\n      return super.render();\n    }\n  }\n}`, `82565711590991720000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">// 属性代理</span>\n<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token function">withHeader</span><span class="token punctuation">(</span><span class="token parameter">WrappedComponent</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token keyword">class</span> <span class="token class-name">HOC</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span> <span class="token comment">// 继承与 React.component</span>\n    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">const</span> newProps <span class="token operator">=</span> <span class="token punctuation">{</span>\n        test<span class="token punctuation">:</span><span class="token string">\'hoc\'</span>\n      <span class="token punctuation">}</span>\n      <span class="token comment">// 透传props，并且传递新的newProps</span>\n      <span class="token keyword">return</span> <span class="token operator">&lt;</span>div<span class="token operator">></span>\n        <span class="token operator">&lt;</span>WrappedComponent <span class="token punctuation">{</span><span class="token operator">...</span>this<span class="token punctuation">.</span>props<span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token operator">...</span>newProps<span class="token punctuation">}</span><span class="token operator">/</span><span class="token operator">></span>\n      <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// 反向继承</span>\n<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">WrappedComponent</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token keyword">class</span> <span class="token class-name">Inheritance</span> <span class="token keyword">extends</span> <span class="token class-name">WrappedComponent</span> <span class="token punctuation">{</span> <span class="token comment">// 继承于被包裹的 React 组件</span>\n    <span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token comment">// 可以方便地得到state，做一些更深入的修改。</span>\n      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<ul>\n<li>注意：不要在 HOC 内修改一个组件的原型（或以其它方式修改组件）</li>\n<li>贯穿传递不相关 props 属性给被包裹的组件，帮助确保高阶组件最大程度的灵活性和可重用性</li>\n<li>应该使用<strong>最大化的组合性</strong></li>\n<li>为了便于调试，可以选择一个显示名字，传达它是一个高阶组件的结果，<code class="language-text">WrappedComponent.displayName || WrappedComponent.name || &#39;Component&#39;;</code></li>\n<li><strong>不要在 render() 方法中创建 HOC</strong>，否则，每一次渲染，都会重新创建渲染 HOC</li>\n<li>必须将原始组件的静态方法在 HOC 中做拷贝，否则 HOC 将没有原始组件的任何静态方法</li>\n<li>Refs 属性不能贯穿传递，我们可以使用 React.forwardRef 解决</li>\n</ul>\n<h2 id="hook-组件"><a href="#hook-%E7%BB%84%E4%BB%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Hook 组件</h2>\n<p>Hook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。</p>\n<p>但与 class 生命周期不同的是，Hook 更接近于实现状态同步，而不是响应生命周期事件。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="23800065761661960000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`import React, { useState, useEffect } from \'react\';\n\nfunction Example() {\n  // 声明一个叫 &quot;count&quot; 的 state 变量\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    // 需要在 componentDidMount 执行的内容\n    return function cleanup() {\n      // 需要在 componentWillUnmount 执行的内容\n    };\n  }, []);\n\n  useEffect(() => {\n    // 在 componentDidMount，以及 count 更改时 componentDidUpdate 执行的内容\n    document.title = \'You clicked \' + count + \' times\';\n    return () => {\n      // 需要在 count 更改时 componentDidUpdate（先于 document.title = ... 执行，遵守先清理后更新）\n      // 以及 componentWillUnmount 执行的内容\n    }; // 当函数中 Cleanup 函数会按照在代码中定义的顺序先后执行，与函数本身的特性无关\n  }, [count]); // 仅在 count 更改时更新\n\n  return (\n    <div>\n      <p>You clicked {count} times</p>\n      <button onClick={() => setCount(count + 1)}>Click me</button>\n    </div>\n  );\n}`, `23800065761661960000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">{</span> useState<span class="token punctuation">,</span> useEffect <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">\'react\'</span><span class="token punctuation">;</span>\n\n<span class="token keyword">function</span> <span class="token function">Example</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 声明一个叫 "count" 的 state 变量</span>\n  <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n    <span class="token comment">// 需要在 componentDidMount 执行的内容</span>\n    <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token function">cleanup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token comment">// 需要在 componentWillUnmount 执行的内容</span>\n    <span class="token punctuation">}</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n    <span class="token comment">// 在 componentDidMount，以及 count 更改时 componentDidUpdate 执行的内容</span>\n    document<span class="token punctuation">.</span>title <span class="token operator">=</span> <span class="token string">\'You clicked \'</span> <span class="token operator">+</span> count <span class="token operator">+</span> <span class="token string">\' times\'</span><span class="token punctuation">;</span>\n    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n      <span class="token comment">// 需要在 count 更改时 componentDidUpdate（先于 document.title = ... 执行，遵守先清理后更新）</span>\n      <span class="token comment">// 以及 componentWillUnmount 执行的内容</span>\n    <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 当函数中 Cleanup 函数会按照在代码中定义的顺序先后执行，与函数本身的特性无关</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>count<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 仅在 count 更改时更新</span>\n\n  <span class="token keyword">return</span> <span class="token punctuation">(</span>\n    <span class="token operator">&lt;</span>div<span class="token operator">></span>\n      <span class="token operator">&lt;</span>p<span class="token operator">></span>You clicked <span class="token punctuation">{</span>count<span class="token punctuation">}</span> times<span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">></span>\n      <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">setCount</span><span class="token punctuation">(</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">></span>Click me<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span>\n    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>\n  <span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<ul>\n<li>Hooks 组件更接近于实现状态同步，而不是响应生命周期事件</li>\n<li>只能在<strong>函数最外层</strong>调用 Hook。只能在 <strong>React 的函数组件</strong>中调用 Hook。</li>\n<li><code class="language-text">useLayoutEffect</code> 与 <code class="language-text">componentDidMount</code>、<code class="language-text">componentDidUpdate</code> 的调用阶段是一样的。但是，我们推荐你<strong>一开始先用 useEffect</strong>，只有当它出问题的时候再尝试使用 <code class="language-text">useLayoutEffect</code></li>\n<li>与 <code class="language-text">componentDidMount</code> 或 <code class="language-text">componentDidUpdate</code> 不同的是，Hook 在浏览器完成布局与绘制<strong>之后</strong>，传给 <code class="language-text">useEffect</code> 的函数会延迟调用，但会保证在任何新的渲染前执行</li>\n<li>effect 的清除（cleanup）并不会读取“最新”的 props 。它只能读取到定义它的那次渲染中的 props 值</li>\n<li>effect 中可以读取到最新的 count 状态值，并不是 count 的值在“不变”的 effect 中发生了改变，而是 effect 函数本身在每一次渲染中都不相同</li>\n<li>在 class 组件生命周期的思维模型中，副作用的行为和渲染输出是不同的。UI 渲染是被 props 和 state 驱动的，并且能确保步调一致，但副作用并不是这样。这是一类常见问题的来源。</li>\n<li>而在 <code class="language-text">useEffect</code> 的思维模型中，默认都是同步的。副作用变成了 React 数据流的一部分。对于每一个 <code class="language-text">useEffect</code> 调用，一旦你处理正确，你的组件能够更好地处理边缘情况。</li>\n</ul>\n<h1 id="component-源码解读"><a href="#component-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Component 源码解读</h1>\n<p>首先看一下 React.Component 结构</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="19819388250138403000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// ReactBaseClasses.js 文件\n/**\n * Base class helpers for the updating state of a component.\n */\nfunction Component(props, context, updater) {\n  this.props = props; // 属性 props\n  this.context = context; // 上下文 context\n  // If a component has string refs, we will assign a different object later.\n  // 初始化 refs，为 {}，主要在 stringRef 中使用，将 stringRef 节点的实例挂载在 this.refs 上\n  this.refs = emptyObject;\n  // We initialize the default updater but the real one gets injected by the\n  // renderer.\n  this.updater = updater || ReactNoopUpdateQueue; // updater\n}\n\nComponent.prototype.isReactComponent = {};\n\n/**\n * 设置 state 的子集，使用该方法更新 state，避免 state 的值为可突变的状态\n * \\`shouldComponentUpdate\\`只是浅比较更新，\n * 可突变的类型可能导致 \\`shouldComponentUpdate\\` 返回 false，无法重新渲染\n * Immutable.js 可以解决这个问题。它通过结构共享提供不可突变的，持久的集合：\n * 不可突变: 一旦创建，集合就不能在另一个时间点改变。\n * 持久性: 可以使用原始集合和一个突变来创建新的集合。原始集合在新集合创建后仍然可用。\n * 结构共享: 新集合尽可能多的使用原始集合的结构来创建，以便将复制操作降至最少从而提升性能。\n *\n * 并不能保证 \\`this.state\\` 通过 \\`setState\\` 后不可突变的更新，它可能还返回原来的数值\n * 不能保证 \\`setrState\\` 会同步更新 \\`this.state\\`\n * \\`setState\\` 是通过队列形式来更新 state ，当 执行 \\`setState\\` 时，\n * 会把 state 浅合并后放入状态队列，然后批量执行，即它不是立即更新的。\n * 不过，你可以在 callback 回调函数中获取最新的值\n *\n * 注意：对于异步渲染，我们应在 \\`getSnapshotBeforeUpdate\\` 中读取 \\`state\\`、\\`props\\`,\n * 而不是 \\`componentWillUpdate\\`\n *\n * @param {object|function} partialState Next partial state or function to\n *        produce next partial state to be merged with current state.\n * @param {?function} callback Called after state is updated.\n * @final\n * @protected\n */\nComponent.prototype.setState = function(partialState, callback) {\n  // 当 partialState 状态为 object 或 function类型 或 null 时，\n  // 执行 this.updater.enqueueSetState 方法，否则报错\n  invariant(\n    typeof partialState === \'object\' || typeof partialState === \'function\' || partialState == null,\n    \'setState(...): takes an object of state variables to update or a \' +\n      \'function which returns an object of state variables.\'\n  );\n  // 将 \\`setState\\` 事务放入队列中\n  this.updater.enqueueSetState(this, partialState, callback, \'setState\');\n};\n\n/**\n * 强制更新，当且仅当当前不处于 DOM 事物（transaction）中才会被唤起\n * This should only be invoked when it is known with\n * certainty that we are **not** in a DOM transaction.\n *\n * 默认情况下，当组件的state或props改变时，组件将重新渲染。\n * 如果你的\\`render()\\`方法依赖于一些其他的数据，\n * 你可以告诉React组件需要通过调用\\`forceUpdate()\\`重新渲染。\n * 调用\\`forceUpdate()\\`会导致组件跳过 \\`shouldComponentUpdate()\\`,\n * 直接调用 \\`render()\\`。但会调用 \\`componentWillUpdate\\` 和 \\`componentDidUpdate\\`。\n * 这将触发组件的正常生命周期方法,包括每个子组件的 shouldComponentUpdate() 方法。\n * forceUpdate 就是重新 render 。\n * 有些变量不在 state 上，当时你又想达到这个变量更新的时候，刷新 render ；\n * 或者 state 里的某个变量层次太深，更新的时候没有自动触发 render 。\n * 这些时候都可以手动调用 forceUpdate 自动触发 render\n *\n * @param {?function} callback 更新完成后的回调函数.\n * @final\n * @protected\n */\nComponent.prototype.forceUpdate = function(callback) {\n  // updater 强制更新\n  this.updater.enqueueForceUpdate(this, callback, \'forceUpdate\');\n};`, `19819388250138403000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">// ReactBaseClasses.js 文件</span>\n<span class="token comment">/**\n * Base class helpers for the updating state of a component.\n */</span>\n<span class="token keyword">function</span> <span class="token function">Component</span><span class="token punctuation">(</span><span class="token parameter">props<span class="token punctuation">,</span> context<span class="token punctuation">,</span> updater</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>props <span class="token operator">=</span> props<span class="token punctuation">;</span> <span class="token comment">// 属性 props</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>context <span class="token operator">=</span> context<span class="token punctuation">;</span> <span class="token comment">// 上下文 context</span>\n  <span class="token comment">// If a component has string refs, we will assign a different object later.</span>\n  <span class="token comment">// 初始化 refs，为 {}，主要在 stringRef 中使用，将 stringRef 节点的实例挂载在 this.refs 上</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>refs <span class="token operator">=</span> emptyObject<span class="token punctuation">;</span>\n  <span class="token comment">// We initialize the default updater but the real one gets injected by the</span>\n  <span class="token comment">// renderer.</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>updater <span class="token operator">=</span> updater <span class="token operator">||</span> ReactNoopUpdateQueue<span class="token punctuation">;</span> <span class="token comment">// updater</span>\n<span class="token punctuation">}</span>\n\n<span class="token class-name">Component</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>isReactComponent <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n<span class="token comment">/**\n * 设置 state 的子集，使用该方法更新 state，避免 state 的值为可突变的状态\n * `shouldComponentUpdate`只是浅比较更新，\n * 可突变的类型可能导致 `shouldComponentUpdate` 返回 false，无法重新渲染\n * Immutable.js 可以解决这个问题。它通过结构共享提供不可突变的，持久的集合：\n * 不可突变: 一旦创建，集合就不能在另一个时间点改变。\n * 持久性: 可以使用原始集合和一个突变来创建新的集合。原始集合在新集合创建后仍然可用。\n * 结构共享: 新集合尽可能多的使用原始集合的结构来创建，以便将复制操作降至最少从而提升性能。\n *\n * 并不能保证 `this.state` 通过 `setState` 后不可突变的更新，它可能还返回原来的数值\n * 不能保证 `setrState` 会同步更新 `this.state`\n * `setState` 是通过队列形式来更新 state ，当 执行 `setState` 时，\n * 会把 state 浅合并后放入状态队列，然后批量执行，即它不是立即更新的。\n * 不过，你可以在 callback 回调函数中获取最新的值\n *\n * 注意：对于异步渲染，我们应在 `getSnapshotBeforeUpdate` 中读取 `state`、`props`,\n * 而不是 `componentWillUpdate`\n *\n * @param {object|function} partialState Next partial state or function to\n *        produce next partial state to be merged with current state.\n * @param {?function} callback Called after state is updated.\n * @final\n * @protected\n */</span>\n<span class="token class-name">Component</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">setState</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">partialState<span class="token punctuation">,</span> callback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 当 partialState 状态为 object 或 function类型 或 null 时，</span>\n  <span class="token comment">// 执行 this.updater.enqueueSetState 方法，否则报错</span>\n  <span class="token function">invariant</span><span class="token punctuation">(</span>\n    <span class="token keyword">typeof</span> partialState <span class="token operator">===</span> <span class="token string">\'object\'</span> <span class="token operator">||</span> <span class="token keyword">typeof</span> partialState <span class="token operator">===</span> <span class="token string">\'function\'</span> <span class="token operator">||</span> partialState <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">,</span>\n    <span class="token string">\'setState(...): takes an object of state variables to update or a \'</span> <span class="token operator">+</span>\n      <span class="token string">\'function which returns an object of state variables.\'</span>\n  <span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token comment">// 将 `setState` 事务放入队列中</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>updater<span class="token punctuation">.</span><span class="token function">enqueueSetState</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> partialState<span class="token punctuation">,</span> callback<span class="token punctuation">,</span> <span class="token string">\'setState\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n<span class="token comment">/**\n * 强制更新，当且仅当当前不处于 DOM 事物（transaction）中才会被唤起\n * This should only be invoked when it is known with\n * certainty that we are **not** in a DOM transaction.\n *\n * 默认情况下，当组件的state或props改变时，组件将重新渲染。\n * 如果你的`render()`方法依赖于一些其他的数据，\n * 你可以告诉React组件需要通过调用`forceUpdate()`重新渲染。\n * 调用`forceUpdate()`会导致组件跳过 `shouldComponentUpdate()`,\n * 直接调用 `render()`。但会调用 `componentWillUpdate` 和 `componentDidUpdate`。\n * 这将触发组件的正常生命周期方法,包括每个子组件的 shouldComponentUpdate() 方法。\n * forceUpdate 就是重新 render 。\n * 有些变量不在 state 上，当时你又想达到这个变量更新的时候，刷新 render ；\n * 或者 state 里的某个变量层次太深，更新的时候没有自动触发 render 。\n * 这些时候都可以手动调用 forceUpdate 自动触发 render\n *\n * @param {?function} callback 更新完成后的回调函数.\n * @final\n * @protected\n */</span>\n<span class="token class-name">Component</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">forceUpdate</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">callback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// updater 强制更新</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>updater<span class="token punctuation">.</span><span class="token function">enqueueForceUpdate</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> callback<span class="token punctuation">,</span> <span class="token string">\'forceUpdate\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>其中 <code class="language-text">this.refs</code> 值 <code class="language-text">emptyObject</code> 为：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="7392026983440347000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// 设置 refs 初始值为 {}\nconst emptyObject = {};\nif (__DEV__) {\n  Object.freeze(emptyObject); // __DEV__ 模式下， 冻结 emptyObject\n}\n// Object.freeze() 冻结一个对象，被冻结的对象不能被修改（添加，删除，\n// 修改已有属性的可枚举性、可配置性、可写性与属性值，原型）；返回和传入的参数相同的对象。`, `7392026983440347000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">// 设置 refs 初始值为 {}</span>\n<span class="token keyword">const</span> emptyObject <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token keyword">if</span> <span class="token punctuation">(</span>__DEV__<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  Object<span class="token punctuation">.</span><span class="token function">freeze</span><span class="token punctuation">(</span>emptyObject<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// __DEV__ 模式下， 冻结 emptyObject</span>\n<span class="token punctuation">}</span>\n<span class="token comment">// Object.freeze() 冻结一个对象，被冻结的对象不能被修改（添加，删除，</span>\n<span class="token comment">// 修改已有属性的可枚举性、可配置性、可写性与属性值，原型）；返回和传入的参数相同的对象。</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p><code class="language-text">ReactNoopUpdateQueue</code> 为：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="61955371474495860000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// ReactNoopUpdateQueue.js 文件\n/**\n * 这是一个关于 更新队列(update queue) 的抽象 API\n */\nconst ReactNoopUpdateQueue = {\n  /**\n   * 检查复合组件是否装载完成（被插入树中）\n   * @param {ReactClass} publicInstance 测试实例单元\n   * @return {boolean} 装载完成为 true，否则为 false\n   * @protected\n   * @final\n   */\n  isMounted: function(publicInstance) {\n    return false;\n  },\n\n  /**\n   * 强制更新队列，当且仅当当前不处于 DOM 事物（transaction）中才会被唤起\n   *\n   * 当 state 里的某个变量层次太深，更新的时候没有自动触发 render 。\n   * 这些时候就可以调用该方法强制更新队列\n   *\n   * 该方法将跳过 \\`shouldComponentUpdate()\\`, 直接调用 \\`render()\\`, 但它会唤起\n   * \\`componentWillUpdate\\` 和 \\`componentDidUpdate\\`.\n   *\n   * @param {ReactClass} publicInstance 将被重新渲染的实例\n   * @param {?function} callback 组件更新后的回调函数.\n   * @param {?string} callerName 在公共 API 调用该方法的函数名称.\n   * @internal\n   */\n  enqueueForceUpdate: function(publicInstance, callback, callerName) {\n    warnNoop(publicInstance, \'forceUpdate\');\n  },\n\n  /**\n   * 完全替换state，与 \\`setState\\` 不同的是，\\`setState\\` 是以修改和新增的方式改变 \\`state \\`的，\n   * 不会改变没有涉及到的 \\`state\\`。\n   * 而 \\`enqueueReplaceState\\` 则用新的 \\`state\\` 完全替换掉老 \\`state\\`\n   * 使用它或 \\`setState\\` 来改变 state，并且应该把 this.state 设置为不可突变类型对象，\n   * 并且this.state不会立即更改\n   * 我们应该在回调函数 callback 中获取最新的 state\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} completeState Next state.\n   * @param {?function} callback Called after component is updated.\n   * @param {?string} callerName name of the calling function in the public API.\n   * @internal\n   */\n  enqueueReplaceState: function(publicInstance, completeState, callback, callerName) {\n    warnNoop(publicInstance, \'replaceState\');\n  },\n\n  /**\n   * 设置 state 的子集\n   * 它存在的唯一理由是 _pendingState 是内部方法。\n   * \\`enqueueSetState\\` 实现浅合并更新 \\`state\\`\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} partialState Next partial state to be merged with state.\n   * @param {?function} callback Called after component is updated.\n   * @param {?string} Name of the calling function in the public API.\n   * @internal\n   */\n  enqueueSetState: function(publicInstance, partialState, callback, callerName) {\n    warnNoop(publicInstance, \'setState\');\n  }\n};\n\nexport default ReactNoopUpdateQueue;`, `61955371474495860000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">// ReactNoopUpdateQueue.js 文件</span>\n<span class="token comment">/**\n * 这是一个关于 更新队列(update queue) 的抽象 API\n */</span>\n<span class="token keyword">const</span> ReactNoopUpdateQueue <span class="token operator">=</span> <span class="token punctuation">{</span>\n  <span class="token comment">/**\n   * 检查复合组件是否装载完成（被插入树中）\n   * @param {ReactClass} publicInstance 测试实例单元\n   * @return {boolean} 装载完成为 true，否则为 false\n   * @protected\n   * @final\n   */</span>\n  <span class="token function-variable function">isMounted</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">publicInstance</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n\n  <span class="token comment">/**\n   * 强制更新队列，当且仅当当前不处于 DOM 事物（transaction）中才会被唤起\n   *\n   * 当 state 里的某个变量层次太深，更新的时候没有自动触发 render 。\n   * 这些时候就可以调用该方法强制更新队列\n   *\n   * 该方法将跳过 `shouldComponentUpdate()`, 直接调用 `render()`, 但它会唤起\n   * `componentWillUpdate` 和 `componentDidUpdate`.\n   *\n   * @param {ReactClass} publicInstance 将被重新渲染的实例\n   * @param {?function} callback 组件更新后的回调函数.\n   * @param {?string} callerName 在公共 API 调用该方法的函数名称.\n   * @internal\n   */</span>\n  <span class="token function-variable function">enqueueForceUpdate</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">publicInstance<span class="token punctuation">,</span> callback<span class="token punctuation">,</span> callerName</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token function">warnNoop</span><span class="token punctuation">(</span>publicInstance<span class="token punctuation">,</span> <span class="token string">\'forceUpdate\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n\n  <span class="token comment">/**\n   * 完全替换state，与 `setState` 不同的是，`setState` 是以修改和新增的方式改变 `state `的，\n   * 不会改变没有涉及到的 `state`。\n   * 而 `enqueueReplaceState` 则用新的 `state` 完全替换掉老 `state`\n   * 使用它或 `setState` 来改变 state，并且应该把 this.state 设置为不可突变类型对象，\n   * 并且this.state不会立即更改\n   * 我们应该在回调函数 callback 中获取最新的 state\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} completeState Next state.\n   * @param {?function} callback Called after component is updated.\n   * @param {?string} callerName name of the calling function in the public API.\n   * @internal\n   */</span>\n  <span class="token function-variable function">enqueueReplaceState</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">publicInstance<span class="token punctuation">,</span> completeState<span class="token punctuation">,</span> callback<span class="token punctuation">,</span> callerName</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token function">warnNoop</span><span class="token punctuation">(</span>publicInstance<span class="token punctuation">,</span> <span class="token string">\'replaceState\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n\n  <span class="token comment">/**\n   * 设置 state 的子集\n   * 它存在的唯一理由是 _pendingState 是内部方法。\n   * `enqueueSetState` 实现浅合并更新 `state`\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} partialState Next partial state to be merged with state.\n   * @param {?function} callback Called after component is updated.\n   * @param {?string} Name of the calling function in the public API.\n   * @internal\n   */</span>\n  <span class="token function-variable function">enqueueSetState</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">publicInstance<span class="token punctuation">,</span> partialState<span class="token punctuation">,</span> callback<span class="token punctuation">,</span> callerName</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token function">warnNoop</span><span class="token punctuation">(</span>publicInstance<span class="token punctuation">,</span> <span class="token string">\'setState\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n<span class="token keyword">export</span> <span class="token keyword">default</span> ReactNoopUpdateQueue<span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>注意，React API 只是简单的功能介绍，具体的实现是在 react-dom 中，这是因为不同的平台，React API 是一致的，但不同的平台，渲染的流程是不同的，具体的 Component 渲染流程不一致，会根据具体的平台去定制。</p>\n<p>组件生命周期请参考 <a href="https://github.com/sisterAn/blog/issues/34" target="_blank" rel="nofollow noreferrer noopener">Hooks 与 React 生命周期的关系</a></p>',
id:"/github/workspace/blog/React之Component入门学习/index.md absPath of file >>> MarkdownRemark",timeToRead:10,frontmatter:{date:"2019-09-19 21:32:42",path:"/react-component-practice-learn/",tags:"前端, React, PureComponent",title:"React之Component入门学习",draft:null}},{excerpt:"PureComponent  最早在 React v15.3 版本中发布，主要是为了优化 React 应用而产生。 在这段代码中，   会浅比较   或   是否改变，来决定是否重新渲染组件。 实现  和   类似，都是定义一个组件类。不同是   没有实现  ，而   通过 props 和 state 的  浅比较  实现了。 使用场景 当   的 props 和 state 均为基本类型，使用   会节省应用的性能 可能出现的问题及解决方案 当 props 或 state…",html:'<h1 id="purecomponent"><a href="#purecomponent" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>PureComponent</h1>\n<p><code class="language-text">PureComponent</code> 最早在 React v15.3 版本中发布，主要是为了优化 React 应用而产生。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="98418108118836120000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`class Counter extends React.PureComponent {\n  constructor(props) {\n    super(props);\n    this.state = { count: 1 };\n  }\n\n  render() {\n    return (\n      <button color={this.props.color} onClick={() => this.setState((state) => ({ count: state.count + 1 }))}>\n        Count: {this.state.count}\n      </button>\n    );\n  }\n}`, `98418108118836120000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">Counter</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>PureComponent</span> <span class="token punctuation">{</span>\n  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span> count<span class="token punctuation">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token punctuation">(</span>\n      <span class="token operator">&lt;</span>button color<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>color<span class="token punctuation">}</span> onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">state</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span> count<span class="token punctuation">:</span> state<span class="token punctuation">.</span>count <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">></span>\n        Count<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>count<span class="token punctuation">}</span>\n      <span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span>\n    <span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>在这段代码中， <code class="language-text">React.PureComponent</code> 会浅比较 <code class="language-text">props.color</code> 或 <code class="language-text">state.count</code> 是否改变，来决定是否重新渲染组件。</p>\n<ul>\n<li>\n<p><strong>实现</strong></p>\n<p><code class="language-text">React.PureComponent</code> 和 <code class="language-text">React.Component</code> 类似，都是定义一个组件类。不同是 <code class="language-text">React.Component</code> 没有实现 <code class="language-text">shouldComponentUpdate()</code>，而 <code class="language-text">React.PureComponent</code> 通过 props 和 state 的 <strong>浅比较</strong> 实现了。</p>\n</li>\n<li>\n<p><strong>使用场景</strong></p>\n<p>当 <code class="language-text">React.Component</code> 的 props 和 state 均为基本类型，使用 <code class="language-text">React.PureComponent</code> 会节省应用的性能</p>\n</li>\n<li>\n<p><strong>可能出现的问题及解决方案</strong></p>\n<p>当 props 或 state 为 <strong>复杂的数据结构</strong> （例如：嵌套对象和数组）时，因为 <code class="language-text">React.PureComponent</code> 仅仅是 <strong>浅比较</strong> ，可能会渲染出 <strong>错误的结果</strong> 。这时有 <strong>两种解决方案</strong> ：</p>\n<ul>\n<li>当 <strong>知道</strong> 有深度数据结构更新时，可以直接调用 <strong>forceUpdate</strong> 强制更新</li>\n<li>考虑使用 <a href="https://facebook.github.io/immutable-js/" target="_blank" rel="nofollow noreferrer noopener">immutable objects</a> （不可突变的对象），实现快速的比较对象</li>\n</ul>\n</li>\n<li>\n<p><strong>注意</strong></p>\n<p><code class="language-text">React.PureComponent</code> 中的 <code class="language-text">shouldComponentUpdate()</code> 将跳过所有子组件树的 props 更新（具体原因参考 <a href="https://github.com/sisterAn/blog/issues/34" target="_blank" rel="nofollow noreferrer noopener">Hooks 与 React 生命周期</a>：即：更新阶段，由父至子去判断是否需要重新渲染），所以使用 React.PureComponent 的组件，它的所有 <strong>子组件也必须都为 React.PureComponent</strong> 。</p>\n</li>\n</ul>\n<h1 id="purecomponent-与-stateless-functional-component"><a href="#purecomponent-%E4%B8%8E-stateless-functional-component" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>PureComponent 与 Stateless Functional Component</h1>\n<p>对于 React 开发人员来说，知道何时在代码中使用 <strong>Component</strong>，<strong>PureComponent ** 和 **Stateless Functional Component</strong> 非常重要。</p>\n<p>首先，让我们看一下无状态组件。</p>\n<h2 id="无状态组件"><a href="#%E6%97%A0%E7%8A%B6%E6%80%81%E7%BB%84%E4%BB%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>无状态组件</h2>\n<p>输入输出数据完全由 <code class="language-text">props</code> 决定，而且不会产生任何副作用。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="85316676051286100000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`const Button = (props) => <button onClick={props.onClick}>{props.text}</button>;`, `85316676051286100000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">const</span> <span class="token function-variable function">Button</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span>props<span class="token punctuation">.</span>onClick<span class="token punctuation">}</span><span class="token operator">></span><span class="token punctuation">{</span>props<span class="token punctuation">.</span>text<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>\n<p>无状态组件可以通过减少继承 <code class="language-text">Component</code> 而来的生命周期函数而达到性能优化的效果。从本质上来说，无状态组件就是一个单纯的 <code class="language-text">render</code> 函数，所以无状态组件的缺点也是显而易见的。因为它没有 <code class="language-text">shouldComponentUpdate</code> 生命周期函数，所以每次 <code class="language-text">state</code> 更新，它都会重新绘制 <code class="language-text">render</code> 函数。</p>\n<p>React 16.8 之后，React 引入 Hooks 。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。</p>\n<h2 id="何时使用-purecomponent？"><a href="#%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8-purecomponent%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>何时使用 <code class="language-text">PureComponent</code>？</h2>\n<p><code class="language-text">PureComponent</code> 提高了性能，因为它减少了应用程序中的渲染操作次数，这对于复杂的 UI 来说是一个巨大的胜利，因此建议尽可能使用。此外，还有一些情况需要使用 <code class="language-text">Component</code> 的生命周期方法，在这种情况下，我们不能使用无状态组件。</p>\n<h2 id="何时使用无状态组件？"><a href="#%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8%E6%97%A0%E7%8A%B6%E6%80%81%E7%BB%84%E4%BB%B6%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>何时使用无状态组件？</h2>\n<p>无状态组件易于实施且快速实施。它们适用于非常小的 UI 视图，其中重新渲染成本无关紧要。它们提供更清晰的代码和更少的文件来处理。</p>\n<h1 id="purecomponent-与-reactmemo"><a href="#purecomponent-%E4%B8%8E-reactmemo" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>PureComponent 与 React.memo</h1>\n<p><code class="language-text">React.memo</code> 为高阶组件。它实现的效果与 <code class="language-text">React.PureComponent</code> 相似，不同的是：</p>\n<ul>\n<li><code class="language-text">React.memo</code> 用于函数组件</li>\n<li><code class="language-text">React.PureComponent</code> 适用于 class 组件</li>\n<li><code class="language-text">React.PureComponent</code> 只是浅比较 <code class="language-text">props</code>、<code class="language-text">state</code>，<code class="language-text">React.memo</code> 也是浅比较，但它可以自定义比较函数</li>\n</ul>\n<h2 id="reactmemo"><a href="#reactmemo" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>React.memo</h2>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="90937950304414740000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`function MyComponent(props) {\n  /* 使用 props 渲染 */\n}\n\n// 比较函数\nfunction areEqual(prevProps, nextProps) {\n  /*\n  如果把 nextProps 传入 render 方法的返回结果与\n  将 prevProps 传入 render 方法的返回结果一致则返回 true，\n  否则返回 false\n  返回 true，复用最近一次渲染\n  返回 false，重新渲染\n  */\n}\n\nexport default React.memo(MyComponent, areEqual);`, `90937950304414740000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span> <span class="token function">MyComponent</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">/* 使用 props 渲染 */</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// 比较函数</span>\n<span class="token keyword">function</span> <span class="token function">areEqual</span><span class="token punctuation">(</span><span class="token parameter">prevProps<span class="token punctuation">,</span> nextProps</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">/*\n  如果把 nextProps 传入 render 方法的返回结果与\n  将 prevProps 传入 render 方法的返回结果一致则返回 true，\n  否则返回 false\n  返回 true，复用最近一次渲染\n  返回 false，重新渲染\n  */</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">export</span> <span class="token keyword">default</span> React<span class="token punctuation">.</span><span class="token function">memo</span><span class="token punctuation">(</span>MyComponent<span class="token punctuation">,</span> areEqual<span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<ul>\n<li><code class="language-text">React.memo</code> 通过记忆组件渲染结果的方式实现 ，提高组件的性能</li>\n<li>只会对 <code class="language-text">props</code> 浅比较，如果相同，React 将跳过渲染组件的操作并直接复用最近一次渲染的结果。</li>\n<li>可以将自定义的比较函数作为第二个参数，实现自定义比较</li>\n<li>此方法仅作为<strong>性能优化</strong>的方式而存在。但请不要依赖它来“阻止”渲染，这会产生 bug。</li>\n<li>与 class 组件中 <code class="language-text">shouldComponentUpdate()</code> 方法不同的是，如果 props 相等，<code class="language-text">areEqual</code>会返回 <code class="language-text">true</code>；如果 props 不相等，则返回 <code class="language-text">false</code>。这与 <code class="language-text">shouldComponentUpdate</code> 方法的返回值相反。</li>\n</ul>\n<h1 id="使用-purecomponent-常见误区"><a href="#%E4%BD%BF%E7%94%A8-purecomponent-%E5%B8%B8%E8%A7%81%E8%AF%AF%E5%8C%BA" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>使用 PureComponent 常见误区</h1>\n<h2 id="误区一：在渲染方法中创建函数"><a href="#%E8%AF%AF%E5%8C%BA%E4%B8%80%EF%BC%9A%E5%9C%A8%E6%B8%B2%E6%9F%93%E6%96%B9%E6%B3%95%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%87%BD%E6%95%B0" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>误区一：在渲染方法中创建函数</h2>\n<p>如果你在 <code class="language-text">render</code> 方法里创建函数，那么使用 <code class="language-text">props</code> 会抵消使用 <code class="language-text">React.PureComponent</code> 带来的优势。因为每次渲染运行时，都会分配一个新函数，如果你有子组件，即使数据没有改变，它们也会重新渲染，因为浅比较 <code class="language-text">props</code> 的时候总会得到 <code class="language-text">false</code>。</p>\n<p>例如：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="10384369688064066000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// FriendsItem 在父组件引用样式\n<FriendsItem key={friend.id} name={friend.name} id={friend.id} onDeleteClick={() => this.deleteFriends(friend.id)} />\n// 在父组件中绑定\n// 父组件在 props 中传递了一个箭头函数。箭头函数在每次 render 时都会重新分配（和使用 bind 的方式相同）`, `10384369688064066000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">// FriendsItem 在父组件引用样式</span>\n<span class="token operator">&lt;</span>FriendsItem key<span class="token operator">=</span><span class="token punctuation">{</span>friend<span class="token punctuation">.</span>id<span class="token punctuation">}</span> name<span class="token operator">=</span><span class="token punctuation">{</span>friend<span class="token punctuation">.</span>name<span class="token punctuation">}</span> id<span class="token operator">=</span><span class="token punctuation">{</span>friend<span class="token punctuation">.</span>id<span class="token punctuation">}</span> onDeleteClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">deleteFriends</span><span class="token punctuation">(</span>friend<span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span>\n<span class="token comment">// 在父组件中绑定</span>\n<span class="token comment">// 父组件在 props 中传递了一个箭头函数。箭头函数在每次 render 时都会重新分配（和使用 bind 的方式相同）</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>其中，<code class="language-text">FriendsItem</code> 为 <code class="language-text">PureComponent</code>：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="28030940281118876000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// 其中 FriendsItem 为 PureComponent\nclass FriendsItem extends React.PureComponent {\n  render() {\n    const { name, onDeleteClick } = this.props;\n    console.log(\\`FriendsItem：\\${name} 渲染\\`);\n    return (\n      <div>\n        <span>{name}</span>\n        <button onClick={onDeleteClick}>删除</button>\n      </div>\n    );\n  }\n}\n// 每次点击删除操作时，未删除的 FriendsItem 都将被重新渲染`, `28030940281118876000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">// 其中 FriendsItem 为 PureComponent</span>\n<span class="token keyword">class</span> <span class="token class-name">FriendsItem</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>PureComponent</span> <span class="token punctuation">{</span>\n  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">const</span> <span class="token punctuation">{</span> name<span class="token punctuation">,</span> onDeleteClick <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">;</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">FriendsItem：</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> 渲染</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">return</span> <span class="token punctuation">(</span>\n      <span class="token operator">&lt;</span>div<span class="token operator">></span>\n        <span class="token operator">&lt;</span>span<span class="token operator">></span><span class="token punctuation">{</span>name<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>span<span class="token operator">></span>\n        <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span>onDeleteClick<span class="token punctuation">}</span><span class="token operator">></span>删除<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span>\n      <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>\n    <span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n<span class="token comment">// 每次点击删除操作时，未删除的 FriendsItem 都将被重新渲染</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p><a href="https://stackblitz.com/edit/react-ta6tww" target="_blank" rel="nofollow noreferrer noopener">点击查看在线实例</a></p>\n<p>这种在 <code class="language-text">FriendsItem</code> 直接调用 <code class="language-text">() =&gt; this.deleteFriends(friend.id)</code>，看起来操作更简单，逻辑更清晰，但它有一个有一个最大的弊端，甚至打破了像 <code class="language-text">shouldComponentUpdate</code> 和 <code class="language-text">PureComponent</code> 这样的性能优化。</p>\n<p>这是因为：父组件在 <code class="language-text">render</code> 声明了一个函数<code class="language-text">onDeleteClick</code>，每次父组件渲染都会重新生成新的函数。因此，每次父组件重新渲染，都会给每个子组件 <code class="language-text">FriendsItem</code> 传递不同的 <code class="language-text">props</code>，导致每个子组件都会重新渲染， 即使 <code class="language-text">FriendsItem</code> 为 <code class="language-text">PureComponent</code>。</p>\n<p><strong>避免在 render 方法里创建函数并使用它。它会打破了像 shouldComponentUpdate 和 PureComponent 这样的性能优化。</strong></p>\n<p>要解决这个问题，只需要将原本在父组件上的绑定放到子组件上即可。<code class="language-text">FriendsItem</code> 将始终具有相同的 <code class="language-text">props</code>，并且永远不会导致不必要的重新渲染。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="60677988240068490000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// FriendsItem 在父组件引用样式\n<FriendsItem key={friend.id} id={friend.id} name={friend.name} onClick={this.deleteFriends} />`, `60677988240068490000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">// FriendsItem 在父组件引用样式</span>\n<span class="token operator">&lt;</span>FriendsItem key<span class="token operator">=</span><span class="token punctuation">{</span>friend<span class="token punctuation">.</span>id<span class="token punctuation">}</span> id<span class="token operator">=</span><span class="token punctuation">{</span>friend<span class="token punctuation">.</span>id<span class="token punctuation">}</span> name<span class="token operator">=</span><span class="token punctuation">{</span>friend<span class="token punctuation">.</span>name<span class="token punctuation">}</span> onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>deleteFriends<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span></span></pre></div>\n<p><code class="language-text">FriendsItem</code>:</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="59425071380621960000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`class FriendsItem extends React.PureComponent {\n  onDeleteClick = () => {\n    this.props.onClick(this.props.id);\n  }; // 在子组件中绑定\n  render() {\n    const { name } = this.props;\n    console.log(\\`FriendsItem：\\${name} 渲染\\`);\n    return (\n      <div>\n        <span>{name}</span>\n        <button onClick={this.onDeleteClick}>删除</button>\n      </div>\n    );\n  }\n}\n// 每次点击删除操作时，FriendsItem 都不会被重新渲染`, `59425071380621960000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">FriendsItem</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>PureComponent</span> <span class="token punctuation">{</span>\n  <span class="token function-variable function">onDeleteClick</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span><span class="token function">onClick</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 在子组件中绑定</span>\n  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">const</span> <span class="token punctuation">{</span> name <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">;</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">FriendsItem：</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> 渲染</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">return</span> <span class="token punctuation">(</span>\n      <span class="token operator">&lt;</span>div<span class="token operator">></span>\n        <span class="token operator">&lt;</span>span<span class="token operator">></span><span class="token punctuation">{</span>name<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>span<span class="token operator">></span>\n        <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>onDeleteClick<span class="token punctuation">}</span><span class="token operator">></span>删除<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span>\n      <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>\n    <span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n<span class="token comment">// 每次点击删除操作时，FriendsItem 都不会被重新渲染</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p><a href="https://stackblitz.com/edit/react-sr5yvp" target="_blank" rel="nofollow noreferrer noopener">点击查看在线实例</a></p>\n<p>通过此更改，当单击删除操作时，其他 <code class="language-text">FriendsItem</code> 都不会被重新渲染了 👍</p>\n<h2 id="误区二：在渲染方法中派生-state"><a href="#%E8%AF%AF%E5%8C%BA%E4%BA%8C%EF%BC%9A%E5%9C%A8%E6%B8%B2%E6%9F%93%E6%96%B9%E6%B3%95%E4%B8%AD%E6%B4%BE%E7%94%9F-state" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>误区二：在渲染方法中派生 state</h2>\n<p>考虑一个文章列表，您的个人资料组件将从中显示用户最喜欢的 10 个作品。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="88520859309117880000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`render() {\n  const { posts } = this.props\n  // 在渲染函数中生成 topTen，并渲染\n  const topTen = [...posts].sort((a, b) =>\n    b.likes - a.likes).slice(0, 9)\n  return //...\n}\n// 这会导致组件每次重新渲染，都会生成新的 topTen，导致不必要的渲染`, `88520859309117880000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> <span class="token punctuation">{</span> posts <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props\n  <span class="token comment">// 在渲染函数中生成 topTen，并渲染</span>\n  <span class="token keyword">const</span> topTen <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>posts<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token operator">=></span>\n    b<span class="token punctuation">.</span>likes <span class="token operator">-</span> a<span class="token punctuation">.</span>likes<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">)</span>\n  <span class="token keyword">return</span> <span class="token comment">//...</span>\n<span class="token punctuation">}</span>\n<span class="token comment">// 这会导致组件每次重新渲染，都会生成新的 topTen，导致不必要的渲染</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p><code class="language-text">topTen</code>每次组件重新渲染时都会有一个全新的引用，即使 <code class="language-text">posts</code> 没有更改，派生 <code class="language-text">state</code> 也是相同的。</p>\n<p>这个时候，我们应该将 <code class="language-text">topTen</code> 的判断逻辑提取到 <code class="language-text">render</code> 函数之外，通过缓存派生 <code class="language-text">state</code> 来解决此问题。</p>\n<p>例如，在组件的状态中设置派生 <code class="language-text">state</code>，并仅在 <code class="language-text">posts</code> 已更新时更新。</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="55051347794643910000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`componentWillMount() {\n  this.setTopTenPosts(this.props.posts)\n}\ncomponentWillReceiveProps(nextProps) {\n  if (this.props.posts !== nextProps.posts) {\n    this.setTopTenPosts(nextProps.posts)\n  }\n}\n// 每次 posts 更新时，更新派生 state，而不是在渲染函数中重新生成\nsetTopTenPosts(posts) {\n  this.setState({\n    topTen: [...posts].sort((a, b) => b.likes - a.likes).slice(0, 9)\n  })\n}`, `55051347794643910000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token function">componentWillMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setTopTenPosts</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>posts<span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n<span class="token function">componentWillReceiveProps</span><span class="token punctuation">(</span><span class="token parameter">nextProps</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>posts <span class="token operator">!==</span> nextProps<span class="token punctuation">.</span>posts<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setTopTenPosts</span><span class="token punctuation">(</span>nextProps<span class="token punctuation">.</span>posts<span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n<span class="token comment">// 每次 posts 更新时，更新派生 state，而不是在渲染函数中重新生成</span>\n<span class="token function">setTopTenPosts</span><span class="token punctuation">(</span><span class="token parameter">posts</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n    topTen<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token operator">...</span>posts<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token operator">=></span> b<span class="token punctuation">.</span>likes <span class="token operator">-</span> a<span class="token punctuation">.</span>likes<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h2 id="总结"><a href="#%E6%80%BB%E7%BB%93" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总结</h2>\n<p>在使用 <code class="language-text">PureComponent</code> 时，请注意：</p>\n<ul>\n<li>突变一般是不好的，但在使用 <code class="language-text">PureComponent</code> 时，问题会更加复杂。</li>\n<li>不要在渲染方法中创建新函数、对象或数组，这会导致项目性能显著降低。</li>\n</ul>\n<h1 id="purecomponent-源码解析"><a href="#purecomponent-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>PureComponent 源码解析</h1>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="28406910491833283000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// 新建了空方法ComponentDummy ，ComponentDummy 的原型 指向 Component 的原型;\nfunction ComponentDummy() {}\nComponentDummy.prototype = Component.prototype;\n\n/**\n * Convenience component with default shallow equality check for sCU.\n */\nfunction PureComponent(props, context, updater) {\n  this.props = props;\n  this.context = context;\n  // If a component has string refs, we will assign a different object later.\n  this.refs = emptyObject;\n  this.updater = updater || ReactNoopUpdateQueue;\n} // 解析同 React.Component，详细请看上一章\n\n/**\n * 实现 React.PureComponent 对 React.Component 的原型继承\n */\n/**\n * 用 ComponentDummy 的原因是为了不直接实例化一个 Component 实例，可以减少一些内存使用\n *\n * 因为，我们这里只需要继承 React.Component 的 原型，直接 PureComponent.prototype = new Component() 的话\n * 会继承包括 constructor 在内的其他 Component 属性方法，但是 PureComponent 已经有自己的 constructor 了，\n * 再继承的话，造成不必要的内存消耗\n * 所以会新建ComponentDummy，只继承Component的原型，不包括constructor，以此来节省内存。\n */\nconst pureComponentPrototype = (PureComponent.prototype = new ComponentDummy());\n\n// 修复 pureComponentPrototype 构造函数指向\npureComponentPrototype.constructor = PureComponent;\n\n// Avoid an extra prototype jump for these methods.\n// 虽然上面两句已经让PureComponent继承了Component\n// 但多加一个 Object.assign()，能有效的避免多一次原型链查找\nObject.assign(pureComponentPrototype, Component.prototype);\n\n// 唯一的区别，原型上添加了 isPureReactComponent 属性去表示该 Component 是 PureComponent\n// 在后续组件渲染的时候，react-dom 会去判断 isPureReactComponent 这个属性，来确定是否浅比较 props、status 实现更新\n/** 在 ReactFiberClassComponent.js 中，有对 isPureReactComponent 的判断\n if (ctor.prototype && ctor.prototype.isPureReactComponent) {\n    return (\n      !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState)\n    );\n  }\n */\npureComponentPrototype.isPureReactComponent = true;`, `28406910491833283000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">// 新建了空方法ComponentDummy ，ComponentDummy 的原型 指向 Component 的原型;</span>\n<span class="token keyword">function</span> <span class="token function">ComponentDummy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n<span class="token class-name">ComponentDummy</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token class-name">Component</span><span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>\n\n<span class="token comment">/**\n * Convenience component with default shallow equality check for sCU.\n */</span>\n<span class="token keyword">function</span> <span class="token function">PureComponent</span><span class="token punctuation">(</span><span class="token parameter">props<span class="token punctuation">,</span> context<span class="token punctuation">,</span> updater</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>props <span class="token operator">=</span> props<span class="token punctuation">;</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>context <span class="token operator">=</span> context<span class="token punctuation">;</span>\n  <span class="token comment">// If a component has string refs, we will assign a different object later.</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>refs <span class="token operator">=</span> emptyObject<span class="token punctuation">;</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>updater <span class="token operator">=</span> updater <span class="token operator">||</span> ReactNoopUpdateQueue<span class="token punctuation">;</span>\n<span class="token punctuation">}</span> <span class="token comment">// 解析同 React.Component，详细请看上一章</span>\n\n<span class="token comment">/**\n * 实现 React.PureComponent 对 React.Component 的原型继承\n */</span>\n<span class="token comment">/**\n * 用 ComponentDummy 的原因是为了不直接实例化一个 Component 实例，可以减少一些内存使用\n *\n * 因为，我们这里只需要继承 React.Component 的 原型，直接 PureComponent.prototype = new Component() 的话\n * 会继承包括 constructor 在内的其他 Component 属性方法，但是 PureComponent 已经有自己的 constructor 了，\n * 再继承的话，造成不必要的内存消耗\n * 所以会新建ComponentDummy，只继承Component的原型，不包括constructor，以此来节省内存。\n */</span>\n<span class="token keyword">const</span> pureComponentPrototype <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">PureComponent</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ComponentDummy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token comment">// 修复 pureComponentPrototype 构造函数指向</span>\npureComponentPrototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> PureComponent<span class="token punctuation">;</span>\n\n<span class="token comment">// Avoid an extra prototype jump for these methods.</span>\n<span class="token comment">// 虽然上面两句已经让PureComponent继承了Component</span>\n<span class="token comment">// 但多加一个 Object.assign()，能有效的避免多一次原型链查找</span>\nObject<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span>pureComponentPrototype<span class="token punctuation">,</span> <span class="token class-name">Component</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token comment">// 唯一的区别，原型上添加了 isPureReactComponent 属性去表示该 Component 是 PureComponent</span>\n<span class="token comment">// 在后续组件渲染的时候，react-dom 会去判断 isPureReactComponent 这个属性，来确定是否浅比较 props、status 实现更新</span>\n<span class="token comment">/** 在 ReactFiberClassComponent.js 中，有对 isPureReactComponent 的判断\n if (ctor.prototype &amp;&amp; ctor.prototype.isPureReactComponent) {\n    return (\n      !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState)\n    );\n  }\n */</span>\npureComponentPrototype<span class="token punctuation">.</span>isPureReactComponent <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>这里只是 <code class="language-text">PureComponent</code> 的声明创建，至于如何实现 <code class="language-text">shouldComponentUpdate()</code> ，核心代码在：</p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="33455974715666637000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`// ReactFiberClassComponent.js\nfunction checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext) {\n  // ...\n  if (ctor.prototype && ctor.prototype.isPureReactComponent) {\n    // 如果是纯组件，比较新老 props、state\n    // 返回 true，重新渲染，\n    // 即 shallowEqual props 返回 false，或 shallowEqual state 返回 false\n    return !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState);\n  }\n  return true;\n}`, `33455974715666637000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">// ReactFiberClassComponent.js</span>\n<span class="token keyword">function</span> <span class="token function">checkShouldComponentUpdate</span><span class="token punctuation">(</span><span class="token parameter">workInProgress<span class="token punctuation">,</span> ctor<span class="token punctuation">,</span> oldProps<span class="token punctuation">,</span> newProps<span class="token punctuation">,</span> oldState<span class="token punctuation">,</span> newState<span class="token punctuation">,</span> nextContext</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// ...</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>ctor<span class="token punctuation">.</span>prototype <span class="token operator">&amp;&amp;</span> ctor<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>isPureReactComponent<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 如果是纯组件，比较新老 props、state</span>\n    <span class="token comment">// 返回 true，重新渲染，</span>\n    <span class="token comment">// 即 shallowEqual props 返回 false，或 shallowEqual state 返回 false</span>\n    <span class="token keyword">return</span> <span class="token operator">!</span><span class="token function">shallowEqual</span><span class="token punctuation">(</span>oldProps<span class="token punctuation">,</span> newProps<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">shallowEqual</span><span class="token punctuation">(</span>oldState<span class="token punctuation">,</span> newState<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p><strong>shallowEqual.js</strong></p>\n<div\n              class="gatsby-code-button-container"\n              data-toaster-id="25716812241001705000"\n              data-toaster-class="gatsby-code-button-toaster"\n              data-toaster-text-class="gatsby-code-button-toaster-text"\n              data-toaster-text="复制成功"\n              data-toaster-duration="3500"\n              onClick="copyToClipboard(`/**\n * 通过遍历对象上的键并返回 false 来执行相等性\n * 在参数列表中，当任意键对应的值不严格相等时，返回 false。\n * 当所有键的值严格相等时,返回 true。\n */\nfunction shallowEqual(objA: mixed, objB: mixed): boolean {\n  // 通过 Object.is 判断 objA、objB 是否相等\n  if (is(objA, objB)) {\n    return true;\n  }\n\n  if (typeof objA !== \'object\' || objA === null || typeof objB !== \'object\' || objB === null) {\n    return false;\n  }\n\n  // 参数列表\n  const keysA = Object.keys(objA);\n  const keysB = Object.keys(objB);\n\n  // 参数列表长度不相同\n  if (keysA.length !== keysB.length) {\n    return false;\n  }\n\n  // 比较参数列表每一个参数，但仅比较一层\n  for (let i = 0; i < keysA.length; i++) {\n    if (!hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {\n      return false;\n    }\n  }\n\n  return true;\n}`, `25716812241001705000`)"\n            >\n              <div\n                class="gatsby-code-button"\n                \n              >\n                js 复制代码\n              </div>\n            </div>\n<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token comment">/**\n * 通过遍历对象上的键并返回 false 来执行相等性\n * 在参数列表中，当任意键对应的值不严格相等时，返回 false。\n * 当所有键的值严格相等时,返回 true。\n */</span>\n<span class="token keyword">function</span> <span class="token function">shallowEqual</span><span class="token punctuation">(</span><span class="token parameter">objA<span class="token punctuation">:</span> mixed<span class="token punctuation">,</span> objB<span class="token punctuation">:</span> mixed</span><span class="token punctuation">)</span><span class="token punctuation">:</span> boolean <span class="token punctuation">{</span>\n  <span class="token comment">// 通过 Object.is 判断 objA、objB 是否相等</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">is</span><span class="token punctuation">(</span>objA<span class="token punctuation">,</span> objB<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> objA <span class="token operator">!==</span> <span class="token string">\'object\'</span> <span class="token operator">||</span> objA <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token keyword">typeof</span> objB <span class="token operator">!==</span> <span class="token string">\'object\'</span> <span class="token operator">||</span> objB <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token comment">// 参数列表</span>\n  <span class="token keyword">const</span> keysA <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>objA<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">const</span> keysB <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>objB<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token comment">// 参数列表长度不相同</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>keysA<span class="token punctuation">.</span>length <span class="token operator">!==</span> keysB<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token comment">// 比较参数列表每一个参数，但仅比较一层</span>\n  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> keysA<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">hasOwnProperty</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>objB<span class="token punctuation">,</span> keysA<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">is</span><span class="token punctuation">(</span>objA<span class="token punctuation">[</span>keysA<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> objB<span class="token punctuation">[</span>keysA<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h2 id="附：objectis（来自-mdn）"><a href="#%E9%99%84%EF%BC%9Aobjectis%EF%BC%88%E6%9D%A5%E8%87%AA-mdn%EF%BC%89" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>附：Object.is（来自 MDN）</h2>\n<p><code class="language-text">Object.is()</code> 判断两个值是否<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Equality_comparisons_and_sameness" target="_blank" rel="nofollow noreferrer noopener">相同</a>。</p>\n<p>这种相等性判断逻辑和传统的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Equality" target="_blank" rel="nofollow noreferrer noopener"><code class="language-text">==</code></a> 运算不同，<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Equality" target="_blank" rel="nofollow noreferrer noopener"><code class="language-text">==</code></a> 运算符会对它两边的操作数做隐式类型转换（如果它们类型不同），然后才进行相等性比较，（所以才会有类似 <code class="language-text">&quot;&quot; == false</code> 等于 <code class="language-text">true</code> 的现象），但 <code class="language-text">Object.is</code> 不会做这种类型转换。</p>\n<p>这与 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Identity" target="_blank" rel="nofollow noreferrer noopener"><code class="language-text">===</code></a> 运算符的判定方式也不一样。<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Identity" target="_blank" rel="nofollow noreferrer noopener"><code class="language-text">===</code></a> 运算符（和<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Equality" target="_blank" rel="nofollow noreferrer noopener"><code class="language-text">==</code></a> 运算符）将数字值 <code class="language-text">-0</code> 和 <code class="language-text">+0</code> 视为相等，并认为 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/NaN" target="_blank" rel="nofollow noreferrer noopener"><code class="language-text">Number.NaN</code></a> 不等于 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/NaN" target="_blank" rel="nofollow noreferrer noopener"><code class="language-text">NaN</code></a>。</p>\n<p>如果下列任何一项成立，则两个值相同：</p>\n<ul>\n<li>两个值都是 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined" target="_blank" rel="nofollow noreferrer noopener"><code class="language-text">undefined</code></a></li>\n<li>两个值都是 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/null" target="_blank" rel="nofollow noreferrer noopener"><code class="language-text">null</code></a></li>\n<li>两个值都是 <code class="language-text">true</code> 或者都是 <code class="language-text">false</code></li>\n<li>两个值是由相同个数的字符按照相同的顺序组成的字符串</li>\n<li>两个值指向同一个对象</li>\n<li>\n<p>两个值都是数字并且</p>\n<ul>\n<li>都是正零 <code class="language-text">+0</code></li>\n<li>都是负零 <code class="language-text">-0</code></li>\n<li>都是 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/NaN" target="_blank" rel="nofollow noreferrer noopener"><code class="language-text">NaN</code></a></li>\n<li>都是除零和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/NaN" target="_blank" rel="nofollow noreferrer noopener"><code class="language-text">NaN</code></a> 外的其它同一个数字</li>\n</ul>\n</li>\n</ul>',
id:"/github/workspace/blog/React之PureComponent入门学习/index.md absPath of file >>> MarkdownRemark",timeToRead:9,frontmatter:{date:"2019-09-19 19:44:14",path:"/react-purecomponent-practice-learn/",tags:"前端, React, PureComponent",title:"React之PureComponent入门学习",draft:null}}],length:131,tag:"前端",pagesSum:27,page:16}}}});